#!/bin/bash
# Copyright (c) 2008 Ingres Corporation
#
# /etc/init.d/ingresINST_ID
#
--REDHAT_CFG
# chkconfig: 235 90 10
# Description:    Start Ingres RDBMS - INST_ID instance
#
### BEGIN INIT INFO
# Provides:       ingresINST_ID
### END INIT INFO
--REDHAT_CFG_END
--SUSE_CFG
### BEGIN INIT INFO
# Ingres Product Entry
# Provides:       ingresINST_ID
# Required-Start: $local_fs $network $remote_fs +ypbind
# Required-Stop: $local_fs $network $remote_fs +ypbind
# Default-Start: 2 3 5
# Default-Stop:  0 1 4 6
### END INIT INFO
--SUSE_CFG_END

shopt -s expand_aliases
export use_rc=false

save_status()
{
    [ "$1" = "-v" ] && { flag=-v ; shift ; }
    if $use_rc ; then
	rc_failed $1
	rc_status $flag
    else
        export STATUS=$1
    fi
}

exit_status()
{
    exit $STATUS
}
if [ -f /etc/rc.status ] ; then 
# Shell functions sourced from /etc/rc.status:
#      rc_check         check and set local and overall rc status
#      rc_status        check and set local and overall rc status
#      rc_status -v     ditto but be verbose in local rc status
#      rc_status -v -r  ditto and clear the local rc status
#      rc_failed        set local and overall rc status to failed
#      rc_failed <num>  set local and overall rc status to <num>
#      rc_reset         clear local rc status (overall remains)
#      rc_exit          exit appropriate to overall rc status
    use_rc=true
    . /etc/rc.status
    echon='echo -n'
    exit=rc_exit
    rc_reset
else
    echon=echo
    exit=exit_status
    export STATUS=0
fi


# Return values acc. to LSB for all commands but status:
# 0 - success
# 1 - generic or unspecified error
# 2 - invalid or excess argument(s)
# 3 - unimplemented feature (e.g. "reload")
# 4 - insufficient privilege
# 5 - program is not installed
# 6 - program is not configured
# 7 - program is not running
# 
# Note that starting an already running service, stopping
# or restarting a not-running service as well as the restart
# with force-reload (in case signalling is not supported) are
# considered a success.

ACTIVE=1

# Ingres environment for INST_ID installation

export II_SYSTEM=INST_LOC
export PATH=$II_SYSTEM/ingres/bin:$II_SYSTEM/ingres/utility:$PATH
export LD_LIBRARY_PATH=/lib:/usr/lib:$II_SYSTEM/ingres/lib
unset BASH_ENV

#Check for install userid, groupid
CONFIG_HOST=`iipmhost`
II_USERID=`iigetres ii.${CONFIG_HOST}.setup.owner.user`   ||
{
    echo "Failed to determine installation owners UID"
    save_status -v 5 
    $exit 
}
II_GROUPID=`iigetres ii.${CONFIG_HOST}.setup.owner.group` ||
{
    echo "Failed to determine installation owner GID"
    save_status -v 5 
    $exit 
}
export II_USERID II_GROUPID

# Run everything from $II_SYSTEM/ingres so CWD is writable for ingres
cd $II_SYSTEM/ingres >> /dev/null 2>&1

# Check all need ingres utilities are present and correct
test -x $II_SYSTEM/ingres/utility/ingstart  && INGSTART="su -m -c \"$II_SYSTEM/ingres/utility/ingstart\" $II_USERID"
test "$INGSTART" || { echo "$II_SYSTEM/ingres/utility/ingstart does not exist"; save_status -v 5 ; $exit ; }

test -x $II_SYSTEM/ingres/utility/ingstop  && INGSTOP="su -m -c \"$II_SYSTEM/ingres/utility/ingstop -kill\" $II_USERID"
test "$INGSTOP" || { echo " $II_SYSTEM/ingres/utility/ingstop does not exist"; save_status -v 5 ; $exit ; }

test -x $II_SYSTEM/ingres/bin/iinamu  && export IINAMU="$II_SYSTEM/ingres/bin/iinamu"
test "$IINAMU" || { echo "$II_SYSTEM/ingres/bin/iinamu does not exist"; save_status -v 5 ; $exit ; }

test -x $II_SYSTEM/ingres/utility/syscheck  && SYSCHECK="su -m -c \"$II_SYSTEM/ingres/utility/syscheck\" $II_USERID"
test "$SYSCHECK" || { echo "$II_SYSTEM/ingres/utility/syscheck does not exist"; save_status -v 5 ; $exit ; }

test -x $II_SYSTEM/ingres/utility/ingstatus && INGSTATUS="su -m -c \"$II_SYSTEM/ingres/utility/ingstatus\" $II_USERID"
test "$SYSCHECK" || { echo "$II_SYSTEM/ingres/utility/ingstatus does not exist"; save_status -v 5 ; $exit ; }

# Check is installation is active

ACTIVE=`$INGSTATUS | grep -v "not active" | wc -l `

case "$1" in
    start)
	# if we are already running, report it and exit cleanly
	[ $ACTIVE != 0 ] && {
	$echon "Ingres, instance INST_ID is already running" 
	save_status -v 0 
	$exit
	}

	# Make sure kernel settings are updated if needed
	$SYSCHECK >> /dev/null 2>&1
	[ $? != 0 ] && {
	echo "Applying kernel setting in /etc/sysctl.conf..."
	/sbin/sysctl -p
	}

	# Start Ingres
	echo "Starting Ingres, instance INST_ID"
	$INGSTART > /dev/null 2>&1
	rc=$?
	
	# Remember status and be verbose
	[ -d /var/lock/subsys ] && touch /var/lock/subsys/ingresINST_ID
	save_status -v $rc
	;;

    stop)
	# Stop Ingres
	echo "Stopping Ingres, instance INST_ID"
	rc=0
	[ $ACTIVE != 0 ] && 
	{
	    [ -x "$CASHCOMP/bin/unisrvcntr" ] && 
	    { 
		if [ "`id -un`" != "root" ]; then
		  $CASHCOMP/bin/unisrvcntr stop ingresINST_ID
		  rc=$?
		  exit $rc
      		fi
		$CASHCOMP/bin/unisrvcntr stop -X ingresINST_ID
	    }

	eval $INGSTOP > /dev/null 2>&1
	rc=$?
	}

	# Remember status and be verbose
	[ "$rc" = "0" -a -d /var/lock/subsys ] && \
		rm -f /var/lock/subsys/ingresINST_ID 2>/dev/null
	save_status -v $rc
	;;

    try-restart)
	## Stop the service and if this succeeds (i.e. the 
	## service was running before), start it again.
	## Note: try-restart is not (yet) part of LSB (as of 0.7.5)
	$0 status >/dev/null &&  $0 restart
	rc=$?

	# Remember status and be quiet
	save_status $rc
	;;

    restart|force-reload)
	echo "Restarting Ingres, instance INST_ID"
	if [ -x "$CASHCOMP/bin/unisrvcntr" ] ; then
	    $CASHCOMP/bin/unisrvcntr cycle ingresINST_ID
	else
	    $0 stop
	    $0 start
	fi
	rc=$?

	save_status

	;;

    reload)
	save_status -v 3
	;;
	
    check|status)
	$INGSTATUS
	rc=$? 
        # Status check should return 7 if not running
        [ $ACTIVE = 0 ] && rc=7
	save_status -v $rc
	;;
    *)
	echo  "Usage: $0 {start|stop|status|reload|restart|try-restart|force-reload}"
	$exit
	;;
esac
$exit
