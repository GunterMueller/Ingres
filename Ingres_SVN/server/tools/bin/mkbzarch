#!/bin/bash
#
# Copyright (c) 2004 Ingres Corporation
#
# This script builds UNIX versions of `bzarch.h,' a file containing
# all configuration dependent definitions and included by <compat.h>.
# It is only valid for INGRES 6.1 and above.  For earlier versions,
# bzarch.h should be created with the "mkhdr" program.
#
# This new version defines only public entities.  Another program,
# mkclconf.sh, builds the cl private cl/cl/hdr/secrets.h file that
# contains definitions that known only to the CL.
#
# The following things are defined in bzarch.h as needed.
#
# Config string machine identifier:
#
#	sun.u42 -> sun_u42
#	3bx_us5 -> x3bx_us5
#
# Obsolescent machine identifiers:
#
#	VAX
#	PYRAMID
#	Power6		(cci tahoe)
#	ELXSI
#	CONCEPT32	(gould PN, not NP)
#	SUN		(really wrong)
#	BURROUGHS
#	CT_MEGA
#	x3B5
#
# Machine/OS common flavors:
#
#	MEGAFRAME	(burroughs or CT)
#	UNIPLUS		(A/UX, BT, etc.)
#	SEQUENT		(Balance or Symmetry)
#	DOMAINOS	(apollo)
#	AIX		(ibm)
#
# Things that don't really change on Unix:
#
#	UNIX		(for all UNIX platforms)
#	BAD_BITFIELDS	(use masks for tid manipulation)
#	GLOBALREF	(extern)
#	GLOBALDEF	(null on non-VMS)
#	NODY		(DY not used)
#	II_DMF_MERGE	(use single server executable)
#
# Arch/compiler specific:
#
#	LITTLE_ENDIAN_INT  (Integers are little-endian)
#	BIG_ENDIAN_INT	(Integers are big-endian)
#	NO_64BIT_INT	(No 64 bit integer in hardware or compiler emulation)
#	IEEE_FLOAT	(might not need extra-CL visibility)
#	FLT_OPEQ_BUF	(common compiler problem)
#	INTERNAT	(obsolete?)
#	NEED_ZERO_FILL	(Must initialize all variables)
#	DUALUBSD	(Dual universe)
#	NODSPTRS	(Can't to 0->element offsetof(element) trick)
#	xHARDMATH	(EXCONTINUE from math exceptions won't work).
#	OS_THREADS_USED	(Operating system threads)
#	SYS_V_THREADS	(SystemV/Unix International/Solaris threads)
#	POSIX_THREADS	(POSIX threads)
#
# Special types:
#
#	READONLY	"const" or ""
#	WSCREADONLY	"const" or ""	(obsolescent)
#	GLOBALCONSTDEF	"const" or ""
#	GLOBALCONSTREF	"extern const" or extern
#
# Alignment/Size related:
#
#	BITSPERBYTE	(better be 8!)
#	ALIGN_I2	(1)
#	ALIGN_I4	(1 | 3)
#	ALIGN_I8	(1 | 3 | 7)
#	ALIGN_F4	(1 | 3)
#	ALIGN_F8	(1 | 3 | 7)
#
#	ALIGN_RESTRICT	(char | short | int | double)
#
# Assignment Macros:
#
#	BA(a,i,b)	Byte aligned move of i bytes from a to b
#	I2_ASSIGN_MACRO
#	I4_ASSIGN_MACRO
#	I8_ASSIGN_MACRO
#	F4_ASSIGN_MACRO
#	F8_ASSIGN_MACRO
#
# Byte ordering, etc:
#
#	BYTE_SWAP	if not VAX ordering
#	TID_SWAP	if "reverse" bitfield ordering
#
# Unsigned char manipulation
#
#	UNS_CHAR	if chars are unsigned only
#	I1_CHECK_MACRO	6.1 flavor of above
#
# Size of pointer, and equivalent sized scalar type for use only within CL
#	
#	PTR_BITS_64	if pointers are 64 bits
#	SCALARP		scalar type same size as a pointer, usually int or long
#	SCALARP_IS_LONG	if SCALARP is defined to be "long"
#

header=bzarch.h
date=`date`

# create header with correct permissions
touch $header
chmod 664 $header

# stdout into newly created header

exec > $header

# don't leave it around if we have trouble

trap 'rm $header' 0

# version file generated by running the source transfer script
# generated by mkreq.sh.  GV_VER and GV_ENV used in gver.roc.

. readvers
# Set vers correctly for reverse hybrid
if [ "$conf_ADD_ON32" ] 
then
    vers=$config64
else
    vers=$config
fi
case $vers in
i64_aix)	CC=xlc_r;;
*)		CC=cc;;
esac

case $vers in
[0-9]*)	echo "# define x$vers";;
  *_lnx|\
int_rpl) if [ "$conf_ADD_ON32" ] ; then
	     echo "/* VERS defined on command from Jamdefs.$vers */"
	 else
	     echo "# define $vers"
	 fi
	 ;;
*_osx)
	echo "# ifndef $vers"
	echo "# define $vers"
	echo "# endif"
	;;
*)	 echo "# define $vers";;
esac

# Alias new HP config strings to hp8_us5 to enable most current settings
[ $vers = "hpb_us5" ] && echo "#define hp8_us5"
if [ $vers = "hp2_us5" ]
then
   echo "#define hpb_us5"
   echo "#define hp8_us5"
fi
if [ $vers = "i64_hpu" ]
then
   echo "#define hp2_us5"
   echo "#define hpb_us5"
   echo "#define hp8_us5"
fi

# Alias new SUN v9 config string to su4_us5 to enable most current settings
[ $vers = "su9_us5" ] && echo "#define su4_us5"

product="Ingres"
machine=`machine`
whatunix=`whatunix`
 
# create a new target:

cat << !
/*
** $product $header created on $date
** by the $0 shell script
*/

!

#
# obsolete machine identifiers (predate use of config string)
#
# These defines are mostly rehashing of the machine ID defined by the
# cpp.  They should eventually expire as the references to them in the
# code are changed to #ifdef's keyed either on some capability determined
# automatically below or on the config string.
#

case $vers in
vax_*)		echo "# define VAX"		;;
pyr_*|pym_us5|rmx_us5|rux_us5)		echo "# define PYRAMID"		;;
cci_*)		echo "# define Power6"		;;
icb_us5)	echo "# define Power6"		;;
elx_*)		echo "# define ELXSI" 		;;
gld_u42)	echo "# define CONCEPT32"	;;
sun_u42)	echo "# define SUN"		;;
brm_us5)	echo "# define BURROUGHS"	;;
ctm_us5)	echo "# define CT_MEGA"		;;
3b5_us5)	echo "# define x3B5"		;;
esac

#
# architecture and operating system variants
#
# This section is for defines that identify common machine and OS variants.
#
#	DOMAINOS	Apollo Domain OS
#	MEGAFRAME	CT Megaframe
#	UNIPLUS		Unisoft UniPlus+
#	SEQUENT		Sequent Balance and Symmetry series for BSD and Sys V
#			Universes
#	MIPS32		32-bit MIPS processor: R3000 or R4000 series
#

case $vers in
brm_us5|ctm_us5)	echo "# define MEGAFRAME"	;;
btf_us5|dma_us5|ica_us5)	echo "# define UNIPLUS"	;;
sq?_u42|sq?_us5|sq?_ptx) 	echo "# define SEQUENT"	;;
ts2_us5)		echo "#define MIPS32"	;;
esac

for o in $opts
do
	echo "# define conf_$o"
#
#       Define FUSEDLL if this is a fused OpenROAD build
#
	if [ "$o" = "FUSEDLL" ]
        then
    	    echo '# define FUSEDLL'
	fi
done

HB=""
# Hybrid build?
if [ "$conf_ADD_ON64" = "true" ]
then
    HB=64
    LPHB=lp64
elif  [ "$conf_ADD_ON32" = "true" ]
then
    HB=32
    LPHB=lp32
fi

if [ "$HB" ]
then
{
printf "# if defined(ADD_ON${HB})\n"
}
fi

[ "$HB" ] && $ING_TOOLS/bin/lp${HB}/bitsin | awk '
/^ptr/ {
    ptrsize = $2
}
/^long:/ {
    longsize = $2
}
/^int/ {
    intsize = $2
}
END {
    if (ptrsize == 64)
	printf "# define PTR_BITS_64\n"
    printf "/* SCALARP, SCALARP_IS_LONG may be used ONLY inside the CL. */\n"
    printf "# undef SCALARP\n"
    if (ptrsize == intsize)
    {
	printf "# define SCALARP int\n"
    }
    else
    {
	if (ptrsize == longsize)
	{
	    printf "# define SCALARP long\n"
	    printf "# define SCALARP_IS_LONG\n"
	}
	else
	{
	    printf "/* SCALARP MUST be defined, please fix in mkbzarch.sh\n"
	}
    }
}'

if [ "$HB" ]
then
{
printf "# else /* ADD_ON${HB} */\n"
}
fi

#
# It can no longer be assumed that the size of a pointer is the same size
# as an int. SCALARP is a scalar type whose size is the same as the size of
# a pointer; it is expected that SCALARP will usually be int or long. If it
# is long, define SCALARP_IS_LONG (useful for #defines in hdr files).
# SCALARP and SCALARP_IS_LONG may be used ONLY inside the CL.
#
# It can no longer be assumed that the size of a pointer is 32 bits as this
# can affect the size of messages (eg. in GCA). If pointer size is 64 bits
# define PTR_BITS_64.
#
bitsin | awk '
/^ptr/ {
    ptrsize = $2
}
/^long:/ {
    longsize = $2
}
/^int/ {
    intsize = $2
}
END {
    if (ptrsize == 64)
	printf "# define PTR_BITS_64\n"
    printf "/* SCALARP, SCALARP_IS_LONG may be used ONLY inside the CL. */\n"
    if (ptrsize == intsize)
    {
	printf "# define SCALARP int\n"
    }
    else
    {
	if (ptrsize == longsize)
	{
	    printf "# define SCALARP long\n"
	    printf "# define SCALARP_IS_LONG\n"
	}
	else
	{
	    printf "/* SCALARP MUST be defined, please fix in mkbzarch.sh\n"
	}
    }
}'

if [ "$HB" ]
then
{
printf "# endif /* ADD_ON${HB} */\n"
}
fi

#
#	Essentially invariant defines.
#

cat << end_of_invariants
# if !defined(MAINWIN) || defined(conf_W4GL)
# define UNIX
# endif
# define BAD_BITFIELDS
# ifdef __cplusplus
# define GLOBALREF extern "C"
# else  /* __cplusplus */
# define GLOBALREF extern
# endif  /* __cplusplus */
# define GLOBALDEF
# define NODY
# define II_DMF_MERGE
# define INGRES65
# define GCF65
# define LOADDS
# define FILE_UNIX
end_of_invariants

#
# other variants
#
# Currently, these capabilities are not determined automatically.
#
# If you make a special case for your machine, be sure to duplicate
# all the defines from the generic *) case.
#
#	NO_64BIT_INT	No 64 bit integer in hardware or compiler emulation)
#	IEEE_FLOAT	has ieee conforming floating point
#	FLT_OPEQ_BUG	can't say "float1 op= float2"
#	INTERNAT	internationalization code
#	NEED_ZERO_FILL	ZERO_FILL must be "= {0}"
#	DUALUBSD	Dual universe with most of the port built in BSD and
#			a veneer of Sys V
#	MCT		Multiple Concurrent Threads (sqs_ptx only, for now)
#	OS_THREADS_USED	Operating System Threads (posix or sysV)
#	SYS_V_THREADS	SystemV/Unix International/Solaris threads
#	POSIX_THREADS	POSIX threads
#	SIMULATE_PROCESS_SHARED 
#			Simulate the process-shared attribute for POSIX
#			THREAD machines that do not support sharing
#			mutexes and condition variables between processes.
#			POSIX_THREADS_PROCESS_SHARED. missing on rs4_us5
#	LARGEFILE64	Support 64 bit file system access.
#	LP64		Support for 64-bit address pointers.
#	RAAT_SUPPORT	Support for obsolescent Record at a Time interface.
#			Restricted to 32 bit HP, SUN, AIX, NT, and Tru64.
#	NO_INTERNAL_THREADS
#			Ingres Internal threading is not supported or has
#			not been enabled for this platform

case $vers in
sqs_ptx)	echo "# define IEEE_FLOAT"
		;;
sqs_*)		echo "# define IEEE_FLOAT"
		;;
su4_u42)	echo "# define IEEE_FLOAT"
		;;
sui_us5|\
su4_us5)	echo "# define IEEE_FLOAT"
                echo "# define OS_THREADS_USED"
                echo "# define SYS_V_THREADS"
		echo "# define LARGEFILE64"
		echo "# if defined(ADD_ON64)"
		echo "# define LP64"
		echo "# else"
		echo "# define RAAT_SUPPORT"
		echo "# endif"
		;;
su9_us5)	echo "# define IEEE_FLOAT"
                echo "# define OS_THREADS_USED"
                echo "# define SYS_V_THREADS"
		echo "# define LARGEFILE64"
		echo "# define LP64"
		;;
a64_sol)
		echo "# define IEEE_FLOAT"
		echo "# define OS_THREADS_USED"
		echo "# define SYS_V_THREADS"
		echo "# if defined(ADD_ON64)"
		echo "# define LP64"
		echo "# endif"
		echo "# define NO_INTERNAL_THREADS"
		echo "# define LARGEFILE64"
		;;
su4_cmw)	echo "# define IEEE_FLOAT"
		;;
sun_u42)	echo "# define FLT_OPEQ_BUG"
		echo "# define IEEE_FLOAT"
		;;
sur_u42)	echo "# define FLT_OPEQ_BUG"
		echo "# define IEEE_FLOAT"
		;;
gld_u42)	echo "# define FLT_OPEQ_BUG"
		;;
u3b_*|3b*_*)	echo "# define IEEE_FLOAT"
		;;
ctm_*|brm_*)	echo "# define INTERNAT"
		;;
hp3_*)		NEED_ZERO_FILL=true
		echo "# define IEEE_FLOAT"
		;;
hp5_*)		NEED_ZERO_FILL=true
		echo "# define IEEE_FLOAT"
		;;
i64_hpu)	echo "# define IEEE_FLOAT"
		echo "# define HPUX"
		echo "# define OS_THREADS_USED"
		echo "# define POSIX_THREADS"
		if [ "$conf_ADD_ON32" = "true" ] ; then
		    echo "# ifndef ADD_ON32"
		    echo "# define LP64"
		    echo "# endif "
		elif [ "$conf_ADD_ON64" = "true" ] ; then
		    echo "# ifdef ADD_ON64"
                    echo "# define LP64"
                    echo "# endif "
		fi
		;;
hpb_us5|\
hp2_us5)	echo "# define IEEE_FLOAT"
		echo "# define HPUX"
		echo "# define OS_THREADS_USED"
		echo "# define POSIX_THREADS"
		echo "# if defined(ADD_ON64)"
		echo "# define LP64"
		echo "# else"
		echo "# define RAAT_SUPPORT"
		echo "# endif"
		;;
hp8_us5)	echo "# define IEEE_FLOAT"
		echo "# define HPUX"
		echo "# define RAAT_SUPPORT"
		;;
hp8_bls)		echo "# define IEEE_FLOAT"
		;;
are_us5)	echo "# define IEEE_FLOAT"
		;;
sos_us5)	NEED_ZERO_FILL=true
		echo "# define IEEE_FLOAT"
		;;
pyr_*)		echo "# define IEEE_FLOAT"
		;;
pym_us5)	echo "# define IEEE_FLOAT"
		;;
rmx_us5)        echo "# define IEEE_FLOAT"
                ;;
rux_us5)        echo "# define IEEE_FLOAT"
                echo "# define OS_THREADS_USED"
                echo "# define POSIX_THREADS"
                echo "# define DCE_THREADS"
                echo "# define SIMULATE_PROCESS_SHARED"
		echo "# define USE_IDLE_THREAD"
		;;
sgi_us5)	echo "# define IEEE_FLOAT"
            	echo "# define OS_THREADS_USED"
            	echo "# define POSIX_THREADS"
                echo "# define LARGEFILE64"
		echo "# if defined(ADD_ON64)"
		echo "# define LP64"
		echo "# endif"
		;;
ds3_ulx)        echo "# define IEEE_FLOAT"
		;;
dr6_us5)	echo "# define IEEE_FLOAT"
		;;
dg8_us5 | dgi_us5)	echo "# define IEEE_FLOAT"
                echo "# define OS_THREADS_USED"
                echo "# define POSIX_THREADS"
                echo "# define _POSIX4A_DRAFT6_SOURCE"
	        echo "# define _POSIX4_DRAFT_SOURCE"	
                ;;
rs4_us5)	echo "# define IEEE_FLOAT"
                echo "# define OS_THREADS_USED"
                echo "# define POSIX_THREADS"
        	echo "# define UNSIGNED_CHAR_IN_HASH"
		echo "# define LARGEFILE64"
		echo "# if defined(ADD_ON64)"
		echo "# define LP64"
		echo "# else"
		echo "# define RAAT_SUPPORT"
		echo "# endif"
                if [ "$conf_ADD_ON64" = "true" ] ; then 
                  echo "# define R_MAINWIN_50" 
                fi
		;;
ris_u64)	echo "# define IEEE_FLOAT"
                echo "# define OS_THREADS_USED"
                echo "# define POSIX_THREADS"
        	echo "# define LP64"
        	echo "# define UNSIGNED_CHAR_IN_HASH"
		echo "# define LARGEFILE64"
		;;
i64_aix)        echo "# define IEEE_FLOAT"
                echo "# define OS_THREADS_USED"
                echo "# define POSIX_THREADS"
                echo "# define USE_IDLE_THREAD"
                echo "# define LARGEFILE64"
        	echo "# define LP64"
                ;;
ris_us5)	echo "# define IEEE_FLOAT"
		;;
nc4_us5)        echo "# define IEEE_FLOAT"
		;;
axp_osf)        echo "# define IEEE_FLOAT"
		echo "# define OS_THREADS_USED"
		echo "# define POSIX_THREADS"
		echo "# define LP64"
		echo "# define RAAT_SUPPORT"
    echo "# define CHCAST_MACRO(a) (((char *)(a))[0])"
    echo "# define ASSIGN_CH_MACRO(s,d) (CHCAST_MACRO(d) = CHCAST_MACRO(s))"
    echo "# define I2CAST_MACRO(a) (*(i2*)(a))"
    echo "# define ASSIGN_I2_MACRO(s,d) (I2CAST_MACRO(d) = I2CAST_MACRO(s))"
    echo "# define I4CAST_MACRO(a) (*(i4*)(a))"
    echo "# define ASSIGN_I4_MACRO(s,d) (I4CAST_MACRO(d) = I4CAST_MACRO(s))"
    echo "# define F4CAST_MACRO(a) (*(f4*)(a))"
    echo "# define F8CAST_MACRO(a) (*(f8*)(a))"
    echo "# define I8CAST_MACRO(a) (*(i8*)(a))"
                ;;
ts2_us5)        echo "# define IEEE_FLOAT"
                ;;
usl_us5)        echo "# define IEEE_FLOAT"
                echo "# define OS_THREADS_USED"
                echo "# define SYS_V_THREADS"
                echo "# define LARGEFILE64"
		;;
int_lnx|\
int_rpl|\
ibm_lnx|\
axp_lnx|\
i64_lnx|\
ppc_lnx|\
a64_lnx)        NEED_ZERO_FILL=true
		NPTL=false
		kmaj=`uname -r | awk -F. '{ print $1 $2 }'`
		kmin=`uname -r | cut -d. -f3 | cut -d- -f1`
		if [ $kmaj -gt 24 ] || \
		     ( [ $kmaj -eq 24 ] && [ "`uname -r | grep EL`" ] )
		then
		    NPTL=true
		fi
		echo "# define IEEE_FLOAT"
		echo "# define OS_THREADS_USED"
		echo "# define POSIX_THREADS"
		if [ "$conf_ADD_ON32" = "true" ] ; then
		    echo "# ifndef ADD_ON32"
		    echo "# define LP64"
		    echo "# endif "
		elif [ "$conf_ADD_ON64" = "true" ] ; then
		    echo "# ifdef ADD_ON64"
                    echo "# define LP64"
                    echo "# endif "
		elif [ "$vers" = "ppc_lnx" ] ; then
		    echo "# define LP64"
		fi
		$NPTL || echo "# define SIMULATE_PROCESS_SHARED" 
		$NPTL || echo "# define USE_IDLE_THREAD"
		echo "# define NO_INTERNAL_THREADS"
		echo "# define LNX"
		;;
  *_osx)	echo "# define OSX"
		echo "# define IEEE_FLOAT"
		echo "# define OS_THREADS_USED"
		echo "# define POSIX_THREADS"
		echo "# define UNSIGNED_CHAR_IN_HASH"
		echo "# define NO_INTERNAL_THREADS"
	   	# xprocsem=`getconf POSIX_THREAD_PROCESS_SHARED`
		# disable X process semaphores for now, they don't work
		xprocsem=""
		if [ X"$xprocsem" = X ] || [ "$xprocsem" = "undefined" ]
		then
		    echo "# define SIMULATE_PROCESS_SHARED"
		    echo "# define USE_IDLE_THREAD"
		fi
		;;

esac

if [ "$NEED_ZERO_FILL" ]
then echo "# define ZERO_FILL = {0}"
else echo "# define ZERO_FILL"
fi

#
# NODSPTRS - can we deference a null structure pointer at compile time?
#
(
	cd /tmp
	echo '
		struct a { int a,b; };
		int c = (int)&(((struct a *)0)->b);
	' > npr.c
	$CC -c npr.c > /dev/null 2>&1
) || echo '# define NODSPTRS'
rm -f /tmp/npr.[co]
#
# BAD_NEG_I2_CAST - check that the compiler can handle the negation
#	of a i2 (short) cast value.  (This is known to effect more
#	compilers than one would imagine!).
#
(
	cd /tmp
	echo '
# define ONE    (i2)1
typedef short i2;
i2 minusone = -ONE;
' > nocast.c
	$CC -c nocast.c > /dev/null 2>&1
) || echo '# define BAD_NEG_I2_CAST'
rm -f /tmp/nocast.[co]
#
# NO_VOID_ASSIGN - can we assign pointers to functions of type 'void' ?
#
(
	cd /tmp
	echo '
void
func()
{
    int nothing;
}

main()
{
    void(*assign)();
    assign = func;
}
' > novoid.c
	$CC -c novoid.c > /dev/null 2>&1
) || echo '# define NO_VOID_ASSIGN'
rm -f /tmp/novoid.[co]
#
# READONLY - can we use const type with the compiler?
# Need to have a special case for ris_us5 because of compiler flag
# conflicts per fredv. (seng)
#
case $vers in
ds3_ulx|ris_us5|hp3_us5|axp_osf|rs4_us5|pym_us5|sqs_ptx|ris_u64|i64_aix)
	echo "# define READONLY"
	echo "# define WSCREADONLY"
	echo "# define GLOBALCONSTDEF"
	echo "# define GLOBALCONSTREF extern"
	;;
dg8_us5|dgi_us5)
        echo "# define READONLY __const__"
        echo "# define WSCREADONLY __const__"
        echo "# define GLOBALCONSTDEF __const__"
        echo "# define GLOBALCONSTREF extern __const__"
        ;;
*)
	if (
		cd /tmp
		echo '
			const int x = 5;
		' > const.c
		$CC -c const.c > /dev/null 2>&1
	)
	then
		echo "# define READONLY	const"
		echo "# define WSCREADONLY const"
		echo "# define GLOBALCONSTDEF const"
		echo "# define GLOBALCONSTREF extern const"
	else
		echo "# define READONLY"
		echo "# define WSCREADONLY"
		echo "# define GLOBALCONSTDEF"
		echo "# define GLOBALCONSTREF extern"
	fi
	rm -f /tmp/const.[co]
	;;
esac

# The following tests whether the volatile keyword is supported
# by the compiler.  The volatile keyword prevents some code from
# being moved when it shouldn't be.  Its use is disallowed
# outside of the CL.
	echo "/* VOLATILE may ONLY be used inside the CL. */"
case $vers in
dg8_us5|dgi_us5)
        echo "# define VOLATILE __volatile__"
        ;;
*)
	if (
		cd /tmp
		echo '
main()

{
      typedef volatile struct _bar bar;
      struct _bar
      {
              int test;
      };
        bar barvar;
        barvar.test = 0;
        return (barvar.test);
}
' > volatile.c
($CC -o volatile volatile.c) > /dev/null 2>&1 && `./volatile`
	)
	then
		echo "# define VOLATILE volatile"
	else
		echo "# define VOLATILE"
	fi
	rm -f /tmp/volatile*
	;;
esac

        case $vers in
        xe3_us5) LIBC=/lib/386/Slibc.a ;;
        dr6_us5|usl_us5) LIBC=/usr/ccs/lib/libc.a ;;
        nc4_us5|pym_us5|rmx_us5|rux_us5) LIBC=/usr/ccs/lib/libc.a ;;
        i64_aix) LIBC=/usr/lib/ia64l64/libc.so ;;
        sgi_us5) LIBC=/usr/lib32/mips3/libc.so ;;
	int_lnx|\
	int_rpl|\
	ibm_lnx|\
	i64_lnx|\
	axp_lnx) LIBC=/usr/lib/libc.a ;;
	a64_lnx) LIBC=/usr/lib64/libc.a ;;
	ppc_lnx) LIBC=/usr/lib64/libc.a ;;
	i64_hpu) LIBC=/usr/lib/hpux64/libc.so ;;
	su9_us5|\
	su4_us5|\
	a64_sol) LIBC=/usr/lib/libc.so ;;
	  *_osx) LIBC=/usr/lib/libc.dylib ;;
        *)       LIBC=/lib/libc.a ;;
        esac

	cnm=/tmp/libc.$$
	nm $LIBC > $cnm

#
# string prefixed to nm symbols.
#
       case $vers in
       sos_us5) pre='^' ;;
       ris_us5|rs4_us5|ris_u64) pre='\.' ;;
       dr6_us5|nc4_us5|i64_aix) pre='^.*\|' ;;
       sgi_us5) pre='' ;;
         *_lnx|\
       int_rpl) pre='' ;;
       su4_us5) pre='' ;;
       usl_us5) pre='' ;;
       *)       pre='_' ;;
       esac

#
# Check to see if __setjmp exists.  We check here because the define
# is needed in the header file ex.h.
#

if [ "$vers" = "hp8_us5" ] || [ "$vers" = "rtp_us5" ]
then
	echo "# define xCL_038_BAD_SETJMP"
else
	grep "${pre}_setjmp" $cnm > /dev/null  ||
		echo "# define xCL_038_BAD_SETJMP"
fi

#
# Determine the _SC_PAGESIZE from sysconf(). Used to define ME_MPAGESIZE
# so that valloc() used instead of brk()/sbrk() on systems which don't
# support memalign. 
#
if [ "$vers" = "mg5_osx" ] || [ "$vers" = "int_osx" ] ; then
    tmpfile=/tmp/scpgsz$$
    cat << EOF > ${tmpfile}.c
# include <unistd.h>
# include <stdio.h>
# include <errno.h>

int
main()
{
    int scpgsz = 0L;

    scpgsz=(int)sysconf(_SC_PAGESIZE);

    if ( errno == 0 )
	return(printf("%dL",scpgsz));
    else
    {
	printf("sysconf() failed, errno = %d",errno);
	return(-1);
    }
}
EOF
    $CC ${tmpfile}.c -o ${tmpfile} && \
	echo "# define SC_PAGESIZE `${tmpfile}`"
fi
#
# heterogeneous processors and alignment override
#
# This section is used to overide automatic determination of capabilities
# on machines distributed with different processors (e.g. processor may be
# either 68010 or 68020) or where our "align" tool is not able to
# correctly determine the optimal alignment requirements.
#
#	ALIGN=68010	Force 68010 alignment.
#	ALIGN=SPARC	Force Sun SPARC optimal alignment.
#	ALIGN=MIPS	Force MIPS optimal alignment.
#	ALIGN=AXP	Force Alpha optimal alignment.
#       ALIGN=POWER64   Force AIX PowerPC 64-bit optimal alignment.
#

case $vers in
brm_us5|alt_u42|btf_us5|dgc_us5|apo_u42)	ALIGN=68010	;;
su4_u42|su4_cmw|dr6_us5|su4_us5|su9_us5)	ALIGN=SPARC	;;
ds3_ulx|pym_us5|rmx_us5|ts2_us5|sgi_us5|rux_us5)	ALIGN=MIPS      ;;
axp_osf)						ALIGN=AXP	;;
ris_u64|rs4_us5)                                ALIGN=POWER64   ;;
i64_aix|\
i64_lnx)                                                ALIGN=IA64   ;;
esac

#	Evaluation section.  Automatically determined defines.
#

#
# Integer storage format
#
endian_type=`endian`
case $endian_type in
little)	echo "# define LITTLE_ENDIAN_INT"
	;;
big)	echo "# define BIG_ENDIAN_INT"
	;;
esac

#
# bits in a byte
#
if [ -f $ING_SRC/bin/bitsin ]
then
echo "# define BITSPERBYTE	"`bitsin char | awk '{print $2}'`
else
echo "# define BITSPERBYTE 8"
fi

#
# If specified above, use overriding alignment.
# Otherwise, determine alignment by trial & error, capturing faults:
#
case $ALIGN in
SPARC)	ALIGN_I2=2 ALIGN_I4=4 ALIGN_I8=8 ALIGN_F4=4 ALIGN_F8=8 ;;
68010)	ALIGN_I2=2 ALIGN_I4=4 ALIGN_I8=4 ALIGN_F4=4 ALIGN_F8=4 ;;
MIPS)   ALIGN_I2=2 ALIGN_I4=4 ALIGN_I8=8 ALIGN_F4=4 ALIGN_F8=8 ;;
AXP)    ALIGN_I2=2 ALIGN_I4=4 ALIGN_I8=8 ALIGN_F4=4 ALIGN_F8=8 ;;
POWER64)    ALIGN_I2=2 ALIGN_I4=4 ALIGN_I8=8 ALIGN_F4=4 ALIGN_F8=8 ;;
IA64)   ALIGN_I2=2 ALIGN_I4=4 ALIGN_I8=8 ALIGN_F4=4 ALIGN_F8=8 ;;
*)      eval `align | awk 'BEGIN{
            v["char"]=1;
	    v["long"]=4;
            n["short"]="I2"; v["short"]=2;
            n["int"]="I4"; v["int"]=4;
            n["float"]="F4"; v["float"]=4;
            n["double"]="F8"; v["double"]=8;
        }
        n[$1] != "" {printf "ALIGN_%s=%s ", n[$1], v[$4];}
	END {printf "ALIGN_I8=8"}'`
        ;;
esac

echo "# define	ALIGN_I2	`expr $ALIGN_I2 - 1`"
echo "# define	ALIGN_I4	`expr $ALIGN_I4 - 1`"
echo "# define	ALIGN_I8	`expr $ALIGN_I8 - 1`"
echo "# define	ALIGN_F4	`expr $ALIGN_F4 - 1`"
echo "# define	ALIGN_F8	`expr $ALIGN_F8 - 1`"

#
# Determine the software imposed alignments
#
eval `salign | awk 'BEGIN{
        n["short:"]="I2";
        n["int:"]="I4";
        n["float:"]="F4";
        n["double:"]="F8";
        n["long:"]="I8";
        }
n[$1] != "" {printf "SALIGN_%s=%s ", n[$1], $5;}'`
if [ "$HB" ] ; then
eval `$ING_TOOLS/bin/$LPHB/salign | awk 'BEGIN{
        n["short:"]="I2";
        n["int:"]="I4";
        n["float:"]="F4";
        n["double:"]="F8";
        n["long:"]="I8";
        }
n[$1] != "" {printf "SALIGN_HB_%s=%s ", n[$1], $5;}'`
fi

if [ $ALIGN_I4 != 1 ] && echo "# define BYTE_ALIGN"
then
echo "# define BA(a,i,b)	(((char *)&(b))[i] = ((char *)&(a))[i])"
echo "# define I2ASSIGN_MACRO(a,b) (BA(a,0,b), BA(a,1,b))"
echo "# define I4ASSIGN_MACRO(a,b) (BA(a,0,b), BA(a,1,b), BA(a,2,b), BA(a,3,b))"
echo "# define I8ASSIGN_MACRO(a,b) (BA(a,0,b), BA(a,1,b), BA(a,2,b), \\"
echo "		BA(a,3,b), BA(a,4,b), BA(a,5,b), BA(a,6,b), BA(a,7,b))"
echo "# define F4ASSIGN_MACRO(a,b) (BA(a,0,b), BA(a,1,b), BA(a,2,b), BA(a,3,b))"
echo "# define F8ASSIGN_MACRO(a,b) (BA(a,0,b), BA(a,1,b), BA(a,2,b), \\"
echo "		BA(a,3,b), BA(a,4,b), BA(a,5,b), BA(a,6,b), BA(a,7,b))"
else
echo "# define I2ASSIGN_MACRO(a,b) ((*(i2 *)&b) = (*(i2 *)&a))"
echo "# define I4ASSIGN_MACRO(a,b) ((*(i4 *)&b) = (*(i4 *)&a))"
echo "# define I8ASSIGN_MACRO(a,b) ((*(i8 *)&b) = (*(i8 *)&a))"
echo "# define F4ASSIGN_MACRO(a,b) ((*(f4 *)&b) = (*(f4 *)&a))"
echo "# define F8ASSIGN_MACRO(a,b) ((*(f8 *)&b) = (*(f8 *)&a))"
fi

#  Align to larger of F8 or I8 padding
pad=$SALIGN_F8
if [ $SALIGN_I8 -gt $SALIGN_F8 ] ; then
   pad=$SALIGN_I8
fi
padhb=$SALIGN_HB_F8
if [ $SALIGN_HB_I8 -gt $SALIGN_HB_F8 ] ; then
   padhb=$SALIGN_HB_I8
fi
# For AIX platform, set $padhb to $pad, so it has a single alignment only.
if [ "$HB" ] && [ "$vers" = "rs4_us5" ] ; then
  pad=$padhb
fi
# Define separate alignment for 32 and 64 bit code if necessary
if [ "$HB" ] && [ $pad -ne $padhb ] ; then
   printf "# if defined(ADD_ON${HB})\n"
   case $padhb in
      7)      echo "# define ALIGN_RESTRICT   double" ;;
      1)      echo "# define ALIGN_RESTRICT   short" ;;
      0)      echo "# define ALIGN_RESTRICT   char" ;;
      *)      echo "# define ALIGN_RESTRICT   int" ;;
    esac
    printf "# else \n"
fi
case $pad in
   7)      echo "# define ALIGN_RESTRICT   double" ;;
   1)      echo "# define ALIGN_RESTRICT   short" ;;
   0)      echo "# define ALIGN_RESTRICT   char" ;;
   *)      echo "# define ALIGN_RESTRICT   int" ;;
esac
if [ "$HB" ] && [ $pad -ne $padhb ] ; then
   printf "# endif \n"
fi

#
# If not VAX byte ordering:
#
[ -n "`byteswap`" ] && echo "# define BYTE_SWAP"

#
# If Compiler does not produce bit-fields ordered as on VAX
#
[ "`tidswap | tr -d '\012'`" = "TID_SWAPPED" ]&& \
		echo "# define TID_SWAP"

#
# If chars are unsigned only:
#
#	The macro, ((i4)(x) <= MAXI1 ? (i4)(x) : ((i4)(x) - (MAXI1 + 1) * 2)),
#	is valid for twos complement machines.
#
if [ "unsigned" = "`unschar`" ]
then
	echo "# define UNS_CHAR"
	echo "# define I1_CHECK(x) ((i4)(x)<=MAXI1?(i4)(x):((i4)(x)-(MAXI1+1)*2))"
else
	echo "# define I1_CHECK	(i4)"
fi
echo "/* 6.1 renamed this... */"
echo "# define I1_CHECK_MACRO( x )	I1_CHECK( (x) )"

#
#	Define the name of the character set being used.  This is
#	used by cmtype.c to determine which table of values will be
#	used to classify characters.  Choose one and only one of:
#
#	CSASCII		Standard ASCII
#	CSDECMULTI	DEC Multinational
#	CSDECKANJI	DEC kanji (double-byte CS)
#	CSJIS		JIS kanji (double-byte CS)
#	CSBURROUGHS 	Burroughs kanji (double-byte CS)
#	CSIBM		IBM's Code Page 0 8 bit character set.
#

if [ "$ING_BUILD" ]
then
case $vers in
ris_us5|rs4_us5|ris_u64|i64_aix) echo '# define CSIBM'
	 ;;
*)	 echo '# define CSASCII'
	 ;;
esac
fi

#
# 	Define LARGEFILE64 if this is a Large File enabled port.
#	axp_osf does not need the conf_B64 option because it already
#	supports large files with the standard file api's
#
if [ "$conf_B64" ]
then
case $vers in
axp_osf)
	;;
dgi_us5)
        echo "# define _FILE_OFFSET_BITS  64"  
	;;
  *_lnx|\
int_rpl)
        :
        ;;
*)	echo "# define LARGEFILE64"
	;;
esac
fi

#
# 	Define BOUBLEBYTE if this is a DBCS enabled port.
#
if [ "$conf_DBL" ]
then
    echo '# define DOUBLEBYTE'
fi

#
# 	Define INGRESII for Ingres II
#
    echo '# define INGRESII'

#
#	Define WORKGROUP_EDITION for Workgroup Edition
#
if [ "$conf_WORKGROUP_EDITION" ]
then
    echo '# define WORKGROUP_EDITION'
fi

#
#	Define DEVELOPER_EDITION for Developer Edition
#
if [ "$conf_DEVELOPER_EDITION" ]
then
    echo '# define DEVELOPER_EDITION'
fi
#
#	Define xCL_SUSPEND_USING_SEM_OPS for use of sem_wait/sem_post
#
if [ "$conf_CLUSTER_BUILD" ]
then
case $vers in
  *_lnx|\
int_rpl)
    echo '# define xCL_SUSPEND_USING_SEM_OPS'
    ;;
esac
fi
# 
# If any math exceptions can't be continued, then we may need to
# put in more handlers lower than we would if we could continue.
# As declaring and deleting them isn't cheap, create an ifdef flag
# to use around them.
#

# FIXME!!!
# mathsigs unreliable in AMD64 Linux
# Hard code value for now
if [ "$vers" = "a64_lnx" ] ; then
    echo "# define xEX_HARDMATH"
else
    mathsigs | grep "HARD" > /dev/null && echo "# define xEX_HARDMATH"
fi

#
#  see if <float.h> exists.
#

# location not guaranteed on linux
case "$vers" in
   *lnx|\
int_rpl)
	floattst=/tmp/flttst$$.c
	cat << EOF > ${floattst}
# include <float.h>

int
main()
{
    return(0);
}

EOF
	$CC ${floattst} > /dev/null 2>&1 && \
		 echo "# define xCL_FLOAT_H_EXISTS"
	rm -f ${floattst}
	;;
     *)
	[ -f /usr/include/float.h ] && \
		echo "# define xCL_FLOAT_H_EXISTS"
	;;
esac

# 
# see if abs() is defined
#
grep "${pre}abs" $cnm > /dev/null &&
	echo "# define xCL_ABS_EXISTS"

# 
# see if finite() is defined
#
grep "${pre}finite" $cnm > /dev/null &&
	echo "# define xCL_FINITE_EXISTS"

#
# GTK support
#
case "$vers" in
    *lnx)
#
# except for Debian - because bldenv doesn't set GTK Header path stuff
# for Debian on the basis that Debian doesn't have RPM. 
# At present (28-mar-2008) GTK support implies RPM support
#
	if [ ! -f /etc/debian_version ]
	then
	  echo "# define xCL_GTK_EXISTS"
	fi
	;;
esac

#
# RPM support
#
case "$vers" in
    *lnx)
	echo "# define xCL_RPM_EXISTS"
	;;
esac

#
# Some OS_THREADS platforms cannot successfully support
# thread stack caching.  It can be turned off here by
# defining xCL_NO_STACK_CACHING for your platform.
# It's defined here, rather than in clsecret.h, so that
# it can be picked up in st/crsfiles for processing dbms.crs.
#


echo ""
echo "/* End of $header */"

rm -f $cnm

trap : 0
