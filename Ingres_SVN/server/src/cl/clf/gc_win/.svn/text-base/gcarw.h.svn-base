/*
** Name: gcarw.h - UNIX GCA CL read/write state machine definition
**
** History:
**	10-Nov-89 (seiwald)
**	    CCB moved in wholesale.
**	    Flush flag reworked.
**	    Prevailing timeout moved into sm's.
**	    Send chops, flush, and close requests now have a struct subchan.
**	    New state flag in struct subchan, to control completion.
**	04-Dec-89 (seiwald)
**	    Added completing flag to GCA_GCB, to provide a simple mutex
**	    on calling completion routines.
**	01-Jan-90 (seiwald)
**	    Removed setaside buffer.
**	08-Jan-90 (seiwald)
**	    No more mustflush, sendflush.  Flushing occurs after every
**	    write.
**	19-Jan-90 (seiwald)
**	    Removed mainline's peer info from GC_RQ_ASSOC, so it can be
**	    used for other things.
**	12-Feb-90 (seiwald)
**	    Rearranged and compacted GCA_GCB.
**      24-May-90 (seiwald)
**	    Built upon new BS interface defined by bsi.h.
**	30-Jun-90 (seiwald)
**	    Changes for buffering: 1) GCB now has a read buffer of
**	    GC_SIZE_ADVISE bytes; 2) MTYP is now a typedef for ease of
**	    use; 3) put room for an MTYP before the sendpeer/recvpeer
**	    buffer, since GCsend and GCreceive now require it.
**	30-Jun-90 (seiwald)
**	    Private and Lprivate renamed to bcb and lbcb, as private
**	    is a reserved word somewhere.
**	1-Jul-90 (seiwald)
**	    Added GC_PCT.
**	24-Oct-90 (pholman)
**	    Add security label 'sec_label' to GCA_GCB (plus inclusion of sl.h)
**	01-Apr-98 (rajus01)
**	    GCA peer info is no longer referenced by the CL.
**      06-aug-1999 (mcgem01)
**          Replace nat and longnat with i4.
*/
# ifdef xORANGE
# include <sl.h>
# endif
/*
** Name: GC_PCT - protocol driver table 
*/

typedef struct _GC_PCT
{
    char	*prot;
    BS_DRIVER	*driver;
} GC_PCT;

/*
** Name: GC_RQ_ASSOC - peer info exchange structure
**
** Description:
**	Format of the information exchanged upon connection.
**
*/

typedef struct _GC_RQ_ASSOC
{
    char        user_name[32];
    char        account_name[32];
    char        access_point_id[32];
}   GC_RQ_ASSOC;

/*
** Name: GC_MTYP - CL level message header
*/

typedef struct _GC_MTYP 
{
	int chan;
	int len;
} GC_MTYP;

/*
** Name: GCA_CONNECT - info for peer info exchange state machine
**
** Description:
**	What would normally be automatic variables have to be stuffed
**	in an allocted structure for use with callbacks.  This structure
**	holds the data to get us through the peer info exchange.
*/

typedef struct _GCA_CONNECT
{
	struct {
	    PTR		    svc_buffer;		
	    i4     	    reqd_amount;
	    VOID    	    (*gca_cl_completion)();
	} svc_save;			/* for redirecting on GCrecvpeer */
	    
	GC_RQ_ASSOC	rq_assoc;	/* received CL peer info */

	GC_MTYP		mtyp_room;	/* pad for GCsend */

	struct {
	    GC_RQ_ASSOC	  rq_assoc;	/* CL level */
	} peer_buf;			/* for GCsend/recvpeer */

} GCA_CONNECT;


/*
** Name: GCA_GCB - GCA CL per association data structure
**
** Description:
**	This structure describes a connection for the GCA CL layer.
**
**	A connection to the GCA CL:
**		- is potentially full duplex
**		- multiplexes two subchannels (normal, expidited)
**		- is controlled by sender and receiver state machines.
**	This structure reflects that.
**
**
** History:
**	13-Jan-1989 (seiwald)
**	    Written.
*/

# define GC_SUB 	2	/* normal + exp data */
# define GC_SIZE_ADVISE	4096	/* bigger is better */

typedef struct _GCA_GCB 
{

	/* 
	** id - connection counter.
	** islisten - connection generated by GClisten().
	** completing - mutex for calling completion routines
	*/
	unsigned char id;
	unsigned char islisten;
	char completing;

	/*
	** user request data for each subchannel
	**	recv_chan[ 2 ] - normal + exp receive
	**	send_chan[ 2 ] - normal + exp send
	**	sendchops - send chop marks on normal subchannel (gag)
	**
	** 	svc_parms - used on completion
	**	state - state of request
	** 	buf, len - set on request
	**	      modified by GC_{recv,send}_sm
	**	      cleared on completion
	*/
	struct subchan 
	{
		SVC_PARMS	*svc_parms; 	
		char		*buf;
		char		state;
		i4 		len;
	} recv_chan[ GC_SUB ], send_chan[ GC_SUB ], 
		sendchops, sendclose, *sending;

# define GC_CHAN_QUIET		0	/* no request */
# define GC_CHAN_ACTIVE		1	/* waiting for GC_{recv,send}_sm */
# define GC_CHAN_DONE		2	/* waiting for GC_drive_complete */

	/* 
	** read/write info for the connection
	**
	** state machine data
	**	state - state of recv/send state machine
	**	running - state machine alive on this channel
	**	timeout - prevailing timeout 
	**	bsp - service parms for BS operations
	**	syserr - for i/o errors
	*/

	struct sm
	{
		char		state;
		bool		running; 
		i4     		timeout;

		BS_PARMS	bsp;
		CL_ERR_DESC	syserr;
	} recv, send;

	/* mtyp - pointer into incoming buffer */

	GC_MTYP	*mtyp;

	/* ccb - connection requests control block */

	GCA_CONNECT ccb;

	/* bcb - byte stream I/O control structure.  */

	char bcb[ BS_MAX_BCBSIZE ];	

	/* buffer - receive buffer */

	char buffer[ GC_SIZE_ADVISE ];
# ifdef xORANGE
	SL_LABEL sec_label;
# endif
} GCA_GCB ;
