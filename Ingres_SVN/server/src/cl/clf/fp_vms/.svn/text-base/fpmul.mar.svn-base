	.title	fpmul
;
;	Copyright (c) 1993	Ingres Corporation
;
;
;   Description:
;	Contains FP routine for decimal multiplication.
;
;	Globally visible entry points:
;	    IIFPpkmul	    - multiply two decimal numbers
;
;   History:
;	28-jun-95 (wagner)
;	    Created.  Actually, extracted from FPDEC.MAR because of a weird
;	    bug in the AXP/VMS macro compiler that can be worked around by
;	    placing this routine in its own module.
;
;
	.psect	$code$	pic,con,rel,lcl,shr,exe,nord,nowrt,novec,4
 

;
; Name: IIFPpkmul - Multiply two packed decimals.
;
; Description:
;      Multiplies two packed decimals and returns the result in another
;      packed decimal.  The precision and scale of the result are
;      also returned, and are calculated thus:
;
;          pout = min(31, (p1+p2))
;          sout = min(31, (s1+s2))
;
;	This routine attempts the multiplication using MULP first, and if
;	it overflows, we call FPpkmul_sim which tries the multiplication in
;	software.
;
; Inputs:
;      pk1                             Pointer to the multiplicand.
;      p1                              Its precision:  1 <= p1 <= 31.
;      s1                              Its scale:  0 <= s1 <= p1.
;      pk2                             Pointer to the multiplier.
;      p2                              Its precision:  1 <= p2 <= 31.
;      s2                              Its scale:  0 <= s2 <= p2.
;
; Outputs:
;      pkout                           The resulting packed decimal value is
;                                      placed here.
;      pout                            Its precision will be calculated based
;                                      on the above formula, and placed here.
;      sout                            Its scale will be calculated based
;                                      on the above formula, and placed here.
;
;      Returns:
;          OK			       Operation succeeded.
;
;          FP_DECOVF                   Result has too many non-fractional
;                                      digits; i.e. more than (pout - sout)
;                                      of them.
;      Exceptions:
;	   None.
;
; Side Effects:
;          None.
;
; History:
;	01-sep-89 (jrb)
;	    Written.
;	13-jan-1993 (rog)
;	    Converted to IIFPpkmul().
;
pk1	= 4
p1	= 8
s1	= 12
pk2	= 16
p2	= 20
s2	= 24
pkout	= 28
pout	= 32
sout	= 36
pktmp	= -16

	.entry	IIFPpkmul,^m<r2,r3,r4,r5,r6>
	subl2	#16,sp
	addl3	p1(ap),p2(ap),r0	; calculate result precision
	cmpl	r0,#31
	bleq	mul01
	movl	#31,r0
mul01:	movl	r0,@pout(ap)
	addl3	s1(ap),s2(ap),r1	; calculate result scale
	subl3	r1,#31,r6
	bgeq	mul02			; if over 31 we have to shift it
	movl	#31,@sout(ap)
	mulp	p1(ap),@pk1(ap),p2(ap),@pk2(ap),#31,pktmp(fp)
	bvs	mul03
	ashp	r6,#31,pktmp(fp),#0,#31,@pkout(ap)
	ret
mul02:	movl	r1,@sout(ap)
	mulp	p1(ap),@pk1(ap),p2(ap),@pk2(ap),r0,@pkout(ap)
	bvs	mul03
	ret
;
; If we overflowed, call FPpkmul_sim to try the multiplication in software.
; This is necessary because it is legal to truncate fractional digits if
; necessary when doing multiplication.  Since the VAX instructions only
; support integral packed decimals, they of course have no concept of
; fractional digits.  The C code which we are going to call knows how to
; do all the right things.
;
mul03:	pushl	@sout(ap)
	pushl	@pout(ap)
	pushl	pkout(ap)
	pushl	s2(ap)
	pushl	p2(ap)
	pushl	pk2(ap)
	pushl	s1(ap)
	pushl	p1(ap)
	pushl	pk1(ap)
	calls	#9,FPPKMUL_SIM
	ret
	.end
