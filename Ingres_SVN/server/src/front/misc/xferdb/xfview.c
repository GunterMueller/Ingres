# include "/home/ingres/SANDBOX/Ingres_SVN/server/install/build/ingres/files/eqdef.h"
/*
**	Copyright (c) 2004 Ingres Corporation
*/
# include	<compat.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<st.h>
# include	<er.h>
# include       <si.h>
# include       <lo.h>
# include	<fe.h>
# include	<ug.h>
# include       <ui.h>
# include       <uigdata.h>
# include       <adf.h>
# include       <afe.h>
# include <xf.h>
# include	"erxf.h"
/*
** Fool MING, which doesn't know about EXEC SQL INCLUDE
# include <xf.qsh>
*/
/**
** Name:	xfview.sc - write statement to create view.
**
** Description:
**	This file defines:
**
**	xfviews		write statements to create views.
**
** History:
**	13-jul-87 (rdesmond) written.
**	10-mar-88 (rdesmond)
**		removed trim() from target list for 'text' field.
**	21-apr-89 (marian)
**		Pass in is_distrib to set the right range variable
**		for STAR.
**	27-may-89 (marian)
**		change is_distrib to global with_distrib.
**	05-mar-1990 (mgw)
**		Changed #include <erxf.h> to #include "erxf.h" since this is
**		a local file and some platforms need to make the destinction.
**	04-may-90 (billc)
**		Major rewrite.  Convert to SQL.
**	03-sep-91 (billc)
**		Fix 39609 - was putting "\sqlcreate view ..." in STAR script.
**	04-mar-92 (billc)
**		Major rewrite for FIPS.
**      27-jul-1992 (billc)
**              Rename from .qsc to .sc suffix.
**      28-oct-94 (sarjo01) Bug 63640
**              xfviews(): added order by iitable.table_reltid to get views
**              back in same order they were created. Fixes problem of view-
**              on-view created out of sequence.
**	31-jan-95 (wonst02) Bug #66496
**		This bug was caused by an incorrect cross-integration of main
**		to ca11sol.  Used change #415078 as my basis.
**	03-feb-95 (wonst02) Bug #63766
**		For fips, look for both $ingres and $INGRES
**	14-may-96 (kch)
**		We now ignore grant 'copy_into' and 'copy_from' privileges.
**		This change fixes bug 74525.
**	07-oct-1997 (nanpr01)
**		Fix bug 86131, 63640
**		Creating view in wrong order.
**      11-Dec-97 (nicph02) Bug 87622
**              We now check that the object type in iipermits is 'V'
**              when retrieving the grant statement for the view.
**      26-Apr-1999 (carsu07)
**            The copy.in script generated by copydb and unloaddb does not
**            contain create view statements for views owned by $ingres.     
**            This fix will now generate create view statements for non
**            system catalog views (e.g. ima views) owned by $ingres (Bug 94930)
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**      04-jan-2002 (stial01)
**          Implement -add_drop for -with_views, -with_proc, -with_rules
**	23-oct-2002 (gupsh01)
**	    Corrected the orders in which views are created, we now
**	    sort by reltid first also for non 6.5 catalogs.
**      19-dec-2002 (stial01)
**          Don't generate drop procedure statements for system generated procs
**	29-jan-03 (inkdo01)
**	    Added drop sequence procedure for sequence support.
**      12-feb-03 (stial01)
**          Only generate one drop procedure statement per procedure
**	9-Sep-2004 (schka24)
**	    Generate dbevent permit drops for 6.4 upgradedb when asked.
**	    Avoid spurious set-authorization noise by blank-trimming ID's.
**	20-Sep-2004 (schka24)
**	    Drop $ingres procs, but not ii-procs or system-use G procs,
**	    when drop requested (upgradedb).
**	02-Dec-2005 (gupsh01)
**	    Fixed xfdrop_sequences() routine to call the correct sql 
**	    statements for obtaining sequences.
**/
/* # define's */
/* GLOBALDEF's */
GLOBALREF bool With_sequences;
/* extern's */
/* static's */
static void writeview( TXT_HANDLE	**tfdp,
	XF_TABINFO	*vi,
	char	*dml,
	char	*subtype,
	char	*permit_grantor,
	i2	permit_number,
	i4	text_sequence,
	i4	*viewcount,
	i4	*regcount,
	char	*text_segment);
/*{
** Name:	xfviews - write statements to create views and set permits.
**
** Description:
**
** Inputs:
**
** Outputs:
**	numobjs		pointer to integer, so we can report the number of
**			views we found.
**
**	Returns:
**		none.
**
** History:
**	13-jul-87 (rdesmond) written.
**	10-mar-88 (rdesmond)
**		removed trim() from target list for 'text' field.
**	18-aug-88 (marian)
**		Changed retrieve statement to reflect column name changes in
**	18-aug-88 (marian)
**		Took out #ifdef HACKFOR50 since it is no longer needed.
**      28-oct-94 (sarjo01)
**              order views by iitables.table_reltid to get them in correct
**              order of creation.
**	31-jan-95 (wonst02) Bug #66496
**		This bug was caused by an incorrect cross-integration of main
**		to ca11sol.  Used change #415078 as my basis.
**	14-may-96 (kch)
**		We now ignore grant 'copy_into' and 'copy_from' privileges
**		when retrieving grant text from iipermits. This change fixes
**		bug 74525.
**	07-oct-1997 (nanpr01)
**		Fix bug 86131, 63640
**		Creating view in wrong order.
**      11-Dec-97 (nicph02) Bug 87622
**              We now check that the object type in iipermits is 'V'
**              when retrieving the grant statement for the view.
**		also for post 6.5 iipermits have a table_type = 'T' 
**		for views also so add that check for procedures. 
*/
void
xfviews(numobjs)
i4	*numobjs;
{
  char text_segment[XF_VIEWLINE + 1];
  char dml[2];
  char subtype[2];
  char alter_date[AFE_DATESIZE + 1];
  i4 text_sequence;
  i2 permit_number;
  i2 permit_depth;
  char permit_grantor[FE_MAXNAME + 1];
  char view_base[8];
  i4 stamp1;
  i4 stamp2;
  i4 reltid;
  auto XF_TABINFO vi;
    auto TXT_HANDLE	*tfd = NULL;
    i4		viewcount = 0;
    i4		regcount = 0;
    if (With_65_catalogs)
    {
	/* 1st clause gets view text. */
/* # line 191 "xfview.sc" */	/* select */
  {
    IIsqInit((char *)0);
    IIwritio(0,(short *)0,1,32,0,(char *)
"select t.view_base, t.table_relstamp1, t.table_relstamp2, t.alter_dat\
e, t.table_owner, t.table_name, '',  -1,  -1, v.text_sequence, v.text_\
segment, v.view_dml, t.table_type, t.table_subtype, t.table_reltid fro\
m iiviews v, iitables t where v.table_name=t.");
    IIwritio(0,(short *)0,1,32,0,(char *)
"table_name and v.table_owner=t.table_owner and(v.table_owner=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)"or ''=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)
")and t.table_type='V' and t.system_use='U' union select t.view_base, \
t.table_relstamp1, t.table_relstamp2, t.alter_date, pe.object_owner, p\
e.object_name, pe.permit_grantor, pe.permit_depth, pe.permit_number, p\
e.text_sequence, pe.text_segment, '', '', '', ");
    IIwritio(0,(short *)0,1,32,0,(char *)
"t.table_reltid from iipermits pe, iitables t where t.table_name=pe.ob\
ject_name and t.table_owner=pe.object_owner and t.table_type='V' and p\
e.object_type='V' and(t.table_owner=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)"or ''=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)
")and t.system_use='U' and pe.text_segment not like '%copy_into%' and \
pe.text_segment not like '%copy_from%' order by 1 DESC, 15, 4, 5, 8, 9\
, 10");
    IIretinit((char *)0,0);
    if (IIerrtest() != 0) goto IIrtE1;
IIrtB1:
    while (IInextget() != 0) {
      IIgetdomio((short *)0,1,32,7,view_base);
      IIgetdomio((short *)0,1,30,4,&stamp1);
      IIgetdomio((short *)0,1,30,4,&stamp2);
      IIgetdomio((short *)0,1,32,AFE_DATESIZE + 1-1,alter_date);
      IIgetdomio((short *)0,1,32,FE_MAXNAME + 1-1,vi.owner);
      IIgetdomio((short *)0,1,32,FE_MAXNAME + 1-1,vi.name);
      IIgetdomio((short *)0,1,32,FE_MAXNAME + 1-1,permit_grantor);
      IIgetdomio((short *)0,1,30,2,&permit_depth);
      IIgetdomio((short *)0,1,30,2,&permit_number);
      IIgetdomio((short *)0,1,30,4,&text_sequence);
      IIgetdomio((short *)0,1,32,XF_VIEWLINE + 1-1,text_segment);
      IIgetdomio((short *)0,1,32,1,dml);
      IIgetdomio((short *)0,1,32,1,vi.table_type);
      IIgetdomio((short *)0,1,32,1,subtype);
      IIgetdomio((short *)0,1,30,4,&reltid);
      if (IIerrtest() != 0) goto IIrtB1;
/* # line 231 "xfview.sc" */	/* host code */
	{
	    writeview( &tfd, &vi, dml, subtype,
		    permit_grantor, permit_number, 
		    text_sequence, &viewcount, &regcount, text_segment);
	}
    } /* IInextget */
    IIflush((char *)0,0);
IIrtE1:;
  }
    }
    else
    {
	/*
	** Three-way union.  We could theoretically do two-way, but all-to-all
	** permissions make it very hard to handle all possible states.  So I 
	** added one special state, one per-view, that appears after the 
	** view text and returns the all-to-all info.  All-to-all info is
	** a no-op in 6.5.
	*/
/* # line 248 "xfview.sc" */	/* select */
  {
    IIsqInit((char *)0);
    IIwritio(0,(short *)0,1,32,0,(char *)
"select t.alter_date, t.table_owner, t.table_name, '',  -1, v.text_seq\
uence, v.text_segment, '', '', v.view_dml, t.table_type, t.table_subty\
pe, t.table_reltid from iiviews v, iitables t where v.table_name=t.tab\
le_name and v.table_owner=t.table_owner and(v.");
    IIwritio(0,(short *)0,1,32,0,(char *)"table_owner=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)"or ''=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)
")and t.table_type='V' and t.system_use='U' union select t.alter_date,\
 t.table_owner, t.table_name, '', 0, 1, '', t.all_to_all, t.ret_to_all\
, '', t.table_type, t.table_subtype, t.table_reltid from iitables t wh\
ere t.table_type='V' and(t.table_owner=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)"or ''=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)
")and t.system_use='U' union select t.alter_date, pe.object_owner, pe.\
object_name, pe.object_owner, pe.permit_number, pe.text_sequence, pe.t\
ext_segment, '', '', '', '', '', t.table_reltid from iipermits pe, iit\
ables t where t.table_name=pe.object_name and ");
    IIwritio(0,(short *)0,1,32,0,(char *)
"t.table_owner=pe.object_owner and t.table_type='V' and(pe.object_type\
='V' or pe.object_type='T')and(t.table_owner=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)"or ''=");
    IIputdomio((short *)0,1,32,0,Owner);
    IIwritio(0,(short *)0,1,32,0,(char *)
")and t.system_use='U' order by 13, 1 ASC, 2, 3, 5, 6");
    IIretinit((char *)0,0);
    if (IIerrtest() != 0) goto IIrtE2;
IIrtB2:
    while (IInextget() != 0) {
      IIgetdomio((short *)0,1,32,AFE_DATESIZE + 1-1,alter_date);
      IIgetdomio((short *)0,1,32,FE_MAXNAME + 1-1,vi.owner);
      IIgetdomio((short *)0,1,32,FE_MAXNAME + 1-1,vi.name);
      IIgetdomio((short *)0,1,32,FE_MAXNAME + 1-1,permit_grantor);
      IIgetdomio((short *)0,1,30,2,&permit_number);
      IIgetdomio((short *)0,1,30,4,&text_sequence);
      IIgetdomio((short *)0,1,32,XF_VIEWLINE + 1-1,text_segment);
      IIgetdomio((short *)0,1,32,1,vi.alltoall);
      IIgetdomio((short *)0,1,32,1,vi.rettoall);
      IIgetdomio((short *)0,1,32,1,dml);
      IIgetdomio((short *)0,1,32,1,vi.table_type);
      IIgetdomio((short *)0,1,32,1,subtype);
      IIgetdomio((short *)0,1,30,4,&reltid);
      if (IIerrtest() != 0) goto IIrtB2;
/* # line 284 "xfview.sc" */	/* host code */
	{
	    writeview( &tfd, &vi, dml, subtype, 
		    permit_grantor, permit_number, 
		    text_sequence, &viewcount, &regcount, text_segment);
	}
    } /* IInextget */
    IIflush((char *)0,0);
IIrtE2:;
  }
    }
    if (tfd != NULL)
        xfclose(tfd);
    *numobjs += viewcount;
    xf_found_msg(ERx("V"), viewcount);
    if (regcount > 0)
    {
	*numobjs += regcount;
	xf_found_msg(ERx("V*"), regcount);
    }
}
/*{
** Name:	writeview - write statements to create views and set permits.
**
** Description:
**
** Inputs:
**
** Outputs:
**
**	Returns:
*/
static void
writeview(
    	TXT_HANDLE	**tfdp,
	XF_TABINFO	*vi,
	char	*dml,
	char	*subtype,
	char	*permit_grantor,
	i2	permit_number,
	i4	text_sequence,
	i4	*viewcount,
	i4	*regcount,
	char	*text_segment
    )
{
    xfread_id(vi->name);
    if (!xfselected(vi->name)) 
	return; 
    xfread_id(vi->owner);
    if (permit_number == -1 && text_sequence == 1)
    {
	/*
	** 1st UNION clause -- New view definition.
	** This is the first line of definition text for a view.
	*/
	if (*subtype == 'N')
	    (*viewcount)++;
	else
	    (*regcount)++;
	if (*tfdp == NULL)
	{
	    /*
	    ** First time called.  Write informative comment, open text handle. 
	    */
	    xfwritehdr(VIEWS_COMMENT);
	    *tfdp = xfreopen(Xf_in, TH_IS_BUFFERED);
	}
	else
	{
	    xfflush(*tfdp);
	}
	/* Does user id have to be reset? */
	xfsetauth(*tfdp, vi->owner);
	xfsetlang(*tfdp, *dml == 'Q' ? DB_QUEL : DB_SQL);
    }
    else if (permit_number == 0)
    {
	/* 
	** Pre-6.5, the second UNION clause.  This gives us the all-to-all
	** and ret-to-all permission info about the view. 
	** This clause goes away in 6.5.
	** 
	** This is a separate clause since we
	** have to handle all-to-all AFTER the entire view definition.)
	*/
	if (vi->alltoall[0] == 'Y' || vi->rettoall[0] == 'Y')
	{
	    xfflush(*tfdp);
	    xfalltoall(vi);
	}
    }
    else if (permit_number > 0 && text_sequence == 1)
    {
	/* 
	** Permission text.  This is the first line of a permission on
	** a view that we've already seen.
	*/
	/* flush previous statement */
	xfflush(*tfdp);
	/* Do we need to reset the permit grantor's user id? */
	xfread_id(permit_grantor);
	xfsetauth(*tfdp, permit_grantor);
        /* set the DML that the permit is written in */
        if (STbcompare(text_segment, 6, ERx("create"), 6, FALSE) == 0
              || STbcompare(text_segment, 5, ERx("grant"), 5, FALSE) == 0)
        {
            xfsetlang(*tfdp, DB_SQL);
        }
        else
        {
            xfsetlang(*tfdp, DB_QUEL);
        }
    }
    xfwrite(*tfdp, text_segment);
}
xfdrop_sequences()
{
  char seq_name[DB_MAXNAME + 1];
  char seq_owner[DB_MAXNAME + 1];
    if (!With_sequences)
	return;
/* # line 424 "xfview.sc" */	/* select */
  {
    IIsqInit((char *)0);
    IIwritio(0,(short *)0,1,32,0,(char *)
"select distinct seq_name, seq_owner from iisequences");
    IIretinit((char *)0,0);
    if (IIerrtest() != 0) goto IIrtE3;
IIrtB3:
    while (IInextget() != 0) {
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,seq_name);
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,seq_owner);
      if (IIerrtest() != 0) goto IIrtB3;
/* # line 429 "xfview.sc" */	/* host code */
    {
	xfread_id(&seq_name[0]);
	xfread_id(&seq_owner[0]);
	xfsetauth(Xf_in, seq_owner);
	xfwrite(Xf_in, ERx("drop sequence "));
	xfwrite_id(Xf_in, seq_name);
	xfwrite(Xf_in, GO_STMT);
    }
    } /* IInextget */
    IIflush((char *)0,0);
IIrtE3:;
  }
}
void xfdrop_rules(i4 output_flags)
{
  char rule_name[DB_MAXNAME + 1];
  char rule_owner[DB_MAXNAME + 1];
/* # line 447 "xfview.sc" */	/* select */
  {
    IIsqInit((char *)0);
    IIwritio(0,(short *)0,1,32,0,(char *)
"select distinct rule_name, rule_owner from iirules where system_use<>\
'G' order by rule_owner, rule_name");
    IIretinit((char *)0,0);
    if (IIerrtest() != 0) goto IIrtE4;
IIrtB4:
    while (IInextget() != 0) {
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,rule_name);
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,rule_owner);
      if (IIerrtest() != 0) goto IIrtB4;
/* # line 454 "xfview.sc" */	/* host code */
    {
	xfread_id(&rule_name[0]);
	xfread_id(&rule_owner[0]);
	xfsetauth(Xf_in, rule_owner);
	xfwrite(Xf_in, ERx("drop rule "));
	xfwrite_id(Xf_in, rule_name);
	xfwrite(Xf_in, GO_STMT);
    }
    } /* IInextget */
    IIflush((char *)0,0);
IIrtE4:;
  }
    /* If we're dropping stuff, see if we need to drop dbevent permits.
    ** (dbevents are created before rules, in the rule handler, so why
    ** not continue the madness and put the dbevent permit drops here.
    ** How stupid is that?)
    ** We need to worry about dbevent permits because they existed
    ** back in 6.4, and old permits are to be reissued.
    */
    if ((output_flags & XF_DROP_INCLUDE) && (output_flags & XF_PERMITS_ONLY))
    {
/* # line 473 "xfview.sc" */	/* select */
  {
    IIsqInit((char *)0);
    IIwritio(0,(short *)0,1,32,0,(char *)
"select distinct event_name, event_owner from iievents order by event_\
owner, event_name");
    IIretinit((char *)0,0);
    if (IIerrtest() != 0) goto IIrtE5;
IIrtB5:
    while (IInextget() != 0) {
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,rule_name);
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,rule_owner);
      if (IIerrtest() != 0) goto IIrtB5;
/* # line 478 "xfview.sc" */	/* host code */
	    xfread_id(&rule_name[0]);
	    xfread_id(&rule_owner[0]);
	    xfsetauth(Xf_in, rule_owner);
	    xfwrite(Xf_in, ERx("drop permit on dbevent "));
	    xfwrite_id(Xf_in, rule_name);
	    xfwrite(Xf_in, " all");
	    xfwrite(Xf_in, GO_STMT);
    } /* IInextget */
    IIflush((char *)0,0);
IIrtE5:;
  }
    }
}
xfdrop_procs()
{
  char proc_name[DB_MAXNAME + 1];
  char proc_owner[DB_MAXNAME + 1];
  char proc_create_date[AFE_DATESIZE + 1];
    /*
    ** Ordering by create_date desc to TRY to drop procedures 
    ** in reverse create order...
    ** However create_date is not necessarily unique
    ** To guarantee reverse create order we would have to select
    ** from iiprocedure, order by dbp_id desc, but iiprocedure is not
    ** a standard catalog.
    ** Fortunately, the drops will work in any order.
    */
/* # line 506 "xfview.sc" */	/* select */
  {
    IIsqInit((char *)0);
    IIwritio(0,(short *)0,1,32,0,(char *)
"select distinct procedure_name, procedure_owner, create_date from iip\
rocedures where LOWERCASE(procedure_name)not like 'ii%' and system_use\
<>'G' order by create_date DESC");
    IIretinit((char *)0,0);
    if (IIerrtest() != 0) goto IIrtE6;
IIrtB6:
    while (IInextget() != 0) {
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,proc_name);
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,proc_owner);
      IIgetdomio((short *)0,1,32,AFE_DATESIZE + 1-1,proc_create_date);
      if (IIerrtest() != 0) goto IIrtB6;
/* # line 514 "xfview.sc" */	/* host code */
    {
	xfread_id(&proc_name[0]);
	xfread_id(&proc_owner[0]);
	xfsetauth(Xf_in, proc_owner);
	xfwrite(Xf_in, ERx("drop procedure "));
	xfwrite_id(Xf_in, proc_name);
	xfwrite(Xf_in, GO_STMT);
    }
    } /* IInextget */
    IIflush((char *)0,0);
IIrtE6:;
  }
}
xfdrop_views()
{
  i4 table_reltid;
  char table_name[DB_MAXNAME + 1];
  char table_owner[DB_MAXNAME + 1];
/* # line 533 "xfview.sc" */	/* select */
  {
    IIsqInit((char *)0);
    IIwritio(0,(short *)0,1,32,0,(char *)
"select table_reltid, table_name, table_owner from iitables where tabl\
e_type='V' order by table_reltid DESC");
    IIretinit((char *)0,0);
    if (IIerrtest() != 0) goto IIrtE7;
IIrtB7:
    while (IInextget() != 0) {
      IIgetdomio((short *)0,1,30,4,&table_reltid);
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,table_name);
      IIgetdomio((short *)0,1,32,DB_MAXNAME + 1-1,table_owner);
      if (IIerrtest() != 0) goto IIrtB7;
/* # line 540 "xfview.sc" */	/* host code */
    {
	if (!xf_is_cat(table_name))
	{
	    xfread_id(&table_name[0]);
	    xfread_id(&table_owner[0]);
	    xfsetauth(Xf_in, table_owner);
	    xfwrite(Xf_in, ERx("drop view "));
	    xfwrite_id(Xf_in, table_name);
	    xfwrite(Xf_in, GO_STMT);
	}
    }
    } /* IInextget */
    IIflush((char *)0,0);
IIrtE7:;
  }
}
