/*
** Generated by: eqmerge grammar -I/home/ingres/SANDBOX/Ingres_SVN/server/src/front/abf/mgram -o/home/ingres/SANDBOX/Ingres_SVN/server/src/front/abf/sql/sql.yf /home/ingres/SANDBOX/Ingres_SVN/server/src/front/abf/sql/sql.sy
*/
%{
/*
** Copyright (c) 1984, 2004, 2008 Ingres Corporation
*/
#ifndef VMS
#include 	<stdio.h>
#endif
#include	<compat.h>
#include	<cm.h>
#include	<me.h>
#include	<si.h>
#include	<st.h>
#include	<lo.h>
#include	<er.h>
#include	<gl.h>
#include	<sl.h>
#include	<iicommon.h>
#include	<adf.h>
#ifndef ADE_CHK_TYPE
#define ADE_CHK_TYPE(itype, type) ((itype) == (type) || (itype) == -(type))
#endif
#include	<fe.h>
#include	<afe.h>
#include	<fdesc.h>
#include	<oslconf.h>
#include	<oserr.h>
#include	<osglobs.h>
#include	<osfiles.h>
#include	<ossym.h>
#include	<ostree.h>
#include	<osquery.h>

#include	<iltypes.h>
#include	<ilops.h>
#include	<ilmenu.h>

#include	<osloop.h>

#include	<osfrs.h>
#include	<frscnsts.h>
#include	<eqsym.h>
#include	<eqgen.h>
#include	<eqfw.h>

#include	<oskeyw.h>
#include	<osmem.h>

#if defined(hp3_us5)
	#pragma OPT_LEVEL 1
#endif /* hp3_us5 */

#if defined(i64_win)
#pragma optimize("", off)
#endif

# if defined(DESKTOP)
# define frs_head    osfrs_head
# define frs_error   osfrs_error
# endif

GLOBALREF	bool		yyreswd;
# define	YYRETRY		1
# define	YYRETRYTOKEN	ID

/*
NO_OPTIM = ris_us5 rs4_us5 i64_aix
*/

/**
** Name:	oslgram.y - OSL Interpreted Frame Object Translator Grammar.
**
** Description:
**	Contains the YACC grammar (LALR(1)) for the OSL interpreted frame object
**	translator independent of the data manipulation language, QUEL or SQL.
**	This file should be merged using "eqmerge" with either "quel/quel.y"
**	or "sql/sql.y" to obtain the complete grammar for OSL/QUEL or OSL/SQL,
**	respectively.  The complete grammar defines either:
**
**	quel()	OSL/QUEL interpreted frame object translator.
**	sql()	OSL/SQL interpreted frame object translator.
**
** History:
**	Revision 5.1  86/10/17	wong
**	Initial revision.
**	10-feb-89 (marian)
**		Add conversion warning messages for begin/end transaction,
**		and abort for oslsql.
**	9/90 (Mike S)
**		Add declaration for osfrs_old. Porting change 130906 from
**		griffin
**	11/24/90 (emerson)
**		Change calling sequence for osqrydot (for bug 34590).
**	01/13/91 (emerson)
**		Fixes for bug 34837.  See productions for if_expr,
**		else_if_expr, and while_expr.
**	23-jan-1991 (mgw) Bug 33236
**		Only quote single character delimiters in copy formats,
**		not multi-char delimiters such as in "text(0)nl".
**	02/24/91 (emerson)
**		Fixes for bug 36068.  See productions for callf_par_ele,
**		position_ele, and keyword_ele.  Note that:
**		(1) 6.3/02 supported CALLPROC x (y.ALL), but didn't allow
**		    any other parameters to be passed to x.
**		(2) 6.3/03/00 erroneously disallows this construction.
**		(3) 6.3/03/01 allows this construction.  It also allows
**		    other parameters to be passed to x, and it allows
**		    "z = y.ALL" in place of "y.ALL" (z is ignored).
**		(4) 6.3/01 (and possibly earlier) through 6.3/03/01
**		    allow "z = y.ALL" in the parameters of a CALLFRAME.
**		    Although the documentation says that z must be the name
**		    of the called frame, in fact z is ignored.
**		    Perhaps future releases should give a warning if z
**		    is not the name of the called frame or procedure.
**	02/25/91 (emerson)
**		Fix for bug 36084.  See production for OSLvalue.
**	04/07/91 (emerson)
**		Modifications for local procedures.
**	04/22/91 (emerson)
**		Fix SubMState logic to handle nested submenus.
**		Add support for alerters.
**	05/07/91 (emerson)
**		More modifications for local procedures:
**		Don't allow RESUME, VALIDATE, and VALIDROW
**		in a local procedure unless they're inside a DISPLAY SUBMENU.
**		Also disallow nested local procedures.
**	09-may-1991 (mgw & davel) Bug 34530
**		Re-wrote copy_null's "WITH NULLK '(' constant ')'" case to
**		properly handle all the various constant strings.
**	07/22/91 (emerson)
**		Fixes for bug 38753: When call_name is a variable rather than
**		a literal, its node doesn't have a valid n_value, and it's
**		not appropriate to call osframesym or osprocsym.
**	07/25/91 (emerson)
**		Fix for bug 38849: Don't allow a CALLPROC of a system function.
**	07/26/91 (emerson)
**		Change alertevent to dbevent (per LRC 7-3-91).
**	02-aug-1991 (davel)
**		Fix for bug 35665 - Disallow table fields in productions below
**		OSLvalue (i.e. Table fields not valid as R.H.S. argument).
**	08/02/91 (emerson)
**		Fix for bug 31342: Enclose copy formats of c0x and d0x
**		(where x represents any single character) in quotes or
**		apostrophes.
**	08/06/91 (emerson)
**		Issue a warning if the system function DBMSINFO is used
**		in an expression (bug 21745).
**	08/06/91 (emerson)
**		Allow menu explanations to be specified as global constants
**		as well as string literals (bug 35460).
**	09-aug-1991 (davel)
**		Fix for bug 35806 - correct arguments passed to oschktypes()
**		in the insrow_ele production (they were in wrong order).
**	08/15/91 (emerson)
**		Fixes for bug 35468: Created the empty disallow_repeat
**		production, and used it after OSLcol_var in several places.
**		Also refined an error message in qualification processing.
**		Also changed the qry production to reflect the fact that
**		RepeatState may now change during the parse of the qry.
**	08/18/91 (emerson)
**		Fixes for bug 38001: call_frame and call_proc weren't
**		restoring FormObj = FormSym in the case where there
**		was no assignment of the return value.
**      08/19/91 (johnr)
**              Added hp3_us5 pragma to use the highest possible
**              optimization level and avoid a compiler failure in hp-ux 8.0
**	08/26/91 (emerson)
**		Fix a serious problem in the fix (08/02/91) that DaveL and I
**		came up with for bug 35665. See OSLcol_var and OSLnocol_var.
**	10/04/91 (emerson)
**		Replaced calls to osblkSID and osblkclose by calls to
**		new osblkbreak (for bugs 34788, 36427, 40195, 40196).
**	10/08/91 (emerson)
**		Allow labels to be assigned to UNLOADTABLE statements,
**		submenu statements, and attached queries.  (SIR 40233).
**	12/14/91 (emerson)
**		Fixes for bug 40908 in ingres_int and ingres_ref.
**	12/14/91 (emerson)
**		Part of fix for bug 38940 in inittable.
**	30-dec-1991 (davel)
**		Fix bugs 37388 and 41635 - change var_colon production
**		to always use FormSym in the osdotnode() call.
**	13-apr-92  (vijay)
**		Add NO_OPTIM for ris_us5. else compile bombs.
**	29-apr-92  (vijay)
**		Oops, no optim hint cannot be a single line comment in .yf
**		files since it is grepped out and appended to the .c file
**		with comments around. Incidentally, the compile error is
**		'system	resource has been exhausted'. (?)
**	29-apr-92 (purusho)
**          Amdahl C compiler cribs about # pragma OPT_LEVEL 1 starting
**          at column 1 and hence inserted a tab character
**	24-jul-92 (sweeney)
**	    add NO_OPTIM for apl_us5 - compiler fails when building
**	    quel.o and sql.o binaries in ../quel and ../sql with:
**	    Fatal error in /usr/apollo/lib/cc
**	    Status 023
**	14-sep-92 (davel)
**		Fixed bug 46472 - ostmpbeg() and ostmpend() statements
**		were incorrectly placed in IF, ELSEIF, and WHILE statements.
**		The ostmpbeg() should be issued before the OSLcondition, and the
**		ostmpend() should be issued before the IL code (for IF
**		and WHILE) is generated.
**	09/20/92 (emerson)
**		Fixes for bugs 38299, 44004, 44056, 46646 in "var_colon: COLID".
**		Changes in the way iiosQrNext is used (for bug 46761).
**		Several changes for bugs 39582 and 34846:
**		Changed calling sequence to osqrygen; it now sets
**		the "top of loop" sid for a SELECT loop.
**		Don't generate IL_QRYBRK after calling osqrgen;
**		osqrgen now does it when necessary.
**		Pass the IL fragment that computes the query target list
**		l-values to osmknode when building a tkQUERY node.
**		Replace the n_sub field by the N_ROW bit for tablefield nodes.
**		Changed calling sequence to osqrydot again.
**		Also, the interface to osqryidchk has changed slightly.
**	27-apr-93 (essi)
**		Generate compile-time error (rather than run-time) for field
**		names that are not on the form (bug 48349). This should only
**		apply to VALIDROW, CLEAR FIELD and CLEARROW.
**      05-Aug-93 (DonC) Bugs 53779 and 53747
**              Fix to bug 48349 broke SQL/and QUEL DDL statements that use
**              the ing_name_list production. Restored the production to its
**              former self and re-implemented a fix for 48349 by introducing
**              the production ing_field_list.
**
**	Revision 6.5
**	28-apr-92 (davel)
**		Added support for 6.5 DBMS features.
**	25-aug-92 (davel)
**		Added rule for execute_procedure.
**	24-sep-92 (davel)
**		Changes required to SET statement now that SESSION is a keyword.
**	06-oct-92 (davel)
**		Add support for SET_INGRES and INQUIRE_INGRES for keyword 
**		SESSION (which is now a reserved word).
**	12-nov-92 (davel)
**		Generate IL_CHKCONNECT after SET_INGRES "SESSION".
**	07-jan-93 (sylviap)
**		Added support for the new FRS statement:
**		   inquire_forms (int_var = exists(FORM_NAME));
**		Needed something special because EXISTS is already a keyword.
**	02-feb-93 (davel)
**		Added support for WITH clause for insertrow and loadtable
**		statements (for cell attribute support).
**	09-feb-93 (davel)
**		Added support for SET_4GL and INQUIRE_4GL.
**	11-feb-93 (davel)
**		Added OFF as a reserved word, and allow ON or OFF as a valid
**		set_forms, set_ingres, or set_4gl value as a synonym for
**		1 or 0 respectively.
**	23-feb-93 (davel)
**		Fixed bug 49823 - added 'opt_ingres_str' rule.
**	25-feb-93 (davel)
**		Fixed bug 49878 (on dbevent syntax).
**	11-mar-93 (davel)
**		Add set_connection as one of the form_stmt statements, which is
**		a little goofy, but it can't be a db_stmt as an extra 
**		IL_ENDLIST gets generated.  So we lump it in with set_ingres
**		which is its next closest cousin.  Also include the 
**		set_connection rule here rather than in sql.sy.
**	24-mar-93 (davel)
**		Fix bug 50675 - several grammar errors for DBMS statement
**		support.
**	19-apr-93 (davel)
**		Fix 51331 - allow SESSION as owner in qual_table_ref (required 
**		by DECLARE GLOBAL TEMPORARY TABLE).
**	17-may-93 (davel)
**		Fix bug 51700 - allow "type of table x.y" as a record 
**		declaration.
**	27-apr-93 (essi)
**		Generate compile-time error (rather than run-time) for field
**		names that are not on the form (bug 48349). This should only
**		apply to VALIDROW, CLEAR FIELD and CLEARROW.
**	05-Aug-93 (DonC)
**		Fix to bug 48349 broke SQL/and QUEL DDL statements that use
**		the ing_name_list production. Restored the production to its
**		former self and re-implemented a fix for 48349 by introducing
**		the production ing_field_list.
**	09-sep-93 (essi)
**		Backed out changes of 27-apr-93 and 05-Aug-93. They just caused
**		more problems than solved.
**	17-jun-93 (essi)
**		Fix bug 52810. Allow keyword parameters to start the
**		parameter list too. 
**	03-aug-1993 (mgw)
**		Added handling for LONG VARCHAR(0) etc. COPY format.
**	07/28/93 (dkh) - Added support for the PURGETABLE and RESUME
**			 NEXTFIELD/PREVIOUSFIELD statements.
**    23-Aug-93 (DonC) Bug 53868
**            Add OUTOFDATAMESSAGE = BELL support.
**      30-aug-93 (huffman)
**            add include <me.h>
**    3-sep-93 (DonC)
**	      Change of 23-Aug-93 broke the compilation of constructs using
**	      set_value where the RHS contained a variable. I removed the
**	      change. 
**    09-sep-93 (essi)
**	      Backed out changes of 27-apr-93 and 05-Aug-93. They just caused
**	      more problems than solved.
**    15-sep-93 (DonC) Bug 53868
**            Add OUTOFDATAMESSAGE = BELL support the right way.
**    20-sep-93 (DonC) 
**	      Add COPY, CREATE TABLE support for BYTE(x) and BYTE VARYING(x)
**    09-sep-93 (essi)
**	      Backed out changes of 27-apr-93 and 05-Aug-93. They just caused
**	      more problems than solved.
**    22-nov-93 (robf)
**            Add enhanced support for SET SESSION statement, including
**	      ADD/DROP PRIVILEGES clauses and more WITH options.
**    09-dec-93 (lan)
**	      Fix bug #47930 - Use of LOADTABLE in a 4GL procedure is not
**	      allowed and should be caught by the 4GL compiler.
**    11-may-94 (robf)
**             Rearrange some productions between here and sql.my to
**	       avoid "rule never reduced" errors when compiling quel.my
**    09-feb-95 (chech02)
**           Added rs4_us5 for AIX 4.1.   
**    07-feb-95 (wolf) 
**	      Inclusion of stdio.h causes compiler warnings on VAX/VMS and
**	      outright errors on Alpha/VMS.  Bracket it with ifdefs.
**    22-Jun-95 (fanra01)
**            Modified the names of the calls to frs_head and frs_error.
**            These symbols conflict with ones defined already in eqgenfrs.c
**            in embed!equel.
**	  18-dec-1995 (angusm)
**		  Remove redundant force of token to lowercase in tbl_col_name
**		  rule - can cause rejection of valid token "_state" if present
**		  in both uppercase and lowercase in source (bug 71314)
**    11-jan-1996 (toumi01; from 1.1 axp_osf port)
**            Added kchin's change for axp_osf
**            11-jan-94 (kchin)
**            Added axp_osf to the NO_OPTIM list to avoid problem
**            introduced by optimizer into 4gl compiler (oslsql,osl).
**     3-dec-1996 (rodjo04)
**            bug 79308: Put back "Hack attack" that was removed 18-dec-1995
**            (bug 71314). Modified it so that when symbol "_state" was read,
**            the hack would not be applied. Added new boolean function
**            is_state(). is_state() will return TRUE if the token read is
**            "_state" (case insensitive).
**     16-Sep-1997 (rodjo04)
**         (bug 85516) Added 'NOT NULLK WITH DEFAULT' and 
**         'NOT NULLK NOT DEFAULT' to null_clause: to correct 
**         quel syntax.
**	10-may-1999 (walro03)
**		Remove obsolete version string apl_us5.
**     06-Jul-1999 (schte01)
**         Remove NO_OPTIM for axp_osf.
**	21-Apr-1999 (consi01) Bug 95433 INGCBT 186
**	    Correct a typo in the fix for bug 85516. Changed output string
**	    from "not null with default" to "not null not default".
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	16-aug-2001 (toumi01)
**	    speculative i64_aix NO_OPTIM change for beta xlc_r - FIXME !!!
**	27-dec-2001 (somsa01)
**	    Added NO_OPTIM for i64_win to avoid 4gl compiler problems
**	    (oslsql, osl).
**	15-feb-2002 (toumi01)
**	    Support keyword retry for ABF to avoid keyword problems.
**	13-jan-2005 (abbjo03)
**	    Change yyreswd to GLOBALREF since it's GLOBALDEF'd in libequel.
**	29-Jan-2007 (kiria01) b117277
**	    Changed method of recognising SET RANDOM_SEED so that the
**	    functionality can both set the seed on the DBMS and within the
**	    local context.
**      13-Dec-2007 (hanal04) Bug 119519
**          Reset FormObj for next statement at the end of execute_procedure:
**          This is in-line with a similar reset performed in call_proc: for
**          Bug 38001.
**	21-Jan-2008 (kiria01) b119806
**	    Extended grammar for postfix operators beyond IS NULL and corrected
**          the operator priority tags
*/


/* %L Configuration */
/* %L merge "oslgram.my" */
/* %L Configuration begin */
#define yyparse sql
/* %L Configuration end */

char	*osstring();
char	*oshexvchar();
OSSYM	*osframesym();
OSSYM	*osprocsym();
STATUS	osblkbreak();
OSNODE	*osblkqry();
bool	osblkutbl();
ILREF	osvalref();
ILREF	osvarref();
bool	oschktypes();
bool	oschkstr();
OSNODE	*osformall();
OSNODE	*ostabfall();
OSNODE	*osall();
OSNODE	*iiosRefGen();
VOID	osdbtle();
VOID	osdbsqltle();
VOID	osdbwith();
VOID	osdbqtle();
VOID	osdblist();
VOID	osdbsrtkey();
VOID	op_vch_change();
char	*osnodename();
OSSYM	*osnodesym();
char	*osldform();
char	*osldtable();
OSNODE	*os_ta_check();
bool	osfrs_old();
OSSYM	*osformdecl();
OSSYM	*osobjinit();
VOID	ostmpinit();
VOID	ostmpnewproc();
OSSYM	*osdefineproc();
VOID	osendproc();
VOID	oschkundefprocs();
PTR	iiIGspStartProc();
VOID	iiIGepEndProc();
VOID	frs_insrow_with(void);

/* State flags */

static bool	ProcState = FALSE;	/* source is for a proc (not a frame) */
static bool	LocalProcState = FALSE;	/* in a local procedure */
static bool	CallState = FALSE;	/* in callframe statement (bug check) */
static bool	QryState = FALSE;	/* in query retrieve */
static bool	QloopState = FALSE;	/* in query loop */
static bool	RetInState = FALSE;	/* in retrieve loop */
static bool	ActState = FALSE;	/* in activation */
static bool	RepeatState = FALSE;	/* in repeat query */
static i4	DeclareFlags = 0;	/* context-sensitive declaration flags*/
static bool	SetSession = FALSE;	/* SET_INGRES "SESSION" specified */

/*
** Keep track of what kind of submenu we're in (if any).
** Possible kinds are DISPLAY_MENU and RUN_SUBMENU.
**
** Since submenus can be nested, we need a stack.
** I use 31 of the bits of SubMState as a stack.
** Assuming submenus aren't nested more than 31 deep
** (more will be flagged as an error), SubMState will be set as follows:
**
** SubMState = 1		initially.
** SubMState = SubMState*2 + 1	when initiating a DISPLAY_MENU.
** SubMState = SubMState*2	when initiating a RUN_MENU.
** SubMState = SubMState/2	when terminating either kind of submenu.
**
** Thus,
**
** SubMState == 1		indicates we're not in either kind of submenu.
** SubMState is even		indicates we're in a RUN_MENU.
** SubMState is odd and > 1	indicates we're in a DISPLAY_MENU.
*/
static u_i4	SubMState = 1;

/*
** Keep track of whether there's a display loop that we can jump to the top of.
**
** DispLoopCount = 1 intially, for a frame.
** DispLoopCount = 0 intially, for a procedure or local procedure.
** DispLoopCount is incremented when we open a DISPLAY SUBMENU.
** DispLoopCount is decremented when we close a DISPLAY SUBMENU.
**
** Thus, there's a display loop that we can jump to the top of
** if and only if DispLoopCount > 0.
*/
static	i4	DispLoopCount = 1;

/*
** Keep track of information about the current menu or submenu.
** Each variable allows for 1 bit of information for each level of
** nested submenu, up to a depth of 31.  The low-order bit
** always represents the current submenu (as for SubMState above).
*/
static u_i4	SubMInAlert = 0;	/* In an alerter activation block? */
static u_i4	SubMGotNonAlert = 0;	/* Found non-alerter activation block?*/

static bool	AllowForm = TRUE;
static bool	FormSpecified = FALSE;

/* Symbol table entry for top routine's form */

static OSSYM	*FormSym = NULL;

/*
** Symbol table entry for "form" for current routine
** (frame, proc, or local proc)
*/
static OSSYM	*LocalFormSym = NULL;

/* Symbol table entry for query retrieve form object */

static OSSYM	*FormObj = NULL;

static OSNODE	*QryTarget = NULL;

/* Pointer to "fragment" of IL which assigns a selected row into its targets */

static PTR	TargListFrag = NULL;

/* Holding area for the label of a SELECT loop or attached query */

static char	*QueryLabel = NULL;

/* Symbol table entry for array or tablefield being operated on by
** INSERTROW, CLEARROW, etc.
*/

static OSSYM	*TableObj = NULL;

/* Name of current frame (not form) or procedure */

static char	*FrmProcName = NULL;

/* Activation Options List */

static ILREF	ActOpt[OPT_MAX] = {0, 0, 0};

/* FRS With Clause Statement Type */

static i4	FrsStmt = 0;

/* Syntax Error Flags */
static bool	OpErr = FALSE;		/* operation in statement context */

/* %L Statics */
/* %L Statics begin */
static bool	TableRef = FALSE;	/* SELECT target list table reference */
static OSNODE	*InsCols = NULL;	/* INSERT column name list */
static i4	InsNcols = 0;		/* Depth of above */

static bool	insert_all();
static OSNODE	*insert_column();
static OSNODE	*expand_insert();
static VOID	open_targ_IL();
static VOID	close_lhs_targ_IL();
static VOID	close_rhs_targ_IL();

VOID      IIOSgqsGenQryStmt();


/* %L Statics end */

/* Parser Debug */
#define YYDEBUG 1

static READONLY char	_SyntaxError[]	= ERx("syntax error");
static READONLY char	_IsNull[]	= ERx("is null");
static READONLY char	_IsInteger[]	= ERx("is integer");
static READONLY char	_IsDecimal[]	= ERx("is decimal");
static READONLY char	_IsFloat[]	= ERx("is float");
static READONLY char	_IsNotNull[]	= ERx("is not null");
static READONLY char	_IsNotInteger[]	= ERx("is not integer");
static READONLY char	_IsNotDecimal[]	= ERx("is not decimal");
static READONLY char	_IsNotFloat[]	= ERx("is not float");
%}

/*
**	Yacc grammar and semantic rules for OSL, QUEL and SQL.
**
**	The grammar is organized in the following manner:
**
**		a) control structure
**		b) query statements
**		c) call statements
**		d) EQUEL/Forms statements
**		e) DML dependent statements
**		f) common DML transaction and DDL statements.
**		g) expressions
**		h) special objects (references)
**
**	Within a single classification, objects may be grouped with major
**	objects ordered alphabetically within groups, and minor objects grouped
**	with the major object to which they belong.
*/

%{
#define YACC	1
%}

/*
** Name:	TOKENS -	OSL Tokens.
**
** Description:
**	These are the tokens recognized by the OSL grammar.
*/
	/* OSL Control Keywords */
%token	ALL	/* special case QUEL/RTI/SQL keyword */
	ARRAY_OF
	BEGIN
	BYREF
	CALL
	CALLF
	CALLP
	DECLARE
	DEREFERENCE
	DISPLAY_MENU
	DO
	ELSE
	ELSEIF
	ENDIF
	ENDLOOP
	END
	ENDWHILE
	EXE_PROC
	EXIT
	FIELD
	FIELD_ENTRY
	FIELD_EXIT
	IF
	INITIALIZE
	KEY
	MODE
	NEXT
	NULLK
	ON_DBEVENT
	PROCEDURE
	PROCEDURE_RETURNING
	CLASS_OF
	REPEAT
	RETURN
	RUN_MENU
	QUALIFICATION
	SESSION
	SYSTEM
	THEN
	USER
	WHILE
	WITH

/* %L tokens */
/* %L tokens begin - SQL tokens to import into G (OSL) */
	/* SQL statement keywords */
%token	ABORT			/* RTI/SQL */
	ALTER_DEFAULT		/* RTI/SQL */
	ALTER_PROFILE		/* RTI/SQL */
	ALTER_TABLE		/* RTI/SQL */
	ALTER_USER		/* RTI/SQL */
	ALTER_LOCATION		/* RTI/SQL */
	ALTER_SECAUDIT		/* RTI/SQL */
	BEGINTRANSACTION	/* RTI/SQL */
	COMMIT
	COPY			/* RTI/SQL */
	CREATE
	CRE_DBEVENT		/* RTI/SQL */
	CRE_PROFILE		/* RTI/SQL */
	CRE_USER		/* RTI/SQL */
	CRE_SECALARM		/* RTI/SQL */
	CRE_LOCATION		/* RTI/SQL */
	CURRENT_INST		/* RTI/SQL */
	DELETE
	DBMS_PASSWORD		/* RTI/SQL */
	DISABLE_SECAUDIT	/* RTI/SQL */
	DROP
	DRP_DBEVENT		/* RTI/SQL */
	DRP_PROFILE		/* RTI/SQL */
	DRP_VIEW
	DRP_PROC		/* RTI/SQL */
	DRP_LINK		/* RTI/SQL */
	DRP_LOCATION		/* RTI/SQL */
	DRP_SECALARM		/* RTI/SQL */
	DRP_USER
	ENABLE_SECAUDIT		/* RTI/SQL */
	ENDTRANSACTION		/* RTI/SQL */
	EXECUTE_IMMED
	GET_DBEVENT		/* RTI/SQL */
	GRANT
	INDEX			/* RTI/SQL */
	CRE_INTEGRITY		/* RTI/SQL */
	INSERT
	MODIFY			/* RTI/SQL */
	CRE_PERMIT		/* RTI/SQL */
	RAISE_DBEVENT		/* RTI/SQL */
	REFERENCING
	REGISTER
	REGISTER_DBEVENT	/* RTI/SQL */
	RELOCATE		/* RTI/SQL */
	REMOVE_DBEVENT		/* RTI/SQL */
	DRP_INTEGRITY		/* RTI/SQL */
	DRP_PERMIT		/* RTI/SQL */
	ROLLBACK
	SAVE			/* RTI/SQL */
	SAVEPOINT		/* RTI/SQL */
	SELECT
	SET			/* RTI/SQL */
	TABLE
	UNION
	UPDATE
	CRE_VIEW
	GLOB_TEMP
	CRE_SYNONYM
	DRP_SYNONYM
	FROM_GROUP
	FROM_ROLE
	FROM_USER
	TO_GROUP
	TO_ROLE
	TO_USER
	CONNECT
	DISCONNECT
	SESSION
	IDENTIFIED_BY

%token	ALL			/* RTI/SQL */
	ANY
	ASC
	AT
	BETWEEN
	BY
	DEFAULT
	DESC
	DISTINCT
	ESCAPE
	EXISTS
	FOR
	FROM
	GROUP
	HAVING
	IN
	INTO
	IS
	JOIN
	OF
	NULLK
	ON
	ORDER
	SOME
	TO
	UNIQUE			/* RTI/SQL */
	UNTIL			/* RTI/SQL */
	USER
	VALUES
	WHERE
	WITH			/* RTI/SQL */
	WORK
	INNER_JOIN
	FULL_JOIN
	LEFT_JOIN
	RIGHT_JOIN
	ON_COMMIT
	ON_DATABASE
	ON_LOCATION
	BY_USER
	BY_GROUP
	BY_ROLE
	CHECK
	CONSTRAINT
	FOREIGN_KEY
	PRIMARY_KEY
	REFERENCES
	UNIQUE
	COMMENT_ON

	/* Added in support of Knowledge Management Extension */
%token	ADD
	ALTER_GROUP
	ALTER_ROLE
	CRE_GROUP
	CRE_ROLE
	CRE_RULE
	CALLP
	DRP_GROUP
	DRP_ROLE
	DRP_RULE
	NEW_AS
	OLD_AS
	REVOKE

%{

#define STARTSTMTOW(string) { osOpenwarn(ERx(string)); IGstartStmt(osscnlno(),IL_LB_NONE); }

/* Undefine these for some systems (e.g., Sun) */
#ifdef MAX
#undef MAX
#endif
#ifdef MIN
#undef MIN
#endif
%}

%token	AVG
	COUNT
	MAX
	MIN
	SUM

	/* Precedence for <select_expr> */
%left	UNION UNION_OP
/* %L tokens end */
%token	COPY
	DEFAULT
	FROM
	INTO
	AS
	IS
	ON
        BELL_TOK
	OFF
	OWNER_INGRES
	RELOCATE
	SAVE
	SET
	TO
	UNTIL
	WHERE

%token	TABLE		/* special case for <frs_object> in OSL/SQL */
%token	UPDATE		/* special case for <mode_val> in OSL/SQL */
%token	ESCAPE		/* special case for escape clause in OSL/SQL */
%token	ROLLBACK	/* special case for <with_key> in OSL/SQL */
%token	GRANT		/* special case for <with_key> in OSL/SQL */
%token	GROUP		/* special case for <with_key> in OSL/SQL */

%token	ASC		/* special cases for REGISTER. reserved only in SQL */
	DESC

	/* SET command tokens */
%token	USER_AUTH
	SYSTEM_USER
	SESSION_USER
	SESSION_GROUP
	SESSION_ROLE
	ADD_PRIVILEGES		
	DROP_PRIVILEGES	

	/* Language-independent STAR commands/keywords */
%token	DIR_CONNECT
 	DIR_DISCONNECT
 	DIR_EXECUTE
 	IMMEDIATE
	REGISTER
	REG_TABLE /* Hack attack!  "table" not reserved in QUEL. */
	REM_TABLE
	REG_VIEW
	REM_VIEW
	REMOVE

	/* Forms system keywords */
%token	CLEAR
	EXISTS
	HELPFILE
	HELP_FORMS
	MESSAGE
	NOECHO
	PRINTSCREEN
	PROMPT
	REDISPLAY
	RESUME
	RESENTRY
	RESNEXT
	RESMENU
	RESNFLD
	RESPFLD
	SCREEN
	SCROLL
	SLEEP
	VALIDATE

	/* INQUIRE and SET */
%token	INQ_FORMS
	INQ_INGRES
	SET_FORMS
	SET_INGRES
	INQ_4GL
	SET_4GL
	SET_CONNECTION
	SET_RANDOM_SEED

	/* Table field statements */
%token	CLEARROW
	DELETEROW
	INITTABLE
	INSERTROW
	VALIDROW
	LOADTABLE
	UNLOADTABLE
	PURGETBL

	/* identifiers */
%token	COLID
	ID

	/* constants */
%token	FCONST
	ICONST
	SCONST
	XCONST
	DCONST

	/* operators */
%token	AND
	EXP
	GTE
	LIKE
	LTE
	NOT
	NOTLIKE
	NOTEQ
	OR

%token	LSQBRK
	RSQBRK
	COLEQ

	/* define ascending precedence for operators */
%left	AND OR	LBOP
%nonassoc '<' '>' '=' NOTEQ GTE LTE LIKE ROP
%left	'+' '-' BOP
%left	'*' '/' BOPH
%left	EXP
%right	NOT UOP
%nonassoc UOP_POSTFIX

/*
** Name:	YACC Types
*/

%union {
	char		*st_name;
#ifdef YACC
	OSSYM		*st_sym;
	OSNODE		*st_node;
	OSTLIST		*st_tlist;
	OSSRTNODE	*st_srtlist;
	OSQRY		*st_qry;
#endif
	i4		st_nat;
};


%type	<st_name>	ID		COLID		DEREFERENCE	NULLK
			SCONST		XCONST		ICONST		FCONST
			DCONST		IS		OWNER_INGRES
			EXIT		END		RETURN
			CLEAR		PRINTSCREEN	REDISPLAY	RESUME
			RESENTRY	RESNEXT		RESMENU		RESNFLD
			VALIDATE	FIELD		NEXT		SCROLL
			CLEARROW	DELETEROW	INSERTROW	VALIDROW
			INITTABLE	UNLOADTABLE	LOADTABLE	MODE
			NOT		AND		OR		PURGETBL
			SYSTEM		USER		SESSION		RESPFLD
			INTO		FROM		KEY		DEFAULT
			TABLE		UPDATE		ROLLBACK	INDEX
			PROCEDURE	ASC		DESC
			GRANT		GROUP		EXISTS		RELOCATE
			id_or_colid
			id_or_sconst	set_ingres_id
			act_const	act_frskey	act_opt_val
			act_fld		act_col		activate_opt
			boph		bop		EXP
			lbop		relop		likeop		is_postfix_op
			frs_constname	frs_newconst
			decl_scale	loop_label	scroll_dir
			copy_dir	copy_delim	
			curly_end
			register_type	register_key	remove_key
			opt_asc_or_desc
			reg_obj_type
			record_decl
			decl_null	null_clause	default_clause
			sys_sess_user	owner_str

%type	<st_node>	OSLexpr		OSLprimary	OSLcondition
			OSLname		OSLname_all
			OSLvalue	colid_ref
			OSLvar		var_nocolon
			OSLcol_var	OSLnocol_var	var_colon
			OSLstrexpr	OSLintexpr
			param_lhs
			row_number	opt_row_number
			callassign	qual_table_ref	qual_id
			constant	escape		constant_or_null
			uconstant	uconstant_or_null
			uconstant_int	constant_str	
			column_list	col_name_list
			ingres_name	ingres_int	ingres_qname
			ing_name_list	ing_int_list	opt_ingres_str
			ingres_ref	ingres_str	keyword_assign
			query		query_menu_head query_loop_head
			query_ele	query_menu_start
			param_query	param_query_ele
			call_name	callf_param	callf_par_list
			callf_par_ele	callp_param	callp_par_list
			func_param	position_list	position_ele
			keyword_list	keyword_ele
			subsys_param	sub_par_list	sub_ele
			act_menu	act_timeout	decl_attr
			table_name	tbl_col_name
			unload_tlist	unload_tl	unload_var
			insrow_tlist	insrow_list	insrow_ele
			insrow_with_clause
			opt_table_column_list	tbl_col_list
			inittab		tab_mode_val	mode_key	mode_val
			scroll_table	scroll_table_opt	scroll_row
			set_forms_tl	set_list_var
			set_option	set_conn_value
			set_expr	set_value	set_value_onoff
			inq_forms_tl	inq_list_var    
			frs_constant	frs_constobj
			inq_ingres_tl	inq_ingres_var
			set_ingres_tl   set_ingres_var
			set_random_seed_key
			qualification	qual_list	qual_ele
			copy_format	copy_null
			location_name	int_list_all	format
			with_key	with_item_list	with_item
			owner_id	modify_to
			is_clause	opt_on_clause	opt_reg_from_clause
			like_pattern	set_sess_with_rhs
			set_rollback_clause set_sess_with_lhs

%type	<st_tlist>	copy_tl		copy_list	copy_list_elm
			lock_list	lock_list_elm
			mod_with_clause
			with_clause	with_body	with_element
			opt_col_spec_list reg_col_spec_list	reg_col_spec
			set_sess_with_list set_sess_with_elem

%type	<st_srtlist>	key_list	modkeys

%type	<st_qry>	qry		qry_body	query_loop_start

%type	<st_sym>	inq_var
			qual_ref
			unloadtab_head

%type	<st_nat>	DISPLAY_MENU	RUN_MENU
			act_opt_key	act_field
			act_opt_expl	act_on_exception
			noecho		unique_clause
			array_decl	proc_returning
			opt_not

/* %L types */
/* %L types begin - SQL grammar token/rule types */
%type	<st_name>	ALL	ANY	ASC	AVG	BETWEEN COUNT
			DELETE	DISTINCT	DESC	DROP	EXISTS
			IN		INSERT	MAX	MIN
			SELECT	SOME	SUM	UNION	GRANT	GROUP
			TO	OLD_AS	NEW_AS	CALLP	REGISTER
			JOIN		INNER_JOIN	FULL_JOIN
			LEFT_JOIN	RIGHT_JOIN	ON	REFERENCES
			agg_name	all_clause	scalar_func
			between_op	in_op		set_op
			union_op	distinct_clause	permit_type
			sys_maintained	on_commit_clause
			alert_key	default_or_sys_clause
			drop_many	drop_many_qual	drop_integ_permit 
			drop_single	drop_single_qual
			drop_secalarm	grant_on	on_table_proc_str
			on_proc_str	on_table_str	drop_permit_on
			join_type	any_clause

%type	<st_node>	DMLexpr		DMLprimary	DMLcondition
			DMLnfexpr	DMLvar		like_value
			qual_column_ref	scalar_args	ins_scalar
			between_range	in_set		in_set_list
			select_set	scalar_select
			sub_select	where_clause	OSLvalue_all
			from_clause	opt_from_clause	from_list
			from_item	from_source	opt_join_cond
			table_correl	group_clause	having_clause
			target_name	order_dir
			formobj_all	ins_expr_list	ins_ele
			ins_expr	ins_primary	insert_object
			ins_columns	ins_col_list	ins_col_ele
			grant_list	grant_type
			revoke_list	revoke_type
			permits		permit_list	perm_cols	perm_who
			perm_term	perm_time	perm_time_elm	perm_day
			group_list	column_opt	null_or_user_id
			crt_rule_ref		crt_rule_opt
			crt_rule_stmt_type	crt_rule_stmt_type_list
			crt_rule_exec_proc_args	crt_rule_exec_proc_val
			crt_rule_exec_proc_argl	crt_rule_exec_proc_arg
			qual_table_ref_list
			getevt_with_clause
			crt_tbl_def_opt		null_or_user_id
			connect_clause	connect_clauses	
			connect_opts	connect_opts_list	
			connect_with	connect_with_list	
			opt_disconnect_sess

%type	<st_tlist>	target_list	target_item_list	target_item
			col_assign_list col_assign		column_spec

%type	<st_qry>	select_qry	rselect_qry select_body	select_expr

%type	<st_srtlist>	order_clause	order_item
			index_key_list	index_key

%type	<st_nat>	delete_key	insert_key	update_key
			view_with

/* %L types end */
%%
/*;
** Name:	driver -	The start production.
**
** History:
**	04/07/91 (emerson)
**		Modifications for local procedures:
**		Added the local_proc_list production.
**		Added check for undefined local procedures at end of program.
**		Also moved to common stuff (e.g. calls to osFree and os_output)
**		from the frame and procedure productions up here under driver.
**		I also moved the call to osFree to the bottom; it frees
**		all tag-zero memory, and it made me nervous to do that
**		before calling os_output, oserrsummary, and osdepwrite.
**		(They write out information from various data structures).
*/
driver:		frame_or_proc local_proc_list
		{
			oschkundefprocs(FormSym);
			if (osErrcnt == 0 || osDebugIL)
			{
				os_output();
			}
			oserrsummary(FormSym);
			if (osErrcnt == 0)
			{
				osdepwrite();
			}
			osFree();
		}
	|	/* empty */
		{
			oscerr(OSEEMPTY, 0);
		}
;
frame_or_proc:	frame
	|	procedure
;
local_proc_list: local_proc_list local_proc
	|	/* empty */
;

/*
** Name:	frame -	An OSL frame.
**
** Generates:  (through 'IGendMenu()')
**		IL_BEGMENU no_of_activations
**		IL_MENUITEM | IL_KEYACT | IL_FLDACT | IL_COLACT ...
**		IL_ENDMENU initSID
**
** Side Effects:
**	Stack  ==>	|display SID	Becomes ==>	...
**			|init SID
**			|menu SID (set)
**			...
*/
frame:		init_section oplist end_submenu
		{
			register IGSID	*initSID;

			IGpopSID();		/* throw away display SID */
			osendblock();
			initSID = IGpopSID();
			IGsetSID(IGpopSID());	/* menu SID */
			IGendMenu(IL_BEGMENU, initSID);	/* end main menu */
			iiIGepEndProc(LocalFormSym->s_rdesc);
			osendproc(LocalFormSym);
		}
;
/*
** Name:	init_section -	Initialization Section
**
** Syntax:
**	INITIALIZE [ '(' <decl_list> ')' ] [ '=' '{' <stmt_list> '}' ]
**
** Generates:
**		object prologue code
**		ILDISPLOOP
**		table field(s) initialization code (through 'ostabsinit()'.)
**
** Side Effects:
**	Stack set up through the empty production for 'init_start'.
**
**	Stack ==>	|display SID	(set)
**			|initialize SID
**			|menu SID
**			...
**
**	04/07/91 (emerson)
**		Modifications for local procedures.
**		Also reworked productions to collapse frame initialization
**		into a single place: the new empty production for init_start.
*/
init_section:	init_start init_head stmt_block semic_option
		{
			IGsetSID(IGtopSID());	/* display SID */
			IGgenStmt(IL_DISPLOOP, (IGSID *)NULL, 0);
		}
	|	init_start
		{
			ostabsinit(FormSym);
			IGgenStmt(IL_INITIALIZE, (IGSID *)NULL, 0);

			IGsetSID(IGtopSID());	/* display SID */
			IGgenStmt(IL_DISPLOOP, (IGSID *)NULL, 0);
		}
;
init_head:	INITIALIZE decl_sec '=' local_sec
		{
			ostabsinit(FormSym);
			IGgenStmt(IL_INITIALIZE, (IGSID *)NULL, 0);
		}
;

/*
** Name:	init_start - Initialize for Frame Processing
**
** Generates:
**		ILSTHD	line_no
**		object prologue code
**
** Side Effects:
**	Stack set up.
**
**	Stack ==>	|display SID
**			|initialize SID
**			|menu SID
**			...
*/
init_start:	/* empty */
		{
			OSSYM	*framesym;
			PTR	rdesc;

			iiIGstmtInit();
			IGstartStmt(osscnlno(), IL_LB_NONE);
			FrmProcName = osFrm;
			rdesc = iiIGspStartProc(0, NULL);
			ostmpinit();
			ostmpnewproc();
			framesym = osobjinit(osFrm, osForm, OSFRAME);
			FormObj = FormSym = LocalFormSym =
				osformdecl(osForm, TRUE, &framesym->s_dbdt);
			LocalFormSym->s_rdesc = rdesc;

			IGpushSID(IGinitSID());	/* menu SID */
			IGgenStmt(IL_DISPLAY, IGtopSID(), 0);
			IGpushSID(IGinitSID());	/* initialization loop SID */
			IGsetSID(IGtopSID());
			IGpushSID(IGinitSID());	/* display loop SID */
			osblock(LP_DISPLAY, IGtopSID(),
					iiIG_string(ERx("$DISPLAY")));
			IGbgnMenu();
		}
;

/*
** Name:	procedure - OSL Procedure.
**
**	An OSL procedure may appear more than once in a file.
**	If there's no frame, the first procedure is the main procedure
**	(non-terminal "procedure").
**	All remaining procedures are local procedures ("local_proc").
**
** Syntax:
**	PROCEDURE <id_or_sconst> '(' <decl_list> ')' '=' '{' <stmt_list> '}'
**
** History:
**	04/07/91 (emerson)
**		Modifications for local procedures: Added local_proc,
**		local_proc_head, local_proc_decl, and proc_decls productions.
**  08-apr-98 (rodjo04) bug 90148
**      Added call to CVlower to ensure that the symbol is first forced
**      to lowercase and then entered into the symbol table.
*/
procedure:	proc_head proc_decls stmt_block semic_option
		{
			IGgenStmt(IL_RETPROC, (IGSID *)NULL, 1, (ILREF)0);
			iiIGepEndProc(LocalFormSym->s_rdesc);
			osendproc(LocalFormSym);
		}
;
proc_head:	PROCEDURE id_or_sconst
		{
			OSSYM	*procsym;
			PTR	rdesc;
            CVlower($2);
			iiIGstmtInit();
			IGstartStmt(osscnlno(), IL_LB_NONE);
			ProcState = TRUE;
			FrmProcName = osFrm;
			if (*osFrm != EOS
				&& STbcompare(osFrm, 0, $2, 0, TRUE) != 0)
			{
				osuerr( OSXPROC, 2, (PTR)osFrm, (PTR)$2 );
			}
			rdesc = iiIGspStartProc(0, NULL);
			ostmpinit();
			ostmpnewproc();
			procsym = osobjinit(osFrm, $2, OSPROC);
			FormObj = FormSym = LocalFormSym =
				osformdecl($2, FALSE, &procsym->s_dbdt);
			LocalFormSym->s_rdesc = rdesc;
			DispLoopCount = 0;
		}
;
local_proc:	local_proc_head proc_decls stmt_block semic_option
		{
			IGgenStmt(IL_RETPROC, (IGSID *)NULL, 1, (ILREF)0);
			iiIGepEndProc(LocalFormSym->s_rdesc);
			osendproc(LocalFormSym);
		}
;
local_proc_head: PROCEDURE id_or_sconst
		{
			ILREF	ilref;
                       
            CVlower($2);
			IGstartStmt(osscnlno(), IL_LB_NONE);
			LocalProcState = TRUE;
			FrmProcName = $2;
			LocalFormSym = osdefineproc($2, FormSym);
			LocalFormSym->s_rdesc = iiIGspStartProc(
					IGsetConst(DB_CHA_TYPE, $2),
					LocalFormSym->s_parent->s_rdesc);
			ostmpnewproc();
			DispLoopCount	= 0;
			SubMState	= 1;
			SubMInAlert	= 0;
			SubMGotNonAlert	= 0;
		}
;
proc_decls:	decl_sec '=' local_sec
		{
			IGgenStmt(IL_INITIALIZE, (IGSID *)NULL, 0);
		}
;

/* Semicolon or comma separator */
semic_or_comma:	';'
	|	','
;

/*
** Name:	decl_sec -	Implicit Declaration Section of INITIALIZE
**				or Procedure.
**
** Description:
**	A possibly empty or missing parenthesis-enclosed, comma-seperated list
**	of declarations.
*/
decl_sec:	'(' decl_list ')'
	|
		'(' ')'
	|
		/* empty */
;
decl_list:	decl_list semic_or_comma decl_elm
	|	decl_list semic_or_comma
	|	decl_elm
;

/*
** Name:	local_sec -	DECLARE Section of INITIALIZE or Procedure.
**
** Description:
**	A possibly empty or missing parenthesis-enclosed, comma-seperated list
**	of declarations.  These cannot be targets of passed parameters, so are
**	not writeable by the outside world.  - hence they are locals.
*/
local_sec:	declare_kw decl_list
		{
			DeclareFlags &= ~FDF_LOCAL;
		}
	|
		/* empty */
;
declare_kw:	DECLARE
		{
			DeclareFlags |= FDF_LOCAL;
		}
;

/*
** Name:	decl_elm -	OSL Declaration or OSL Constant Definition.
**
** Syntax:
**	ID [ '.' ID ] '=' ID [ '(' ICONST [ ',' ICONST ] ')' ]
**					[ WITH | NOT NULL ]
**	ID = [ ARRAY OF ] ID | TYPE OF FORM ID | TYPE OF TABLE FIELD ID . ID
**				| TYPE OF TABLE ID [ WITH | NOT NULL ]
** History:
**	04/07/91 (emerson)
**		Modifications for local procedures:
**		If PROCEDURE RETURNING specified, set new 9th parm
**		for osdeclare to TRUE.  Also boiled down and orthogonalized
**		the productions; certain invalid combinations that were being
**		reported as syntax errors (e.g. X = ARRAY OF CHAR(9)) are now
**		being passed to osdeclare, which will give a better message.
*/
decl_elm:	decl_attr '=' proc_returning array_decl ID decl_null
		{
			if ( $1 != NULL )
			{
				i4 flags = DeclareFlags;

				if ($4)
					flags |= FDF_ARRAY;

				(VOID)osdeclare( LocalFormSym, $1->n_name,
						$1->n_attr, $5,
						(char *)NULL, (char *)NULL,
						$6, flags,
						(bool)$3
				);
				ostrfree($1);
			}
		}
	| 	decl_attr '=' proc_returning array_decl
				CLASS_OF record_decl decl_null
		{
			if ( $1 != NULL && $6 != NULL )
			{
				i4 flags = DeclareFlags;

				if ($4)
					flags |= FDF_ARRAY;

				(VOID)osdeclare( LocalFormSym, $1->n_name,
						$1->n_attr, $6,
						(char *)NULL, (char *)NULL,
						$7, flags,
						(bool)$3
				);
				ostrfree($1);
			}
		}
	|	decl_attr '=' proc_returning array_decl
				ID '(' ICONST decl_scale ')' decl_null
		{
			if ($1 != NULL)
			{
				i4 flags = DeclareFlags;

				if ($4)
					flags |= FDF_ARRAY;

				(VOID)osdeclare( LocalFormSym, $1->n_name,
						$1->n_attr, $5,
						$7, $8,
						$10, flags,
						(bool)$3
				);
				ostrfree($1);
			}
		}
	|	decl_attr '=' PROCEDURE
		{
			if ($1 != NULL)
			{
				(VOID)osdeclare( LocalFormSym, $1->n_name,
						$1->n_attr, ERx("none"),
						(char *)NULL, (char *)NULL,
						(char *)NULL, DeclareFlags,
						(bool)TRUE
				);
				ostrfree($1);
			}
		}
/*
** Name:	const_defn -	OSL Constant Definition.
**
** Syntax:
**	ID = SCONST | XCONST | ICONST | FCONST | DCONST | NULLK
*/
	|	decl_attr '=' uconstant_or_null
		{
			yyerror(_SyntaxError);
			_VOID_ ossymundef($1->n_name, LocalFormSym);
			ostrfree($3);
			ostrfree($1);
		}
;
decl_attr:	ID '.' ID
		{
			if (ProcState || LocalProcState)
			{
				oscerr(E_OS016F_InProcOrLocalProc,
						1, ERget(_ColumnDecl));
				$$ = NULL;
			}
			else
			{
				u_ptr[0].u_cp = $1;
				u_ptr[1].u_cp = $3;
				$$ = osmknode(ATTR, &u_ptr[0], &u_ptr[1],
							(U_ARG*)NULL);
			}
		}
	|	COLID '.' ID
		{
			if (ProcState || LocalProcState)
			{
				oscerr(E_OS016F_InProcOrLocalProc,
						1, ERget(_ColumnDecl));
				$$ = NULL;
			}
			else
			{
				u_ptr[0].u_cp = $1;
				u_ptr[1].u_cp = $3;
				$$ = osmknode(ATTR, &u_ptr[0], &u_ptr[1],
							(U_ARG*)NULL);
			}
		}
	|	ID
		{
			u_ptr[0].u_cp = $1;
			u_ptr[1].u_cp = NULL;
			$$ = osmknode(ATTR, &u_ptr[0], &u_ptr[1], (U_ARG*)NULL);
		}
;
decl_scale:	/* empty */
		{
			$$ = NULL;
		}
	|	',' ICONST
		{
			$$ = $2;
		}
;
decl_null:	/* empty */
		{
			$$ = NULL;
		}
	|	WITH NULLK
		{
			$$ = ERx("with null");
		}
	|	NOT NULLK decl_default
		{
			$$ = ERx("not null");
		}
;
array_decl:	/* empty */
		{
			$$ = FALSE;
		}
	|	ARRAY_OF
		{
			$$ = TRUE;
		}
;
proc_returning:	/* empty */
		{
			$$ = FALSE;
		}
	|	PROCEDURE_RETURNING
		{
			/*
			** Local procedures within local procedures
			** can be allowed by changing the #if 1 below to #if 0.
			*/
#if 1
			if (LocalProcState)
			{
				oscerr(E_OS016D_NestedLocalProc, 0);
			}
#endif
			$$ = TRUE;
		}
;
record_decl:	TABLE ID
		{
			$$ = osldtable($2, (char *)NULL);
		}
	|	TABLE ID '.' ID
		{
			$$ = osldtable($4, $2);
		}
	|	TABLE FIELD ID '.' ID
		{
			$$ = osldform($3, $5);
		}
	|	TABLE FIELD ID
		{
			$$ = osldform(FormSym->s_name, $3);
		}
	|	ID ID
		{
			$$ = $2;
			if (!osw_compare(ERx("form"), $1))
				yyerror(_SyntaxError);
			$$ = osldform($2, (char*)NULL);
		}
;

/* `noise':  Default clause is meaningless for OSL declarations */
decl_default:	WITH DEFAULT
	|	NOT DEFAULT
	|	/* empty */
;

/*
** Name:	oplist -	Operations List.
**
** Description:
**	The main body of a OSL frame consist of a list of operations.
*/
oplist:		oplist op
	|
		op
;
op:		activations '=' stmt_block semic_option
		{
			SubMInAlert &= ~1;
		}
	|	error
		{
			i4	line;

			line = osscnlno();
			oscerr(OSEHEADER, 1, (PTR)&line);

			SubMInAlert &= ~1;

		} '=' stmt_block semic_option
;

/*
** Name:	activations -	The activations for an operation.
**
** Side Effects:
**	Stack ==>	|operation SID	(set)	Becomes ==>	...
**			...
*/
activations:	activate_list
		{
			if (ActState)
				IGsetSID(IGpopSID() /* operation SID */);
			ActState = FALSE;
		}
;
activate_list:	activate_ele
	|	activate_list ',' activate_ele
;

/*
** Name:	activate_ele -	Activation List Element.
**
** Syntax:
**	ID | SCONST | EXIT | END | RETURN
**		[ '(' VALIDATE '=' ICONST [ ',' EXPLANATION '=' SCONST ] ')' ]
**	KEY ID | SCONST
**		[ '(' VALIDATE '=' ICONST [ ',' EXPLANATION '=' SCONST ] ')' ]
**	[ BEFORE | AFTER ] FIELD ID | SCONST | ALL [ '.' ID | SCONST | ALL ]
**	ON TIMEOUT [ ICONST ]
**	ON DBEVENT
**
** Assumptions:
**	Stack ==>	|operation SID
**			...
** History:
**	08/06/91 (emerson)
**		Allow menu explanations to be specified as global constants
**		as well as string literals (bug 35460).
**		This required that menu activation options be ILREFs
**		instead of character strings; also see ilg!igmenu.c.
*/
activate_ele:	act_menu activate_opt
		{
			IGactivate( OLMENU, (PTR)osvalref($1), $2,
					IGtopSID() /* operation SID */
			);
			SubMGotNonAlert |= 1;
		}
	|	act_key act_frskey activate_opt
		{
			if ( $2 != NULL )
				IGactivate( OLKEY, $2, $3,
						IGtopSID()/* operation SID */
				);
			else
			{ /* no FRSkey */
				i4	line = osscnlno();
				oscerr(OSEHEADER, 1, (PTR)&line);
			}
			SubMGotNonAlert |= 1;
		}
	|	act_field act_fld act_col
		{
			register char	*cp;

			if ( $3 == NULL &&
				      (cp = STindex($2, ERx("."), 0)) == NULL )
			{ /* field */
				if ( !osw_compare(_All, $2) )
				{
					osfldcheck(FormSym, $2);
				}
				IGactivate($1 ? OLFLD_ENTRY : OLFIELD, $2,
						(PTR)NULL,
						IGtopSID() /* operation SID */
				);
			}
			else
			{ /* should be table field . column */
				char	buf[OSBUFSIZE];
				char	*table;
				char	*column;

				if ( $3 != NULL )
				{
					table = $2;
					column = $3;
				}
				else
				{
					_VOID_ STlcopy($2, buf, cp - $2);
					table = iiIG_string(buf);
					STcopy(cp+1, buf);
					column = iiIG_string(buf);
				}
				if ( !osw_compare(_All, column) )
					oscolcheck(FormSym, table, column);
				else
					_VOID_ ostblcheck(FormSym, table);
				IGactivate( $1 ? OLCOL_ENTRY : OLCOLUMN, table,
						column,
						IGtopSID() /* operation SID */
				);
			}
			SubMGotNonAlert |= 1;
		}
	|	act_on_exception act_timeout
		{
			if ( !ActState )
			{ /* 1st activation in list */
				IGpushSID(IGinitSID()); /* operations SID */
				IGstartStmt(osscnlno(), IL_LB_MENU);
				ActState = TRUE;
			}
			if ( $1 != -1 )
			{
				if ( $1 == OLALERTER )
				{
					if ( $2 != NULL )
					{
						yyerror(_SyntaxError);
					}
					if ( ( SubMState & 1 ) == 0 )
					{ /* In RUN_MENU */
						oscerr(E_OS017D_BabSubmAct, 0);
					}
					SubMInAlert |= 1;
				}
				else if ( $1 == OLTIMEOUT )
				{
					if ( $2 != NULL
						&& $2->n_token != tkICONST )
					{
						yyerror(_SyntaxError);
					}
					SubMGotNonAlert |= 1;
				}

				IGactivate( $1, $2, (PTR)NULL,
					IGtopSID() /* operations SID */
				);
			}
		}
	|	error '{' { i4  line = osscnlno();
				oscerr(OSEHEADER, 1, (PTR)&line);} activate_opt
;

activate_opt:	'(' act_opt_init act_opt_list ')'
		{
			$$ = (PTR)ActOpt;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
act_opt_init:	/* empty */
		{
			ActOpt[OPT_EXPL]  = 0;
			ActOpt[OPT_VAL]   = FRS_UF;
			ActOpt[OPT_ACTIV] = FRS_UF;
		}
;
act_opt_list:	act_opt_ele
	|	act_opt_list ',' act_opt_ele
	|	error
	|	act_opt_list ',' error
;
act_opt_ele:	act_val_key '=' act_opt_val
		{
			if ( ActOpt[OPT_VAL] == FRS_UF ) 
			{
				if ( *($3+1) == EOS )
				{
					if ( *$3 == '0' )
					{
						ActOpt[OPT_VAL] = FRS_NO;
					}
					else if ( *$3 == '1' )
					{
						ActOpt[OPT_VAL] = FRS_YES;
					}
				}
				if ( ActOpt[OPT_VAL] == FRS_UF )
				{
					frs_error( E_EQ0306_actARGS, EQ_ERROR,
						2, ERx("validate"), $3 );
				}
			}
		}
	|	act_opt_key '=' act_opt_expl
		{
			if ( $1 != 0 )
			{
				if ( $1 != tkSCONST )
				{
					yyerror(_SyntaxError);
				}
				else if ( ActOpt[OPT_EXPL] == 0 )
				{
					ActOpt[OPT_EXPL] = $3;
				}
			}
		}
	|	act_opt_key '=' act_opt_val
		{
			if ( $1 != 0 )
			{
				if ( $1 != tkICONST )
				{
					yyerror(_SyntaxError);
				}
				else if ( ActOpt[OPT_ACTIV] == FRS_UF )
				{
					if ( *($3+1) == EOS )
					{
						if ( *$3 == '0' )
						{
							ActOpt[OPT_ACTIV] =
							    FRS_NO;
						}
						else if ( *$3 == '1' )
						{
							ActOpt[OPT_ACTIV] =
							    FRS_YES;
						}
					}
					if ( ActOpt[OPT_ACTIV] == FRS_UF )
					{
						frs_error( E_EQ0306_actARGS,
							   EQ_ERROR, 2,
							   ERx("activate"),
							   $3 );
					}
				}
			}
		}
;
act_val_key:	VALIDATE
		{
			if ( ActOpt[OPT_VAL] != FRS_UF )
			{
				yyerror(_SyntaxError);
			}
		}
;
act_opt_key:	ID
		{
			if (osw_compare(_Explanation, $1))
			{
				if ( ActOpt[OPT_EXPL] != 0 )
				{
					yyerror(_SyntaxError);
				}
				$$ = tkSCONST;
			}
			else if (osw_compare(_Activate, $1))
			{
				if ( ActOpt[OPT_ACTIV] != FRS_UF )
				{
					yyerror(_SyntaxError);
				}
				$$ = tkICONST;
			}
			else
			{
				yyerror(ERx("VALIDATE, EXPLANATION, ACTIVATE"));
				$$ = 0;
			}
		}
;

act_opt_val:	ICONST
		{
			$$ = $1;
		}
	|	ON
		{
			$$ = ERx("1");
		}
	|	OFF
		{
			$$ = ERx("0");
		}
        |	BELL_TOK
		{
			$$ = ERx("2");
		}
	|	ID
		{
			static READONLY char	_True[]		= ERx("true"),
						_False[]	= ERx("false");

			if ( osw_compare(_True, $1) )
				$$ = ERx("1");
			else if ( osw_compare(_False, $1) )
				$$ = ERx("0");
			else
			{
				yyerror(_SyntaxError);
				$$ = ERx("0");
			}
		}
;
act_opt_expl:	SCONST
		{
			$$ = IGsetConst( DB_CHR_TYPE,
					 osstring( FALSE, $1, osldml ) );
		}
	|	COLID
		{
			OSSYM	*sym;

			sym = osfld( FormSym, $1, OSOBJUNDEF );
			$$ = sym->s_ilref;
			if ( sym->s_kind != OSACONST )
			{
				yyerror( _SyntaxError );
			}
		}
;


act_menu:	id_or_sconst
		{
			if (!ActState)
			{ /* 1st activation in list */
				IGpushSID(IGinitSID()); /* operations SID */
				IGstartStmt(osscnlno(), IL_LB_MENU);
				ActState = TRUE;
			}
			$$ = osmkconst(tkSCONST, osstring( FALSE, $1, osldml ));
		}
	|	act_const
		{
			if (!ActState)
			{ /* 1st activation in list */
				IGpushSID(IGinitSID()); /* operations SID */
				IGstartStmt(osscnlno(), IL_LB_MENU);
				ActState = TRUE;
			}
			$$ = osmkconst(tkSCONST, $1);
		}
	|	COLID
		{
			if (!ActState)
			{ /* 1st activation in list */
				IGpushSID(IGinitSID()); /* operations SID */
				IGstartStmt(osscnlno(), IL_LB_MENU);
				ActState = TRUE;
			}

			$$ = osvalnode(FormSym, $1);
			if ( $$->n_sym->s_kind != OSACONST )
				yyerror(_SyntaxError);
		}
;
act_const:	EXIT
		{
			$$ = $1;
		}
	|	END
		{
			$$ = $1;
		}
	|	RETURN
		{
			$$ = $1;
		}
;

act_key:	KEY
		{
			if (!ActState)
			{ /* 1st activation in list */
				IGpushSID(IGinitSID()); /* operations SID */
				IGstartStmt(osscnlno(), IL_LB_MENU);
				ActState = TRUE;
			}
		}
;
act_frskey:	id_or_sconst
		{
			register i4	keyval;

			if ((keyval = frsck_key($1)) == 0)
			{
				yyerror(ERx("FRSKEYn"));
				$$ = NULL;
			}
			else if (keyval < 0)
			{
				char	key_max[24];

				CVna(Fsi_KEY_PF_MAX, key_max);
				frs_error(E_EQ0157_fsNUM, EQ_ERROR,
						2, ERx("FRSKEY"), key_max
					);
				$$ = iiIG_string(ERx("1"));
			}
			else
			{
				char	buf[24];

				CVna(keyval, buf);
				$$ = iiIG_string(buf);
			}
		}
;

act_field:	FIELD begin_field_act
		{
			$$ = FALSE;
		}
	|	FIELD_EXIT begin_field_act
		{
			$$ = FALSE;
		}
	|	FIELD_ENTRY begin_field_act
		{
			$$ = TRUE;
		}
;
begin_field_act: /* empty */
		{
			if ( ( SubMState & 1 ) == 0 ) /* In RUN_MENU */
			{
				oscerr( E_OS017D_BabSubmAct, 0 );
			}

			if (!ActState)
			{ /* 1st activation in list */
				IGpushSID(IGinitSID()); /* operations SID */
				IGstartStmt(osscnlno(), IL_LB_MENU);
				ActState = TRUE;
			}
		}
;
act_fld:	id_or_sconst
		{
			$$ = $1;
		}
	|	ALL
		{
			$$ = _All;
		}
;
act_col:	'.' id_or_sconst
		{
			$$ = $2;
		}
	|	'.' ALL
		{
			$$ = _All;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

act_on_exception:	ON ID
		{
			if ( osw_compare(ERx("timeout"), $2) )
			{
				$$ = OLTIMEOUT;
			}
			else
			{
				yyerror(ERx("TIMEOUT"));
				$$ = -1;
			}
		}
	|	ON_DBEVENT
		{
			$$ = OLALERTER;
		}
;
act_timeout:	ICONST
		{
			$$ = osmkconst(tkICONST, $1);
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/**-
** Statement section.
**
** Includes:
**	stmt_block	stmt_list	semic_option	semicolon
**	curly_begin	curly_end	stmt
*/
/*;
** Name:	stmt_block -	A statement block.
**
** Syntax:
**	'=' '{' <stmt_list> '}'
**
** Generates (for frames):
**		ILGOTO	displaySID
**
** Assumptions (for frames or sub-menus):
**	Stack  ==>	|display SID
**			|initialize SID
**			|menu SID
**			...
*/
stmt_block:	curly_begin stmt_list curly_end
		{
			if ( !( ProcState || LocalProcState ) || SubMState > 1 )
			{
				IGstartStmt(osscnlno(), IL_LB_NONE);
				IGgenStmt( IL_GOTO,
					IGtopSID() /* display/menu loop SID */,
					0
				);
			}
		}
;

/*::
** Name:	stmt_list - A Statement List.
**
** Syntax:
**	<stmt_list> ';' <stmt>
**	<stmt>
*/
stmt_list:	stmt_list semicolon { ostmpbeg(); osclrrefs(FormSym); } stmt
		{
			osgenputs();
			ostmpend();
		}
	|	{ ostmpbeg(); osclrrefs(FormSym); } stmt
		{
			osgenputs();
			ostmpend();
		}
	|	error_oper stmt
;

/* Optional semicolon separator */
semic_option:	';'
	|	/* empty */
;
/* Semicolon separator */
semicolon:	';'
	|
		error {oscerr(OSESEMIC, 0);}
	|
		error_oper
;

curly_begin:	BEGIN
	|	'{'
;

curly_end:	END
		{
			$$ = $1;
		}
	|	'}'
		{
			$$ = ERx("}");
		}
;

/* Operation error (invalid in statement context) */
error_oper:	error activate_opt more_err_acts '=' {operr();}
			curly_begin stmt_list curly_end
	|	error curly_begin {operr();} stmt_list curly_end
;
more_err_acts:	',' activate_list
	|	/* empty */
;

stmt:		/* empty */
	|
		KEY {yyerror(_SyntaxError);} act_frskey {YYERROR;}
	|
		FIELD {yyerror(_SyntaxError);} act_fld act_col {YYERROR;}
	|
		FIELD_ENTRY {yyerror(_SyntaxError);} act_fld act_col {YYERROR;}
	|
		FIELD_EXIT {yyerror(_SyntaxError);} act_fld act_col {YYERROR;}
	|
		act_on_exception {yyerror(_SyntaxError);} act_timeout {YYERROR;}
	|
		osl_stmt
	|
		call_stmt
	|
		query_block
	|
		db_stmt
		{
			osdbflush();
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
		}
	|
		sub_menu
	|
		form_stmt
;

/**:
** Name:	osl_stmt -	OSL Control Statements.
**
*/
osl_stmt:	if_stmt
	|	while_stmt
	|	endloop_stmt
	/*	assignment statement	*/
/*::
** Name:	assign_stmt -	OSL Assignment Statement.
**
** Syntax:
**	ID ':=' <OSLexpr>
**	ID [ '[' <OSLexpr> ']' ] '.' ID ':=' <OSLexpr>
**
**	04/07/91 (emerson)
**		Do type check when right-hand side is a call of
**		a defined procedure (whether or not it's a local procedure).
*/
	|	OSLvar assign_op OSLexpr	/* assignment statement */
		{

			/* Special case:  Generate code for procedure calls
			** even if the procedure is not defined at this time.
			*/
			if ( !osiserr($1) )
			{
				if ($1->n_flags & N_READONLY)
				{
					oscerr(OSASNOVAR, 1, osnodename($1));
				}
				else if (  (  $3->n_token == tkPCALL
				           && (  $3->n_psym == NULL
					      || $3->n_psym->s_kind == OSUNDEF
					      )
				           )
				        || oschktypes($3->n_type, $1->n_type)
				        )
				{ /* generate assignment */
					if (AFE_NULLABLE_MACRO($3->n_type)
					  && !AFE_NULLABLE_MACRO($1->n_type))
					{
						if ($3->n_token == tkNULL)
							oscerr(OSNULLEXPR, 0);
						else
							oswarn(OSNULLCHK, 0);
					}

					osevalexpr($3, osnodesym($1));
					osvardisplay($1);
				}
				else
				{
					oscerr(OSASNTYPES, 0);
				}
			}
			ostrfree($1);
			ostrfree($3);

			FormObj = FormSym;
		} /* end assignment statement */
;

/*::
** Name:	if_stmt	-	The IF statement.
**
** Syntax:
**	IF <OSLcondition> THEN <stmt_list>
**	[ ELSEIF <OSLcondition> THEN <stmt_list> ] ...
**	[ ELSE <stmt_list> ]
**	ENDIF
**
** Side Effects:
**	Stack  ==>	|end SID (set)	Becomes ==>	...
**			...
*/
if_stmt:	if_part else_part
		{
			IGsetSID(IGpopSID());	/* end SID */
		}
;

/*;
** Name:	if_part -	IF clause of IF statement.
**
** Generates:
**		ILGOTO	endSID
**
** Side Effects:
**	Stack ==>	|else SID (set) Becomes ==>	|end SID
**			|end SID			...
**			...
*/
if_part:	if_expr stmt_list
		{
			register IGSID	*elseSID = IGpopSID();

			IGgenStmt(IL_GOTO, IGtopSID() /* end SID */, 0);
			IGsetSID(elseSID);
		}
;

/*;
** Name:	if_expr -	Condition of IF clause.
**
** Generates:
**		code for <OSLcondition>
**		ILIF	tmp elseSID
**
** Assumptions:
**	Stack ==>	|else SID
**			|end SID
**			...
**
** Side Effects:
**	Opens and closes a temp block.
**
** History:
**	01/13/91 (emerson)
**		Insert call to osgenputs after generating IL to evaluate
**		the logical expression (but before generating the IF).
**		This will generate a PUTFORM for each parameter passed
**		by reference to a procedure within the logical expression.
**		(Bug 34837).
**	14-sep-92 (davel)
**		Fixed bug 46472 - moved ostmpend() to before the IL_IF
**		generation, and moved the ostmpbeg() in front of OSLcondition.
**		Similar changes are made in the WHILE and ELSEIF rules.
*/
if_expr:	if_key {ostmpbeg();} OSLcondition then_key
		{
			ILREF	refer;

			refer = osvalref($3);
			osgenputs();
			ostmpend();
			IGgenStmt(IL_IF, IGtopSID() /* else SID */, 1, refer);
		}
;

/*;
** Name:	if_key -	IF keyword.
**
** Generates:
**		ILSTHD	line_no
**
** Side Effects:
**	Stack ==>	|else SID
**			|end SID
**			...
*/
if_key:		IF
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGpushSID(IGinitSID());		/* end SID */
			IGpushSID(IGinitSID());		/* else SID */
		}
;

/*
** Name:	then_key -	THEN Keyword for IF Statement.
**
** Description:
**	Catches missing THEN keyword.
*/
then_key:	THEN
	|	error {yyerror(ERx("THEN"));}
;

/*;
** Name:	else_part - Further clauses of IF statement.
*/
else_part:	else_if_part else_part
	|
		else_head ENDIF
	|
		else_head curly_end
		{ /* Error! */
			i4	line = osscnlno();

			oscerr(OSENDIF, 2, (PTR)&line, $2);
			YYERROR;
		}
	|
		ENDIF
	|
		curly_end
		{ /* Error! */
			i4	line = osscnlno();

			oscerr(OSENDIF, 2, (PTR)&line, $1);
			YYERROR;
		}
;

/*;
** Name:	else_if_part -	ELSEIF clause of IF statement.
**
** Generates:
**		ILGOTO	endSID
**
** Side Effects:
**	Stack ==>	|else SID (set) Becomes ==>	|end SID
**			|end SID			...
**			...
*/
else_if_part:	else_if_expr stmt_list
		{
			register IGSID	*elseSID = IGpopSID();

			IGgenStmt(IL_GOTO, IGtopSID() /* end SID */, 0);
			IGsetSID(elseSID);
		}
;

/*;
** Name:	else_if_expr -	Condition of ELSEIF clause.
**
** Generates:
**		code for condition
**		ILIF	tmp elseSID
**
** Assumptions:
**	Stack ==>	|new else SID
**			|end SID
**			...
**
** Side Effects:
**	Opens and closes a temp block.
**
** History:
**	01/13/91 (emerson)
**		Insert call to osgenputs after generating IL to evaluate
**		the logical expression (but before generating the IF).
**		This will generate a PUTFORM for each parameter passed
**		by reference to a procedure within the logical expression.
**		(Bug 34837).
**	14-sep-92 (davel)
**		Fixed bug 46472 - moved ostmpend() to before the IL_IF
**		generation, and moved the ostmpbeg() in front of OSLcondition.
**		Similar changes are made in the WHILE and IF rules.
*/
else_if_expr:	else_if_key {ostmpbeg();} OSLcondition then_key
		{
			ILREF	refer;

			refer = osvalref($3);
			osgenputs();
			ostmpend();
			IGgenStmt(IL_IF, IGtopSID() /* else SID */, 1, refer);
		}
;

/*;
** Name:	else_if_key -	ELSEIF keyword.
**
** Generates:
**		ILSTHD	line_no
**
** Side Effects:
**	Stack ==>	|end SID	Becomes ==>	|new else SID
**			...				|end SID
**							...
*/
else_if_key:	ELSEIF
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGpushSID(IGinitSID());		/* new else SID */
		}
;

/*;
** Name:	else_head - ELSE clause of IF statement.
**
** Generates:
**	Nothing, since the code falls through to the `end' SID that is set
**	when this production is reduced as part of the <if_stmt> production.
*/
else_head:	else_key stmt_list
;

/*;
** Name:	else_key -	ELSE Keyword.
**
** Generates:
**		ILSTHD	line_no
*/
else_key:	ELSE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	while_stmt -	The WHILE statement.
**
** Syntax:
**	[ ID : ] WHILE <OSLcondition> DO <stmt_list> ENDWHILE
**
** Generates:
**	whileSID: code for <OSLcondition>
**		ILIF tmp endSID
**	==>	ILGOTO	whileSID
**		code for <stmt_list>
**	endSID:
**
** Side Effects:
**	Stack ==>	|end SID (set)	Becomes ==>	...
**			|while SID
**			...
*/
while_stmt:	while_head while_expr stmt_list ENDWHILE
			
		{
			register IGSID	*endSID = IGpopSID();

			IGgenStmt(IL_GOTO, IGpopSID() /* while SID */, 0);
			IGsetSID(endSID);
			osendblock();
		}
;
/*;
** Name:	while_expr -	Condition for WHILE statement.
**
** Generates:
**		code for <OSLcondition>
**		ILIF	tmp endSID
**
** Assumptions:
**	Stack ==>	|end SID
**			|while SID
**			...
**
** Side Effects:
**	Opens and closes a temp block.
**
** History:
**	01/13/91 (emerson)
**		Insert call to osgenputs after generating IL to evaluate
**		the logical expression (but before generating the IF).
**		This will generate a PUTFORM for each parameter passed
**		by reference to a procedure within the logical expression.
**		(Bug 34837).
**	31-jul-92 (edf)
**		Made a call to op_vch_change to convert the string to
**		VARCHAR. This was handled correctly in expressions, but
**		when used singly as in "return 'text  '", the blanks
**		were being removed due to CHAR typing. (Bug 44485).
**	14-sep-92 (davel)
**		Fixed bug 46472 - moved ostmpend() to before the IL_IF
**		generation, and moved the ostmpbeg() in front of the
**		OSLcondition. Similar changes are made in the IF
**		and ELSEIF rules.
*/
while_expr:	{ostmpbeg();} OSLcondition do_key
		{
			ILREF	refer;

			refer = osvalref($2);
			osgenputs();
			ostmpend();
			IGgenStmt(IL_IF, IGtopSID() /* end SID */, 1, refer);
		}
;
do_key:		DO
	|	error {yyerror(ERx("DO"));}
;

/*
** Name:	while_head -	Label ID and Keyword of WHILE statement.
**
** Generates:
**		ILSTHD	line_no
**
** Side Effects:
**	Stack ==>	|end SID
**			|while SID	(set)
**			...
**
**	Also, sets the SID of the label identifier to be the `end' SID.
*/
while_head:	loop_label WHILE
		{
			IGpushSID(IGinitSID());		/* while SID */
			IGsetSID(IGtopSID());
			IGstartStmt(osscnlno(), IL_LB_WHILE);
			IGpushSID(IGinitSID());		/* end SID */
			osblock(LP_WHILE, IGtopSID(), $1);
		}
;

/*;
** Name:	loop_label -	Label ID of WHILE, UNLOADTABLE, RUN SUBMENU,
**				or DISPLAY SUBMENU statement.
*/
loop_label:	ID ':'
		{
			$$ = $1;
		}
	|
		/* empty */
		{
			$$ = NULL;
		}
;

/*::
** Name:	endloop_stmt -	The ENDLOOP statement.
**
** Syntax:
**	ENDLOOP [ ID ]
**
** Generates:
**	<code to clean up intervening loops>
**	ILGOTO	endSID | idSID
**
*/
endloop_stmt:	endloop_key
		{
			if (osblkbreak(LP_NONDISPLAY, (char *)NULL) != OK)
			{
				oscerr(OSENDLOOP, 0);
			}
		}
	|	endloop_key ID
		{
			_VOID_ osblkbreak(LP_LABEL, $2);
		}
;
endloop_key:	ENDLOOP
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/**:
** Name:	call_stmt - OSL Call Statements.
**
*/
call_stmt:	call_frame
	|	call_proc
	|	execute_procedure
	|	call_system
	|	call_subsystem
	|	return
	/*	exit	*/
/*::
** Name:	exit -			EXIT Statement.
**
** Syntax:
**	EXIT
*/
	|	EXIT
		{
			_VOID_ osblkbreak(LP_NONE, (char *)NULL);
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_EXIT, (IGSID *)NULL, 0);
		}
;

/*::
** Name:	return -		RETURN Statement.
**
** Syntax:
**	RETURN [ <OSLexpr> ]
**	04/07/91 (emerson)
**		Modifications for local procedures:
**		Get return type from OSFORM symbol table entry
**		instead of calling osobjtype; use FrmProcName instead of odFrm
**		in error messages.
*/
return:		return_key
		{
			DB_DT_ID	rettype;

			_VOID_ osblkbreak(LP_NONE, (char *)NULL);
			rettype = LocalFormSym->s_type;
			if (rettype != DB_NODT && osCompat > 5)
				oswarn(OSRETTYPE, 1, FrmProcName);
			if (ProcState || LocalProcState)
			{
				IGgenStmt(IL_RETPROC, (IGSID *)NULL,
					1, (ILREF)0);
			}
			else
			{
				IGgenStmt(IL_RETFRM, (IGSID *)NULL,
					1, (ILREF)0);
			}
		}
	|	return_key OSLexpr
		{
			DB_DT_ID	rettype;

			_VOID_ osblkbreak(LP_NONE, (char *)NULL);
			rettype = LocalFormSym->s_type;
			if ( rettype == DB_NODT )
				oscerr(OSNORETYPE, 1, FrmProcName);

			if ( $2->n_type != DB_NODT )
			{ /* valid return expression */
				if ( !oschktypes($2->n_type, rettype) )
					oscerr(OSBADRET, 1, FrmProcName);
				else if ( !AFE_NULLABLE(rettype) )
				{
					if ( $2->n_token == tkNULL )
						oscerr(OSNULLRET, 1,
								FrmProcName);
					else if ( AFE_NULLABLE($2->n_type) )
						oswarn(OSNULRETWARN, 1,
								FrmProcName);
				}

				/*
				** more dangerous magic: character constants
				** must be of type varchar. Bug 44485.
				*/
				op_vch_change($2);

				if (ProcState || LocalProcState)
				{
					IGgenStmt(IL_RETPROC, (IGSID *)NULL,
						1, osvarref($2));
				}
				else
				{
					IGgenStmt(IL_RETFRM, (IGSID *)NULL,
						1, osvarref($2));
				}
			}
		}
;
return_key:	RETURN
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/**-
** Call (Sub)System Statements.
**
** Includes:
**	call_system	call_subsystem
*/
call_key:	CALL
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
/*::
** Name:	call_system -	CALL SYSTEM Statement.
**
** Syntax:
**	CALL SYSTEM [ <OSLexpr> ]
*/
call_system:	call_key SYSTEM
		{
			IGgenStmt(IL_CALSYS, (IGSID *)NULL, 1, 0);
		}
	|	call_key SYSTEM OSLstrexpr
		{
			IGgenStmt(IL_CALSYS, (IGSID *)NULL, 1, osvalref($3));
		}
;

/*::
** Name:	call_subsystem -	CALL Subsystem Statement.
**
** Syntax:
**	CALL <ingres_name> [ '(' [ <sub_par_list> ] ')' ]
*/
call_subsystem: call_key ingres_name subsys_param
		{
			ossubsys($2, $3);
		}
;
subsys_param:	'(' sub_par_list ')'
		{
			$$ = $2;
		}
	|	'(' ')'
		{
			$$ = NULL;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
sub_par_list:	sub_par_list ',' sub_ele
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	sub_ele
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
sub_ele:	ingres_name '=' OSLexpr
		{
			if ( AFE_NULLABLE_MACRO($3->n_type) )
				oswarn( $3->n_token == tkNULL
					? OSNULLEXPR : OSNULVCHK, 0
				);
			u_ptr[0].u_cp = ERx(":=");
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(ASNOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	MODE '=' OSLexpr
		{
			if ( AFE_NULLABLE_MACRO($3->n_type) )
				oswarn( $3->n_token == tkNULL
					? OSNULLEXPR : OSNULVCHK, 0
				);
			u_ptr[0].u_cp = ERx(":=");
			u_ptr[1].u_nodep = osmkident( $1, (OSNODE *)NULL );
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(ASNOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	TABLE '=' OSLexpr
		{
			if ( AFE_NULLABLE_MACRO($3->n_type) )
				oswarn( $3->n_token == tkNULL
					? OSNULLEXPR : OSNULVCHK, 0
				);
			u_ptr[0].u_cp = ERx(":=");
			u_ptr[1].u_nodep = osmkident( $1, (OSNODE *)NULL );
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(ASNOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;

/**-
** Call Frame/Procedure Statements.
**
** Includes:
**	call_frame	call_proc
*/
callassign:	OSLvar assign_op
		{
			if ($1->n_flags & N_READONLY)
				$$ = NULL;
			else
				$$ = $1;
		}
	|	/* empty */
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = NULL;
		}
;
call_name:	ingres_name
		{
			$$ = $1;
		}
	|	SCROLL
		{
			$$ = osmkident( $1, (OSNODE *)NULL );
			$$->n_type = DB_CHA_TYPE;	/* special case */
		}
;
/*::
** Name:	call_frame -	CALL FRAME Statement.
**
** Syntax:
**	[ <OSLvar> ':=' ] CALLFRAME <ingres_name>
**					[ '(' [ <callf_par_list> ] ')' ]
**
** History:
**      01/90 (jhw) -- Reset 'FormObj' for next statement.  JupBug #6675.
**		('FormObj' gets set by the <OSLvar> rule.)
**	04/07/91 (emerson)
**		Modifications for local procedures:
**		Call new function osframesym instead of old osobjsym;
**	07/22/91 (emerson)
**		Fix for bug 38753: When call_name is a variable rather than
**		a literal, its node doesn't have a valid n_value, and it's
**		not appropriate to call osframesym.
**	08/18/91 (emerson)
**		Fix for bug 38001: FormObj was left NULL in the case where
**		there was no assignment of the return value.
*/
call_frame:	callassign callf_key call_name callf_param with_frs
		{
			register OSNODE	*node;

			if ($3->n_token == tkID)
			{
				u_ptr[0].u_symp = osframesym($3->n_value, TRUE);
			}
			else
			{
				u_ptr[0].u_symp = (OSSYM *)NULL;
			}
			u_ptr[1].u_nodep = $3;
			u_ptr[2].u_nodep = $4;
			node = osmknode(tkFCALL, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			if ($1 == NULL)
			{
				if ( node->n_type != DB_NODT && osCompat > 5
						&& osUser )
					oswarn(OSEXPRETVAL, 1, node->n_fsym->s_name);
				/* build param structure and call frame */
				osgencall(node, (OSSYM *)NULL);
			}
			else
			{ /* assignment */
				register OSSYM	*var = osnodesym($1);

				if (node->n_type != DB_NODT)
					node->n_fsym->s_ref |= OS_OBJREF;
				else
				{
					register OSSYM	*frame = node->n_fsym;

					if ( frame != NULL )
					{
					    if ( frame->s_kind == OSUNDEF )
						frame->s_ref |= OS_OBJREF;
					    else
						oscerr( OSNORETVAL,
							1, frame->s_name
						);
					}
				}

				if (osiserr($1))
					var = NULL;
				else if (node->n_type != DB_NODT
				  && !oschktypes(node->n_type, $1->n_type) )
				{
					oscerr(OSASNTYPES, 0);
					var = NULL;
				}

				/* build param structure and call frame */
				osgencall(node, var);
				if (var != NULL)
					osvardisplay($1);
				ostrfree($1);
			}
			FormObj = FormSym;
			ostrfree(node);
		}
;
callf_key:	CALLF
		{
			FrsStmt = IIDISPFRM;
		}
;
/* Note:  'CallState' used for #9133 bug check */
callf_param:	'(' {CallState = TRUE;} callf_par_list ')'
		{
			CallState = FALSE;
			$$ = $3;
		}
	|	'(' ')'
		{
			$$ = NULL;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
callf_par_list: callf_par_list par_list_sep callf_par_ele
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
		}
	|	callf_par_ele
		{
			$$ = $1;
		}
;
callf_par_ele:	param_query
		{
			$$ = $1;
		}
	|	param_lhs assign_op position_ele
		{
			/* ID [ '.' ID ] assign_op ... */
			/* save flag since 'osvarref()' frees node */
			bool		byref = $3->n_token == tkBYREF;

			if ($1->n_token != ATTR
			  || ($3->n_token == DOTALL && $1->n_attr != NULL))
			{
				osuerr(OSNULLCONST, 1, ERx("attribute"));
			}

			if ($3->n_token == DOTALL)
			{
				$$ = $3;
				ostrfree($1);
			}
			else
			{
				$$ = osmkassign(
					IGsetConst(DB_CHA_TYPE,
						$1->n_attr == NULL
						? $1->n_name : $1->n_attr),
					osvarref($3), byref
				);
			}
		}
;

/*::
** Name:	execute_procedure - EXECUTE PROCEDURE Statement.
**
** Syntax:
**	[ <OSLvar> ':=' ] EXECUTE PROCEDURE
**		<ingres_name> [ '(' [ <callp_par_list> ] ')' ]
**
*/
execute_procedure:	callassign EXE_PROC qual_id callp_param
		{
			register OSNODE	*node;
			register OSSYM	*var;

			u_ptr[0].u_symp = (OSSYM *)NULL;
			u_ptr[1].u_nodep = $3;
			u_ptr[2].u_nodep = $4;
			node = osmknode(tkEXEPROC, &u_ptr[0], &u_ptr[1], 
								&u_ptr[2]);
			if ( $1 == NULL 
			  || osiserr($1) || $1->n_flags & N_READONLY
			   )
			{
				var = (OSSYM *)NULL;
			}
			else if ( !oschktypes(node->n_type, $1->n_type) )
			{
				oscerr(OSASNTYPES, 0);
				var = (OSSYM *)NULL;
			}
			else
			{
				var = osnodesym($1);
			}
			osgencall(node, var);
			if (var != NULL)
				osvardisplay($1);
                        FormObj = FormSym;
			ostrfree($1);
			ostrfree(node);
		}
;
/*::
** Name:	call_proc - CALL PROCEDURE Statement.
**
** Syntax:
**	[ <OSLvar> ':=' ] CALL PROCEDURE
**		<ingres_name> [ '(' [ <callp_par_list> ] ')' ]
**
** (Note that CALL PROCEDURE is optional through the <OSLexpr> syntax.)
**
** Note <keyword_assign> is equivalent to "<ingres_name> <assign_op>" but
** has the <ingres_name> rules expanded directly to avoid "reduce/reduce"
** conflicts with <OSLvalue> from <OSLexpr> from <position_ele>.
**
** History:
**      01/90 (jhw) -- Reset 'FormObj' for next statement.  JupBug #6675.
**		('FormObj' gets set by the <OSLvar> rule.)
**	04/07/91 (emerson)
**		Modifications for local procedures:
**		Call new function osprocsym instead of old osobjsym;
**		it will look for a local procedure before looking for
**		a "regular" procedure.
**	07/22/91 (emerson)
**		Fix for bug 38753: When call_name is a variable rather than
**		a literal, its node doesn't have a valid n_value, and it's
**		not appropriate to call osprocsym.
**	07/25/91 (emerson)
**		Fix for bug 38849: Don't allow a CALLPROC of a system function.
**		(It was causing a bus error in osgencall, because osgencall
**		expects a tkPCALL node, but osmknode builds an OP or UNARYOP
**		node for a system function).
**	08/18/91 (emerson)
**		Fix for bug 38001: FormObj was left NULL in the case where
**		there was no assignment of the return value.
**  29-jun-98 (rodjo04) bug 90148
**      Added call to CVlower to ensure that the symbol is first
**      forced to lowercase and then entered into the symbol table.
**  18-aug-98 (rodjo04)
**      Amemded above fix by calling CVlower() only if n_value is
**      a constant, and not a variable.
*/

call_proc:	callassign CALLP call_name callp_param
		{
			register OSNODE	*node;
			char	*proc_name;
              
      			if ($3->n_token == tkID)
			{
				CVlower($3->n_value);
				proc_name = $3->n_value;
				u_ptr[0].u_symp = osprocsym(proc_name, TRUE);
			}
			else
			{
				proc_name = NULL;
				u_ptr[0].u_symp = (OSSYM *)NULL;
			}
			u_ptr[1].u_nodep = $3;
			u_ptr[2].u_nodep = $4;
			node = osmknode(tkPCALL, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			/*
			** If osmknode set node->n_token to something other
			** than tkPCALL, it's because it (osmknode) decided
			** that call_name represented a system (ADF) function.
			** This is an error:  CALLPROC may only be used
			** to call a procedure.
			*/
			if (node->n_token != tkPCALL)
			{
				oscerr( E_OS0267_CallProcSysFunc, 1,
					proc_name );
			}
			/* Type Check */
			else if ($1 == NULL)
			{
				if (node->n_type != DB_NODT && osCompat > 5
						&& osUser)
					oswarn(OSEXPRETVAL, 1, node->n_psym->s_name);
				/* build param structure and call procedure */
				osgencall(node, (OSSYM *)NULL);
			}
			else
			{
				register OSSYM	*var = osnodesym($1);

				if (node->n_type != DB_NODT)
				{
					node->n_psym->s_ref |= OS_OBJREF;
				}
				else
				{
					register OSSYM	*proc = node->n_psym;

					if ( proc != NULL )
					{
					    if ( proc->s_kind == OSUNDEF )
						proc->s_ref |= OS_OBJREF;
					    else
						oscerr( OSNORETVAL,
							1, proc->s_name
						);
					}
				}

				if (osiserr($1) || $1->n_flags & N_READONLY)
				{
					var = NULL;
				}
				else if (node->n_type != DB_NODT
				  && !oschktypes(node->n_type, $1->n_type) )
				{
					oscerr(OSASNTYPES, 0);
					var = NULL;
				}

				/* Generate code for procedure call */
				osgencall(node, var);

				if (var != NULL)
					osvardisplay($1);
				ostrfree($1);
			}
			FormObj = FormSym;
			ostrfree(node);
		}
;
callp_param:	'(' callp_par_list ')'
		{
			$$ = $2;
		}
	|	'(' ')'
		{
			$$ = NULL;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

callp_par_list: position_list par_list_sep keyword_list
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG *)NULL, &u_ptr[0], &u_ptr[1]);
		}
	|	keyword_list par_list_sep position_list
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			$$ = osmknode(COMMA, (U_ARG *)NULL, &u_ptr[0], &u_ptr[1]);
		}

	|	position_list
		{
			$$ = $1;
		}
	|	keyword_list
		{
			$$ = $1;
		}
;

position_list:	position_list par_list_sep position_ele
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode( COMMA, (U_ARG*)NULL, &u_ptr[0],
					&u_ptr[1]
			);
		}
	|	position_ele
		{
			$$ = $1;
		}
;
position_ele:	OSLexpr
		{
			$$ = $1;
		}
	|	BYREF '(' OSLvalue ')'
		{
			if ( $3->n_flags & N_READONLY )
			{
				oscerr(OSFNARG, 0);
				u_ptr[0].u_symp = ossymundef(ERx("*BYREF"),
						FormSym);
			}
			else
			{
				osmarkput($3);
				u_ptr[0].u_symp = osnodesym($3);
			}
			$$ = osmknode( tkBYREF, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
	|	OSLname_all
		{
			u_ptr[0].u_nodep = $1;
			$$ = osmknode(DOTALL, &u_ptr[0],
					(U_ARG*)NULL, (U_ARG*)NULL);
		}
;

keyword_list:	keyword_list par_list_sep keyword_ele
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode( COMMA, (U_ARG *)NULL, &u_ptr[0],
					&u_ptr[1]
			);
		}
	|	keyword_ele
		{
			$$ = $1;
		}
;
keyword_ele:	keyword_assign position_ele
		{
			/*
			** Note that this rule is used for a CALLPROC.
			** We don't generate code to do an assign if r.h.s.
			** is of the form x.ALL; we simply ignore the l.h.s.
			** (as is currently done for x.ALL in a CALLFRAME;
			** perhaps we should verify that l.h.s. is the name
			** of the called frame or procedure for both CALLFRAME
			** and CALLPROC).
			*/
			if ($2->n_token == DOTALL)
			{
				$$ = $2;
				ostrfree($1);
			}
			else
			{
				/* save flag since 'osvarref()' frees node */
				bool	byref = $2->n_token == tkBYREF;

				$$ = osmkassign(osvalref($1), osvarref($2),
						byref);
			}
		}
;
keyword_assign: ID assign_op
		{
			$$ = osmkconst( tkSCONST, $1 );
		}
	|	SCONST assign_op
		{
			$$ = osmkconst( tkSCONST, $1 );
		}
	|	OSLcol_var assign_op
		{
			if ($1->n_type != DB_NODT && !oschkstr($1->n_type))
				oscerr(OSNOTSTR, 1, ERget(_PrmKeyWord));
			$$ = $1;
		}
;

par_list_sep:	semic_or_comma
;

/**:
** Name:	query_block -	OSL Query Statements.
**
*/
/*::
** Name:	query_single -	Query Singleton Statement.
**
** Syntax:
**	<query>
**
** Generates:
**		code for <query>
**		ILQRYBRK qvar
*/
query_block:	query
		{
			osqrygen( $1, OS_QRYSTMT, !ProcState,
				  (IGSID *)NULL, (IGSID *)NULL );
			ostrfree($1);
		}
	/*	query_menu	*/
/*::
** Name:	query_menu -	Query Attached Menu Statement.
**
** Syntax:
**	<query> '{' <oplist> '}'
**
** Generates:  (from <query_menu_head>)
**		code for <query> (... QRYGEN qvar unique endquerySID)
**		ILGOTO	menuSID
**	initSID:
**		code for initialization <stmt_block> (if any)
**	submenuSID:
**		ILMENULOOP
**		code for <oplist>
**	(through 'IGendMenu()' and directly ...)
**	menuSID:
**		ILBEGDISPMU no_of_activations
**		ILMENUITEM | IL_KEYACT | IL_FLDACT | IL_COLACT ...
**		ILENDMENU initSID
**	endsubmenuSID:
**		ILPOPSUBMU
**	endquerySID:
**
** Side Effects:
**	Stack  ==>	|submenu loop SID	Becomes ==>	...
**			|initcode SID
**			|menu SID (set)
**			|end submenu SID (set)
**			|end query SID (set)
**			...
*/
	|	query_menu_head submenu_init oplist curly_end end_submenu
		{
			IGSID	*initcodeSID;

			DispLoopCount -= 1;

			_VOID_ IGpopSID(); 	/* discard MENULOOP SID */
			initcodeSID = IGpopSID();

			IGsetSID(IGpopSID());	/* BEGIN-DISPLAY SID */
			IGendMenu(IL_BEGDISPMU, initcodeSID);

			IGsetSID(IGpopSID());	/* end submenu SID */
			osendblock();		/* sub-menu */
			osendblock();		/* query */

			IGgenStmt(IL_POPSUBMU, (IGSID *)NULL, 0);
			IGsetSID(IGpopSID());	/* end query SID */
			ostrfree($1);
		}
/*	|	query_loop	*/
/*::
** Name:	query_loop -	Query Loop Statement.
**
** Syntax:
**	[ ID : ] <qry> '{' <stmt_list> '}'
**
** Generates:
**		code for <query> (... QRYGEN qvar unique endquerySID)
**	qwhileSID:
**		code for <stmt_list>
**	==>	ILQRYNEXT|ILM_BRANCH_ON_SUCCESS whileSID qvar FALSE
**	endquerySID:
**
** Side Effects:
**	Stack ==>	|query loop SID Becomes	 ==>	...
**			|end query SID (set)
**			...
*/
	|	query_loop_head stmt_list curly_end
		{
			register IGSID	*endwhileSID = IGpopSID();

			iiosQrNext($1, endwhileSID, (bool)FALSE);
			IGsetSID(IGpopSID() /* end query SID */);
			osendblock();
			ostrfree($1);

			QloopState = FALSE;
			OpErr = FALSE;
		}
	|	qry
		{
			register OSNODE *qry;

			u_ptr[0].u_symp = FormSym;
			u_ptr[1].u_nodep = osmknode( VALUE, &u_ptr[0],
						(U_ARG *)NULL, (U_ARG *)NULL );
			u_ptr[1].u_nodep->n_flags |= N_READONLY;
			u_ptr[0].u_p = TargListFrag;
			u_ptr[2].u_qrynodep = $1;
			qry = osmknode(tkQUERY,&u_ptr[0],&u_ptr[1],&u_ptr[2]);
			TargListFrag = NULL;
			osqrygen( qry, OS_QRYSTMT, !ProcState,
				  (IGSID *)NULL, (IGSID *)NULL );
			ostrfree(qry);
		}
/*	|	next	*/
/*::
** Name:	next -		NEXT Query Statement.
**
** Generates:
**		ILQRYNEXT okSID qvar msgon
**		<code to clean up intervening loops>
**		ILGOTO endquerySID|endsubmenuSID
**		okSID:
**		<code to recompute SELECT targets>
**
** Syntax:
**	NEXT
*/
	|	NEXT
		{
			IGSID		*qrySID;
			register OSNODE	*qry = osblkqry(&qrySID);

			IGstartStmt(osscnlno(), IL_LB_NONE);
			iiosQrNext( qry, (IGSID *)NULL,
				    (bool)(qry == NULL || SubMState > 1) );
		}
;

/*
** Name:	query_menu_head -	Query Submenu Head Statement.
**
** Generates:
**		code for <query> (... QRYGEN qvar unique endquerySID)
**
** Side Effects:
**	Stack ==>	|menu SID
**			|end submenu SID
**			|end query SID
**			...
*/
query_menu_head: query_menu_start
		{
			SubMState |= 1;
			DispLoopCount += 1;

			IGpushSID(IGinitSID());		/* end retrieve SID */
			osqrygen( $1, OS_SUBMENU, !ProcState,
				  IGtopSID(), (IGSID *)NULL );
			IGpushSID(IGinitSID());		/* end submenu SID */
			osblock(LP_QUERY, IGtopSID(), QueryLabel, $1);
			IGpushSID(IGinitSID());		/* menu SID */

			IGgenStmt(IL_GOTO, IGtopSID(), 0);
			$$ = $1;
		}
;
query_menu_start: ID ':' query curly_begin begin_submenu
		{
			QueryLabel = $1;
			$$ = $3;
		}
	|	query curly_begin begin_submenu
		{
			QueryLabel = NULL;
			$$ = $1;
		}
;
/*
** Name:	submenu_init -	Submenu Initialization Statement.
**
** Generates:
**		code for initialization <stmt_block> (if any)
**	submenu:
**	==>	ILMENULOOP
**
** Assumptions:
**	Stack ==>	|menu SID
**			...
**
** Side Effects:
**	Stack ==>	|submenu loop SID (set)
**			|initcode SID (set)
**			|menu SID (set)
**			...
*/
submenu_init: submenu_init_key '=' stmt_block semic_option
		{
			IGsetSID(IGtopSID());		/* menu SID */
			IGstartStmt(osscnlno(), IL_LB_WHILE);
			IGgenStmt(IL_MENULOOP, (IGSID *)NULL, 0);
		}
	|	/* empty */
		{
			IGpushSID(IGinitSID());		/* init code SID */
			IGsetSID(IGtopSID());
			IGstartStmt(osscnlno(), IL_LB_WHILE);

			IGpushSID(IGinitSID());		/* menu SID */
			IGbgnMenu();
			osblock(LP_DISPLAY, IGtopSID(), (char *) NULL);

			IGsetSID(IGtopSID());		/* menu SID */
			IGgenStmt(IL_MENULOOP, (IGSID *)NULL, 0);
		}
;
submenu_init_key: INITIALIZE
		{
			IGpushSID(IGinitSID());		/* init code SID */
			IGsetSID(IGtopSID());
			IGstartStmt(osscnlno(), IL_LB_WHILE);

			IGpushSID(IGinitSID());		/* menu SID */
			IGbgnMenu();
			osblock(LP_DISPLAY, IGtopSID(), (char *) NULL);
		}
;

/*
** Name:	query_loop_head -	Query Loop Head Statement.
**
** Generates:  (through 'osqrygen()')
**		code for <qry> (... QRYGEN qvar unique endquerySID)
**		qwhileSID:
**
** Side Effects:
**	Stack ==>	|query loop SID (set)
**			|end query SID
**			...
*/
query_loop_head: query_loop_start
		{
			IGSID	*endsid, *topsid;

			u_ptr[0].u_symp = FormSym;
			u_ptr[1].u_nodep = osmknode( VALUE, &u_ptr[0],
						(U_ARG *)NULL, (U_ARG *)NULL );
			u_ptr[1].u_nodep->n_flags |= N_READONLY;
			u_ptr[0].u_p = TargListFrag;
			u_ptr[2].u_qrynodep = $1;
			$$ = osmknode(tkQUERY, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			TargListFrag = NULL;
			endsid = IGinitSID();		/* end query SID */
			IGpushSID(endsid);
			topsid = IGinitSID();		/* query loop SID */
			IGpushSID(topsid);
			osqrygen( $$, OS_QRYLOOP, !ProcState,
				  endsid, topsid );
			osblock(LP_QWHILE, endsid, QueryLabel, $$);

			QloopState = TRUE;
		}
;
query_loop_start: ID ':' qry curly_begin
		{
			QueryLabel = $1;
			$$ = $3;
		}
	|	qry curly_begin
		{
			QueryLabel = NULL;
			$$ = $1;
		}
;

/*::
** Name:	query -		Form Object Query RETRIEVE/SELECT Statement.
**
** Description:
**	A retrieve into an form object, either a single retrieve or a
**	master-detail retrieve.
**
** Syntax:
**	<query_ele>
**	<query_ele> <query_ele>
*/
query:		query_ele
		{
			$$ = $1;
		}
	|	query_ele query_ele
		{
			$1->n_child = $2;
			$$ = $1;
		}
;

/*::
** Name:	query_ele -		Form Query RETRIEVE/SELECT Statement.
**
** Syntax:
**	ID [ '.' ID ] ':=' <qry>
*/
query_ele:	OSLvar assign_op qry
		{
			u_ptr[0].u_p = TargListFrag;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_qrynodep = $3;
			$$ = osmknode(tkQUERY, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			TargListFrag = NULL;
		}
;
param_query:	param_query_ele
		{
			$$ = $1;
		}
	|	param_query_ele param_query_ele
		{
			$1->n_child = $2;
			$$ = $1;
		}
;

param_query_ele:	param_lhs assign_op qry
		{
			u_ptr[0].u_p = TargListFrag;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_qrynodep = $3;
			$$ = osmknode(tkQUERY, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			TargListFrag = NULL;
		}
;

/*
** Name:	qry -	Query RETRIEVE/SELECT Statement.
**
** Description:
**	A <qry> is an optional REPEAT followed by a <qry_body>, which is
**	DML dependent.
*/
qry:		REPEAT {RepeatState = TRUE;} qry_body
		{
			$3->qn_repeat = RepeatState; /*may have been set FALSE*/
			$$ = $3;

			FormObj = FormSym;
			RepeatState = FALSE;
		}
	|	qry_body
		{
			$1->qn_repeat = FALSE;
			$$ = $1;

			FormObj = FormSym;
		}
;

/**:
** Name:	menu_stmt -	OSL SubMenu Statements.
*/
sub_menu:	/* display_menu */

/*::
** Name:	display_menu -	Display SubMenu Statement.
**
** Syntax:
**	DISPLAY MENU '{' <oplist> '}'
**
** Generates:
**		ILGOTO	menuSID
**	initcodeSID:
**		<initialize-block code>
**	submenuSID:
**		ILMENULOOP
**		code for <oplist>
**	(through 'IGendMenu()' and directly ...)
**	menuSID:
**		ILBEGDISPMU no_of_activations
**		ILMENUITEM | IL_KEYACT | IL_FLDACT | IL_COLACT ...
**		ILENDMENU initcodeSID
**	endsubmenuSID:
**		ILPOPSUBMU
**
** Side Effects:
**	Stack  ==>	|submenu loop SID	Becomes ==>	...
**			|init code SID
**			|menu SID (set)
**			|end submenu SID (set)
**			...
*/
		display_menu_key curly_begin submenu_init oplist curly_end
			end_submenu
		{
			register IGSID	*initcodeSID;

			DispLoopCount -= 1;

			_VOID_ IGpopSID(); 	/* discard menuloop SID */
			initcodeSID = IGpopSID();

			IGsetSID(IGpopSID());	/* BEGINMENU SID */
			IGendMenu(IL_BEGDISPMU, initcodeSID);

			IGsetSID(IGpopSID());	/* end submenu SID */
			osendblock();		/* sub-menu */
			osendblock();		/* sub-menu end */

			IGgenStmt(IL_POPSUBMU, (IGSID *)NULL, 0);
		}
	|	/* run_menu */
/*::
** Name:	run_menu -	Run SubMenu Statement.
**
** Syntax:
**	RUN MENU '{' <oplist> '}'
**
** Generates:
**		<initialize-block code>
**		ILGOTO	menuSID
**	submenuSID:
**		ILSUBMENU
**		code for <oplist>
**	(through 'IGendMenu()' and directly ...)
**	menuSID:
**		ILBEGSUBMU no_of_activations
**		ILMENUITEM | IL_KEYACT | IL_FLDACT | IL_COLACT ...
**		ILENDMENU submenuSID
**	endsubmenuSID:
**
** Side Effects:
**	Stack  ==>	|menu SID (set)		Becomes ==>	...
**			|submenu loop SID
**			|end submenu SID (set)
**			...
*/
		run_menu_key curly_begin runsub_init oplist curly_end
			end_submenu
		{
			IGsetSID(IGpopSID());	/* menu SID */
			IGendMenu(IL_BEGSUBMU, IGpopSID());/* submenu top SID */
			IGsetSID(IGpopSID());	/* end submenu SID */
			osendblock();		/* sub-menu end */
		}
;

/*
** Name:	display_menu_key
**
** Generates:
**	==>	ILGOTO	menuSID (directly or from <stmt_block>)
**
** Side Effects:
**	Stack ==>	|menu SID
**			|end submenu SID
**			...
*/
display_menu_key: loop_label DISPLAY_MENU begin_submenu
		{
			SubMState |= 1;
			DispLoopCount += 1;

			IGpushSID(IGinitSID());		/* end submenu SID */
			osblock(LP_DISPMENU, IGtopSID(), $1);
			IGpushSID(IGinitSID());		/* menu SID */
			IGgenStmt(IL_GOTO, IGtopSID(), 0);
		}
;

/*
** Name:	run_menu_key
**
** Side Effects:
**	Stack ==>	|end submenu SID
**			...
*/
run_menu_key:	loop_label RUN_MENU begin_submenu
		{
			IGpushSID(IGinitSID());		/* end submenu SID */
			osblock(LP_RUNMENU, IGtopSID(), $1);
		}
;

begin_submenu:	/* empty */
		{
			if ( SubMState > 0x7FFFFFFF )
			{
				SubMState &= 0x7FFFFFFF;
				oscerr( E_OS017C_SubmTooDeep, 0 );
			}
			SubMState	<<= 1;
			SubMInAlert	<<= 1;
			SubMGotNonAlert	<<= 1;
		}
;

end_submenu:	/* empty */
		{
			if ( ( SubMGotNonAlert & 1 ) == 0 )
			{
				oscerr( E_OS017F_MissingActs, 0 );
			}
			SubMState	>>= 1;
			SubMInAlert	>>= 1;
			SubMGotNonAlert	>>= 1;
		}
;

/*
** Name:	runsub_init -	Run Submenu Initialization Statement.
**			This is the same as submenu_init, but with a
**			different stack of SIDs.
**
** Generates:
**		<initialize-block code, possibly empty>
**	menuloopSID:
**		SUBMENU
**
** Assumptions:
**	Stack ==>	|end submenu SID
**			...
**
** Side Effects:
**	Note:  This stack is different than that for DISPLAY MENU.
**
**	Stack ==>	|menu SID
**			|submenu loop SID (set)
**			|end submenu SID
**			...
*/
runsub_init: runsub_init_key '=' stmt_block semic_option
		{
			register IGSID	*menuSID;

			/* re-arrange the stack here. */
			menuSID = IGpopSID();		/* menu SID */

			IGpushSID(IGinitSID());		/* submenu loop SID */
			IGsetSID(IGtopSID());

			IGpushSID(menuSID);		/* re-push menu SID */
			IGgenStmt(IL_SUBMENU, (IGSID *)NULL, 0);
			IGbgnMenu();
		}
	|	/* empty */
		{
			register IGSID	*menuSID;

			menuSID = IGinitSID();		/* menu SID */
			IGgenStmt(IL_GOTO, menuSID, 0);
			IGpushSID(IGinitSID());		/* submenu loop SID */
			IGsetSID(IGtopSID());
			IGpushSID(menuSID);		/* push menu SID */
			IGgenStmt(IL_SUBMENU, (IGSID *)NULL, 0);
			IGbgnMenu();
		}
;
runsub_init_key: INITIALIZE
		{
			IGpushSID(IGinitSID());		/* menu SID */
		}
;
/**:
** Name:	form_stmt - OSL Forms System Statements.
*/
form_stmt:	clear
	|	clearrow
	|	deleterow
	|	helpfile
	|	help_forms
	|	inittable
	|	inq_forms
	|	inq_ingres	/* the only EQUEL run-time statement */
	|	inq_4gl
	|	insertrow
	|	loadtable
	|	message
	|	mode
	|	printscreen
	|	prompt
	|	redisplay
	|	resume
	|	set_connection
	|	set_forms
	|	set_ingres
	|	set_4gl
	|	set_random_seed
	|	scroll
	|	sleep
	|	unloadtable
	|	validate
	|	validrow
	|	purgetable
;

/**-
** General OSL Forms System Statements.
**
** Includes:
**	clear	helpfile	help_forms	message		printscreen
**	prompt	redisplay	resume		scroll		sleep
**	validate
*/
/*::
** Name:	clear -		CLEAR Statement.
**
** Syntax:
**	CLEAR SCREEN
**	CLEAR FIELD ALL
**	CLEAR FIELD <ing_name_list>
**
** Generates:
**		ILSTHD	line_no
**		ILCLRSCR | ILCLRALL |
**		[ code for <ingres_name> ]
**		ILCLRFLD ref
**		...
*/
clear:		clear_key SCREEN
		{
			IGgenStmt(IL_CLRSCR, (IGSID *)NULL, 0);
		}
	|	clear_key FIELD ALL
		{
			IGgenStmt(IL_CLRALL, (IGSID *)NULL, 0);
		}
	|	clear_key FIELD ing_name_list
		{
			osevallist($3, clrfld);
		}
;
clear_key:	CLEAR
		{
			if (ProcState)
				oscerr(OSINPROC, 1, $1);
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	helpfile -	HELPFILE Statement.
**
** Syntax:
**	HELPFILE <ingres_name> <OSLexpr>
**
** Generates:
**		ILSTHD	line_no
**		[ code for <ingres_name> ]
**		[ code for <OSLexpr> ]
**		ILHLPFILE ref expr
*/
helpfile:	helpfile_key ingres_name OSLstrexpr
		{
			IGgenStmt(IL_HLPFILE, (IGSID *)NULL,
					2, osvalref($2), osvalref($3)
				);
		}
;
helpfile_key:	HELPFILE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	help_forms -	HELPFORMS Statement.
**
** Syntax:
**	HELPFORMS '(' SUBJECT '=' <OSLexpr> ',' FILE '=' <OSLexpr> ')'
**
** Generates:
**		ILSTHD	line_no
**		[ code for <OSLexpr> ]
**		[ code for <OSLexpr> ]
**		ILHLPFORMS expr1 expr2
*/
help_forms:	help_forms_key '(' subject '=' OSLstrexpr ','
						file '=' OSLstrexpr ')'
		{
			IGgenStmt(IL_HLPFORMS, (IGSID *)NULL,
				2, osvalref($5), osvalref($9)
				);
		}
;
help_forms_key: HELP_FORMS
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
subject:	id_or_sconst
		{
			if (!osw_compare(_Subject, $1))
				yyerror(ERx("SUBJECT"));
		}
;

/*::
** Name:	message -	MESSAGE Statement.
**
** Syntax:
**	MESSAGE <OSLexpr> [ WITH ... ]
**
** Generates:
**		ILSTHD	line_no
**		[ code for <OSLexpr> ]
**		ILMESSAGE expr
*/
message:	message_key OSLstrexpr with_frs
		{
			IGgenStmt(IL_MESSAGE, (IGSID *)NULL, 1, osvalref($2));
		}
;
message_key:	MESSAGE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			FrsStmt = IIMESSAGE;
		}
;

/*::
** Name:	prompt -	PROMPT Statement.
**
** Syntax:
**	<OSLvar> ':=' PROMPT [ NOECHO ] <OSLexpr> [ WITH ... ]
**
** Generates:
**		ILSTHD	line_no
**		[ code for <OSLexpr> ]
**		ILPROMPT expr
**
** History:
**      01/90 (jhw) -- Reset 'FormObj' for next statement.  JupBug #6675.
**		('FormObj' gets set by the <OSLvar> rule.)
*/
prompt:		OSLvar assign_op prompt_key noecho OSLstrexpr with_frs
		{
			if ( !($1->n_flags & N_READONLY))
			{
				if (!oschkstr($1->n_type))
					oscerr(OSVARPSTR, 0);
				else
				{
					IGgenStmt($4 ? IL_NEPROMPT : IL_PROMPT,
						(IGSID*)NULL, 2,
						$1->n_ilref, osvalref($5)
						);
					osvardisplay($1);
				}
			}
			else
			{
				ostrfree($5);
			}
			ostrfree($1);
			FormObj = FormSym;
		}
;
prompt_key:	PROMPT
		{
			FrsStmt = IINPROMPT;
		}
;
noecho:		NOECHO
		{
			$$ = TRUE;
		}
	|	/* empty */
		{
			$$ = FALSE;
		}
;

/*::
** Name:	printscreen -	PRINTSCREEN Statement.
**
** Syntax:
**	PRINTSCREEN [ '(' FILE '=' <OSLexpr> ')' ]
**
** Generates:
**		ILSTHD	line_no
**		[ code for <OSLexpr> ]
**		ILPRNTSCR expr
*/
printscreen:	printscr_key '(' file '=' OSLstrexpr ')'
		{
			IGgenStmt(IL_PRNTSCR, (IGSID *)NULL, 1, osvalref($5));
		}
	|	printscr_key
		{
			IGgenStmt(IL_PRNTSCR, (IGSID *)NULL, 1, 0);
		}
;
printscr_key:	PRINTSCREEN
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

file:		id_or_sconst
		{
			if (!osw_compare(_File, $1))
				yyerror(ERx("FILE"));
		}
;

/*::
** Name:	redisplay - REDISPLAY Statement.
**
** Syntax:
**	REDISPLAY
**
** Generates:
**		ILSTHD	line_no
**		ILREDISPLAY
*/
redisplay:	REDISPLAY
		{
			if (ProcState)
				oscerr(OSINPROC, 1, $1);
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_REDISPLAY, (IGSID *)NULL, 0);
		}
;

/*::
** Name:	resume -	RESUME Statement.
**
** Syntax:
**	RESUME
**	RESUME NEXT
**	RESUME MENU
**	RESUME FIELD <ingres_name>
**	RESUME FIELD ID '.' ID
**	RESUME NEXTFIELD
**	RESUME PREVIOUSFIELD
**
** Generates:
**		ILSTHD	line_no
**		RESUME |
**		RESMENU |
**		RESNEXT |
**		RESFLD ref |
**		RESCOL ref ref |
**		RESNFLD |
**		RESPFLD
**
** History:
**	01/90 (jhw) -- Don't generate GOTO unless its a frame.  JupBug #9247.
*/
resume:		resume_key res_list
		{
			if (DispLoopCount > 0)
			{
				_VOID_ osblkbreak(LP_DISPLAY, (char *)NULL);
			}
		}
|		resume_keyword res_extra_chk
		{
			if (DispLoopCount > 0)
			{
				_VOID_ osblkbreak(LP_DISPLAY, (char *)NULL);
			}
		}
;
resume_key:	RESUME
		{
			if (DispLoopCount == 0)
			{
				oscerr(E_OS016E_NotInDisplayLoop, 1, $1);
			}
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
res_list:	FIELD ingres_name res_extra_chk
		{
			register char	*cp;

			if ($2->n_token == tkID &&
				(cp = STindex($2->n_value, ERx("."), 0)) != NULL)
			{
				char	buf[OSBUFSIZE];
				char	*table;
				char	*column;

				STlcopy($2->n_value, buf, cp - $2->n_value);
				table = iiIG_string(buf);
				STcopy(cp+1, buf);
				column = iiIG_string(buf);
				resumecolumn(table, osmkident(column, (OSNODE *)NULL));
			}
			else
			{
				if ($2->n_token == tkID)
				{
					osfldcheck(FormSym, $2->n_value);
				}
				IGgenStmt(IL_RESFLD, (IGSID *)NULL, 1, osvalref($2));
			}
		}
	|	FIELD ID '.' ingres_name res_extra_chk
		{
			resumecolumn($2, $4);
		}
	|	/* empty */
		{
			IGgenStmt(IL_RESUME, (IGSID *)NULL, 0);
		}
;
resume_keyword:	RESENTRY
		{
			if (DispLoopCount == 0)
			{
				oscerr(E_OS016E_NotInDisplayLoop, 1, $1);
			}
			IGgenStmt(IL_RESENTRY, (IGSID *)NULL, 0);
		}
	|	RESNEXT
		{
			if (DispLoopCount == 0)
			{
				oscerr(E_OS016E_NotInDisplayLoop, 1, $1);
			}
			IGgenStmt(IL_RESNEXT, (IGSID *)NULL, 0);
		}
	|	RESMENU
		{
			if (DispLoopCount == 0)
			{
				oscerr(E_OS016E_NotInDisplayLoop, 1, $1);
			}
			IGgenStmt(IL_RESMENU, (IGSID *)NULL, 0);
		}
	|	RESNFLD
		{
			if (DispLoopCount == 0)
			{
				oscerr(E_OS016E_NotInDisplayLoop, 1, $1);
			}
			IGgenStmt(IL_RESNFLD, (IGSID *)NULL, 0);
		}
	|	RESPFLD
		{
			if (DispLoopCount == 0)
			{
				oscerr(E_OS016E_NotInDisplayLoop, 1, $1);
			}
			IGgenStmt(IL_RESPFLD, (IGSID *)NULL, 0);
		}
;
res_extra_chk:	/* empty */
		{
			/*
			** RESUME with operands is not allowed
			** inside an alerter activation.
			*/
			if ( SubMInAlert & 1 )
			{
				oscerr( E_OS017E_BadResInAlert, 0 );
			}
		}
;

/*::
** Name:	scroll -	SCROLL TO Statement.
**
** Syntax:
**	SCROLL [ <ingres_name> ] <ingres_name> TO <OSLintexpr> | END
**	SCROLL [ <ingres_name> ] <ingres_name> UP | DOWN
**
** Note:  Form name is not optional from within procedures.
**
** Generates:
**		ILSTHD	line_no
*/
scroll:		scroll_key ingres_name scroll_table_opt TO scroll_row
		{
			if ( $3 == NULL )
				scroll( (OSNODE *)NULL, $2, $5 );
			else
				scroll( $2, $3, $5 );
		}
	|	scroll_key ingres_name scroll_table scroll_dir
		{
			char	*dir;
			bool	up;
			OSNODE	*row;
			char	buf[16];

			if (( $4 == NULL && $3->n_token != tkID ) )
			{
				yyerror( ERx("TO, UP, DOWN") );
				ostrfree($2);
				ostrfree($3);
				break;
			}
			dir = ( $4 == NULL ) ? $3->n_value : $4;
			if ( !(up = osw_compare( ERx("up"), dir )) &&
				!osw_compare( ERx("down"), dir) )
			{
				yyerror( ERx("UP, DOWN") );
				ostrfree($2);
				ostrfree($3);
				break;
			}
			row = osmkconst( tkICONST,
				iiIG_string( STprintf(buf, ERx("%d"),
							up ? rowUP : rowDOWN
					)
				)
			);
			if ( $4 == NULL )
			{
				if ( ProcState )
					oscerr( OSINPROC, 1, 
						ERx("SCROLL <table field>") );
				scroll( (OSNODE *)NULL, $2, row );
			}
			else
				scroll( $2, $3, row );
		}
;
scroll_key:	SCROLL
		{
			IGstartStmt( osscnlno(), IL_LB_NONE );
		}
;
scroll_table:	ingres_name
		{
			$$ = $1;
		}
;
scroll_table_opt:	scroll_table
		{
			$$ = $1;
		}
	|	/* empty */
		{
			if ( ProcState )
				oscerr( OSINPROC, 1, ERx("SCROLL <table field>") );
			$$ = NULL;
		}
;
scroll_row:	OSLintexpr
		{
			$$ = $1;
		}
	|	END
		{
			char	buf[16];

			$$ = osmkconst( tkICONST,
				iiIG_string( STprintf(buf, ERx("%d"), rowEND) )
			);
		}
;
scroll_dir:	ID
		{
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}

/*::
** Name:	sleep -		SLEEP Stateement.
**
** Syntax:
**	SLEEP <OSLintexpr>
**
** Generates:
**		ILSTHD	line_no
**		[ code for <OSLintexpr> ]
**		ILSLEEP ref
*/
sleep:		sleep_key OSLintexpr
		{
			IGgenStmt(IL_SLEEP, (IGSID *)NULL, 1, osvalref($2));
		}
;
sleep_key:	SLEEP
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	validate -	VALIDATE Statement.
**
** Syntax:
**	VALIDATE
**	VALIDATE FIELD <ingres_name>
**
** Generates:
**		ILSTHD	line_no
**		ILVALIDATE bSID |
**		[ code for <ingres_name> ]
**		ILVALFLD tmp bSID
**		[ code to end any loops ]
**		GOTO displaySID
**	bSID:
*/
validate:	validate_key
		{
			IGSID	*xSID;

			IGgenStmt(IL_VALIDATE, (xSID = IGinitSID()), 0);
			if (DispLoopCount > 0)
			{
				_VOID_ osblkbreak(LP_DISPLAY, (char *)NULL);
			}
			IGsetSID(xSID);
		}
	|	validate_key FIELD ingres_name
		{
			IGSID	*xSID;

			if ($3->n_token == tkID)
				osfldcheck(FormSym, $3->n_value);
			IGgenStmt(IL_VALFLD, (xSID = IGinitSID()), 1, osvalref($3));
			if (DispLoopCount > 0)
			{
				_VOID_ osblkbreak(LP_DISPLAY, (char *)NULL);
			}
			IGsetSID(xSID);
		}
;
validate_key:	VALIDATE
		{
			if (ProcState)
			{
				oscerr(OSINPROC, 1, $1);
			}
			if (DispLoopCount == 0)
			{
				oscerr(E_OS016E_NotInDisplayLoop, 1, $1);
			}
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/**-
** OSL Forms System Table-Field/Array Statements.
**
** Includes:
**	clearrow	deleterow	insertrow	validrow
**	inittable	unloadtable
**
**	table_name, tbl_col_name	(used only here.)
*/

table_name: 	SCONST opt_row_number
		{
			$$ = osvalnode(FormSym, $1);
			if ($2 != NULL)
				$$ = osarraynode($$, $2, TRUE);
			$$ = os_ta_check(FormSym, $$);
			if (!osiserr($$))
				TableObj = osnodesym($$);
		}
	|	var_colon
		{ /* variable with a ':' */
			$$ = $1;
			if (!oschkstr($1->n_type))
				oscerr(OSNOTSTR, 1, ERget(_TblFldName));
			else if ( AFE_NULLABLE_MACRO($1->n_type) )
				oswarn(OSNULVCHK, 0);
		}
	|	{AllowForm = FALSE;} var_nocolon
		{ /* variable - could be tblfld or array */
			$$ = os_ta_check(FormSym, $2);
			if (!osiserr($$))
				TableObj = osnodesym($$);
		}
;

tbl_col_name:	ingres_name
		{
			if ($1->n_token == tkID && TableObj != NULL)
			{
				if (ossympeek($1->n_value, TableObj) != NULL)
				{
				     /* Hack Put back  - bug 79308 */

                     if (TableObj->s_type == DB_DMY_TYPE)
                     {
                         /*  HACK ATTACK - must be lowercase
                         **  in our string constants table.
                         */

                         if ( !is_state($1->n_value) )
                         {
                             CVlower($1->n_value);
                         }

                     }
				}
				else if (TableObj->s_type == DB_DMY_TYPE)
				{
					oscerr( OSNOTMEM,
						2, $1->n_value, TableObj->s_name
					);
					$1->n_flags |= N_ERROR;
				}
				else
				{
					/* tablefield, but no such column. */
					oscerr( OSNOCOL,
						3, TableObj->s_parent->s_name,
							TableObj->s_name,
							$1->n_value
					);
					$1->n_flags |= N_ERROR;
				}

			}
			$$ = $1;
		}
;

/*::
** Name:	clearrow -	CLEARROW Statement.
**
** Syntax:
**	CLEARROW <table_name> [ <row_number> ] [ '(' <ing_name_list> ')' ]
**
** Generates:
**		ILSTHD	line_no
**		[ code for <table_name> ]
**		[ code for <row_number> ]
**		CLRROW table row
**		[ TL1ELM VALUE ]
**		[ ... ]
**		ENDLIST
*/
clearrow:	clearrow_key table_name opt_table_column_list
		{
			osrowops(FormSym, (IGSID*)NULL, IL_CLRROW, $2);
			if ($3 != NULL)
				osevallist($3, ostl1elm);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
			TableObj = NULL;
		}
;
clearrow_key:	CLEARROW
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
opt_table_column_list:	'(' tbl_col_list ')'
		{
			$$ = $2;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
tbl_col_list:	tbl_col_list ',' tbl_col_name
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	tbl_col_name
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
/*::
** Name:	deleterow - DELETEROW Statement.
**
** Syntax:
**	DELETEROW <table_name> [ <row_number> ]
**
** Generates:
**		ILSTHD	line_noe
**		[ code for <table_name> ]
**		[ code for <row_number> ]
**		DELROW table row
*/
deleterow:	deleterow_key table_name
		{
			osrowops(FormSym, (IGSID*)NULL, IL_DELROW, $2);
			TableObj = NULL;
		}
;
deleterow_key:	DELETEROW
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
/*::
** Name:	purgetable - PURGETABLE Statement.
**
** Syntax:
**	PURGETABLE <table_name>
**
** Generates:
**		ILSTHD	line_noe
**		[ code for <form_name> ]
**		[ code for <table_name> ]
**		PURGETABLE form table
*/
purgetable:	purgetable_key ingres_name ingres_name
		{
			if ($3 == NULL)
			{
				oscerr(E_OS0270_NoPurgeTableName, 0);
			}
			if ($3->n_token == tkID && ($2 == NULL ||
				($2->n_token == tkID &&
				  STbcompare(FormSym->s_name, 0, $2->n_value,
				  0, TRUE) == 0)))
			{
				(void) ostblcheck(FormSym, $3->n_value);
			}
			IGgenStmt(IL_PURGETBL, (IGSID *) NULL, 2,
				$2 == NULL ? 0 : osvalref($2), osvalref($3));

		}
;
purgetable_key:	PURGETBL
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
/*::
** Name:	loadtable - LOADTABLE Statement.
**
** Syntax:
**	LOADTABLE <loadtable_name> [ '(' <insrow_list> ')' ]
**
** Generates:
*/
loadtable:	loadtable_key table_name insrow_tlist insrow_with_clause
		{
			if (osiserr($2))
			{
				; /* We've already output an error */
			}
			else if (  ($2->n_token == TABLE && $2->n_flags & N_ROW)
				|| ($2->n_token == VALUE && $2->n_sexpr != NULL)
				|| ($2->n_token == ARRAYREF) )
			{
			    	oscerr(OSLDTBLIDX, 0);
			}
			else if ($3 == NULL)
			{
				/* LOADTABLE must have a list */
			    	oscerr(OSLDTBLEMP, 0);
			}
			else
			{
				if ($4 == NULL)
				{
				    osrowops(FormSym, (IGSID*)NULL, 
					IL_LOADTABLE, $2);
				    osevallist($3, ostl2elm);
				    IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
				}
				else
				{
				    osrowops(FormSym, (IGSID*)NULL, 
					IL_LOADTABLE|ILM_HAS_CELL_ATTR, $2);
				    osevallist($3, ostl2elm);
				    IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
				    osevallist($4, frs_gen);
				    IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
				}
				TableObj = NULL;
			}
		}
;
loadtable_key:	LOADTABLE
		{
			if (ProcState)			/* Fix bug #47930 */
				oscerr(OSINPROC, 1, $1);
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	insertrow - INSERTROW Statement.
**
** Syntax:
**	INSERTROW <table_name> [ <row_number> ] [ '(' <insrow_list> ')' ]
**
** Generates:
*/
insertrow:	insertrow_key table_name insrow_tlist insrow_with_clause
		{
			if ($4 == NULL)
			{
			    osrowops(FormSym, (IGSID*)NULL, IL_INSROW, $2);
			    if ($3 != NULL)
				osevallist($3, ostl2elm);
			    IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
			}
			else
			{
			    osrowops(FormSym, (IGSID*)NULL, 
				IL_INSROW|ILM_HAS_CELL_ATTR, $2);
			    if ($3 != NULL)
				osevallist($3, ostl2elm);
			    IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
			    osevallist($4, frs_gen);
			    IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
			}
			TableObj = NULL;
		}
;
insertrow_key:	INSERTROW
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
insrow_with_clause:	insrow_with_key '(' set_forms_tl ')'
		{
			$$ = $3;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
insrow_with_key:	WITH
		{
			frs_insrow_with();
		}
;
insrow_tlist:	'(' insrow_list ')'
		{
			$$ = $2;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
insrow_list:	insrow_list ',' insrow_ele
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	insrow_ele
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
insrow_ele:	tbl_col_name '=' OSLexpr
		{
			if ( $1->n_token == tkID && TableObj != NULL
				&& !osiserr($1) )
			{
				OSSYM 	*sym = ossympeek($1->n_value, TableObj);

				if ($1->n_flags & N_READONLY)
				{
					oscerr(OSASNOVAR, 1, osnodename($1));
				}
				else if ( sym != NULL )
				{
					if (!oschktypes($3->n_type,sym->s_type))
					{
						oscerr(OSASNTYPES, 0);
					}
					else if ( AFE_NULLABLE_MACRO($3->n_type)
					  && !AFE_NULLABLE_MACRO(sym->s_type) )
					{
						if ($3->n_token == tkNULL)
							oscerr(OSNULLEXPR, 0);
						else
							oswarn(OSNULLCHK, 0);
					}
				}
			}
			$$ = osmkassign(osvalref($1), osvarref($3), FALSE);
		}
;
/*::
** Name:	validrow -	VALIDROW Statement.
**
** Syntax:
**	VALIDROW <table_name> [ <row_number> ] [ '(' <ing_name_list> ')' ]
**
** Generates:
**		ILSTHD	line_no
**		[ code for <table_name> ]
**		[ code for <row_number> ]
**		VALROW bSID table row
**		[ TL1ELM VALUE ]
**		[ ... ]
**		ENDLIST
**		[ code to end any loops ]
**		GOTO displaySID
**	bSID:
*/
validrow:	validrow_key table_name opt_table_column_list
		{
			IGSID	*xSID = IGinitSID();;

			osrowops(FormSym, xSID, IL_VALROW, $2);
			if ($3 != NULL)
				osevallist($3, ostl1elm);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
			if (DispLoopCount > 0)
			{
				_VOID_ osblkbreak(LP_DISPLAY, (char *)NULL);
			}
			IGsetSID(xSID);
			TableObj = NULL;
		}
;
validrow_key:	VALIDROW
		{
			if (ProcState)
			{
				oscerr(OSINPROC, 1, $1);
			}
			if (DispLoopCount == 0)
			{
				oscerr(E_OS016E_NotInDisplayLoop, 1, $1);
			}
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	inittable - INITTABLE Statement.
**
** Syntax:
**	INITTABLE <ingres_name> [ <mode_val> ]
**
** Generates:
**		ILSTHD	line_no
**		[ code for <ingres_name> ]
**		[ code for <mode_val> ]
**		ILINITTAB name mode
**		[ possible list of hidden columns ]
**		ILENDLIST
**
** Note:  Uses <mode_val> from Set/Inquire productions below.
**
** History:
**	12/14/91 (emerson)
**		Part of fix for bug 38940: If mode_val is omitted,
**		generate an ILREF pointing to "f" instead of an ILREF of 0.
**		See IIOitInittableExec in interp!ilftfld.c for details.
*/
inittable:	inittab tab_mode_val
		{
			register char *table;
			ILREF	ref1, ref2;

			/* save table name since 'osvalref()' frees node */
			table = ($1->n_token == tkID) ? $1->n_value : NULL;
			ref1 = osvalref($1);
			if ($2 == NULL)
				ref2 = IGsetConst(DB_CHA_TYPE, ERx("f"));
			else
				ref2 = osvalref($2);
			IGgenStmt(IL_INITTAB, (IGSID *)NULL, 2, ref1, ref2);
			if (table != NULL)
				oshidcol(FormSym, table);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
		}
;
inittab:	inittab_key ingres_name
		{
			if ($2->n_token == tkID)
				_VOID_ ostblcheck(FormSym, $2->n_value);
			else
				oswarn(OSTABINIT, 0);
			$$ = $2;
		}
;
inittab_key:	INITTABLE
		{
			if (ProcState)
				oscerr(OSINPROC, 1, $1);
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
tab_mode_val:	mode_val
		{
			if ($1 != NULL && $1->n_token == tkID)
				$1->n_value =
				 iiIG_string(frsck_mode(ERx("INITTABLE"), $1->n_value));
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*::
** Name:	unloadtable -	UNLOADTABLE Statement.
**
** Syntax:
**	UNLOADTABLE <id_or_sconst> [ '(' <unload_tl> ')' ] '{' <stmt_list> '}'
*/
unloadtable:	unloadtab_head curly_begin stmt_list curly_end
		{
			if ($1 != NULL)
			{
				osclrunld($1);
				IGgenStmt(IL_GOTO, IGpopSID() /*unload SID*/,0);
			}
			IGsetSID(IGpopSID());	/* end SID */
			osendblock();
		}
;
unloadtab_head: unloadtable_key table_name unload_tlist
		{
			IGSID	*endSID = IGtopSID();
			OSSYM *sym = NULL;

			if ( !osiserr($2) )
			{
				OSSYM	*osunload();

				/* There's an IGpushSID hidden in here. */
				sym = osunload(TableObj, endSID, $2);
			}
			if (sym != NULL)
				osgenunldcols(sym);
			osevallist($3, ostl2elm);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
			osgenputs();
			$$ = sym;
			TableObj = NULL;
		}
;
unloadtable_key: loop_label UNLOADTABLE
		{
			if (osblkutbl())
				oscerr(OSNESTUNLD, 0);
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGpushSID(IGinitSID());	/* end SID () */
			osblock(LP_UNLOADTBL, IGtopSID(), $1);
		}
;
unload_tlist:	'(' unload_tl ')'
		{
			$$ = $2;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
unload_tl:	unload_var
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	unload_tl ',' unload_var
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
unload_var:	OSLname '=' tbl_col_name
		{
			if ( !osiserr($3)
			  && $3->n_token == tkID
			  && TableObj != NULL
			  && !osiserr($1) )
			{
				OSSYM 	*sym = ossympeek($3->n_value, TableObj);

				if ( sym != NULL )
				{
					if (!oschktypes(sym->s_type,$1->n_type))
						oscerr(OSASNTYPES, 0);
					else if (AFE_NULLABLE_MACRO(sym->s_type)
					    && !AFE_NULLABLE_MACRO($1->n_type))
						oswarn(OSNULLCHK, 0);
				}
			}
			osmarkput($1);
			u_ptr[1].u_symp = osnodesym($1);
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(tkASSIGN, (U_ARG*)NULL, &u_ptr[1], &u_ptr[2]);
		}
;

/**-
** OSL Forms System Set/Inquire Statements.
**
** Includes:
**	mode	inq_forms	set_forms
**
**	mode_val	(used here and by <inittable> above.)
**
**	(used only here)
**	frs_object	frs_parlist	frs_constant	frs_constobj
**	frs_parname	frs_constname
*/
/*
** Set/Inquire FRS Shared Productions.
*/
frs_object:	id_or_sconst
		{
			frs_object($1);
		}
	|	FIELD
		{
			frs_object($1);
		}
	|	TABLE
		{
			frs_object($1);
		}
;
frs_parlist:	/* empty -- No parent-names */
	|	frs_parlist frs_parname
;
frs_parname:	ingres_ref
		{
			if ($1->n_token == tkID)
				frs_parentname($1->n_value, T_CHAR, (PTR)NULL);
			else if ( $1->n_token == tkICONST )
			{ /* should be row number */
				frs_parentname( $1->n_const, T_INT, (PTR)NULL );
			}
			else
			{ /* variable reference */
				frs_parentname(ERx(""), osfrs_basetype($1->n_type),
					(PTR)osnodesym($1)
				);
			}
			ostrfree($1);
		}
;
frs_constant:	frs_constname
		{
			$$ = osfrs_constant($1, (OSNODE *)NULL);
		}
	|	frs_newconst ')'
		{
			$$ = osfrs_constant($1, (OSNODE *)NULL);
		}
	|	frs_newconst frs_constobj ')'
		{
			$$ = osfrs_constant($1, $2);
		}
;
/* recognize as `new' style syntax */
frs_newconst:	frs_constname '('
		{
			if (osfrs_old())
				yyerror(_SyntaxError);
			$$ = $1;
		}
;
frs_constname:	id_or_sconst
		{
			$$ = $1;
		}
	|	MODE
		{
			$$ = $1;
		}
	|	VALIDATE
		{
			$$ = $1;
		}
	|	FIELD
		{
			$$ = $1;
		}
	|	TABLE
		{
			$$ = $1;
		}
	|	EXISTS
		{
			$$ = $1;
		}
;
frs_constobj:	ingres_ref
		{
			$$ = $1;
		}
	|	CLEAR
		{
			$$ = osmkconst( tkSCONST, $1 );
		}
	|	PRINTSCREEN
		{
			$$ = osmkconst( tkSCONST, $1 );
		}
	|	MODE		/* Added for JupBug #20809. */
		{
			$$ = osmkconst( tkSCONST, $1 );
		}
;

/*::
** Name:	mode -		MODE Statement.
**
** Syntax:
**	MODE <mode_val>
**
** Generates:
**		ILSTHD	line_no
**		ILSETFRS form NULL NULL 0
**		ILINQELM
**		ENDLIST
*/
mode:		mode_key mode_val
		{
			if ($2 != NULL && $2->n_token == tkID)
				$2->n_value =
				  iiIG_string(frsck_mode(ERx("MODE"), $2->n_value));
			IGgenStmt(IL_MODE, (IGSID *)NULL, 1, osvalref($2));
		}
;
mode_key:	MODE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
mode_val:	ingres_name
		{
			$$ = $1;
		}
	|	UPDATE
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;	/* special case */
		}
;

/*::
** Name:	inq_forms - INQUIRE_FORMS Statement.
**
** Syntax:
**	INQUIRE_FORMS <frs_object> [ <frs_parlist> ] '(' <inq_forms_tl> ')'
**
** Generates:
**		ILSTHD	line_no
**		[code for ..
**		IL_INQFRS parent1 parent2 row object_value
**		INQELM value object row ?
**		ENDLIST
*/
inq_forms:	inq_forms_head '(' inq_forms_tl ')'
		{
			frs_head();
			osevallist($3, frs_gen);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
		}
;
inq_forms_key:	INQ_FORMS
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			frs_inqset(FRSinq);
		}
;
inq_forms_head: inq_forms_key frs_object frs_parlist
		{
			frs_style();	/* recognize style semantically */
		}
;
inq_forms_tl:	inq_list_var
		{
			if ($1 != NULL)
			{
				u_ptr[0].u_nodep = $1;
				u_ptr[1].u_nodep = NULL;
				u_ptr[2].u_nodep = NULL;
				$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			}
			else
			{
				$$ = NULL;
			}
		}
	|	inq_forms_tl ',' inq_list_var
		{
			if ($3 != NULL)
			{
				u_ptr[0].u_nodep = $3;
				u_ptr[1].u_nodep = $1;
				u_ptr[2].u_nodep = NULL;
				$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			}
			else
			{
				$$ = $1;
			}
		}
;
inq_list_var:	inq_var '=' frs_constant
		{
			OSNODE 	*n = NULL;

			if ( $1 != NULL && $3 != NULL )
			{
				if ( $3->n_token == FRSCONST )
                		{ /* `new' style */
					$3->n_inqvar = $1;
					n = $3;
				}
				else
				{ /* `old' style */
					n = osmkassign( $1->s_ilref,
							osvalref($3), FALSE
					);
				}
			}
			$$ = n;
		}
;
inq_var:	OSLname
		{
			OSSYM 	*sym = osnodesym($1);

			frs_iqset(sym);
			osmarkput($1);

			if (osiserr($1))
				$$ = NULL;
			else
				$$ = sym;
		}
;

/*::
** Name:	set_forms - SET_FORMS Statement.
**
** Syntax:
**	SET_FORMS <frs_object> [ <frs_parlist> ] '(' <set_forms_tl> ')'
**
** Generates:
**		ILSTHD	line_no
**		[code for ..
**		IL_SETFRS parent1 parent2 row object_value
**		INQELM value object row ?
**		ENDLIST
*/
set_forms:	set_forms_head '(' set_forms_tl ')'
		{
			frs_head();
			osevallist($3, frs_gen);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
		}
;
set_forms_key:	SET_FORMS
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			frs_inqset(FRSset);
		}
;
set_forms_head: set_forms_key frs_object frs_parlist
		{
			frs_style();	/* recognize style semantically */
		}
;
set_forms_tl:	set_list_var
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	set_forms_tl ',' set_list_var
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
set_list_var:	frs_constant '=' set_value
		{
			if ($1 == NULL)
				ostrfree($3);
			else
			{
				if ($1->n_token == FRSCONST)
				{ /* `new' style */
					$1->n_setref = osfrs_setval($3);
				}
				else
				{ /* `old' style */
					$1 = osmkassign(osvalref($1), osvarref($3), FALSE);
				}
			}
			$$ = $1;
		}

/*::
** Name:	inq_ingres -	INQUIRE_INGRES Statement.
**
** Syntax:
**	INQUIRE_INGRES '(' <OSLname> '=' <id_or_sconst> [ ',' ... ] ')'
*/
inq_ingres:	inq_ingres_key '(' inq_ingres_tl ')'
		{
			IGgenStmt(IL_INQING, (IGSID *)NULL, 0);
			osevallist($3, ostl2elm);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
		}
;
inq_ingres_key: INQ_INGRES
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
inq_ingres_tl:	inq_ingres_var
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	inq_ingres_tl ',' inq_ingres_var
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
inq_ingres_var: OSLname '=' set_ingres_id
		{
			if ($1->n_flags & N_READONLY)
			{
				$$ = NULL;
			}
			else
			{
				osmarkput($1);
				u_ptr[1].u_symp = osnodesym($1);
				u_ptr[2].u_nodep = osmkconst( tkSCONST, $3 );
				$$ = osmknode(tkASSIGN, (U_ARG*)NULL,
						&u_ptr[1], &u_ptr[2]
				);
			}
		}
;

/*::
** Name:    set_ingres -    SET_INGRES Statement.
**
** Syntax:
**  SET_INGRES '(' <id_or_sconst> '=' <OSLexpr> [ ',' ... ] ')'
*/
set_ingres: set_ingres_key '(' set_ingres_tl ')'
		{
			IGgenStmt(IL_SETING, (IGSID *)NULL, 0);
			osevallist($3, ostl2elm);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
			if (SetSession)
			{
				IGgenStmt(IL_CHKCONNECT, (IGSID *)NULL, 0);
			}
		}
;
set_ingres_key: SET_INGRES
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			SetSession = FALSE;
		}
;
set_ingres_tl:  set_ingres_var
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|   set_ingres_tl ',' set_ingres_var
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
set_ingres_var: set_ingres_id '=' set_expr
		{
			$$ = osmkassign( IGsetConst(DB_CHA_TYPE, $1),
						osvarref($3), FALSE
			);
		}
;
set_ingres_id:	id_or_sconst
		{
			$$ = $1;
		}
	|	SESSION
		{
			SetSession = TRUE;
			$$ = $1;
		}
;

set_expr:	OSLexpr
		{
			$$ = $1;
		}
	|	set_value_onoff
		{
			$$ = $1;
		}
;

set_value:	OSLprimary
		{
			$$ = $1;
		}
	|	set_value_onoff
		{
			$$ = $1;
		}
;

set_value_onoff:	ON
		{
			$$ = osmkconst(tkICONST, ERx("1"));
		}
	|	OFF
		{
			$$ = osmkconst(tkICONST, ERx("0"));
		}
        |	BELL_TOK 	
		{
                     	$$ = osmkconst(tkICONST, ERx("2"));
		}
;

/*::
** Name:	set_connection - SET CONNECTION statement.
**
** Syntax:
**	SET CONNECTION <set_value>
**
** Note: this fakes a SET_SQL call, using "connection_name" as the SET keyword.
*/
set_connection:	set_conn_key set_conn_value
	{
		IGgenStmt(IL_SETING, (IGSID *)NULL, 0);
		u_ptr[0].u_nodep = $2;
		u_ptr[1].u_nodep = NULL;
		u_ptr[2].u_nodep = NULL;
		u_ptr[0].u_nodep = osmknode(NLIST, &u_ptr[0], 
						&u_ptr[1], &u_ptr[2]);
		osevallist(u_ptr[0].u_nodep, ostl2elm); 
		IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
		IGgenStmt(IL_CHKCONNECT, (IGSID *)NULL, 0);
	}
;
set_conn_key:	SET_CONNECTION
	{
		IGstartStmt(osscnlno(), IL_LB_NONE);
	}
;

set_conn_value:	ingres_str
	{
		$$ = osmkassign( IGsetConst(DB_CHA_TYPE, 
				ERx("connection_name")), osvarref($1), FALSE);
	}
;
/*::
** Name:	inq_4gl -	INQUIRE_4GL Statement.
**
** Syntax:
**	INQUIRE_4GL '(' <OSLname> '=' <id_or_sconst> [ ',' ... ] ')'
**
**	Note: this uses the inq_ingres target list rules!  This is fine for
**	now, as no keyword validation is done at compile time.
*/
inq_4gl:	inq_4gl_key '(' inq_ingres_tl ')'
		{
			IGgenStmt(IL_INQ4GL, (IGSID *)NULL, 0);
			osevallist($3, ostl2elm);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
		}
;
inq_4gl_key: INQ_4GL
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:    set_4gl -    SET_4GL Statement.
**
** Syntax:
**  SET_4GL '(' <id_or_sconst> '=' <OSLexpr> [ ',' ... ] ')'
**
**	Note: this uses the set_ingres target list rules!  This is fine for
**	now, as no keyword validation is done at compile time.
*/
set_4gl: set_4gl_key '(' set_ingres_tl ')'
		{
			IGgenStmt(IL_SET4GL, (IGSID *)NULL, 0);
			osevallist($3, ostl2elm);
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
		}
;
set_4gl_key: SET_4GL
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:    set_random_seed -    SET_RANDOM_SEED Statement.
**
** Note:	Unlike all other commands, this one needs to be executed
**		both locally and on the DBMS - we therefore generate
**		intemediate code for the DB commmand, and then generate
**		the code for the abf side.
** Syntax:
**  SET_RANDOM_SEED [ <OSLintexpr> ]
**
*/
set_random_seed: set_random_seed_key
		{
			IGgenStmt(QUEL ? IL_SET : IL_SETSQL, (IGSID *)NULL, 0);
			osdbstr(ERx("random_seed"));
			osdbflush();
			IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_SET_RANDOM, (IGSID *)NULL, 1, 0);
		}
	|	set_random_seed_key OSLintexpr
		{
			if (tkIS_CONST_MACRO($2->n_token)) {
				IGgenStmt(QUEL ? IL_SET : IL_SETSQL, (IGSID *)NULL, 0);
				osdbstr(ERx("random_seed "));
				/*
				** We could do 'osdbeval($2);' to achieve what we want
				** except it will quietly free the $2 expr that we need
				** for the IL_SET_RANDOM.
				*/
				osdbstr($2->n_const);
				osdbflush();
				IGgenStmt(IL_ENDLIST, (IGSID *)NULL, 0);
				IGstartStmt(osscnlno(), IL_LB_NONE);
			}
			IGgenStmt(IL_SET_RANDOM, (IGSID *)NULL, 1, osvalref($2));
		}
;
set_random_seed_key: SET_RANDOM_SEED
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/**-
** Forms Statement WITH Options Clause
**
**	Used with <message>, <prompt> and <call_frame>.
**
** Includes:
**	with_frs
*/
/*
** Name:	with_frs -	FRS With Options Clause.
**
** Syntax:
**	WITH ID '=' ID [ '(' ID '=' <ingres_ref> [ ',' ... ] ')' ]
*/
with_frs:	WITH {_VOID_ EQFWopen( FrsStmt );} frs_options
		{
			frs_optgen();
		}
	|	/* empty */
;
frs_options:	frs_option
	|	frs_options ',' {yyerror(_SyntaxError);} frs_option
;
frs_option:	frs_wcoption frs_suboptions
;
frs_wcoption:	ID '=' ID
		{
			EQFWwcoption($1, $3);
		}
;
frs_suboptions:	'(' frs_list ')'
	|	/* empty */
;
frs_list:	frs_suboption
	|	frs_list ',' frs_suboption
;
frs_suboption:	ID '=' ingres_ref
		{
			if ( $3->n_token == tkSCONST ||
					$3->n_token == tkICONST ||
					$3->n_token == tkFCONST ||
					$3->n_token == tkDCONST )
			{ /* a constant */
				EQFWsuboption( $1, $3->n_type, $3->n_const, (PTR)NULL );
			}
			else if ( $3->n_token == tkID )
			{ /* an ID constant */
				EQFWsuboption( $1, DB_CHR_TYPE, $3->n_value, (PTR)NULL );
			}
			else
			{ /* a variable reference */
				OSSYM *sym = osnodesym($3);

				if ( AFE_NULLABLE_MACRO($3->n_type) )
					oswarn(OSNULVCHK, 0);
				EQFWsuboption( $1,
					AFE_NULLABLE_MACRO($3->n_type)
						? ( - $3->n_type ) : $3->n_type,
						sym->s_name, (PTR)sym
				);
			}
		}
		|	ID '=' DEFAULT
			{
				EQFWsuboption( $1, DB_CHR_TYPE, $3, (PTR)NULL );
			}
;

/* %L rules */
/* %L rules begin - SQL dependent grammar */
/*
** Name:	qry_body -	Query SELECT Expression.
**
** Description:
**	Components of the query retrieve statement for SQL.
**
** Syntax:
**	SELECT [ DISTINCT | ALL ] <target_list> FROM <table_correl> [ ',' ... ]
**		[ WHERE <DMLcondition> ]
**		[ GROUP BY <column_list> [ ',' ... ] ]
**		[ HAVING <DMLcondition> ]
**		[ UNION SELECT [ DISTINCT | ALL ] <target_list>
**			FROM <table_correl> [ ',' ... ]
**			[ WHERE <DMLcondition> ]
**			[ GROUP BY <column_list> [ ',' ... ] ]
**			[ HAVING <DMLcondition> ] ]
**		[ ORDER BY <ingres_name> [ ASC | DESC ] [ ',' ... ] ]
**
** History:
**	10/90 (jhw) - Added <rselect_qry> to distiguish the first query in a
**		query expression (which reduces <qry_start>.)  This ensures
**		that the secondary target lists are not processed as for a
**		retrieval query.  Bug #9413.
*/
qry_body:	select_qry order_clause
		{
			$$ = osmkqry(DB_SQL, $1, $2);
		}
;
select_qry:	'(' select_qry ')'
		{
			$$ = osmkquery(PARENS, (char *)NULL, (PTR)$2,
				(PTR)NULL, (OSNODE*)NULL,
				(OSNODE*)NULL, (OSNODE*)NULL
			    );
		}
	|	select_qry union_op rselect_qry	%prec UNION_OP
		{
			$$ = osmkquery(OP, $2, (PTR)$1, (PTR)$3,
				(PTR)NULL, (OSNODE*)NULL,
				(OSNODE*)NULL, (OSNODE*)NULL
			    );
		}
	|	qry_start SELECT select_body	/* sub_select */
		{
			$$ = $3;
		}
;
rselect_qry:	'(' rselect_qry ')'
		{
			$$ = osmkquery(PARENS, (char *)NULL, (PTR)$2,
				(PTR)NULL, (OSNODE*)NULL,
				(OSNODE*)NULL, (OSNODE*)NULL
			    );
		}
	|	rselect_qry union_op rselect_qry	%prec UNION_OP
		{
			$$ = osmkquery(OP, $2, (PTR)$1, (PTR)$3,
				(PTR)NULL, (OSNODE*)NULL,
				(OSNODE*)NULL, (OSNODE*)NULL
			    );
		}
	|	SELECT select_body	/* sub_select */
		{
			$$ = $2;
		}
;
qry_start:	{
			if ( FormObj == NULL )
			{ /* Either a CALLFRAME parameter or a bug */
				if ( !CallState )
				{ /* Bug check: (for JupBug #9133.) */
					osuerr( OSBUG, 1,
						ERx("sql(missing query object)")
					);
				}
			}
			else if ( FormObj != FormSym
				&&  FormObj->s_kind != OSTABLE
				&&  ( FormObj->s_kind != OSVAR
					&& FormObj->s_kind != OSGLOB
					&& FormObj->s_kind != OSRATTR
				  || (FormObj->s_flags & (FDF_RECORD|FDF_ARRAY))
						== 0 ) )
			{
				if ( FormObj->s_kind == OSUNDEF 
					&& FormObj->s_parent->s_kind != OSFORM )
				{
					oscerr( OSNOTCUR, 2,
						FormObj->s_parent->s_name,
						FormSym->s_name
					);
				}
				else
				{
					oscerr( OSNOQRYOBJ, 2,
						FormObj->s_name,
						FormSym->s_name
					);
				}

				FormObj = NULL;
			}
			QryState = TRUE;

			/*
			** We're about to start generating the IL to:
			** (1) assign a selected row into the appropriate
			** targets (recomputing the target l-values), and
			** (2) compute the values of any variables in
			** any DML expressions in the target list.
			** We want to redirect (1) into a "fragment"
			** which can be emitted where appropriate
			** (after the initial QRYSINGLE and after each QRYNEXT).
			** Unfortunately, (1) and (2) may be interspersed.
			** So we'll redirect each contiguous piece
			** of (1) and (2) into a smaller fragment of IL.
			** As each of these smaller fragments is completed,
			** it will be included in either:
			** (1) The fragment TargListFrag (set "empty" below), or
			** (2) The "default" fragment.
			**
			** We also begin a temp block that will contain
			** temporaries in (1).
			*/
			ostmpbeg();
			iiIGofOpenFragment();
			TargListFrag = iiIGcfCloseFragment();
		}
;

/**-
** Miscellaneous SQL Query Statement Productions.
**
** Includes:
**	select_expr	union_op	sub_select	select_body
**	from_clause	where_clause	group_clause
**	having_clause	order_clause	distinct_clause
*/
select_expr:	'(' select_expr ')'
		{
			$$ = osmkquery(PARENS, (char*)NULL, (PTR)$2,
				(PTR)NULL, (OSNODE*)NULL,
				(OSNODE*)NULL, (OSNODE*)NULL
			    );
		}
	|	select_expr union_op select_expr	%prec UNION_OP
		{
			$$ = osmkquery(OP, $2, (PTR)$1, (PTR)$3, (OSNODE*)NULL,
				(OSNODE*)NULL, (OSNODE*)NULL
			    );
		}
	|	SELECT select_body	/* sub_select */
		{
			$$ = $2;
		}
;

union_op:	UNION ALL
		{
			$$ = ERx("union all");
		}
	|	UNION
		{
			$$ = $1;
		}
;

sub_select:	SELECT select_body
		{
			u_ptr[0].u_nodep = NULL;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_qrynodep = $2;
			$$ = osmknode(tkQUERY, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;

select_body:	distinct_clause target_list target_list_end from_clause
			where_clause group_clause having_clause
		{
			$$ = osmkquery(tkQUERY, $1, (PTR)$2,
				(PTR)$5, $4, $6, $7
			    );
		}
	|	distinct_clause target_list target_list_end
		{
			if (TableRef)
				yyerror(ERx("FROM"));
			$$ = osmkquery(tkQUERY, $1, (PTR)$2,
				(PTR)NULL, (OSNODE*)NULL,
				(OSNODE*)NULL, (OSNODE*)NULL
			    );
		}
;

distinct_clause: DISTINCT
		{
			TableRef = FALSE;
			$$ = $1;
		}
	|	ALL
		{
			TableRef = FALSE;
			$$ = $1;
		}
	|	/* empty */
		{
			TableRef = FALSE;
			$$ = NULL;
		}
;

target_list:	'*'
		{
			open_targ_IL();
			TableRef = TRUE;
			if (QryState)
			{
				$$ = ostlqryall(QryTarget, FormObj, ERx("*"));
				if ($$ == NULL)
				{
					oscerr( OSBADQRYALL, 2,
						ERx("*"), FormSym->s_name );
				}
			}
			else
			{
				$$ = osmaketle( osmkident( ERx("*"),
							   (OSNODE *)NULL ),
						(OSNODE *)NULL,
						(OSNODE *)NULL );
			}
			close_lhs_targ_IL();
		}
	|	target_item_list
		{
			$$ = $1;
		}
	|	target_item_list INTO name_list
		{
			oscerr(OSINTO, 0);
			$$ = $1;
		}
;

target_list_end: /* empty */
		{
			if (QryState)
			{
				QryState = FALSE;

				/*
				** We've just about finished generating the IL
				** to assign a selected row into the appropriate
				** targets (recomputing the target l-values).
				** All that's left to do is to end the tmp block
				** associated with this IL, which may emit IL
				** (e.g. IL_RELEASEOBJ instructions).  This IL
				** *must* go into the same fragment that already
				** contains the IL to recompute target l-values.
				**
				** We also "freeze" the temporaries that have
				** generated so far in the enclosing temp block
				** (which *must* be the one that spans the
				** entire SELECT statement).  This prevents
				** IL within the SELECT loop or submenu
				** from reusing temps that were used in
				** the IL to recompute SELECT target l-values
				** (which will get emitted wherever a NEXT
				** is encountered).
				*/
				iiIGrfReopenFragment(TargListFrag);
				ostmpend();
				ostmpfreeze();
				TargListFrag = iiIGcfCloseFragment();
			}
		}
;

target_item_list: { open_targ_IL(); } target_item
		{
			$$ = $2;
		}
	|	target_item_list ',' { open_targ_IL(); } target_item
		{
			$$ = osaddtlist($1, $4);
		}
;
target_item:    ID LSQBRK OSLintexpr RSQBRK '.' '*'
		{
			oscerr(OSQRYTFALL, 1, ERx(".*"));
			ostrfree($3);
			$$ = NULL;
			close_lhs_targ_IL();
		}
	|	ID '.' '*'
		{
			TableRef = TRUE;
			if (QryState)
			{
				$$ = ostlqryall(QryTarget, FormObj, $1);
				if ($$ == NULL)
				{
					oscerr( OSBADQRYALL, 2,
						ERx("*"), FormSym->s_name );
				}
			}
			else
			{ /* non-query select DB statment */
				u_ptr[0].u_cp = $1;
				u_ptr[1].u_cp = ERx("*");
				$$ = osmaketle( osmknode( ATTR,
							  &u_ptr[0], &u_ptr[1],
							  (U_ARG*)NULL ),
						(OSNODE *)NULL,
						(OSNODE *)NULL );
			} /* end non-query DB statement */
			close_lhs_targ_IL();
		}
	|	target_name '=' { close_lhs_targ_IL(); open_targ_IL(); } DMLexpr
		{
			close_rhs_targ_IL();
			$$ = ( ($1 != NULL) ? osmaketle($1, $4, (OSNODE*)NULL)
					    : NULL );
		}
	|	DMLexpr AS { close_rhs_targ_IL(); open_targ_IL(); } target_name
		{
			close_lhs_targ_IL();
			$$ = ( ($4 != NULL) ? osmaketle($4, $1, (OSNODE*)NULL)
					    : NULL );
		}
	|	DMLexpr
		{
			if (!QryState)
			{
				$$ = osmaketle( $1,
						(OSNODE *)NULL,
						(OSNODE *)NULL );
			}
			else if (  $1->n_token == VALUE
				|| $1->n_token == ARRAYREF
				|| (  $1->n_token == DOT
				   && $1->n_right->n_token == VALUE
				   )
				)
			{ /* field or variable */
				oscerr(E_OS015C_BadColonInSelect, 0);
				ostrfree($1);
				$$ = NULL;
			}
			else if ( ! (  $1->n_token == DOT
				    || $1->n_token == ATTR
				    || (  $1->n_token == tkID
				       && $1->n_left == NULL
				       )
				    )
				)
			{
				oscerr(OSSELLIST, 0);
				ostrfree($1);
				$$ = NULL;
			}
			else if (FormObj == NULL)
			{
				$$ = osmaketle( $1,
						(OSNODE *)NULL,
						(OSNODE *)NULL );
			}
			else
			{ /* database column name */
				register OSSYM	*sym;
				register char	*attr;
				register OSNODE	*dml_obj;
				register OSNODE	*ele;

				if ($1->n_token == tkID)
				{
					attr = $1->n_value;
				}
				else if ($1->n_token == ATTR)
				{
					attr = $1->n_attr;
				}
				else if ($1->n_right->n_token == DOT)
				{
					attr = $1->n_right->n_right->n_value;
				}
				else /* single DOT node */
				{
					attr = $1->n_right->n_value;
				}
				sym = osqryidchk(FormObj, attr);

				if (  $1->n_token == ATTR
				   || $1->n_token == DOT
				   || STequal($1->n_value, sym->s_name)
				   )
				{
					dml_obj = $1;
				}
				else
				{
					dml_obj = NULL;
					ostrfree($1);
				}
				if (  FormObj == FormSym 
				   || FormObj->s_kind == OSTABLE
				   )
				{
					u_ptr[0].u_symp = sym;
					ele = osmknode( VALUE,
							&u_ptr[0],
							(U_ARG*)NULL,
							(U_ARG*)NULL );
				}
				else
				{
					ele = os_lhs(osqrydot(QryTarget, sym));
				}
				$$ = osmaketle(ele, dml_obj, (OSNODE *)NULL);
			}
			close_lhs_targ_IL();
		}
;
target_name:	ID
		{
			if (!QryState || FormObj == NULL)
			{
				$$ = osmkident($1, (OSNODE *)NULL);
			}
			else
			{ /* target list in query select */
				register OSSYM	*sym;

				sym = osqryidchk(FormObj, $1);

				if (  FormObj == FormSym
				   || FormObj->s_kind == OSTABLE )
				{
					u_ptr[0].u_symp = sym;
					$$ =  osmknode( VALUE, &u_ptr[0],
							(U_ARG *)NULL,
							(U_ARG *)NULL );
				}
				else
				{
					$$ = os_lhs(osqrydot(QryTarget, sym));
				}
			} /* end query select target list */
		}
	|	var_colon
		{
			if (!QryState || FormObj != FormSym)
			{
				oscerr(E_OS015C_BadColonInSelect, 0);
				$$ = os_lhs($1);
			}
			else if ($1->n_token == VALUE)
			{
				$$ = os_lhs($1);
				/*
				** If we're selecting into the form,
				** but the target for this particular
				** column is a tablefield cell, then
				** generate the necessary IL_PUTROW.
				** Note that we *don't* generate an
				** IL_PUTFORM for a simple field;
				** that's handled via the query's
				** PUTFORM string.  (See osquery.c).
				*/
				if ($$->n_tfref != NULL)
				{
					osvardisplay($$);
				}
			}
			else
			{	/*
				** Handle the case where we're looking at
				** a DOT or ARRAYREF node.  Note that we're
				** selecting into the form (FormObj == FormSym).
				** We call os_lhs($1) to emit IL to build
				** a placeholder temp representing the
				** ultimate LHS.  Then we allocate a true temp
				** and emit IL to assign it to the ultimate LHS.
				** We return the true temp, which is what
				** we'll select into.
				**
				** Important note: before allocationg the true
				** temp, we must "freeze" all temporaries that
				** were freed by nested temp blocks.
				** Otherwise, the true temp may overlay one of
				** those nested temps, but at run time the
				** nested temp will be use *between* the time
				** of the actual query and the time of the
				** IL_ASSIGN below.  (Phew!)
				*/
				OSNODE	*tmpnode;	/* placeholder temp */
				OSNODE	*datnode;	/* true temp */
				OSSYM	*sym;
				char	*name = osnodesym($1)->s_name;

				tmpnode = os_lhs($1);
				ostmpfreeze();
				sym = osdatalloc( tmpnode->n_type,
						  (i4)tmpnode->n_length,
						  (i2)tmpnode->n_prec );
				sym->s_name = name;
				u_ptr[0].u_symp = sym;

				datnode = osmknode( VALUE, &u_ptr[0],
						    (U_ARG *)NULL,
						    (U_ARG *)NULL );

				IGgenStmt( IL_ASSIGN, (IGSID *)NULL, 3,
					   tmpnode->n_ilref, datnode->n_ilref,
					   oschkcoerce( datnode->n_type,
							tmpnode->n_type ) );
				ostrfree(tmpnode);
				$$ = datnode;
			}
		}
;
/*
** Name:	name_list -		INTO Name List.
**
** Description:
**	The INTO clause is semantically invalid, but is syntactically recognized
**	for error recovery (synchronization) purposes.
*/
name_list:	ID
	|	name_list ',' ID
;

/*
** Name:	from_clause -	FROM Clause for SQL.
*/
opt_from_clause: /* empty */
		{
			$$ = NULL;
		}
	|	from_clause
		{
			$$ = $1;
		}
;

from_clause:	FROM from_list
		{
		    $$ = $2;
		}
;
from_list:	from_source
		{
		    $$ = $1;
		}
	|	from_list ',' from_source
		{
		    u_ptr[0].u_nodep = $1;
		    u_ptr[1].u_nodep = $3;
		    $$ = osmknode(COMMA, (U_ARG *)NULL, &u_ptr[0], &u_ptr[1]);
		}
;
from_source:	from_item
		{
		    $$ = $1;
		}
	|
		from_source join_type from_item opt_join_cond
		{
		    u_ptr[0].u_nodep = $1;
		    u_ptr[1].u_nodep = osmkident($2, (OSNODE *)NULL);
		    u_ptr[0].u_nodep = 
			osmknode(BLANK, (OSNODE *)NULL, &u_ptr[0], &u_ptr[1]);
		    u_ptr[1].u_nodep = $3;
		    $$ = osmknode(BLANK, (OSNODE *)NULL, &u_ptr[0], &u_ptr[1]);
		    if ($4 != NULL)
		    {
			u_ptr[0].u_nodep = $$;
			u_ptr[1].u_nodep = $4;
			$$ = osmknode(BLANK, (OSNODE *)NULL, &u_ptr[0], 
								&u_ptr[1]);
		    }
		}
;
from_item:	table_correl
		{
		    $$ = $1;
		}
	|	'(' from_source ')'
		{
		    u_ptr[0].u_nodep = $2;
		    $$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], 
								(U_ARG*)NULL);
		}
;
join_type:	JOIN
		{
			$$ = $1;
		}
	|	INNER_JOIN
		{
			$$ = iiIG_string(ERx("inner join"));
		}
	|	FULL_JOIN
		{
			$$ = iiIG_string(ERx("full join"));
		}
	|	LEFT_JOIN
		{
			$$ = iiIG_string(ERx("left join"));
		}
	|	RIGHT_JOIN
		{
			$$ = iiIG_string(ERx("right join"));
		}
;
opt_join_cond:	ON DMLcondition

		{
		    u_ptr[0].u_nodep = osmkident($1, (OSNODE *)NULL);
		    u_ptr[1].u_nodep = $2;
		    u_ptr[2].u_nodep = osmknode(BLANK, (OSNODE *)NULL, &u_ptr[0], &u_ptr[1]);
		    $$ = osmknode(ONCLAUSE, (OSNODE *)NULL, &u_ptr[2]  , (OSNODE *)NULL);


		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
/*
** Name:	where_clause -	WHERE Clause for SQL.
*/
where_clause:	WHERE DMLcondition
		{
			$$ = $2;
		}
	|	WHERE OSLcol_var disallow_repeat
		{
			osval($2);
			if ($2->n_type != DB_NODT && !oschkstr($2->n_type))
				oscerr(OSNOTSTRX, 0);
			$$ = $2;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*
** Name:	group_clause -	GROUP BY Clause for SQL Queries.
*/
group_clause:	GROUP BY group_list
		{
			$$ = $3;
		}
	|	/* empty */
		{
			 $$ = NULL;
		}
;
/*
** Name:	group_list -	Column-Name List for GROUP BY clause.
*/
group_list:	qual_column_ref
		{
			$$ = $1;
		}
	|	group_list ',' qual_column_ref
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG*)NULL,
						&u_ptr[0], &u_ptr[1]);
		}
;

/*
** Name:	having_clause -	HAVING Clause for SQL Queries.
*/
having_clause:	HAVING DMLcondition
		{
			$$ = $2;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*
** Name:	order_clause
*/
order_clause:	ORDER BY key_list
		{
			$3->srt_type = SRT_ORDER;
			$$ = $3;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
key_list:	order_item
		{
			$$ = $1;
		}
	|	key_list ',' order_item
		{
			/* Maintain sort list as circular linked list */
			$3->srt_next = $1->srt_next;
			$1->srt_next = $3;
			$$ = $3;
		}
;
/*
** Name:	order_item -	SQL Order Key Specification Production.
*/
order_item:	ingres_ref
		{
			$$ = osmksrtnode($1, (OSNODE *)NULL);
		}
	|	ingres_ref order_dir
		{
			$$ = osmksrtnode($1, $2);
		}
	;
order_dir:	ASC
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	DESC
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	OSLcol_var disallow_repeat
		{
			if ($1 == NULL || !oschkstr($1->n_type))
				oscerr(OSNOTSTR, 0);
			osval($1);
			$$ = $1;
		}
;

/*
** Name:	table_correl -	Table/Correlation Name.
*/
table_correl:
    	qual_table_ref
    	{
    	    $$ = $1;
    	}
    |	qual_table_ref ID
    	{
	    u_ptr[0].u_nodep = $1;
	    u_ptr[1].u_nodep = osmkident($2, (OSNODE *)NULL);
	    $$ = osmknode(BLANK, (U_ARG *) NULL, &u_ptr[0], &u_ptr[1]);
    	}
;

/**:
** Name:	db_stmt -	OSL/SQL Database Statements.
**
** Generates:
**		ILSTHD line_no
**		[ code for any evaluations ]
**		database command
**		[ ILDBCONST | ILDBVAR reference ... ]
**		ILENDLIST
*/
db_stmt:	abort			/* RTI/SQL (shared) */
	|	alert_stmt		/* RTI/SQL */
	|	alter_group		/* RTI/SQL */
	|	alter_location		/* RTI/SQL */
	|	alter_profile		/* RTI/SQL */
	|	alter_role		/* RTI/SQL */
	|	alter_secaudit		/* RTI/SQL */
	|	alter_table		/* RTI/SQL */
	|	alter_user		/* RTI/SQL */
	|	comment_on		/* RTI/SQL */
	|	commit
	|	connect			/* RTI/SQL */
	|	copy			/* RTI/SQL (shared) */
	|	create
	|	create_group		/* RTI/SQL */
	|	create_location		/* RTI/SQL */
	|	create_profile		/* RTI/SQL */
	|	create_role		/* RTI/SQL */
	|	create_rule		/* RTI/SQL */
	|	create_secalarm		/* RTI/SQL */
	|	create_syn		/* RTI/SQL */
	|	create_user		/* RTI/SQL */
	|	declare_glob		/* RTI/SQL */
	|	delete
	|	direct_connect		/* STAR */
	|	direct_disconnect	/* STAR */
	|	direct_execute		/* STAR */
	|	disable_secaudit	/* RTI/SQL */
	|	disconnect		/* RTI/SQL */
	|	drop
	|	enable_secaudit		/* RTI/SQL */
	|	execute_immediate
	|	grant
	|	index
	|	insert
	|	integrity		/* RTI/SQL */
	|	modify			/* RTI/SQL (shared) */
	|	permit			/* RTI/SQL */
	|	relocate		/* RTI/SQL (shared) */
	|	register		/* STAR */
	|	remove 			/* STAR */
	|	revoke 			/* RTI/SQL */
	|	rollback
	|	save			/* RTI/SQL (shared) */
	|	savepoint		/* RTI/SQL (shared) */
	|	set			/* RTI/SQL (shared) */
	|	transaction		/* RTI/SQL (shared) */
	|	update
	|	view
;

/**-
** Database Query Statements.
**
** Includes:
**	delete		insert		update
*/
/*
** Name:	formobj_all -	Form Object ".all" Reference.
**
** Description:
**	Special rule for ".all" in OSL/SQL.  Note that <row_number> cannot be
**	used due to "shift/reduce" conflicts with <var_tbl> through <ins_expr>.
*/
	/* Note:  Separate rules for table field references w.r.t. <OSLvalue> */
formobj_all:	OSLvalue_all
		{
			$$ = $1;
		}
;

OSLvalue_all:	OSLname_all
		{
			$$ = $1;
		}
	|	var_colon '.' ALL
		{
			$$ = osall(FormSym, $1);
		}
;

/*::
** Name:	connect -	SQL CONNECT statement
**
** Syntax:
**	CONNECT [TO] <ingres_name> 
**		[SESSION <ingres_int>] 
**		[AS <ingres_str>]
**		[IDENTIFIED BY | USER <ingres_name>]
**		[OPTIONS = <ingres_str> {, <ingres_str>}]
**		[WITH <connect_with> {, <connect_with>}]
**	where the connect_with's are:
**		ID = <ingres_ref>
**
**	Note the with_fragment's values must be osvarref()'s and not
**	osvalref()'s, as the interpreter will not what type the value is
**	(can be DB_INT_TYPE or DB_CHR_TYPE).
*/

connect:	CONNECT ingres_name connect_clauses
		{
		    /* bypass all invalid arg checking for now */
		    IGstartStmt(osscnlno(), IL_LB_NONE);
		    IGgenStmt(IL_CONNECT, (IGSID *)NULL, 1, osvalref($2));
		    connect_clauses($3);
		}
	|	CONNECT ingres_name
		{
		    IGstartStmt(osscnlno(), IL_LB_NONE);
		    IGgenStmt(IL_CONNECT, (IGSID *)NULL, 1, osvalref($2));
		}
;
connect_clauses:
		connect_clause
		{
		    $$ = $1;
		}
	|	connect_clauses connect_clause
		{
		    u_ptr[0].u_nodep = $1;
		    u_ptr[1].u_nodep = $2;
		    $$ = osmknode(COMMA, (U_ARG *)NULL, &u_ptr[0], &u_ptr[1]);
		}
;
connect_clause:	SESSION ingres_int
		{
		    $$ = osmkassign(
				IGsetConst(DB_CHA_TYPE, ERx("ii_sess")),
				osvalref($2), FALSE);
		}
	|	AS ingres_str
		{
		    $$ = osmkassign(
				IGsetConst(DB_CHA_TYPE, ERx("ii_conn")),
				osvalref($2), FALSE);
		}
	|	connect_user_key ingres_name
		{
		    $$ = osmkassign(
				IGsetConst(DB_CHA_TYPE, ERx("ii_user")),
				osvalref($2), FALSE);
		}
	/*
	|	DBMS_PASSWORD '=' ingres_str
		{
		    $$ = osmkassign(
				IGsetConst(DB_CHA_TYPE, ERx("ii_dbms_password")),
				osvalref($3), FALSE);
		}
	*/
	|	ID '=' connect_opts_list
		{
		    if ( !osw_compare(ERx("options"), $1) )
		    {
			yyerror(_SyntaxError);
			$$ = NULL;
		    }
		    else
		    {
			$$ = $3;
		    }
		}
	|	WITH connect_with_list
		{
			$$ = $2;
		}
;
connect_opts_list:
		connect_opts
		{
		    $$ = $1;
		}
	|	connect_opts_list ',' connect_opts
		{
		    u_ptr[0].u_nodep = $1;
		    u_ptr[1].u_nodep = $3;
		    $$ = osmknode(COMMA, (U_ARG *)NULL, &u_ptr[0], &u_ptr[1]);
		}
;
connect_opts:	ingres_str
		{
		    $$ = osmkassign(		
				IGsetConst(DB_CHA_TYPE, ERx("ii_flag")),
				osvalref($1), FALSE);
		}
;
connect_with_list:
		connect_with
		{
		    $$ = $1;
		}
	|	connect_with_list ',' connect_with
		{
		    u_ptr[0].u_nodep = $1;
		    u_ptr[1].u_nodep = $3;
		    $$ = osmknode(COMMA, (U_ARG *)NULL, &u_ptr[0], &u_ptr[1]);
		}
;
connect_with:	ID '=' ingres_ref
		{
		    $$ = osmkassign(		
				IGsetConst(DB_CHA_TYPE, $1),
				osvarref($3), FALSE);
		}
;
connect_user_key:	USER
	|		IDENTIFIED_BY
;

/*::
** Name:	disconnect -	SQL DISCONNECT statement
**
** Syntax:
**	DISCONNECT [CURRENT]
**	DISCONNECT <ingres_name>
**	DISCONNECT SESSION <ingres_int> 
*/

disconnect:	DISCONNECT opt_disconnect_sess
		{
			/* bypass all invalid arg checking for now */
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DISCONNECT, (IGSID *)NULL, 0);
			if ($2 != NULL)
				connect_clauses($2);
		}
;
opt_disconnect_sess:	
		SESSION ingres_int
		{
		    $$ = osmkassign(
				IGsetConst(DB_CHA_TYPE, ERx("ii_sess")),
				osvalref($2), FALSE);
		}
	|	ingres_str
		{
		    $$ = osmkassign(
				IGsetConst(DB_CHA_TYPE, ERx("ii_conn")),
				osvalref($1), FALSE);
		}
	|	ALL
		{
		    $$ = osmkassign(
				IGsetConst(DB_CHA_TYPE, ERx("ii_all")),
				(ILREF)0, FALSE);
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*::
** Name:	delete -	SQL DELETE Statement.
**
** Syntax:
**	DELETE FROM <ingres_name> [ ID ] [ WHERE <DMLcondition> ]
*/
delete:		delete_key FROM table_correl where_clause
		{
			IIOSgqsGenQryStmt(IL_DELETEFRM, RepeatState);
			osdbeval($3);
			if ($4 != NULL)
			{ /* delete qualification */
				osqwhere($4);
			}
			RepeatState = FALSE;
		}
;
delete_key:	DELETE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = FALSE;
		}
	|	REPEAT DELETE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			RepeatState = TRUE;
			$$ = TRUE;
		}
;

/*::
** Name:	insert -	SQL INSERT Statement.
**
** Syntax:
**	INSERT INTO <qual_table_ref> [ '(' <ingres_name> | '*' [ ',' ... ] ')' ]
**		<sub_select> | VALUES '(' <ins_expr_list> ')'
*/
insert:		insert_key INTO qual_table_ref ins_columns insert_object
		{
			IIOSgqsGenQryStmt(IL_INSERT, RepeatState);
			osdbeval($3);
			if ($4 != NULL)
			{ /* insert column list */
				if ($5->n_token == tkQUERY && !insert_all($4->n_left))
				    oscerr(OSINSSTAR, 0);   /* "*" with sub-query */
				else if ($5->n_token != tkQUERY && InsNcols > 0)
					oscerr(OSINSLISTS, 0);	/* unbalanced */
				osdbeval($4);	/* column name list */
			}
			if ($5->n_token != tkQUERY)
			{
				osdbstr(ERx(" values "));
				osqtraverse($5);
			}
			else
			{
				osdbstr(ERx(" "));
				osdbqry($5->n_query);
				$5->n_query = NULL;
				ostrfree($5);
			}
			RepeatState = FALSE;
		}
;
insert_key:	INSERT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = FALSE;
		}
	|	REPEAT INSERT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			RepeatState = TRUE;
			$$ = TRUE;
		}
;
ins_columns:	'(' ins_col_list ')'
		{
			u_ptr[0].u_nodep = InsCols = $2;
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
	|	/* empty */
		{
			$$ = InsCols = NULL;
		}
;
ins_col_list:	ins_col_ele
		{
			InsNcols = 1;
			$$ = $1;
		}
	|	ins_col_list ',' ins_col_ele
		{
			InsNcols += 1;
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
		}
;
ins_col_ele:	ingres_name
		{
			$$ = $1;
		}
	/* Special case for OSL/SQL not present in SQL */
	|	'*'
		{
			$$ = osmkident(ERx("*"), (OSNODE *)NULL);
		}
;
insert_object:	VALUES '(' ins_expr_list ')'
		{
			u_ptr[0].u_nodep = $3;
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
	|	sub_select
		{
			$$ = $1;
		}
;
ins_expr_list:	ins_ele
		{
			$$ = $1;
		}
	|	ins_expr_list ',' ins_ele
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
		}
;
ins_ele:	formobj_all
		{
			register OSNODE	*col_n;

			if (InsCols == NULL || InsNcols == 0 ||
			 (col_n = insert_column(InsCols, InsNcols--)) == NULL ||
			   col_n->n_token != tkID || *col_n->n_value != '*')
			{
				oscerr(OSINSALL, 0);	/* no "*" in column list */
				ostrfree($1);
				$$ = osmkident(ERx("*.all"), (OSNODE *)NULL);
			}
			else
			{
				$$ = expand_insert($1, col_n);
			}
		}
	|	ins_expr
		{
			register OSNODE	*col_n;

			if (InsCols != NULL)
			{
				if (InsNcols == 0)
					oscerr(OSINSLISTS, 0);	/* unbalanced */
				else if ((col_n=insert_column(InsCols,InsNcols--)) != NULL
				  && col_n->n_token == tkID && *col_n->n_value == '*')
					oscerr(OSINSSTAR, 0);
				$$ = $1;
			}
		}
;
ins_expr:	ins_expr boph ins_expr		%prec BOPH
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	ins_expr bop ins_expr		%prec BOP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	ins_expr EXP ins_expr		%prec EXP
		{
			u_ptr[0].u_cp = _Exp;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	'-' ins_expr			%prec UOP
		{
			u_ptr[0].u_cp = _Minus;
			u_ptr[1].u_nodep = $2;
			$$ = osmknode(DML|UNARYOP, &u_ptr[0], &u_ptr[1],
				(U_ARG*)NULL
				 );
		}
	|	'(' ins_expr ')'
		{
			u_ptr[0].u_nodep = $2;
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
	|	ins_primary
		{
			$$ = $1;
		}
;
ins_primary:	constant
		{
			$$ = $1;
		}
	|	null_or_user_id
		{
			$$ = $1;
		}
	|	OSLvalue
		{
			$$ = $1;
		}
	|	scalar_func '(' ins_scalar ')'
		{
			u_ptr[0].u_nodep = $3;
			$$ = osmkident($1, osmknode(PARENS, (U_ARG*)NULL,
							 &u_ptr[0], (U_ARG*)NULL
					   )
			 );
		}
;

ins_scalar:	ins_expr ',' ins_expr
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
		}
	|	ins_expr
		{
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*::
** Name:	update -	SQL UPDATE Statement.
**
** Syntax:
**	UPDATE <ingres_name> [ ID ] SET <ingres_name> '=' <DMLexpr> [ ',' ... ]
**		[ WHERE <DMLcondition> ]
*/
update:		update_key table_correl opt_from_clause
			SET col_assign_list where_clause
		{
			IIOSgqsGenQryStmt(IL_UPDATE, RepeatState);
			osdbeval($2);
			if ($3 != NULL)
			{
				osOpenwarn(ERx("UPDATE ... FROM"));
				osdbstr(ERx(" from "));
				osdbeval($3);
			}
			osdbstr(ERx(" set "));
			osevaltlist($5, osdbqtle);
			if ($6 != NULL)
			{ /* update qualification */
				osqwhere($6);
			}
			RepeatState = FALSE;
		}
;
update_key:	UPDATE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = FALSE;
		}
	|	REPEAT UPDATE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			RepeatState = TRUE;
			$$ = TRUE;
		}
;
col_assign_list: col_assign
		{
			$$ = $1;
		}
	|	col_assign_list ',' col_assign
		{
			$$ = osaddtlist($1, $3);
		}
;
col_assign:	ingres_name '=' DMLnfexpr
		{
			$$ = osmaketle($1, $3, (OSNODE *)NULL);
		}
	|	'*' '=' formobj_all
		{
			$$ = $3 != NULL ? ostlall($3) : NULL;
		}
;

/**-
** SQL Database Transaction Statements.
**
** Includes:
**	commit	rollback	(other transaction statements, abort, savepoint
**				and begin and end transaction shared with QUEL.)
*/
/*::
** Name:	commit -	SQL COMMIT Statement.
**
** Syntax:
**	COMMIT [ WORK ]
*/
commit:		commit_key work_noise
		{
			IGgenStmt(IL_COMMIT, (IGSID *)NULL, 0);
		}
;
commit_key:	COMMIT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
work_noise:	WORK
	|	/* empty */
;

/*::
** Name:	rollback -	SQL ROLLBACK Statement.
**
** Syntax:
**	ROLLBACK [ WORK ] [ TO <ingres_ref> ]
*/
rollback:	rollback_key work_noise
		{
			IGgenStmt(IL_ROLLBACK, (IGSID *)NULL, 0);
		}
	|	rollback_key work_noise TO ingres_ref
		{
			osOpenwarn(ERx("ROLLBACK ... TO"));
			IGgenStmt(IL_ROLLBACK, (IGSID *)NULL, 0);
			osdbstr(ERx(" to "));
			osdbeval($4);
		}
;
rollback_key:	ROLLBACK
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/**-
** Database Object Create/Destroy Statements.
**
** Includes:
**	create		index	view	grant
**	integrity	permit		(RTI/SQL)
**	drop		alter
*/
/*
** Name:	qual_table_ref_list -	A List of fully qualified table names
**
** Description:
**	A comma separated list of fully qualified Ingres table names
*/

qual_table_ref_list:
    	qual_table_ref
    	{
    	    u_ptr[0].u_nodep = $1;
    	    u_ptr[1].u_nodep = NULL;
    	    u_ptr[2].u_nodep = NULL;
    	    $$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
    	}
    |	qual_table_ref_list ',' qual_table_ref
    	{
    	    u_ptr[0].u_nodep = $3;
    	    u_ptr[1].u_nodep = $1;
    	    u_ptr[2].u_nodep = NULL;
    	    $$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
	}
;

create_key:	CREATE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	create -		SQL CREATE TABLE Statement.
**
** Syntax:
**	CREATE TABLE [ <ingres_name> ':' ] <ingres_name>
**		'(' <ingres_name> <ingres_name>
**		[ NOT NULL [ WITH|NOT DEFAULT ] | WITH NULL ]
**		[NOT | WITH SYSTEM_MAINTAINED]
**			[ ',' ... ] ')'
**		[ WITH ID '=' <ingres_ref> [ ',' ... ] ]
**
**	CREATE TABLE [ <ingres_name> ':' ] <ingres_name>
**		'(' <ingres_name> [ ',' ... ] ')' AS <select_expr>
**		[ WITH ID '=' <ingres_ref> [ ',' ... ] ]
**
**	9-april-1996 (angusm)
**	- Combine 'cre_tbl_key' and 'cre_tbl_name' rules
**	  to reinstate original(6.4) order of evaluation.
**	- keep cre_tbl_name as referenced elsewhere.
*/

create:
	cre_tbl_key db_lparen cre_tbl_list db_rparen
		with_clause
	{
	    osdbwith($5);
	}
    |	cre_tbl_key db_lparen cre_tbl_list db_rparen
		cre_tbl_as select_expr with_clause
	{
	    osdbqry($6);
	    osdbwith($7);
	}
    |   cre_tbl_key db_lparen db_ingname_list db_rparen
		cre_tbl_as select_expr with_clause
	{
	    osdbqry($6);
	    osdbwith($7);
	}
    |   cre_tbl_key cre_tbl_as select_expr with_clause
	{
	    osdbqry($3);
	    osdbwith($4);
	}
;
cre_tbl_key:	create_key TABLE location_name
	{
		IGgenStmt(IL_CRTTABLE, (IGSID *)NULL, 0);
		osdbeval($3);
	}
;
cre_tbl_name:	location_name
	{
		osdbeval($1);
	}
;
cre_tbl_as:	AS
	{
		osOpenwarn(ERx("CREATE TABLE ... AS SELECT"));
		osdbstr(ERx(" as "));
	}
;
cre_tbl_list:	cre_tbl_ele
	|	cre_tbl_list db_comma cre_tbl_ele
;
cre_tbl_ele:	cre_tbl_coldef
	|	cre_tbl_tblcon
	|	cre_tbl_constr db_ingname cre_tbl_tblcon
;
cre_tbl_coldef:	db_ingname cre_tbl_col_format cre_tbl_col_clauses
	|	db_ingname cre_tbl_col_format
;
cre_tbl_col_format:	format
	{
		osdbstr(ERx(" "));
		osdbeval($1);
	}
;
cre_tbl_col_clauses:	cre_tbl_col_clause
	|		cre_tbl_col_clauses cre_tbl_col_clause
;

cre_tbl_col_clause:	cre_tbl_col_null
	|		cre_tbl_col_default
	|		cre_tbl_col_sys
	|		cre_tbl_col_constr
;
cre_tbl_col_null:	null_clause
	{
		osdbstr(ERx(" "));
		osdbstr($1);
	}
;
cre_tbl_col_default:	
	default_clause
	{
		osdbstr(ERx(" "));
		osdbstr($1);
	}
    |	WITH DEFAULT crt_tbl_def_opt
	{
		osdbstr(ERx(" with default "));
		osdbeval($3);
	}
    |	DEFAULT crt_tbl_def_opt
	{
		osdbstr(ERx(" default "));
		osdbeval($2);
	}
;
crt_tbl_def_opt:
	OSLcol_var
	{
		if ( AFE_NULLABLE_MACRO($1->n_type) )
			oswarn(OSNULVCHK, 0);
		$$ = $1;
	}
    |	null_or_user_id
		{
			$$ = $1;
		}
    |	uconstant
	{
		$$ = $1;
	}
;
cre_tbl_col_sys:	sys_maintained
	{
		osdbstr($1);
	}
;

cre_tbl_col_constr:	
    	CHECK '(' DMLcondition ')'
	{
		osdbstr(ERx(" check ("));
		osqtraverse($3);
		osdbstr(ERx(")"));
	}
    |	crt_tbl_unique
    |	crt_tbl_primkey
    |	crt_tbl_refer db_qingname
    |	crt_tbl_refer db_qingname db_lparen db_ingname db_rparen
;

cre_tbl_tblcon:	
    	CHECK '(' DMLcondition ')'
	{
		osdbstr(ERx(" check ("));
		osqtraverse($3);
		osdbstr(ERx(")"));
	}
    |	crt_tbl_unique db_lparen db_ingname_list db_rparen
    |	crt_tbl_primkey db_lparen db_ingname_list db_rparen
    |	crt_tbl_forkey db_lparen db_ingname_list db_rparen
		 crt_tbl_refer db_qingname
    |	crt_tbl_forkey db_lparen db_ingname_list db_rparen
		 crt_tbl_refer db_qingname db_lparen db_ingname_list db_rparen
;
crt_tbl_unique:	UNIQUE
	{
		osdbstr(ERx(" unique"));
	}
;
crt_tbl_primkey: PRIMARY_KEY
	{
		osdbstr(ERx(" primary key"));
	}
;
crt_tbl_refer:	REFERENCES
	{
		osdbstr(ERx(" references "));
	}
;
crt_tbl_forkey:	FOREIGN_KEY
	{
		osdbstr(ERx(" foreign key "));
	}
;
cre_tbl_constr:	CONSTRAINT
	{
		osdbstr(ERx(" constraint "));
	}
;

sys_maintained :
	NOT ID
	{
		if ( !osw_compare(ERx("system_maintained"), $2) )
			yyerror(_SyntaxError);
		$$ = ERx(" not system_maintained");
	}
    |   WITH ID
	{
		if ( !osw_compare(ERx("system_maintained"), $2) )
			yyerror(_SyntaxError);
		$$ = ERx(" with system_maintained");
	}
;
/* these crappy rules are still used by the register statement...*/
column_spec:
	ingres_name format column_opt
	{
	    $$ = osmaketle($1, $2, $3);
	}
;
column_opt:	null_clause
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	default_clause
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	sys_maintained
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	null_clause default_or_sys_clause
		{
			char	buf[OSBUFSIZE];

			_VOID_ STprintf(buf, ERx("%s %s"), $1, $2);
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL);
		}
	|	null_clause default_clause sys_maintained
		{
			char	buf[OSBUFSIZE];

			_VOID_ STprintf(buf, ERx("%s %s %s"), $1, $2, $3);
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL);
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
default_or_sys_clause :
		default_clause
		{
			$$ = $1;
		}
	|	sys_maintained
		{
			$$ = $1;
		}
;
/*::
** Name:	declare_glob - SQL DECLARE GLOBAL TEMPORARY TABLE Statement.
**
** Syntax:
**	DECLARE GLOBAL TEMPORARY TABLE  <ingres_name> '.' <ingres_name>
**		'(' <ingres_name> <ingres_name>
**		[ NOT NULL [ WITH|NOT DEFAULT ] | WITH NULL ]
**		[NOT | WITH SYSTEM_MAINTAINED]
**			[ ',' ... ] ')'
**		ON COMMIT PRESERVE ROWS
**		WITH NORECOVERY
**		[, WITH ID '=' <ingres_ref> [ ',' ... ] ]
**
**	DECLARE GLOBAL TEMPORARY TABLE <ingres_name> '.' <ingres_name>
**		'(' <ingres_name> [ ',' ... ] ')' AS <select_expr>
**		ON COMMIT PRESERVE ROWS
**		WITH NORECOVERY
**		[, WITH ID '=' <ingres_ref> [ ',' ... ] ]
**	3-jul-1996 (angusm)
**		rewrite to be more like CREATE TABL
*/
declare_glob:
	declare_glob_key db_lparen decl_tbl_list db_rparen
		on_commit_clause with_clause
	{
	    osdbstr($5);
	    osdbwith($6);
	}
    |   declare_glob_key db_lparen decl_tbl_list db_rparen
		cre_tbl_as select_expr on_commit_clause with_clause
	{
	    osdbqry($6);
	    osdbstr($7);
	    osdbwith($8);
	}
    |   declare_glob_key db_lparen db_ingname_list db_rparen
		cre_tbl_as select_expr on_commit_clause with_clause
	{
	    osdbqry($6);
	    osdbstr($7);
	    osdbwith($8);
	}
    |   declare_glob_key 
		cre_tbl_as select_expr on_commit_clause with_clause
	{
	    osdbqry($3);
	    osdbstr($4);
	    osdbwith($5);
	}
;
declare_glob_key: DECLARE GLOB_TEMP TABLE location_name
	{
		STARTSTMTOW("DECLARE GLOBAL TEMPORARY TABLE");
		IGgenStmt(IL_DGTT, (IGSID *)NULL, 0);
		osdbeval($4);
	}
;
on_commit_clause:	ON_COMMIT ID ID
	{
		if ( !osw_compare(ERx("preserve"), $2) 
		  || !osw_compare(ERx("rows"), $3)
		   )
			yyerror(_SyntaxError);
		$$ = ERx(" on commit preserve rows ");
	}
;
decl_tbl_list:	decl_tbl_ele
	|	decl_tbl_list db_comma decl_tbl_ele
;
decl_tbl_ele:	db_ingname cre_tbl_col_format decl_tbl_col_clauses
	|	db_ingname cre_tbl_col_format
;
decl_tbl_col_clauses:	decl_tbl_col_clause
	|		decl_tbl_col_clauses decl_tbl_col_clause
;

decl_tbl_col_clause:	cre_tbl_col_null
	|		cre_tbl_col_default
	|		cre_tbl_col_sys
;
/*::
** Name:	index -		SQL CREATE INDEX Statement.
**
** Syntax:
**	CREATE [ UNIQUE ] INDEX [ <ingres_name> ':' ] <ingres_name>
**		ON <ingres_name> '(' <ingres_name> [ ASC | DESC ] [ ',' ... ] ] ')'
**		[ WITH ID '=' <ingres_ref> [ ',' ... ] ]
*/
index:		create_key unique_clause INDEX location_name ON qual_table_ref
				'(' index_key_list ')' with_clause
		{
			IGgenStmt($2 ? IL_CRTUINDEX : IL_CRTINDEX, (IGSID *)NULL, 0);
			osdbeval($4);
			osdbstr(ERx(" on "));
			osdbeval($6);
			osdbstr(ERx("("));
			osevalsklist($8, osdbsrtkey, osldml);
			osdbstr(ERx(")"));
			osdbwith($10);
		}
;
index_key_list: index_key
		{
			$$ = $1;
		}
	|	index_key_list ',' index_key
		{
			/* Maintain sort list as circular linked list */
			$3->srt_next = $1->srt_next;
			$1->srt_next = $3;
			$$ = $3;
		}
;
index_key:	ingres_name
		{
			$$ = osmksrtnode($1, (OSNODE *)NULL);
		}
	|	ingres_name ASC
		{
			$$ = osmksrtnode($1, osmkident($2, (OSNODE *) NULL));
		}
	|	ingres_name DESC
		{
			$$ = osmksrtnode($1, osmkident($2, (OSNODE *) NULL));
		}
	|	ingres_name ingres_name
		{
			$$ = osmksrtnode($1, $2);
		}
;

/*::
** Name:	view -		SQL CREATE VIEW Statement.
**
** Syntax:
**	CREATE VIEW <qual_table_ref> [ '(' <ingres_name> [ ',' ... ] ]
**		AS <select_expr> [ WITH CHECK OPTION ]
*/
view:		view_key qual_table_ref col_name_list AS select_expr view_with
		{
			IGgenStmt(IL_CRTVIEW, (IGSID *)NULL, 0);
			osdbeval($2);
			if ($3 != NULL)
				osdbeval($3);	/* column name list (with "()") */
			osdbstr(ERx(" as "));
			osdbqry($5);
			if ($6 != NULL)
				osdbstr(ERx(" with check option"));
		}
;
view_key:	CRE_VIEW
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
view_with:	WITH CHECK ID
		{
			if (!osw_compare(ERx("option"), $3))
				yyerror(_SyntaxError);
			$$ = TRUE;
		}
	|	/* emtpy */
		{
			$$ = FALSE;
		}
;

/*::
** Name:	CREATE GROUP
**
** Syntax:
**	CREATE GROUP <ingres_name> {,<ingres_name>}
**	[ WITH USERS = ( <ingres_name>, {,<ingres_name>} ) ]
*/
create_group:		create_group_key create_group_list db_with_clause
;

create_group_key:	CRE_GROUP
		{
			STARTSTMTOW("CREATE GROUP");
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("create group "));
		}
;

create_group_list:	ing_name_list
		{
			osevallist($1, osdblist);
		}
;


/*::
** Name:	CREATE LOCATION
**
** Syntax:
**	CREATE LOCATION <ingres_name> {,<ingres_name>}
**	[ WITH AREA = ( <ingres_name>, {,<ingres_name>} ) 
**		| USAGE = NOUSAGE | ( <ingres_name>, {,<ingres_name>} ) ]
*/
create_location:	CRE_LOCATION ingres_name with_clause
		{
			STARTSTMTOW("CREATE LOCATION");
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("create location "));
			osdbeval($2);
			osdbwith($3);
		}
;

/*::
** Name:	ALTER LOCATION
**
** Syntax:
**	ALTER LOCATION <ingres_name> {,<ingres_name>}
**	[ WITH USAGE = NOUSAGE | ( <ingres_name>, {,<ingres_name>} ) ]
*/
alter_location:	ALTER_LOCATION ingres_name with_clause
		{
			STARTSTMTOW("ALTER LOCATION");
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("alter location "));
			osdbeval($2);
			osdbwith($3);
		}
;

/*::
** Name:	CREATE ROLE
**
** Syntax:
**	CREATE ROLE <ingres_name> {,<ingres_name>}
**	[ WITH NOPASSWORD ] | [ WITH PASSWORD = <ingres_name> ]
*/
create_role:		create_role_key create_role_list with_clause
				{
					osdbwith($3);	
				}
;

create_role_key:	CRE_ROLE
		{
			STARTSTMTOW("CREATE ROLE");
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("create role "));
		}
;

create_role_list:	ing_name_list
		{
			osevallist($1, osdblist);
		}
;


/*::
** Name:	ALTER GROUP
**
** Syntax:
**	ALTER GROUP <ingres_name> {,<ingres_name>}
**		ADD USERS ( <ingres_name>, {,<ingres_name>} )
**	|	DROP USERS ( <ingres_name>, {,<ingres_name>} )
**	|	DROP ALL
*/
alter_group:		alter_group_key alter_group_list alter_group_clause
;

alter_group_key:	ALTER_GROUP
		{
			STARTSTMTOW("ALTER GROUP");
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("alter group "));
		}
;

alter_group_list:	ing_name_list
		{
			osevallist($1, osdblist);
		}
;

alter_group_clause:	ADD ID '(' ing_name_list ')'
		{
			if (!osw_compare(ERx("users"), $2) )
				yyerror(_SyntaxError);
			osdbstr(ERx(" add users ("));
			osevallist($4, osdblist);   /* name list w/o "()") */
			osdbstr(ERx(")"));
		}
	|	DROP ID '(' ing_name_list ')'
		{
			if (!osw_compare(ERx("users"), $2) )
				yyerror(_SyntaxError);
			osdbstr(ERx(" drop users ("));
			osevallist($4, osdblist);   /* name list w/o "()") */
			osdbstr(ERx(")"));
		}
	|	DROP ALL
		{
			osdbstr(ERx(" drop all"));
		}
;

/*::
** Name:	ALTER TABLE
**
** Syntax:
**	ALTER TABLE <ingres_name> 
**		ADD <table constraint defintion> [WITH INDEX = <ingres_name>]
**	|	DROP CONSTRAINT <ingres_name> [CASCADE | RESTRICT]
*/
alter_table:		alter_table_key db_qingname alter_table_clause
;

alter_table_key:	ALTER_TABLE
		{
			STARTSTMTOW("ALTER TABLE");
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("alter table "));
		}
;

alter_table_clause:	
		alter_table_add cre_tbl_tblcon with_clause
		{
			osdbwith($3);
		}
	|	alter_table_drop opt_cascade_restrict
;
alter_table_add:	ADD		/* bug #57078 - ADD instead ID */
		{
			osdbstr(ERx(" add "));
		}
	|	ADD CONSTRAINT ingres_name	/* bug #57078 - allow optional
						   CONSTRAINT clause */
		{
			osdbstr(ERx(" add constraint "));
			osdbeval($3);
		}
;
alter_table_drop:DROP CONSTRAINT ingres_name
		{
			osdbstr(ERx(" drop constraint "));
			osdbeval($3);
		}
;

/*::
** Name:	ALTER ROLE
**
** Syntax:
**	ALTER ROLE <ingres_name> {,<ingres_name>}
**	[ WITH NOPASSWORD ] | [ WITH PASSWORD = <ingres_name> ]
**
**	Share much of the CREATE ROLE productions
*/
alter_role:		alter_role_key create_role_list adp_privs with_clause
				{
					osdbwith($4);	
				}
;

alter_role_key:	ALTER_ROLE
		{
			STARTSTMTOW("ALTER ROLE");
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("alter role "));
		}
;

/*::
** Name:	create_user -	   CREATE USER Statement.
**
** Syntax:
**      CREATE USER <user_id>
**	   [ WITH [ NOPASSWORD | PASSWORD = <password> ]
**			| [ GROUP = <ingres_name> ]
**			| [ PRIVILEGES = '(' <with_item_list> ')' ]
**		{, ...} ]
**
** History:
**	09/90 (jhw) - Written.
*/
create_user :
	create_user_key ingres_name with_clause
	{
		IGgenStmt(IL_CREATEUSER, (IGSID *)NULL, 0);
		osdbeval($2);
		osdbwith($3);
	}
;
create_user_key :
	CRE_USER
	{
		STARTSTMTOW("CREATE USER");
	}
;

/*::
** Name:	alter_user -	   ALTER USER Statement.
**
** Syntax:
**      ALTER USER <user_id> 
**	[ADD|DROP PRIVILEGES (priv_list>)]
**	[WITH [ NOPASSWORD | PASSWORD = <password> ]
**				| [ GROUP = <ingres_name> ]
**				| [ PRIVILEGES = '(' <with_item_list> ')' ]
**				{, ...}
**				]
**
** History:
**	09/90 (jhw) - Written.
**	19-nov-93 (robf)
**         User name now optional (for changing passwords)
*/
alter_user : alter_user_key alt_user_tail 
;
alter_user_key :
	ALTER_USER
	{
		STARTSTMTOW("ALTER USER");
		IGgenStmt(IL_ALTERUSER, (IGSID *)NULL, 0);
	}
;

alt_user_tail: ingres_name {osdbeval($1);} adp_privs with_clause
	{
		osdbwith($4);
	}
	| adp_privs with_clause
	{
		/* No user name */
		osdbwith($2);
	}
/*
** adp_privs - handle ADD/DROP PRIVILEGES. Either or neither of these
**             clauses is allowed. This is used by the SET SESSION
**             statement, and also by the SQL ALTER USER/PROFILE statements
*/

adp_privs: add_privs_kw db_lparen db_ingname_list db_rparen
        |
        drop_privs_kw db_lparen db_ingname_list db_rparen
        |
        /* Empty */
        ;

/*::
** Name:	create_profile -	   CREATE PROFILE Statement.
**
** Syntax:
**      CREATE PROFILE <user_id>
**	   [ WITH | [ GROUP = <ingres_name> ]
**			| [ PRIVILEGES = '(' <with_item_list> ')' ]
**		{, ...} ]
**
** History:
**	19-nov-93 (robf) - Written
*/
create_profile :
	create_profile_key ingres_name with_clause
	{
		osdbeval($2);
		osdbwith($3);
	}
;
create_profile_key :
	CRE_PROFILE
	{
		osOpenwarn(ERx("CREATE PROFILE"));
		IGstartStmt(osscnlno(), IL_LB_NONE);
		IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
		osdbstr(ERx("create profile "));
	}
;

/*::
** Name:	alter_profile -	   ALTER PROFILE Statement.
**
** Syntax:
**      ALTER [DEFAULT] PROFILE [<profile_id>] WITH [ 
**		[ADD|DROP PRIVILEGES (priv_list>)]
**		[WITH 	| [ GROUP = <ingres_name> ]
**			| [ PRIVILEGES = '(' <with_item_list> ')' ]
**			{, ...}
**
** History:
**	19-nov-93 (robf) - Written.
*/
alter_profile :
	alter_profile_key adp_privs with_clause {osdbwith($3);}
;
alter_profile_key :
	ALTER_PROFILE ingres_name 
	{
		osOpenwarn(ERx("ALTER PROFILE"));
		IGstartStmt(osscnlno(), IL_LB_NONE);
		IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
		osdbstr(ERx("alter profile "));
		osdbeval($2);
	}
	| ALTER_DEFAULT ID
	{
		if (!osw_compare(ERx("profile"), $2) )
			yyerror(_SyntaxError);
		osOpenwarn(ERx("ALTER PROFILE"));
		IGstartStmt(osscnlno(), IL_LB_NONE);
		IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
		osdbstr(ERx("alter default profile "));
	}
;

/*::
** Name:	create_syn -	   CREATE SYNONYM Statement.
**
** Syntax:
**      CREATE SYNONYM <qual_table_ref> FOR <qual_table_ref>
**
*/
create_syn :
	create_syn_key qual_table_ref FOR qual_table_ref
	{
		IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
		osdbstr(ERx("create synonym "));
		osdbeval($2);
		osdbstr(ERx(" for "));
		osdbeval($4);
	}
;
create_syn_key :
	CRE_SYNONYM
	{
		STARTSTMTOW("CREATE SYNONYM");
	}
;

/*::
** Name:	create_rule -	CREATE RULE Statement.
**
** Syntax:
**      CREATE RULE rulename table_condition
**	  EXECUTE PROCEDURE procname [(parameter = value {, parameter = value})]
**
**	   where table_condition is
**
**      AFTER statement_type {, statement_type}
**			[ON | OF | FROM | INTO] tablename
**		[REFERENCING [OLD AS old_corr_name] [NEW AS new_corr_name]]
**		[WHERE qualification]
**
**	   and statement_type is
**
**      INSERT | UPDATE[(columnname)] | DELETE
**
**  This is part of the "Knowledge Management Extension" package.
*/
create_rule :
	crt_rule_key qual_table_ref crt_rule_after crt_rule_stmt_type_list
			crt_rule_prep qual_table_ref
		crt_rule_ref where_clause
		EXE_PROC qual_table_ref crt_rule_exec_proc_args
	{
		IGgenStmt(IL_CREATERULE, (IGSID *)NULL, 0);
		osdbeval( $2 );
		osdbstr( ERx(" after ") );
		osevallist( $4, osdblist );
		osdbstr( ERx(" on ") );
	 	osdbeval ( $6 );
		if ( $7 != NULL )
		{
			osdbstr( ERx(" referencing ") );
			osdbeval( $7 );
		}
		if ( $8 != NULL )
		{
			osqwhere($8);
		}
		osdbstr(ERx(" execute procedure "));
		osdbeval( $10 );
		if ( $11 != NULL )
		{
			osdbstr( "(" );
			osevallist($11, osdblist);
			osdbstr( ERx(")") );
		}
	}
;
crt_rule_key :
	CRE_RULE {STARTSTMTOW("CREATE RULE")}
;
crt_rule_after :
	ID
	{
		if ( !osw_compare(ERx("after"), $1) )
			yyerror(_SyntaxError);
	}
;
crt_rule_prep :
	ON
    |   OF      /* This keyword must be added to SQLKW.ROC */
    |   FROM
    |   INTO
;
crt_rule_stmt_type_list :
	crt_rule_stmt_type
	{
    	    u_ptr[0].u_nodep = $1;
	    u_ptr[1].u_nodep = NULL;
    	    u_ptr[2].u_nodep = NULL;
    	    $$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
	}
    |   crt_rule_stmt_type_list ',' crt_rule_stmt_type
	{
	    u_ptr[0].u_nodep = $3;
	    u_ptr[1].u_nodep = $1;
    	    u_ptr[2].u_nodep = NULL;
    	    $$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
	}
;
crt_rule_stmt_type :
	INSERT
	{
	    $$ = osmkident($1, (OSNODE *)NULL);
	}
    |   UPDATE
	{
	    $$ = osmkident($1, (OSNODE *)NULL);
	}
    |   UPDATE '(' ing_name_list ')'
	{
	    u_ptr[0].u_nodep = $3;
    	    u_ptr[1].u_nodep = osmkident($1, (OSNODE *)NULL);
    	    u_ptr[2].u_nodep =
    		osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
	    $$ = osmknode(BLANK, (U_ARG*)NULL, &u_ptr[1], &u_ptr[2]);
	}
    |   DELETE
	{
	    $$ = osmkident($1, (OSNODE *)NULL);
	}
;
crt_rule_ref :
	REFERENCING crt_rule_opt crt_rule_opt
	{
	    u_ptr[0].u_nodep = $2;
	    u_ptr[1].u_nodep = $3;
	    $$ = osmknode( BLANK, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1] );
	}
    |   /* empty */
	{
	    $$ = NULL;
	}
;
crt_rule_opt :
	ID AS ID
	{
		if ( osw_compare(ERx("old"), $1) )
			$$ = osmkident(" old as ", osmkident($3,(OSNODE*)NULL));
		else if ( osw_compare(ERx("new"), $1) )
			$$ = osmkident(" new as ", osmkident($3,(OSNODE*)NULL));
		else
		{
			yyerror(_SyntaxError);
			$$ = NULL;
		}
	}
    |   /* empty */
	{
	    $$ = NULL;
	}
;
crt_rule_exec_proc_args :
	'(' crt_rule_exec_proc_argl ')'
	{
	    $$ = $2;
	}
    | /* empty */
	{
	    $$ = NULL;
	}
;
crt_rule_exec_proc_argl :
	crt_rule_exec_proc_arg
	{
    	    u_ptr[0].u_nodep = $1;
	    u_ptr[1].u_nodep = NULL;
    	    u_ptr[2].u_nodep = NULL;
    	    $$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
	}
    |   crt_rule_exec_proc_argl ',' crt_rule_exec_proc_arg
	{
	    u_ptr[0].u_nodep = $3;
	    u_ptr[1].u_nodep = $1;
    	    u_ptr[2].u_nodep = NULL;
    	    $$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
	}
;
crt_rule_exec_proc_arg :
	ID '=' crt_rule_exec_proc_val
	{
	    u_ptr[0].u_cp = ERx("=");
	    u_ptr[1].u_nodep = osmkident($1, (OSNODE *)NULL);
	    u_ptr[2].u_nodep = $3;
	    $$ = osmknode(ASSOCOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
	}
;
crt_rule_exec_proc_val :
	ID '.' ID
	{
	    u_ptr[0].u_nodep = osmkident($1, (OSNODE *)NULL);
	    u_ptr[1].u_nodep = osmkident($3, (OSNODE *)NULL);
	    $$ = osmknode(DML|DOT, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
	}
;


/*::
** Name:	grant -	RTI/SQL GRANT Statement.
**
** Syntax:
**	GRANT ALL | ALL PRIVELEGES |
**	SELECT | INSERT | DELETE | EXECUTE | <other IDs > | 
**			UPDATE [ '(' <ingres_name> [ ',' ... ] ] ')' ]
**			[ ',' ... ]
**	ON [ TABLE | PROCEDURE | DATABASE | DBEVENT | CURRENT INSTALLATION] 
**	<ingres_name> [ ',' ... ]
**	TO PUBLIC | [auth_type] <ingres_name> [ ',' ... ]
**	[WITH GRANT OPTION]
**
**	Note: the "ON CURRENT INSTALLATION" does not take an object list.
*/
grant:		grant_key grants grant_object grant_whom with_grant_option
;

grant_key:	GRANT
		{
	    		STARTSTMTOW("GRANT")
			IGgenStmt(IL_GRANT, (IGSID *)NULL, 0);
		}
;
grants:		grant_list
		{
			osevallist($1, osdblist);	/* grant list */
		}
	|	ALL privilege_key
		{
			osdbstr(ERx("all"));
		}
;
privilege_key:	ID
		{
			if (!osw_compare(ERx("privileges"), $1))
				yyerror(_SyntaxError);
		}
	|	/* empty */
;
grant_list:	grant_type
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	grant_list ',' grant_type
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
grant_type:	SELECT
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	INSERT col_name_list
		{
			$$ = osmkident($1, $2);
		}
	|	DELETE
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	UPDATE col_name_list
		{
			$$ = osmkident($1, $2);
		}
	|	REGISTER
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	REFERENCES col_name_list
		{
			$$ = osmkident($1, $2);
		}
	|	ID	/* EXECUTE & database and current installation grants*/
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
;

grant_object:	grant_on qual_table_ref_list
		{
			osdbstr(ERx(" "));
			osdbstr($1);
			osevallist($2, osdblist);
		}
	|	ON CURRENT_INST
		{
			osOpenwarn(ERx(
				"GRANT/REVOKE ... ON CURRENT INSTALLATION"));
			osdbstr(ERx(" on current installation"));
		}
	| 	/* empty */
;
grant_on:	on_table_proc_str
		{
			$$ = $1;
		}
	|	ON_DATABASE
		{
			osOpenwarn(ERx("GRANT/REVOKE ... ON DATABASE"));
			$$ = ERx("on database ");
		}
	|	ON_DBEVENT
		{
			osOpenwarn(ERx("GRANT/REVOKE ... ON DBEVENT"));
			$$ = ERx("on dbevent ");
		}
	|	ON_LOCATION
		{
			osOpenwarn(ERx("GRANT/REVOKE ... ON LOCATION"));
			$$ = ERx("on location ");
		}
;
grant_whom:	TO ing_name_list
		{
			osdbstr(ERx(" to "));
			osevallist($2, osdblist);
		}
	|	TO_GROUP ing_name_list
		{
			osOpenwarn(ERx("GRANT ... TO GROUP"));
			osdbstr(ERx(" to group "));
			osevallist($2, osdblist);
		}
	|	TO_ROLE ing_name_list
		{
			osOpenwarn(ERx("GRANT ... TO ROLE"));
			osdbstr(ERx(" to role "));
			osevallist($2, osdblist);
		}
	|	TO_USER ing_name_list
		{
			osdbstr(ERx(" to user "));
			osevallist($2, osdblist);
		}
;
with_grant_option:	WITH GRANT ID
		{
			if (!osw_compare(ERx("option"), $3))
				yyerror(_SyntaxError);
			osdbstr(ERx(" with grant option "));
		}
	|	/* empty */
;
grant_option_for:	GRANT ID FOR
		{
			if (!osw_compare(ERx("option"), $2))
				yyerror(_SyntaxError);
			osdbstr(ERx(" grant option for "));
		}
	|	/* empty */
;

/*::
** Name:	revoke - RTI/SQL REVOKE Statement.
**
** Syntax:
**	REVOKE [GRANT OPTION FOR]
**	ALL | ALL PRIVELEGES | <db privledge> {, <db privledge> }
**	ON [ DATABASE | CURRENT INSTALLATION] 
**	<ingres_name> [ ',' ... ]
**	FROM PUBLIC | [auth_type] <ingres_name> [ ',' ... ]
**	[CASCADE | RESTRICT]
**
**	Note: the "ON CURRENT INSTALLATION" does not take an object list.
*/
revoke:		revoke_key grant_option_for revokes grant_object 
			revoke_whom opt_cascade_restrict
;

revoke_key:	REVOKE
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx(" revoke "));
		}
;
revokes:	revoke_list
		{
			osevallist($1, osdblist);	/* revoke list */
		}
	|	ALL privilege_key
		{
			osdbstr(ERx("all"));
		}
;
revoke_list:	revoke_type
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	revoke_list ',' revoke_type
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
revoke_type:	SELECT	
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	INSERT
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	DELETE
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	UPDATE col_name_list
		{
			$$ = osmkident($1, $2);
		}
	|	REGISTER
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	REFERENCES
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	ID	/* database and current installation revokes */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
;

revoke_whom:	FROM ing_name_list
		{
			osdbstr(ERx(" from "));
			osevallist($2, osdblist);
		}
	|	FROM_GROUP ing_name_list
		{
			osOpenwarn(ERx("REVOKE ... FROM GROUP"));
			osdbstr(ERx(" from group "));
			osevallist($2, osdblist);
		}
	|	FROM_ROLE ing_name_list
		{
			osOpenwarn(ERx("REVOKE ... FROM ROLE"));
			osdbstr(ERx(" from role "));
			osevallist($2, osdblist);
		}
	|	FROM_USER ing_name_list
		{
			osdbstr(ERx(" from user "));
			osevallist($2, osdblist);
		}
;
opt_cascade_restrict:	ID
		{
			if (osw_compare(ERx("cascade"), $1))
				osdbstr(ERx(" cascade"));
			else if (osw_compare(ERx("restrict"), $1))
				osdbstr(ERx(" restrict"));
			else
				yyerror(_SyntaxError);
		}
	|	/* empty */
;

/*::
** Name:	permit -	RTI/SQL CREATE PERMIT Statement.
**
** Syntax:
**	CREATE PERMIT SELECT | INSERT | UPDATE | DELETE | ALL [ ',' ... ]
**	 ON | OF | TO <ingres_name> [ ID ] [ '(' <ingres_name> [ ',' ... ] ')' ]
**	 TO <ingres_name> | ALL [ AT <ingres_name> | ALL ]
**	 [ FROM <ingres_int> ':' <ingres_int> TO <ingres_int> ':' <ingres_int> ]
**	 [ ON <ingres_name> TO <ingres_name> ] [ WHERE <DMLcondition> ]
*/
permit:		permit_key permits on_of_to table_correl perm_cols
			 perm_who perm_term perm_time perm_day where_clause
		{
			IGgenStmt(IL_CRTPERMIT, (IGSID *)NULL, 0);
			osevallist($2, osdblist);	/* permit list */
			osdbstr(ERx(" on "));
			osdbfrom($4);	/* table correlation name */
			if ($5 != NULL)
			{ /* permit columns */
				osdbstr(ERx("("));
				osevallist($5, osdblist);
				osdbstr(ERx(")"));
			}
			/* permit who */
			osdbstr(ERx(" to "));
			osdbeval($6);

			if ($7 != NULL)
			{ /* permit terminal */
				osdbstr(ERx(" at "));
				osdbeval($7);
			}
			if ($8 != NULL)
			{ /* permit time */
				osdbstr(ERx(" from "));
				osdbeval($8);
			}
			if ($9 != NULL)
			{ /* permit day */
				osdbstr(ERx(" on "));
				osdbeval($9);
			}
			if ($10 != NULL)
			{ /* permit qualification */
				osqwhere($10);
			}
		}
;
permit_key:	CRE_PERMIT
		{
			STARTSTMTOW("CREATE PERMIT");
		}
;
permits:	permit_list
		{
			$$ = $1;
		}
	|	ALL
		{
			u_ptr[0].u_nodep = osmkident($1, (OSNODE *)NULL);
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
permit_list:	permit_type
		{
			u_ptr[0].u_nodep = osmkident($1, (OSNODE *)NULL);
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	permit_list ',' permit_type
		{
			u_ptr[0].u_nodep = osmkident($1, (OSNODE *)NULL);
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
permit_type:	SELECT
		{
			$$ = $1;
		}
	|	INSERT
		{
			$$ = $1;
		}
	|	UPDATE
		{
			$$ = $1;
		}
	|	DELETE
		{
			$$ = $1;
		}
;
on_of_to:	ON	/* RTI/SQL keyword */
	|	OF	/* RTI/SQL keyword */
	|	TO	/* RTI/SQL keyword */
;
perm_cols:	'(' ing_name_list ')'
		{
			$$ = $2;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
perm_who:	TO ingres_name
		{
			$$ = $2;
		}
	|	TO ALL
		{
			$$ = osmkident($2, (OSNODE *)NULL);
		}
;
perm_term:	AT ingres_name
		{
			$$ = $2;
		}
	|	AT ALL
		{
			$$ = osmkident($2, (OSNODE *)NULL);
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
perm_time:	FROM perm_time_elm TO perm_time_elm
		{
			u_ptr[0].u_cp = $3;
			u_ptr[1].u_nodep = $2;
			u_ptr[2].u_nodep = $4;
			$$ = osmknode(ASSOCOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
perm_time_elm:	ingres_int ':' ingres_int
		{
			u_ptr[0].u_cp = ERx(":");
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(ASSOCOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
perm_day:	ON ingres_name TO ingres_name
		{
			u_ptr[0].u_cp = $3;
			u_ptr[1].u_nodep = $2;
			u_ptr[2].u_nodep = $4;
			$$ = osmknode(ASSOCOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*::
** Name:	integrity - RTI/SQL CREATE INTEGRITY Statement.
**
** Syntax:
**	CREATE INTEGRITY ON <ingres_name> [ ID ] IS <DMLcondition>
*/
integrity:	integrity_key ON table_correl IS DMLcondition
		{
			IGgenStmt(IL_CRTINTEG, (IGSID *)NULL, 0);
			osdbfrom($3);	/* table correlation name */
			osdbstr(ERx(" is "));
			osqtraverse($5);
		}
;
integrity_key:	CRE_INTEGRITY
		{
			STARTSTMTOW("CREATE INTEGRITY");
		}
;

/*::
** Name:	drop -		SQL DROP Statement.
**
** Syntax:
**	DROP [ TABLE | VIEW | INDEX | GROUP | ROLE ] <ingres_name> [ ',' ... ]
**	DROP INTEGRITY | PERMIT ON <ingres_name> ALL | <ingres_int> [ ',' ... ]
**      DROP PROCEDURE <ingres_name>
**      DROP RULE <ingres_name>
**	DROP USER <ingres_name>
**	DROP LOCATION <ingres_name>
**	DROP PROFILE <ingres_name> [RESTRICT|CASCADE]
*/
drop:		drop_many ing_name_list
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr($1);
			if ($2->n_next != NULL)
				osOpenwarn(ERx("DROP ... name_list"));
			osevallist($2, osdblist);
		}
	|	drop_many_qual qual_table_ref_list
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr($1);
			if ($2->n_next != NULL)
				osOpenwarn(ERx("DROP ... name_list"));
			osevallist($2, osdblist);
		}
	|	drop_single ingres_name 
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr($1);
			osdbeval($2);
		} opt_cascade_restrict
	|	drop_single_qual qual_table_ref
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr($1);
			osdbeval($2);
		}
	|	drop_integ_permit drop_permit_on table_correl int_list_all
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr($1);
			osdbstr($2);
			osdbeval($3);
			if ($4 == NULL)
				osdbstr(ERx(" all"));
			else
			{
				osdbstr(ERx(" "));
				osevallist($4, osdblist);
			}
		}
	|	drop_secalarm secalarm_on { osdbstr(ERx(" ")); }
			drop_alarm_spec_all
;
drop_alarm_spec_all:  drop_alarm_spec_list
		| db_all
;
drop_alarm_spec_list:	drop_alarm_spec
		| drop_alarm_spec_list db_comma drop_alarm_spec
;
drop_alarm_spec: ingres_name {osdbeval($1); osdbstr(ERx(" "));}
	       | 
		  uconstant_int
			{ osdbeval($1); osdbstr(ERx(" "));}
;
drop_many:	DRP_LINK 		/* STAR */
 		{
			osOpenwarn(ERx("DROP LINK"));
			$$ = ERx("drop link ");
		}
;
drop_many_qual:	DROP TABLE
		{
			$$ = ERx("drop table ");
		}
	|	DROP INDEX
		{
			$$ = ERx("drop index ");
		}
	|	DRP_VIEW
		{
			$$ = ERx("drop view ");
		}
	|	DRP_ROLE
 		{
			osOpenwarn(ERx("DROP ROLE"));
			$$ = ERx("drop role ");
		}
 	|	DRP_GROUP
 		{
			osOpenwarn(ERx("DROP GROUP"));
			$$ = ERx("drop group ");
		}
 	|	DRP_SYNONYM
 		{
			osOpenwarn(ERx("DROP SYNONYM"));
			$$ = ERx("drop synonym ");
		}
	|	DROP
		{
			osOpenwarn(ERx("DROP object"));
			$$ = ERx("drop ");
		}
;
drop_single_qual:	DRP_RULE
		{
			osOpenwarn(ERx("DROP RULE"));
			$$ = ERx("drop rule ");
		}
	|	DRP_PROC
		{
			osOpenwarn(ERx("DROP PROCEDURE"));
			$$ = ERx("drop procedure ");
		}
;
drop_single:	DRP_LOCATION
		{
			osOpenwarn(ERx("DROP LOCATION"));
			$$ = ERx("drop location ");
		}
	|	DRP_USER
		{
			osOpenwarn(ERx("DROP USER"));
			$$ = ERx("drop user ");
		}
	|	DRP_PROFILE
		{
			osOpenwarn(ERx("DROP PROFILE"));
			$$ = ERx("drop profile ");
		}
;
drop_integ_permit:	DRP_INTEGRITY
		{
			osOpenwarn(ERx("DROP INTEGRITY"));
			$$ = ERx("drop integrity ");
		}
	|	DRP_PERMIT
		{
			osOpenwarn(ERx("DROP PERMIT"));
			$$ = ERx("drop permit ");
		}
;
drop_secalarm:	DRP_SECALARM
		{
			osOpenwarn(ERx("DROP SECURITY_ALARM"));
			$$ = ERx("drop security_alarm ");
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("drop security_alarm "));
		}
;

drop_permit_on:	on_table_proc_str
		{
			$$ = $1;
		}
	|	ON_DBEVENT
		{
			$$ = ERx("on dbevent ");
		}
;
on_table_proc_str:	on_table_str
		{
			$$ = $1;
		}
	|		on_proc_str
		{
			$$ = $1;
		}
;

on_table_str:	ON TABLE
		{
			$$ = ERx("on table ");
		}
	|	ON
		{
			$$ = ERx("on ");
		}
;
on_proc_str:	ON PROCEDURE
		{
			$$ = ERx("on procedure ");
		}
;

/*::
** Name:	create_secalarm - SQL CREATE SECURITY_ALARM statement
**
** Syntax:
**	CREATE SECURITY_ALARM [name] ON [TABLE] tablespec | DATABASE dbname 
**		| CURRENT INSTALLATION
**		[IF condition {, condition}]  [WHEN priv {, priv}]
**		[BY [USER|GROUP|ROLE] <ing_name_list> ]
**		[RAISE DBEVENT [eventowner.]eventname ['eventtext']]
**	where:
**	     condition ::= SUCCESS | FAILURE
**	     priv ::= SELECT | UPDATE | INSERT | DELETE | CONNECT | DISCONNECT
*/
create_secalarm:	cre_secalarm_key 
			cre_secalarm_name
			secalarm_on
			cre_secalarm_if 
			cre_secalarm_when 
			cre_secalarm_by
			cre_secalarm_raise
;
cre_secalarm_name:	cre_tbl_name {osdbstr(ERx(" "));}
		|	/* empty */
;
cre_secalarm_key:	CRE_SECALARM
		{
			osOpenwarn(ERx("CREATE SECURITY_ALARM"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("create security_alarm "));
		}
;
secalarm_on: db_on_opt_table db_qingname_list
	|    db_on_database db_qingname_list
	|    db_on_current_installation
	;

cre_secalarm_if:	IF
		{
			osdbstr(ERx(" if "));
		}
		cre_secalarm_conds
		| /* empty */
;

cre_secalarm_conds:	cre_secalarm_cond
	|		cre_secalarm_conds db_comma cre_secalarm_cond
;
cre_secalarm_cond:	ID
		{
			if (osw_compare(ERx("success"), $1))
				osdbstr(ERx("success "));
			else if (osw_compare(ERx("failure"), $1))
				osdbstr(ERx("failure "));
			else
				yyerror(_SyntaxError);
		}
;
cre_secalarm_when:	db_when cre_secalarm_privs
	|		/* empty */
;
cre_secalarm_privs:	cre_secalarm_priv
	|		cre_secalarm_privs db_comma cre_secalarm_priv
;
cre_secalarm_priv:	db_select
	|		db_insert
	|		db_update
	|		db_delete
	|		db_connect
	|		db_disconnect
;
cre_secalarm_by:	cre_secalarm_byspec db_ingname_list
	|		/* empty */
;
cre_secalarm_byspec:	db_by_opt_user
	|		db_by_group
	|		db_by_role
	;

cre_secalarm_raise:	RAISE_DBEVENT qual_table_ref opt_ingres_str
			    {
				osdbstr(" raise dbevent ");
				osdbeval($2);
			       	if ($3 != NULL)
			       	{ /* optional event text */
				   osdbstr(ERx(" "));
				   osdbveval($3);
				   osdbstr(ERx(" "));
			       	}
			    }
	|		/* empty */
;

/*::
** Name:  enable_secaudit/disable_secaudit/alter_secaudit - 
**			ALTER/ENABLE/DISABLE SECURITY_AUDIT statements
**
** Syntax:
**	ENABLE SECURITY_AUDIT audit_type
**	DISABLE SECURITY_AUDIT audit_type
**	ALTER SECURITY_AUDIT [STOP|RESTART|SUSPEND|RESUME] [with_clause]
**	where:
**		audit_type ::=    ALL | TABLE | PROCEDURE | DATABASE | VIEW
**				| LOCATION | USER | SECURITY | ALARM
*/
enable_secaudit:	enable_secaudit_key secaudit_type
;
disable_secaudit:	disable_secaudit_key secaudit_type
;
alter_secaudit:		alter_secaudit_key alter_secaudit_opt db_with_clause
;
enable_secaudit_key:	ENABLE_SECAUDIT
		{
			osOpenwarn(ERx("ENABLE SECURITY_AUDIT"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("enable security_audit "));
		}
;
disable_secaudit_key:	DISABLE_SECAUDIT
		{
			osOpenwarn(ERx("DISABLE SECURITY_AUDIT"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("disable security_audit "));
		}
;
alter_secaudit_key:	ALTER_SECAUDIT
		{
			osOpenwarn(ERx("ALTER SECURITY_AUDIT"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("alter security_audit "));
		}
;
alter_secaudit_opt: db_id
	| RESUME { osdbstr(ERx("resume "));}
	| /* empty */
	;

secaudit_type:	db_table
	|	db_procedure
	|	db_all
	|	db_user
	|	db_id		/* don't bother checking  the types */
;

/*::
** Name:	comment_on - Table and Column comments
**
** Syntax:
**	COMMENT ON TABLE <qual_table_ref> remark_clause [remark_clause]
**	COMMENT ON COLUMN <qual_column_ref> remark_clause [remark_clause]
**	where:
**		remark_clause ::=   IS <ingres_str>
**				  | WITH SHORT_REMARK = <ingres_str>
*/
comment_on:		comment_on_key comment_table comment_clauses
		|	comment_on_key comment_column comment_clauses
;
comment_on_key:	COMMENT_ON
		{
			osOpenwarn(ERx("COMMENT ON"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("comment on "));
		}
;
comment_table:	db_table db_qingname
;
comment_column:	db_column db_qcolref
;
comment_clauses:	comment_clause
	|		comment_clause comment_clause
;
comment_clause:	IS ingres_str
		{
			osdbstr(ERx(" is "));
			osdbveval($2);
		}
	|	WITH ID '=' ingres_str
		{
			osdbstr(ERx(" with short_remark = "));
			osdbveval($4);
		}
;
/* 
**	emit strings as part of DBMS statements 
*/
db_id:	ID
	{
	    osdbstr($1);
	}
;
db_when:	ID
	{
	    if (!osw_compare(ERx("when"), $1))
		yyerror(_SyntaxError);
	    osdbstr(ERx(" when "));
	}
;
db_column:	ID
	{
	    if (!osw_compare(ERx("column"), $1))
		yyerror(_SyntaxError);
	    osdbstr(ERx("column "));
	}
;
db_all:	ALL
	{
	    osdbstr(ERx("all "));
	}
;
db_select:	SELECT
	{
	    osdbstr(ERx("select "));
	}
;
db_insert:	INSERT
	{
	    osdbstr(ERx("insert "));
	}
;
db_update:	UPDATE
	{
	    osdbstr(ERx("update "));
	}
;
db_delete:	DELETE
	{
	    osdbstr(ERx("delete "));
	}
;
db_connect:	CONNECT
	{
	    osdbstr(ERx("connect "));
	}
db_disconnect:	DISCONNECT
	{
	    osdbstr(ERx("disconnect "));
	}
;
db_table:	TABLE
	{
	    osdbstr(ERx("table "));
	}
;
db_procedure:	PROCEDURE
	{
	    osdbstr(ERx("procedure "));
	}
;
db_on_opt_table:	on_table_str
	{
	    osdbstr($1);
	}
;
db_on_database:	ON_DATABASE
	{
		osdbstr(" on database ");
	}
;
db_on_current_installation: ON CURRENT_INST
	{
		osdbstr(" on current installation ");
	}
;
db_user:	USER
	{
	    osdbstr(ERx("user "));
	}
;
db_by_group:	BY_GROUP
	{
	    osdbstr(ERx("by group "));
	}
;
db_by_role:	BY_ROLE
	{
	    osdbstr(ERx("by role "));
	}
;
db_by_opt_user:	BY_USER
	{
	    osdbstr(ERx("by user "));
	}
    |	BY
	{
	    osdbstr(ERx("by "));
	}
;
db_qingname:	qual_table_ref
	{
	    osdbeval($1);
	}
;
db_qcolref:	qual_column_ref
	{
	    osdbeval($1);
	}
;
db_qingname_list:	db_qingname
	|		db_qingname_list db_comma db_qingname
;
db_with_clause:	with_clause
		{
			osdbwith($1);
		}
;
/**-
** DML Expressions.
**
*/
/*::
** Name:	DMLexpr -	SQL Expressions.
**
** Description:
**	Expressions as recognized by SQL, including functions and scalar
**	functions.
*/
DMLexpr:	DMLexpr boph DMLexpr	%prec BOPH
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	DMLexpr bop DMLexpr	%prec BOP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	DMLexpr EXP DMLexpr	%prec EXP
		{
			u_ptr[0].u_cp = _Exp;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	'(' DMLexpr ')'
		{
			u_ptr[0].u_nodep = $2;
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
	|	'-' DMLexpr			%prec UOP
		{
			u_ptr[0].u_cp = _Minus;
			u_ptr[1].u_nodep = $2;
			$$ = osmknode(DML|UNARYOP, &u_ptr[0], &u_ptr[1],
					(U_ARG*)NULL
			 );
		}
	|	DMLprimary
		{
			$$ = $1;
		}
	/*
	** Name:	SQL set functions ...
	**
	** Syntax:
	**		COUNT '(' '*' ')'
	**		AVG | COUNT | MAX | MIN | SUM
	**				'(' [ ALL | DISTINCT ] <DMLnfexpr> ')'
	**
	** History:
	**      01/90 (jhw) -- Modified to support DISTINCT <DMLnfexpr>, but
	**		with an Open/SQL warning since this is only supported
	**		by the INGRES DBMS.  JupBug #9519.
	*/
	|	agg_name '(' '*'
		{
			/* Note:  COUNT already recognized by
			** <agg_name> so just look for 'c'.
			*/
			if ( CMcmpnocase($1, ERx("c")) != 0 )
			{
				yyerror( _SyntaxError );
			}
		} ')'
		{
			TableRef = TRUE;
			$$ = osmkident($1, osmkident(ERx("(*)"), (OSNODE*)NULL));
		}
	|	agg_name '(' all_clause DMLnfexpr ')'
		{
			TableRef = TRUE;
			u_ptr[0].u_nodep = ($3 == NULL) ? $4 : osmkident($3, $4);
			$$ = osmkident($1, osmknode(PARENS, (U_ARG*)NULL,
							&u_ptr[0], (U_ARG*)NULL
					)
			 );
		}
	|	any_clause '(' all_clause DMLnfexpr ')'
		{
			TableRef = TRUE;
			u_ptr[0].u_nodep = ($3 == NULL) ? $4 : osmkident($3, $4);
			$$ = osmkident($1, osmknode(PARENS, (U_ARG*)NULL,
							&u_ptr[0], (U_ARG*)NULL
					)
			 );
		}
	|	agg_name '(' DISTINCT DMLnfexpr ')'
		{
			TableRef = TRUE;
			if ( $4->n_token != ATTR && ( $4->n_token != tkID
			   || $4->n_left != NULL ) )
			{
				osOpenwarn(
				      ERx("<aggregate>(DISTINCT <expression>)")
				);
			}
			u_ptr[0].u_nodep = osmkident($3, $4);
			$$ = osmkident($1, osmknode(PARENS, (U_ARG*)NULL,
							&u_ptr[0], (U_ARG*)NULL
					   )
			 );
		}
;
agg_name:	AVG
		{
			$$ = $1;
		}
	|	COUNT
		{
			$$ = $1;
		}
	|	MAX
		{
			$$ = $1;
		}
	|	MIN
		{
			$$ = $1;
		}
	|	SUM
		{
			$$ = $1;
		}
;
any_clause:	ANY
		{
			$$ = $1;
		}
;
all_clause:	ALL
		{
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
DMLnfexpr:	DMLnfexpr boph DMLnfexpr	%prec BOPH
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	DMLnfexpr bop DMLnfexpr %prec BOP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	DMLnfexpr EXP DMLnfexpr %prec EXP
		{
			u_ptr[0].u_cp = _Exp;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	'-' DMLnfexpr			%prec UOP
		{
			u_ptr[0].u_cp = _Minus;
			u_ptr[1].u_nodep = $2;
			$$ = osmknode(DML|UNARYOP, &u_ptr[0], &u_ptr[1],
					(U_ARG*)NULL
			 );
		}
	|	'(' DMLnfexpr ')'
		{
			u_ptr[0].u_nodep = $2;
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
	|	DMLprimary
		{
			$$ = $1;
		}
;

DMLprimary:	constant
		{
			$$ = $1;
		}
	|	null_or_user_id
		{
			$$ = $1;
		}
	|	DMLvar
		{
			$$ = $1;
		}
	|	qual_column_ref
		{
			if ($1->n_token == DOT)
				TableRef = TRUE;
			$$ = $1;
		}
	|	scalar_func '(' scalar_args ')'
		{
			u_ptr[0].u_nodep = $3;
			$$ = osmkident($1, osmknode(PARENS, (U_ARG*)NULL,
							  &u_ptr[0], (U_ARG*)NULL
					)
			 );
		}
;
null_or_user_id: NULLK
                {
                        $$ = osmkident($1, (OSNODE *)NULL);
                }
        |       USER
                {
                        $$ = osmkident($1, (OSNODE *)NULL);
                }
;

/*
** Name:	DMLvar -	DML Expression 4GL Variable Reference.
**
** Description:
**	References to 4GL variables in DML expressions.  Used by <DMLprimary>
**	and in the <likeop> rule for <DMLcondition>.
*/
DMLvar:		OSLcol_var
		{
			$$ = $1;
		}
;

scalar_func:	ID
		{
			/* DBMSINFO is the only function in Open SQL. */
			if ( STbcompare($1, 0, ERx("dbmsinfo"), 0, TRUE) != 0 )
	    			osOpenwarn($1);
			$$ = $1;
		}
;
scalar_args:	DMLexpr ',' scalar_args
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
		}
	|	DMLexpr
		{
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

qual_column_ref:
    	ID '.' ID '.' ID
    	{
    	    u_ptr[0].u_nodep = osmkident($1, (OSNODE *)NULL);
    	    u_ptr[0].u_nodep->n_type = DB_CHA_TYPE;  /* see ingres_name def. */
    	    u_ptr[1].u_nodep = osmkident($3, (OSNODE *)NULL);
    	    u_ptr[1].u_nodep->n_type = DB_CHA_TYPE;
    	    u_ptr[2].u_nodep = osmkident($5, (OSNODE *)NULL);
    	    u_ptr[2].u_nodep->n_type = DB_CHA_TYPE;
	    u_ptr[1].u_nodep = osmknode(DML|DOT, (U_ARG*)NULL, 
		                        &u_ptr[1], &u_ptr[2]);
    	    $$ = osmknode(DML|DOT, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1] );
    	}
    |	ID '.' ID
    	{
    	    u_ptr[0].u_nodep = osmkident($1, (OSNODE *)NULL);
    	    u_ptr[0].u_nodep->n_type = DB_CHA_TYPE;  /* see ingres_name def. */
    	    u_ptr[1].u_nodep = osmkident($3, (OSNODE *)NULL);
    	    u_ptr[1].u_nodep->n_type = DB_CHA_TYPE;
    	    $$ = osmknode(DML|DOT, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
    	}
    |	ID
    	{
    	    $$ = osmkident($1, (OSNODE *)NULL);
    	}
;

/*::
** Name:	DMLcondition -  SQL Logical Expressions (Condition and Predicates.)
**
** Description:
**	Logical expressions as recognized by SQL, but with the addition
**	of predicate clauses (QUALIFICATIONs.)
*/

DMLcondition:	'(' DMLcondition ')'
		{
			u_ptr[0].u_nodep = $2;
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0],
					(U_ARG*)NULL
			);
		}
	|	DMLcondition lbop DMLcondition		%prec LBOP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|LOGOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	NOT DMLcondition			%prec UOP
		{
			u_ptr[0].u_cp = $1;
			u_ptr[1].u_nodep = $2;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(DML|LOGOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	/* SQL predicates ... */
	|	DMLexpr relop DMLexpr			%prec ROP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
           	$$ = osmknode(DML|RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	qual_column_ref is_postfix_op
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(DML|RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	DMLexpr likeop like_value escape
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			if ( $4 != NULL )
			{
				u_ptr[0].u_cp = _Escape;
				u_ptr[1].u_nodep = $$;
				u_ptr[2].u_nodep = $4;
				$$ = osmknode(DML|RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			}
		}
	|	DMLexpr relop select_set
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	DMLexpr in_op in_set
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	DMLexpr between_op between_range
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	EXISTS '(' sub_select ')'
		{
			u_ptr[0].u_nodep = $3;
			$$ = osmkident($1, osmknode(PARENS, (U_ARG*)NULL,
							  &u_ptr[0], (U_ARG*)NULL)
				 );
		}
	|	qualification
		{
			$$ = $1;
		}
;
like_value:	DMLvar
		{
			if ( $1->n_type != DB_NODT && !oschkstr($1->n_type) )
				oscerr(OSNOTSTRX, 0);
			$$ = $1;
		}
	|	constant_str
		{
			$$ = $1;
		}
;
between_op:	BETWEEN
		{
			$$ = $1;
		}
	|	NOT BETWEEN
		{
			$$ = ERx("not between");
		}
;
between_range:	DMLexpr AND DMLexpr
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|LOGOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
in_op:		IN
		{
			$$ = $1;
		}
	|	NOT IN
		{
			$$ = ERx("not in");
		}
;
in_set:		'(' DMLnfexpr ',' in_set_list ')'
		{
			u_ptr[0].u_nodep = $2;
			u_ptr[1].u_nodep = $4;
			u_ptr[0].u_nodep =
			   osmknode(COMMA, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
	|	DMLnfexpr
		{
			$$ = $1;
		}
	|	'(' scalar_select ')'
		{
			u_ptr[0].u_nodep = $2;
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
;
in_set_list:	DMLnfexpr
		{
			$$ = $1;
		}
	|	in_set_list ',' DMLnfexpr
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
		}
;
/*
** History:
**	09/90 (jhw) - Support GROUP BY/HAVING for all sub-selects.  Bug #31708.
*/
select_set:	'(' scalar_select ')'
		{
			u_ptr[0].u_nodep = $2;
			$$ = osmknode( PARENS, (U_ARG *)NULL, &u_ptr[0],
					(U_ARG *)NULL
			);
		}
	|	set_op '(' scalar_select ')'
		{
			u_ptr[0].u_nodep = $3;
			$$ = osmkident($1, osmknode( PARENS, (U_ARG *)NULL,
							&u_ptr[0], (U_ARG *)NULL
						)
			);
		}
	|       any_clause '(' scalar_select ')'
		{
			u_ptr[0].u_nodep = $3;
			$$ = osmkident($1, osmknode( PARENS, (U_ARG *)NULL,
							&u_ptr[0], (U_ARG *)NULL
						)
                        );
                }
;
set_op:		ALL
		{
			$$ = $1;
		}
	|	SOME
		{
			$$ = $1;
		}
;
scalar_select:	SELECT distinct_clause DMLexpr from_clause where_clause
			group_clause having_clause
		{
			u_ptr[0].u_nodep = NULL;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_qrynodep =
			osmkquery( tkQUERY, $2,
				(PTR)osmaketle($3, (OSNODE*)NULL,(OSNODE*)NULL),
				(PTR)$5, $4, $6, $7
			);
			$$ = osmknode(tkQUERY, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;

/*::
** Name:	execute_immediate - EXECUTE IMMEDIATE Statement.
**
** Syntax:
**	EXECUTE IMMEDIATE <string_expression>
**
** History:
**	03/12/91 (emerson)
**		Written for Topaz release.
*/
execute_immediate: EXECUTE_IMMED OSLstrexpr
        	{
			ILREF       fres = 0;

			if ( AFE_NULLABLE_MACRO($2->n_type) )
			{
				oswarn(OSNULVCHK, 0);
			}
			IGstartStmt(osscnlno(), IL_LB_NONE);
			fres = osvarref($2);
			IGgenStmt(IL_EXIMMEDIATE, (IGSID *)NULL, 0);
			IGgenStmt(IL_DBVAL, (IGSID *)NULL, 1, fres);
		}
;

/*::
** Name:	alerter statements -	SQL Alerter statements
**
** Syntax:
**	CREATE    DBEVENT <ingres_name>
**	DROP      DBEVENT <ingres_name>
**	REGISTER  DBEVENT [ <ingres_name> '.' ] <ingres_name>
**	REMOVE    DBEVENT [ <ingres_name> '.' ] <ingres_name>
**	RAISE     DBEVENT [ <ingres_name> '.' ] <ingres_name> [ <ingres_qname> ]
**			[ WITH [NO]SHARE ]
**	GET       DBEVENT [ WITH NOWAIT | WITH WAIT [ '=' <ingres_int> ] ]
**
**	Note that the grammar allows a superset of above:
**	<ingres_name> '.' <ingres_name> is allowed on CREATE and DROP,
**	and arbitrary WITH clauses are allowed on RAISE.
**	Such illegal constructs will be caught by the backend.
**	This approach may or may not be desirable, but it's expedient
**	and consistent with the approach taken by the grammar on other
**	SQL statements.
**
**	Also note that GET DBEVENT allows the wait interval to be expressed only
**	as an integer constant, or as an integer variable preceded by a colon.
**	I could have allowed an arbitrary expression, but that wouldn't be
**	consistent with other WITH clauses.
**
** History:
**	04/22/91 (emerson)
**		Created.
**	05/03/91 (emerson)
**		Handle GET EVENT properly.
**		(It needs a special call to LIBQ and thus a special IL op code).
**	07/26/91 (emerson)
**		Change EVENT to DBEVENT (per LRC 7-3-91).
*/

alert_stmt:	alert_key qual_table_ref
		{
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr($1);
			osdbeval($2);
		}
	|	alert_raise_key qual_table_ref opt_ingres_str with_clause
		{
			IGgenStmt(IL_DBSTMT, (IGSID *)NULL, 0);
			osdbstr(ERx("raise dbevent "));
			osdbeval($2);
			if ($3 != NULL)
			{ /* optional event text */
				osdbstr(ERx(" "));
				osdbveval($3);
				osdbstr(ERx(" "));
			}
			osdbwith($4);
		}
	|	alert_get_key getevt_with_clause
		{
			if ($2 != NULL)
			{
				ILREF	ilref;

				ilref = osvalref($2);
				IGgenStmt(IL_GETEVENT, (IGSID *)NULL, 1, ilref);
			}
		}
;

getevt_with_clause: WITH ID
		{
			if ( osw_compare(ERx("wait"), $2) )
			{
				$$ = osmkconst(tkICONST, iiIG_string(ERx("-1")));
			}
			else if ( osw_compare(ERx("nowait"), $2) )
			{
				$$ = osmkconst(tkICONST, iiIG_string(ERx("0")));
			}
			else
			{
				yyerror(_SyntaxError);
				$$ = NULL;
			}
		}
	|	WITH ID '=' ingres_int
		{
			if ( osw_compare(ERx("wait"), $2) )
			{
				$$ = $4;
			}
			else
			{
				yyerror(_SyntaxError);
				$$ = NULL;
			}
		}
	|	/* empty */
		{
			$$ = osmkconst(tkICONST, iiIG_string(ERx("0")));
		}
;

alert_key:	CRE_DBEVENT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = ERx("create dbevent ");
		}
	|	DRP_DBEVENT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = ERx("drop dbevent ");
		}
	|	REGISTER_DBEVENT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = ERx("register dbevent ");
		}
	|	REMOVE_DBEVENT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = ERx("remove dbevent ");
		}
;

alert_raise_key: RAISE_DBEVENT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

alert_get_key:	GET_DBEVENT
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
/* %L rules end */

/**-
** Database DML Transaction Statements.
**
** Includes:
**	abort	savepoint	transaction
*/
/*::
** Name:	abort -		DBMS ABORT Statement.
**
** Syntax:
**	ABORT [ [ TO ] <ingres_ref> ]
*/
abort:		abort_key
		{
			IGgenStmt(IL_ABORT, (IGSID *)NULL, 0);
		}
	|	abort_key to_noise ingres_ref
		{
			IGgenStmt(IL_ABORT, (IGSID *)NULL, 0);
			osdbeval($3);
		}
;
abort_key:	ABORT
		{
			if ( SQL )
			{
				/* not supported in future SQL... */
				oswarn(OSXACTWRN, 1, ERx("ABORT TRANSACTION"));

				/* and not part of Open SQL. */
				osOpenwarn(ERx("ABORT TRANSACTION"));
			}
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
to_noise:	TO	/* DBMS noise */
	|	/* empty */
;

/*::
** Name:	savepoint -		DBMS SAVEPOINT Statement.
**
** Syntax:
**	SAVEPOINT <ingres_ref>
**
** History:
**	03/90 (jhw) -- Generate IL_SAVPT_SQL instead for SQL.  JupBug #4567.
*/
savepoint:	savepoint_key ingres_ref
		{
			IGgenStmt( QUEL ? IL_SAVEPOINT : IL_SAVPT_SQL,
					(IGSID *)NULL, 0
			);
			osdbeval($2);
		}
;
savepoint_key:	SAVEPOINT
		{
			if ( SQL )
				osOpenwarn(ERx("SAVEPOINT"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	transaction -	DBMS Transaction Statements.
**
** Syntax:
**	BEGIN TRANSACTION | END TRANSACTION
*/
transaction:	BEGINTRANSACTION
		{
			if ( SQL )
			{
				/* not supported in future SQL... */
				oswarn(OSXACTWRN, 1, ERx("BEGIN TRANSACTION"));

				/* and not part of Open SQL. */
				osOpenwarn(ERx("BEGIN TRANSACTION"));
			}
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_BEGTRANS, (IGSID *)NULL, 0);
		}
	|	ENDTRANSACTION
		{
			if ( SQL )
			{
				/* not supported in future SQL... */
				oswarn(OSXACTWRN, 1, ERx("END TRANSACTION"));

				/* and not part of Open SQL. */
				osOpenwarn(ERx("END TRANSACTION"));
			}
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_ENDTRANS, (IGSID *)NULL, 0);
		}
;

/**-
** Database Data Definition (DDL) Statements.
**
** Includes:
**	location_name	int_list_all	format		null_clause
**	default_clause	unique_clause	with_clause
**	copy		modify		relocate	save	set
*/
/*
** Name:	location_name -	DBMS Location Name Production.
**
** Description:
**	Production for location name of table in Ingres.
*/
location_name:	qual_table_ref
		{
			$$ = $1;
		}
	|	ingres_name ':' qual_table_ref
		{
			u_ptr[0].u_cp = ERx(":");
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	ingres_name colid_ref
		{
			u_ptr[0].u_cp = ERx(":");
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $2;
			$$ = osmknode(DML|OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;

colid_ref:
    	COLID
    	{
    	    $$ = osmkident( $1, (OSNODE *)NULL );
    	}
    |	COLID '.' ID
        {
            u_ptr[0].u_nodep = osmkident( $1, (OSNODE *)NULL );
            u_ptr[1].u_nodep = osmkident($3, (OSNODE *)NULL);
    	    u_ptr[1].u_nodep->n_type = DB_CHA_TYPE;  /* see ingres_name def. */
            $$ = osmknode(DOT|DML, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
        }
;

/*
** Name:	int_list_all -	DBMS Ingres Integer List or ALL.
**
** Description:
**	A production for a list of Ingres integer references or ALL
**	used by the DESTROY or DROP PERMIT and INTEGRITY statements
**	for both QUEL and SQL.
*/
int_list_all:	ing_int_list
		{
			$$ = $1;
		}
	|	ALL
		{
			$$ = NULL;
		}
;

/*
** Name:	format -	DBMS Format Production.
**
** Description:
**	Production for
*/
format:		ingres_name
		{
			$$ = $1;
		}
	|	ID '(' ICONST ')'
		{
			char	buf[OSBUFSIZE];

			_VOID_ STprintf(buf, ERx("%s(%s)"), $1, $3);
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL );
		}
	|	ID '(' ICONST ',' ICONST ')'
		{
			char	buf[OSBUFSIZE];

			_VOID_ STprintf(buf, ERx("%s(%s,%s)"), $1, $3, $5);
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL );
		}
	|	ID ID '(' ICONST ')' 
		{
			char	buf[OSBUFSIZE];
			(VOID) STprintf(buf, ERx("%s %s(%s)"), $1, $2, $4 );
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL );
		}
	|	ID ID 
		{
			char	buf[OSBUFSIZE];
			(VOID) STprintf(buf, ERx("%s %s"), $1, $2 );
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL );
		}
;
/*
** Name:	null_clause -	DBMS NULL Clause Production.
**
*/
null_clause:	WITH NULLK
		{
			$$ = ERx("with null");
		}
	|	NOT NULLK
		{
			$$ = ERx("not null");
		}
        |       NOT NULLK WITH DEFAULT
                {
                        if ( SQL )
                                osOpenwarn(ERx("... WITH DEFAULT"));
                        $$ = ERx("not null with default");
                }
        |       NOT NULLK NOT DEFAULT
                {
                        if ( SQL )
                                osOpenwarn(ERx("... WITH DEFAULT"));
                        $$ = ERx("not null not default");
                }


;
default_clause: WITH DEFAULT
		{
			if ( SQL )
				osOpenwarn(ERx("... WITH DEFAULT"));
			$$ = ERx("with default");
		}
	|	NOT DEFAULT
		{
			if ( SQL )
				osOpenwarn(ERx("... NOT DEFAULT"));
			$$ = ERx("not default");
		}
;

/*
** Name:	unique_clause -	DBMS UNIQUE Keyword Clause.
**
** Description:
**	Optional UNIQUE keyword production for "CREATE INDEX" (SQL),
**	"RETRIEVE" and "RETRIEVE INTO" (QUEL), and "MODIFY".
*/
unique_clause:	UNIQUE
		{
			$$ = TRUE;
		}
	|	/* empty */
		{
			$$ = FALSE;
		}
;

/*
** Name:	with_clause -	DBMS Database Object With Clause.
**
** Description:
**	Optional WITH clause for DDL statements.
**
** Syntax:
**  WITH ingres_name
**	[ '=' [ UNIQUE ] <ID>
**		| <quoted_string>
**		| '(' ingres_ref [ ASC | DESC ] ',' ... ')'
**	]
**
** DDL Specific Instances as of 6.5
** ================================
** SQL:
**
**	ALTER ROLE ... WITH
**		NOPASSWORD
**		PASSWORD = 'rolepass'
**	ALTER USER ... WITH		<== 6.5
**		GROUP = 'groupname'
**		NOPASSWORD
**		PASSWORD = 'password'
**		PRIVILEGES = ( ... )
**	COPY [TABLE] ... INTO | FROM 'filename[,type]' WITH
**		ON_ERROR = TERMINATE | CONTINUE
**		ERROR_COUNT = n
**		ROLLBACK = ENABLED | DISABLED
**		LOG = 'filename'
**	CREATE GROUP ... WITH
**		USERS = ( 'userid' {, ...} )
**	CREATE INDEX ... WITH
**		KEY = ( columnname {, ...} )
**		STRUCTURE = CBTREE | BTREE | CISAM | ISAM | CHASH | HASH
**		FILLFACTOR = n
**		MINPAGES = n
**		MAXPAGES = n
**		LEAFFILL = n
**		NONLEAFFILL = n
**		LOCATION = ( locationname {, ...} )
**		ALLOCATION = n
**		EXTEND = n
**	CREATE ROLE ... WITH
**		NOPASSWORD
**		PASSWORD = 'rolepass'
**	CREATE TABLE ... WITH
**		LOCATION = ( locationname {, ...} )
**		[NO]JOURNALING
**		[NO]DUPLICATES
**		ALLOCATION = n
**		EXTEND = n
**	CREATE VIEW ... WITH
**		CHECK OPTION
**	CREATE USER ... WITH		<== 6.5
**		GROUP = 'groupname'
**		NOPASSWORD
**		PASSWORD = 'password'
**		PRIVILEGES = ( ... )
**	MODIFY ... WITH
**		FILLFACTOR = n
**		MINPAGES = n
**		MAXPAGES = n
**		LEAFFILL = n
**		NONLEAFFILL = n
**		NEWLOCATION = ( locationname {, ...} )
**		OLDLOCATION = ( locationname {, ...} )
**		LOCATION = ( locationname {, ...} )
**		ALLOCATION = n
**		EXTEND = n
**
** QUEL:
**
**	COPY  ... INTO | FROM "filename[,type]" WITH
**		ON_ERROR = TERMINATE | CONTINUE
**		ERROR_COUNT = n
**		ROLLBACK = ENABLED | DISABLED
**		LOG = "filename"
**	CREATE ... WITH
**		LOCATION = ( locationname {, ...} )
**		[NO]JOURNALING
**		[NO]DUPLICATES
**	INDEX ... WITH
**		KEY = ( columnname {, ...} )
**		STRUCTURE = CBTREE | BTREE | CISAM | ISAM | CHASH | HASH
**		FILLFACTOR = n
**		MINPAGES = n
**		MAXPAGES = n
**		LEAFFILL = n
**		NONLEAFFILL = n
**		LOCATION = ( locationname {, ...} )
**		ALLOCATION = n
**		EXTEND = n
**	MODIFY ... WITH
**		FILLFACTOR = n
**		MINPAGES = n
**		MAXPAGES = n
**		LEAFFILL = n
**		NONLEAFFILL = n
**		NEWLOCATION = ( locationname {, ...} )
**		OLDLOCATION = ( locationname {, ...} )
**		LOCATION = ( locationname {, ...} )
**		ALLOCATION = n
**		EXTEND = n
**	RETRIEVE INTO ... WITH
**		KEY = ( columnname {, ...} )
**		STRUCTURE = CBTREE | BTREE | CISAM | ISAM | CHASH | HASH
**		[NO]JOURNALING
**		[NO]DUPLICATES
**		LOCATION = ( locationname {, ...} )
**		FILLFACTOR = n
**		MINPAGES = n
**		MAXPAGES = n
**		NONLEAFFILL = n
**		LEAFFILL = n
**		INDEXFILL = n
**		MAXINDEXFILL = n
**		ALLOCATION = n
**		EXTEND = n
*/
with_clause:	WITH with_body
		{
			$$ = $2;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

with_body:	with_element
		{
			$$ = $1;
		}
	|	with_body ',' with_element
		{
			$$ = osaddtlist($1, $3);
		}
;

with_element:	with_key '=' unique_clause with_item
		{
			OSNODE *t1 = $4;
			OSNODE *t2 = (OSNODE *) NULL;

			if ($3)
			{
				t1 = osmkident(ERx("unique"), (OSNODE *) NULL);
				t2 = $4;
			}
			$$ = osmaketle($1, t1, t2);
		}
	|	with_key '=' '(' with_item_list ')'
		{
			u_ptr[1].u_nodep = $4;
			$$ = osmaketle( $1,
				osmknode(PARENS, (U_ARG*)NULL, &u_ptr[1],
					(U_ARG*)NULL),
				(OSNODE*)NULL
			);
		}
	|	with_key
		{
			$$ = osmaketle($1, (OSNODE *) NULL, (OSNODE *) NULL);
		}
;
with_item_list:	with_item_list ',' with_item
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG *)NULL, &u_ptr[0], &u_ptr[1]);
		}
	|	with_item
		{
			$$ = $1;
		}
;
with_item:	ingres_ref opt_asc_or_desc
		{
			if ($2 == NULL)
				$$ = $1;
			else
			{
				u_ptr[0].u_nodep = $1;
				u_ptr[1].u_nodep = osmkident($2, (OSNODE *)NULL);
				$$ = osmknode(BLANK, (U_ARG *)NULL,
							&u_ptr[0], &u_ptr[1]
				);
			}
		}
	|	UPDATE	/* special case: can appear in WITH clause rhs */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	ALL	/* special case: can appear in WITH clause rhs */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	KEY	/* special case: can appear in WITH clause rhs */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
;

with_key:	ingres_name
		{
			$$ = $1;
		}
	/* special cases:  can appear in WITH clause left-hand side */
	|	KEY	/* 4GL; [CREATE] INDEX | RETRIEVE INTO ... WITH KEY = */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;
		}
	|	TABLE	/* SQL only */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;
		}
	|	ROLLBACK /* SQL only; COPY [TABLE] ... WITH ROLLBACK = ... */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;
		}
	|	GRANT	/* SQL only */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;
		}
	|	GROUP	/* SQL only; CREATE|ALTER USER ... WITH GROUP = ... */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;
		}
	|	UPDATE	/* SQL only */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;
		}
	|	INDEX	/* SQL only */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;
		}
;
opt_asc_or_desc: /* empty */
		{
			$$ = NULL;
		}
	|	ID
		{
			/* We'd better be in QUEL. */
			if (!osw_compare(ERx("asc"), $1)
			 && !osw_compare(ERx("desc"), $1))
				yyerror(_SyntaxError);
			$$ = $1;
		}
	|	ASC
		{
			$$ = $1;
		}
	|	DESC
		{
			$$ = $1;
		}
;

/*::
** Name:	copy -	DBMS COPY Statement.
**
** Syntax:
**	COPY <ingres_name> '('
**	  [ <ingres_name> '=' <ingres_name> [ WITH NULL [ '(' <constant> ')' ] ]
**			[ ',' ... ] ] ')'
**		INTO | FROM <OSLexpr> [ WITH ID '=' <ingres_ref> [ ',' ... ] ]
**
** History:
**	03/90 (jhw) -- Generate IL_COPY_SQL instead for SQL.  JupBug #9734.
**	08/02/91 (emerson)
**		Fix for bug 31342: Enclose copy formats of c0x and d0x
**		(where x represents any single character) in quotes or
**		apostrophes.  Also made some cosmetic changes.
*/
copy:		copy_key qual_table_ref '(' copy_tl ')' copy_dir OSLstrexpr
			with_clause
		{
			ILREF	fres = 0;

			/* pass file directly as semantic value (w/o '\\') */
			fres = osvarref($7);

			IGgenStmt(QUEL ? IL_COPY :IL_COPY_SQL, (IGSID*)NULL, 0);
			osdbeval($2);
			osdbstr(ERx("("));
			if ($4 != NULL)
				osevaltlist($4, osdbtle); /* copy target list */
			osdbstr(ERx(")"));
			osdbstr($6);
			osdbflush();
			IGgenStmt(IL_DBVAR, (IGSID *)NULL, 1, fres);/* string val */
			osdbwith($8);	/* optional with clause */
		}
;
copy_key:	COPY
		{
			if ( SQL )
				osOpenwarn(ERx("COPY"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
copy_dir:	INTO
		{
			$$ = $1;
		}
	|	FROM
		{
			$$ = $1;
		}
;
copy_tl:	/* empty */
		{
			$$ = NULL;
		}
	|	copy_list
		{
			$$ = $1;
		}
;
copy_list:	copy_list_elm
		{
			$$ = $1;
		}
	|	copy_list ',' copy_list_elm
		{
			$$ = osaddtlist($1, $3);
		}
;
copy_list_elm:	ingres_name '=' copy_format copy_null
		{
			$$ = osmaketle($1, $3, $4);
		}
;
copy_format:	ingres_name
		{
			$$ = $1;

			/*
			** Hack for bug 31342:
			**
			** The INGRES DBMS requires that a copy format
			** of c0<delim> or d0<delim> be enclosed
			** in quotes (QUEL) or apostrophes (SQL),
			** in the case where <delim> is a 1-character
			** delimiter, so we force quotes or apostrophes
			** in precisely those 2 cases.
			**
			** A cleaner approach would have been to emit
			** exactly what the user entered: that is, to
			** restore the enclosing quotes or apostrophes
			** if the copy format came in as an SCONST.
			** However, that could break existing applications.
			** For example, if the user specifies a copy format
			** of 'char(0)', we currently strip off the apostrophes,
			** which produces a legal format: char(0).  If we were
			** to restore the apostrophes, the DBMS would reject
			** the copy format.
			*/
			if ($1->n_token == tkID)
			{
				char	*format_string = $1->n_value;

				if (  STlength(format_string) == 3
				   && format_string[1] == '0'
				   && (  format_string[0] == 'c'
				      || format_string[0] == 'd'
				      )
				   )
				{
					char	buf[OSBUFSIZE];

					(VOID) STprintf(buf, ERx("%s%s%s"),
							osQuote, format_string,
							osQuote);
					$$ = osmkident( iiIG_string(buf),
							(OSNODE *)NULL );
				}
			}
		}
	|	ID '(' ICONST ')' copy_delim
		{
			char	buf[OSBUFSIZE];

			if ($5 == NULL)
			{
				(VOID) STprintf(buf, ERx("%s(%s)"), $1, $3);
			}
			else if (STlength($5) == 1)
			{
				(VOID) STprintf(buf, ERx("%s(%s)%s%s%s"),
						$1, $3, osQuote, $5, osQuote);
			}
			else
			{
				(VOID) STprintf(buf, ERx("%s(%s)%s"),
						$1, $3, $5);
			}
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL );
		}
	/* Add handling for LONG VARCHAR(0), BYTE VARYING copy format etc. */
	|	ID ID '(' ICONST ')' copy_delim
		{
			char	buf[OSBUFSIZE];

			if ($6 == NULL)
			{
				(VOID) STprintf(buf, ERx("%s %s(%s)"),
				                $1, $2, $4);
			}
			else if (STlength($6) == 1)
			{
				(VOID) STprintf(buf, ERx("%s %s(%s)%s%s%s"),
						$1, $2, $4, osQuote, $6,
				                osQuote);
			}
			else
			{
				(VOID) STprintf(buf, ERx("%s %s(%s)%s"),
						$1, $2, $4, $6);
			}
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL );
		}
;
copy_delim:	id_or_sconst
		{
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
copy_null:	WITH NULLK
		{
			$$ = osmkident( ERx("with null"), (OSNODE *)NULL );
		}
	|	WITH NULLK '(' uconstant ')'
		{
			/* 
			 * Bug 34530 - re-written to produce the correct
			 * "with null(...)" string for all the various
			 * constant types.
			 */

			char	buf[OSBUFSIZE]; /* put "with null (...)" here */
			char	xcstr[2];	/* the "X" in "(X'3939')" */
			i4	ntk;		/* token type of $4 */
			char	*qstr;		/* osQuote in string, else "" */

			xcstr[0] = xcstr[1] = EOS;
			ntk = $4->n_token;
			qstr = osQuote;

			if ( ntk == tkXCONST )
				xcstr[0] = 'X';
			else if ( ntk == tkFCONST 
			       || ntk == tkICONST 
			       || ntk == tkDCONST 
				)
				qstr = ERx("");
			else if ( ntk != tkSCONST )
			{
				/* syntax error */
				oscerr(E_OS0132_BadWithNull, 1, $4->n_const);
			}

			STprintf(buf, ERx("with null(%s%s%s%s)"), xcstr,
								  qstr,
								  $4->n_const,
								  qstr);
			$$ = osmkident( iiIG_string(buf), (OSNODE *)NULL );
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*::
** Name:	modify -	QUEL MODIFY Statement.
**
** Syntax:
**	MODIFY <ingres_name> TO <ingres_name> [ UNIQUE ]
**		[ ON <key> [ ',' <key> ] ]
**		[ WHERE|WITH ID '=' <ingres_ref> [ ',' ... ] ]
*/
modify:		modify_key qual_table_ref TO modify_to unique_clause modkeys
			mod_with_clause
		{
			IGgenStmt(QUEL ? IL_MODIFY : IL_SQLMODIFY, (IGSID*)NULL, 0);
			osdbeval($2);
			osdbstr(ERx(" to "));
			osdbeval($4);
			if ($5)
				osdbstr(ERx(" unique "));
			if ($6 != NULL)
			{ /* modify key list */
				osdbstr(ERx(" on "));
				osevalsklist($6, osdbsrtkey, osldml);
			}
			if ($7 != NULL)
			{ /* modify fill list */
				osdbstr(ERx(" where "));
				osevaltlist($7, osdbtle);
			}
		}
;
modify_key:	MODIFY
		{
			if ( SQL )
				osOpenwarn(ERx("MODIFY"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
modify_to:	ingres_name
		{
			$$ = $1;
		}
	|	RELOCATE	/* special keywords */
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
;
modkeys:	ON key_list
		{
			$$ = $2;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
mod_with_clause:/* empty */
		{
			$$ = NULL;
		}
	|	WHERE with_body
		{
			$$ = $2;
		}
	|	WITH with_body
		{
			$$ = $2;
		}
;

/*::
** Name:	relocate -	DBMS RELOCATE Statement.
**
** Syntax:
**	RELOCATE <ingres_name> TO <ingres_name>
*/
relocate:	relocate_key ingres_name TO ingres_name
		{
			IGgenStmt(IL_RELOCATE, (IGSID *)NULL, 0);
			osdbeval($2);
			osdbstr(ERx(" to "));
			osdbeval($4);
		}
;
relocate_key:	RELOCATE
		{
			if ( SQL )
				osOpenwarn(ERx("RELOCATE"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	save -	DBMS SAVE Statement.
**
** Syntax:
**	SAVE <ingres_name> UNTIL <ingres_ref> <ingres_int> <ingres_int>
*/
save:		save_key ingres_name UNTIL ingres_ref ingres_int ingres_int
		{
			IGgenStmt(IL_SAVE, (IGSID *)NULL, 0);
			osdbeval($2);
			osdbstr(ERx(" until "));
			osdbeval($4);
			osdbstr(ERx(" "));
			osdbeval($5);
			osdbstr(ERx(" "));
			osdbeval($6);
		}
	|	save_key ingres_name
		{
			IGgenStmt(IL_SAVE, (IGSID *)NULL, 0);
			osdbeval($2);
		}
;
save_key:	SAVE
		{
			if ( SQL )
				osOpenwarn(ERx("SAVE"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;

/*::
** Name:	set -	DBMS SET Statements.
**
** Syntax:
**	SET <ingres_name>
**	SET <ingres_name> <ingres_ref>
**	SET <ingres_name> ON
**	SET <ingres_name> [ ON <ingres_name> ]
**	SET <ingres_name> <ingres_ref> <ingres_ref>  
** 	SET <ingres_name> <ingres_name> <ingres_name> = ROLLBACK <ingres_name>
**	SET USER AUTHORIZATION <ingres_name> | SYSTEM USER | SESSION USER
**	SET GROUP <ingres_name> | SESSION GROUP
**	SET ROLE <ingres_name> [WITH PASSWORD='aaaa']
**	SET <ingres_name> <ingres_name> | ON <ingres_name>
**		WHERE <ingres_name> '=' <ingres_ref> [ ',' ... ]
*/
set:	set_key set_option
		{
			osdbeval($2);
		}
	|	set_key set_option ingres_ref 
		{
			osdbeval($2);
			osdbstr(ERx(" "));
			osdbeval($3);
		} set_opt_with
		/* SET AUTOCOMMIT ON */
	|	set_key set_option ON
		{
			osdbeval($2);
			osdbstr(ERx(" on"));
		}
		/* SET AUTOCOMMIT OFF */
	|	set_key set_option OFF
		{
			osdbeval($2);
			osdbstr(ERx(" off"));
		}
		/* SET [NO]JOURNALING ON ... */
	|	set_key set_option ON qual_table_ref
		{
			osdbeval($2);
			osdbstr(ERx(" on "));
			osdbeval($4);
		}

	|	set_key set_option ingres_name ingres_name
		{
			osdbeval($2);
			osdbstr(ERx(" "));
			osdbeval($3);
			osdbstr(ERx(" "));
			osdbeval($4);
		}
		/* SET SESSION [ADD/DROP PRIVILEGES ( priv, priv )] 
		**	[WITH with_list] 
		*/
	|	set_key_session set_sess_tail
	 	/* SET ROLE SESSION ROLE */
	|	set_key set_option SESSION_ROLE
		{
			osOpenwarn(ERx("SET ROLE"));
			osdbeval($2);
			osdbstr(ERx(" session role"));
		}

	 	/* SET GROUP SESSION GROUP */
	|	set_key GROUP SESSION_GROUP
		{
			osOpenwarn(ERx("SET GROUP"));
			osdbstr(ERx(" group session group"));
		}

	 	/* SET GROUP <ingres_name> */
	|	set_key GROUP ingres_name
		{
			osOpenwarn(ERx("SET GROUP"));
			osdbstr(ERx(" group "));
			osdbeval($3);
		}

	 	/* SET USER AUTHORIZATION <ingres_name> */
	|	set_key USER_AUTH ingres_name
		{
			osOpenwarn(ERx("SET USER AUTHORIZATION"));
			osdbstr(ERx(" user authorization "));
			osdbeval($3);
		}

	 	/* SET USER AUTHORIZATION SYSTEM USER | SESSION USER */
	|	set_key USER_AUTH sys_sess_user
		{
			osOpenwarn(ERx("SET USER AUTHORIZATION"));
			osdbstr(ERx(" user authorization "));
			osdbstr($3);
		}

		/* SET CACHE ID WHERE ... */
	|	set_key set_option ingres_name WHERE lock_list
		{
			osdbeval($2);
			osdbstr(ERx(" "));
			osdbeval($3);
			osdbstr(ERx(" where "));
			osevaltlist($5, osdbtle);	/* lock list */
		}
		/* SET LOCKMODE SESSION | ON <ingres_name> ... */
	|	set_key set_option SESSION WHERE lock_list
		{
			osdbeval($2);
			osdbstr(ERx(" session where "));
			osevaltlist($5, osdbtle);	/* lock list */
		}
	|	set_key set_option ON qual_table_ref WHERE lock_list
		{
			osdbeval($2);
			osdbstr(ERx(" on "));
			osdbeval($4);
			osdbstr(ERx(" where "));
			osevaltlist($6, osdbtle);	/* lock list */
		}
;
set_key:	SET
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(QUEL ? IL_SET : IL_SETSQL, (IGSID *)NULL, 0);
		}
;

set_key_session:	SET SESSION
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(QUEL ? IL_SET : IL_SETSQL, (IGSID *)NULL, 0);
			osdbstr(ERx("session"));
		}
;
set_opt_with:   WITH set_sess_with_list
		{
			osdbwith($2);
		}
	|
		/* empty */
	;
/*
** set_sess_tail - tailing options from SET SESSION
** The intent here is at least one of the ADD/DROP/WITH clauses must be
** given.
*/
set_sess_tail:  adp_privs_req
	     |  adp_privs_req set_sess_with
	     |  set_sess_with
;
set_sess_with:	WITH set_sess_with_list
		{
			osdbwith($2);
		}
;
/*
** set_sess_with_list - SET SESSION WITH-clause
*/
set_sess_with_list:	set_sess_with_elem
		{
			$$ = $1;
		}
	     |  
		set_sess_with_list ',' set_sess_with_elem
		{
			$$ = osaddtlist($1, $3);
		}

;
set_sess_with_elem: set_sess_with_lhs '=' set_sess_with_rhs
		/* SET SESSION WITH SECURITY_LABEL='xxx'  */
		{
			$$ = osmaketle($1, $3, (OSNODE *)NULL);
		}
	|	set_sess_with_lhs 
		/* SET SESSION WITH NOPRIVILEGES/NODESCRIPTION */
		{
			$$ = osmaketle($1, (OSNODE *) NULL,
						(OSNODE *)NULL);
		}
	|	set_sess_with_lhs '=' '(' with_item_list ')'
		{
			u_ptr[1].u_nodep = $4;
			$$ = osmaketle( $1,
				osmknode(PARENS, (U_ARG*)NULL, &u_ptr[1],
					(U_ARG*)NULL),
				(OSNODE*)NULL
			);
		}
	|	set_sess_with_lhs '=' set_rollback_clause
	 	/* SET SESSION WITH ON_ERROR = ROLLBACK STATEMENT|TRANSACTION */
		{
			$$ = osmaketle($1,  $3,
					(OSNODE *)NULL);
		}
;

set_sess_with_lhs: ID
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	OSLcol_var disallow_repeat
		{
			if (!oschkstr($1->n_type))
				oscerr(OSNOTSTR, 1, ERget(_FrsName));
			else if ( AFE_NULLABLE_MACRO($1->n_type) )
				oswarn(OSNULVCHK, 0);
			$$ = $1;
		}
;
set_sess_with_rhs: ingres_ref 
			{$$=$1;}

		| ALL
			{ $$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;	/* special case */
			}
		| DEFAULT
			{ $$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;	/* special case */
			}
;

set_rollback_clause: ROLLBACK ingres_name
		{
			u_ptr[0].u_nodep = osmkident($1, (OSNODE*)NULL);
			u_ptr[1].u_nodep = $2;
			$$ = osmknode( BLANK, (U_ARG*)NULL,
					&u_ptr[0], &u_ptr[1]);
		}
;
set_option:	ingres_name
		{
                        if (osChkSQL && $1->n_token == tkID
			  && STbcompare($1->n_value, 0, ERx("autocommit"), 0,
					FALSE) != 0
				)
			{
				char	buf[OSBUFSIZE];

				osOpenwarn( STprintf( buf, ERx("SET %s"),
							$1->n_value
						)
				);
			}
			$$ = $1;
		}
;
sys_sess_user:	SYSTEM_USER
		{
			$$ = ERx("system user");
		}
	|	SESSION_USER
		{
			$$ = ERx("session user");
		}
;
lock_list:	lock_list_elm
		{
			$$ = $1;
		}
	|	lock_list ',' lock_list_elm
		{
			$$ = osaddtlist($1, $3);
		}
;
lock_list_elm:	ingres_name '=' ingres_ref
		{
			$$ = osmaketle($1, $3, (OSNODE *)NULL);
		}
	|	ingres_name '=' SYSTEM
		{
			$$ = osmaketle($1, osmkident($3, (OSNODE *) NULL),
						(OSNODE *)NULL);
		}
	|	ingres_name '=' SESSION
		{
			$$ = osmaketle($1, osmkident($3, (OSNODE *) NULL),
						(OSNODE *)NULL);
		}
	|	ingres_name '=' TABLE	/* SQL only */
		{
			$$ = osmaketle($1, osmkident($3, (OSNODE *) NULL),
						(OSNODE *)NULL);
		}
;

/*
** adp_privs_req - handle ADD/DROP PRIVILEGES. Only one of these
**	       clauses is allowed. This is used by the SET SESSION
**	       statement, and also by the SQL ALTER USER/PROFILE statements
*/


adp_privs_req: add_privs_kw db_lparen db_ingname_list db_rparen
	|
	drop_privs_kw db_lparen db_ingname_list db_rparen
	;

add_privs_kw: ADD_PRIVILEGES 
		{  osdbstr(ERx(" add privileges "));}
;		
drop_privs_kw: DROP_PRIVILEGES 
		{  osdbstr(ERx(" drop privileges "));}
;
db_ingname:	ingres_name
	{
	    osdbeval($1);
	}
;
db_ingname_list:	db_ingname
	|		db_ingname_list db_comma db_ingname
;
db_lparen:	'('
	{
	    osdbstr(ERx("("));
	}
;
db_rparen:	')'
	{
	    osdbstr(ERx(")"));
	}
;
db_comma:	','
	{
	    osdbstr(ERx(","));
	}
;
/**-
** STAR Statements.
**
** Includes:
**	direct connect, direct disconnect, direct execute immediate (SQL only),
**	register, remove
*/
/*::
** Name: direct execute immediate - STAR version of EXECUTE IMMEDIATE
**
** Syntax:
**	DIRECT EXECUTE IMMEDIATE <ingres_qname>
**		[ WITH ID '=' <ingres_ref> [ ',' ... ] ]
*/
direct_execute:	dir_ex_key ingres_qname with_clause
		{
			IGgenStmt(IL_DIREXIMM, (IGSID *)NULL, 0);
			osdbeval($2);
			osdbwith($3);	/* optional with clause */
		}
;
dir_ex_key:	DIR_EXECUTE IMMEDIATE
		{
			/*
			**  In Quel, error recovery is awful for unrecognized
			**  2nd words of double-keywords.  So it's much
			**  prettier if we catch it here.  This should be fixed.
			*/
			if (QUEL)
				yyerror(_SyntaxError);
			else
				osOpenwarn(ERx("DIRECT EXECUTE IMMEDIATE"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
		}
;
/*::
** Name: direct connect - STAR "DIRECT CONNECT" command.
**
** Syntax:
**	DIRECT CONNECT [ WITH ID '=' <ingres_ref> [ ',' ... ] ]
*/

direct_connect:	DIR_CONNECT with_clause
		{
			if ( SQL )
				osOpenwarn(ERx("DIRECT CONNECT"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DIRCONN, (IGSID *)NULL, 0);
			osdbwith($2);	/* optional with clause */
		}
;

/*::
** Name: direct disconnect - STAR "DIRECT DISCONNECT" command.
**
** Syntax:
**	DIRECT DISCONNECT
*/

direct_disconnect:	DIR_DISCONNECT
		{
			if ( SQL )
				osOpenwarn(ERx("DIRECT DISCONNECT"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_DIRDIS, (IGSID *)NULL, 0);
		}
;

/*::
** Name: register - STAR "REGISTER {TABLE,INDEX,VIEW,PROCEDURE}" command.
**
** Syntax:
**	REGISTER  [ TABLE | INDEX | VIEW | PROCEDURE ] <obj_name>
**	[ ON <ingres_name> ]
**	[ <col_name> <EQ> <format> [ IS <string> ]
**			{, <col_name> <EQ> <format> [ IS <string> ]
**	AS LINK | IMPORT
**	[ FROM <source> ]
**	[ WITH <with_clause> ]
**
** where <EQ> is empty for SQL, '=' for QUEL.  REGISTER PROCEDURE in SQL only.
*/
register:	register_key ingres_name opt_on_clause opt_col_spec_list
			AS register_type /* link or import */
			opt_reg_from_clause
			with_clause
		{
			IGgenStmt(IL_REGISTER, (IGSID *)NULL, 0);

			/* <empty>, TABLE, INDEX, VIEW, or PROCEDURE(SQL) */
			if ($1 != NULL)
			{
				osdbstr($1);
				osdbstr(ERx(" "));
			}

			/* object name */
			osdbeval($2);

			/* the optional ON <name> */
			if ($3 != NULL)
			{
				osdbstr(ERx(" on "));
				osdbeval($3);
			}

			/* the optional formatlist */
			if ($4 != NULL)
			{
				osdbstr(ERx("("));
				if (QUEL)
					osevaltlist($4, osdbtle);
				else
					osevaltlist($4, osdbsqltle);
				osdbstr(ERx(")"));
			}

			osdbstr(ERx(" as "));
			osdbstr($6);

			/* optional FROM clause */
			if ($7 != NULL)
			{
				osdbstr(ERx(" from "));
				osdbeval($7);
			}

			osdbwith($8);	/* optional WITH clause */
		}
;
register_key:	REGISTER reg_obj_type
		{
			if ( SQL )
				osOpenwarn(ERx("REGISTER"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = $2;
		}
	|	REG_TABLE /* QUEL only */
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = ERx("table");
		}
	|	REG_VIEW
		{
			osOpenwarn(ERx("REGISTER"));
			IGstartStmt(osscnlno(), IL_LB_NONE);
			$$ = ERx("view");
		}
;
reg_obj_type:	/* empty */
		{
			$$ = NULL;
		}
	|	INDEX
		{
			$$ = $1;
		}
	|	UNIQUE INDEX
		{
			$$ = ERx("unique index");
		}
	|	TABLE /* SQL only.  RE[GM]_TABLE does it in QUEL. */
		{
			$$ = $1;
		}
	|	PROCEDURE /* SQL only. */
		{
			$$ = $1;
		}
;
register_type:	ID
		{
			if ( !osw_compare(ERx("import"), $1)
					&& !osw_compare(ERx("link"), $1) )
			{
				yyerror(_SyntaxError);
			}
			$$ = $1;
		}
;
opt_on_clause: /* empty */
		{
			$$ = NULL;
		}
	|	ON ingres_name
		{
			$$ = $2;
		}
;
opt_col_spec_list:
	/* empty */
	{
		$$ = NULL;
	}
    |	'(' reg_col_spec_list ')'
	{
		$$ = $2;
	}
;
reg_col_spec_list:
	reg_col_spec
	{
		$$ = $1;
	}
    |   reg_col_spec_list ',' reg_col_spec
	{
		$$ = osaddtlist($1, $3);
	}
;
reg_col_spec :
	column_spec			/* REGISTER ... AS IMPORT ... */
	{
		$$ = $1;
	}
    |	column_spec is_clause		/* REGISTER ... AS IMPORT ... */
	{
		if ( $1->tl_dim == NULL )
			$1->tl_dim = $2;
		else
		{
			OSNODE *tmp;

			u_ptr[0].u_nodep = $1->tl_dim;
			u_ptr[1].u_nodep = $2;
			$1->tl_dim = osmknode( BLANK, (U_ARG *)NULL,
						&u_ptr[0], &u_ptr[1]
			);
		}
		$$ = $1;
	}
    |	ingres_name			/* REGISTER ... AS LINK ... */
	{
		$$ = osmaketle($1, (OSNODE *)NULL, (OSNODE *)NULL);
	}
;
is_clause:	IS ingres_qname
		{
			u_ptr[0].u_nodep = osmkident($1, (OSNODE *) NULL);
			u_ptr[1].u_nodep = $2;
			$$ = osmknode( BLANK, (U_ARG *) NULL,
						&u_ptr[0], &u_ptr[1]
			);
		}
;
opt_reg_from_clause:	/* empty */
		{
			$$ = NULL;
		}
	|	FROM qual_table_ref
		{
			$$ = $2;
		}
;

/*::
** Name: remove - STAR "REMOVE {TABLE,INDEX,VIEW}" command.
**
** Syntax:
**	REMOVE [ TABLE | INDEX | VIEW ] <obj_name>
*/
remove:		remove_key qual_table_ref
		{
			IGstartStmt(osscnlno(), IL_LB_NONE);
			IGgenStmt(IL_REMOVE, (IGSID *)NULL, 0);

			/* <empty>, TABLE, INDEX, or VIEW */
			if ($1 != NULL)
			{
				osdbstr($1);
				osdbstr(ERx(" "));
			}

			/* object name */
			osdbeval($2);
		}
;
remove_key:	REMOVE reg_obj_type
		{
			if ( SQL )
				osOpenwarn(ERx("REMOVE"));
			$$ = $2;
		}
	|	REM_TABLE /* QUEL only */
		{
			$$ = ERx("table");
		}
	|	REM_VIEW
		{
			if ( SQL )
				osOpenwarn(ERx("REMOVE"));
			$$ = ERx("view");
		}
;


/**-
** OSL Expressions.
**
** Note:  The OSL parser recognizes expressions in two different
** contexts; database (QUEL or SQL) context, and OSL context.
*/

/*::
** Name:	OSLexpr -	OSL Expressions.
**
**	04/07/91 (emerson)
**		Modifications for local procedures:
**		When expression is a procedure call,
**		call new function osprocsym instead of old osobjsym;
**		it will look for a local procedure before looking for
**		a "regular" procedure.
**	07/22/91 (emerson)
**		Fix for bug 38753: When call_name is a variable rather than
**		a literal, its node doesn't have a valid n_value, and it's
**		not appropriate to call osprocsym.
**	08/06/91 (emerson)
**		Issue a warning if the system function DBMSINFO is used
**		in an expression (bug 21745).
*/
OSLexpr:	OSLexpr boph OSLexpr	%prec BOPH
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	OSLexpr bop OSLexpr	%prec BOP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	OSLexpr EXP OSLexpr
		{
			u_ptr[0].u_cp = _Exp;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(OP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	'(' OSLexpr ')'
		{
			$$ = $2;
		}
	|	'-' OSLexpr	%prec UOP
		{
			u_ptr[0].u_cp = _UnaryMinus;
			u_ptr[1].u_nodep = $2;
			$$ =
			  osmknode(UNARYOP, &u_ptr[0], &u_ptr[1], (U_ARG*)NULL);
		}
	|	call_name '(' func_param ')'
		{
			register OSNODE	*proc;
			char	*proc_name;

			if ($1->n_token == tkID)
			{
				proc_name = $1->n_value;
				u_ptr[0].u_symp = osprocsym($1->n_value, TRUE);
			}
			else
			{
				proc_name = NULL;
				u_ptr[0].u_symp = (OSSYM *)NULL;
			}
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			proc = osmknode(tkPCALL, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			if ( proc->n_token == tkPCALL )
			{
				if ( proc->n_psym != NULL )
				{
					if ( proc->n_psym->s_kind == OSUNDEF
						|| proc->n_type != DB_NODT )
					{
						proc->n_psym->s_ref |=
							OS_OBJREF;
					}
					else
					{
						oscerr( OSNORETVAL,
							1, proc->n_proc->n_const
						);
					}
				}
			}
			else	/* osmknode determined that the specified
				** procedure is a system (ADF) function.
				** See if it's DBMSINFO.
				*/
			{
				if ( STbcompare(proc_name, 0,
					ERx("dbmsinfo"), 0, TRUE) == 0 )
				{
					oswarn(E_OS0269_BadDbmsinfo);
				}
			}

			$$ = proc;
		}
	|	OSLprimary
		{
			$$ = $1;
		}
;

OSLprimary:	constant_or_null
		{
			/* Translate strings */
			if ( $1->n_token == tkSCONST )
				$1->n_const = osstring( FALSE, $1->n_const, osldml);
			else if ( $1->n_token == tkXCONST )
				$1->n_const = oshexvchar($1->n_const);	/* SQL only */
			$$ = $1;
		}
	|	OSLvalue
		{
			$$ = $1;
		}
;

func_param:	callp_par_list
		{
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*
** Name:	row_number -	Table Field Row Reference Production.
**
** Note:  Can only be used where there is not both rules of the form
** "ID row_number '.' ID" and "ID'.'ID" or "ID LSQBRK OSLintexpr RSQBRK '.' ID",
** otherwise a "shift/reduce" conflict results.
*/

opt_row_number:	row_number
		{
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;
row_number:	LSQBRK OSLintexpr RSQBRK
		{
			$$ = $2;
		}
	|	LSQBRK RSQBRK
		{
			$$ = NULL;
		}
;

OSLstrexpr:	OSLexpr
		{
			if ( $1->n_token == tkNULL ||
				( $1->n_type != DB_NODT &&
					!oschkstr($1->n_type) ) )
			{ /* not a string! */
				oscerr(OSNOTSTRX, 0);
			}
			$$ = $1;
		}
;

OSLintexpr:	OSLexpr
		{
			if ( !ADE_CHK_TYPE($1->n_type, DB_INT_TYPE) &&
					$1->n_type != DB_NODT )
				oscerr(OSNOTINT, 0);
			$$ = $1;
		}
;

/*::
** Name:	OSLcondition -	OSL Logical Expressions.
**
** Description:
**	An OSL logical expression, recognized for <if_stmt> and <while_stmt>.
*/
OSLcondition:	'(' OSLcondition ')'
		{
			$$ = $2;
		}
	|	OSLcondition lbop OSLcondition	%prec LBOP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(LOGOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	NOT OSLcondition	%prec UOP
		{
			u_ptr[0].u_cp = _Not;
			u_ptr[1].u_nodep = $2;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(LOGOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	OSLexpr relop OSLexpr	%prec ROP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;
			$$ = osmknode(RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	OSLexpr is_postfix_op	%prec UOP_POSTFIX
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	OSLexpr likeop like_pattern escape   %prec ROP
		{
			u_ptr[0].u_cp = $2;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = $3;

			$$ = osmknode(RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			if ( $4 != NULL )
			{ /* SQL only because ESCAPE is not a keyword in QUEL */
				u_ptr[0].u_cp = _Escape;
				u_ptr[1].u_nodep = $$;
				u_ptr[2].u_nodep = $4;
				$$ = osmknode(RELOP, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
			}
		}
;
like_pattern:	constant
		{
			/* Translate strings */
			if ( $1->n_token == tkSCONST )
				$1->n_const = osstring( TRUE, $1->n_const, osldml);
			else if ( $1->n_token == tkXCONST )
				$1->n_const = oshexvchar($1->n_const);  /* SQL only */
			else
			{
				/* not a string! */
				oscerr(OSNOTSTRX, 0);
			}
			$$ = $1;
		}
	|   OSLvalue
		{
			if ( $1->n_token == tkNULL
			  || ( $1->n_type != DB_NODT && !oschkstr($1->n_type) ) )
			{
				/* not a string! */
				oscerr(OSNOTSTRX, 0);
			}
			if ( QUEL )
			{ /* Must encode dynamic value for pattern-match */
				U_ARG   encode;
				U_ARG   utmp;

				/* Note:  ADE_PMENCODE operates on its argument
				** translating pattern-match characters (and escapes)
				** into the internal pattern-match representation.
				** So, variables must be copied into a temporary
				** before applying ADE_PMENCODE and the LIKE operators.
				*/
                		encode.u_cp = ERx("varchar");
				utmp.u_nodep = $1;
				utmp.u_nodep = osmknode(UNARYOP, &encode,
						&utmp, (U_ARG *)NULL);

				encode.u_cp = _PMEncode;
				$$ = osmknode(UNARYOP, &encode,
						&utmp, (U_ARG *)NULL);
			}
			else
			{
				$$ = $1;
			}
		}
;

/**-
** Constant, Operator, etc. Productions.
**
** Includes:
**	constant	boph		bop		lbop		relop
**	likeop		escape		is_postfix_op		
**	constant_or_null		uconstant	uconstant_or_null
*/
constant:	SCONST
		{
			$$ = osmkconst(tkSCONST, $1);
		}
	|	XCONST	/* SQL only */
		{
			if (QUEL)
				yyerror(_SyntaxError);
			$$ = osmkconst(tkXCONST, $1);
		}
	|	ICONST
		{
			$$ = osmkconst(tkICONST, $1);
		}
	|	FCONST
		{
			$$ = osmkconst(tkFCONST, $1);
		}
	|	DCONST
		{
			$$ = osmkconst(tkDCONST, $1);
		}
;
uconstant:	constant
		{
			$$ = $1;
		}
	|	'-' ICONST
		{
			char    buf[OSBUFSIZE];

			buf[0] = '-'; STcopy( $2, buf + 1 );
			$$ = osmkconst(tkICONST, iiIG_string(buf));
		}
	|	'-' FCONST
		{
			char    buf[OSBUFSIZE];

			buf[0] = '-'; STcopy( $2, buf + 1 );
			$$ = osmkconst(tkFCONST, iiIG_string(buf));
		}
	|	'-' DCONST
		{
			char    buf[OSBUFSIZE];

			buf[0] = '-'; STcopy( $2, buf + 1 );
			$$ = osmkconst(tkDCONST, iiIG_string(buf));
		}
;
constant_or_null:	constant
		{
			$$ = $1;
		}
	|	NULLK
		{
			$$ = osmkconst(tkNULL, $1);
		}
;
uconstant_or_null:	uconstant
		{
			$$ = $1;
		}
	|	NULLK
		{
			$$ = osmkconst(tkNULL, $1);
		}
;
constant_str:	SCONST
		{
			$$ = osmkconst(tkSCONST, $1);
		}
;
uconstant_int:	ICONST
		{
			$$ = osmkconst(tkICONST, $1);
		}
	|	'-' ICONST
		{
			char	buf[64];

			buf[0] = '-'; STcopy( $2, buf + 1 );
			$$ = osmkconst(tkICONST, iiIG_string(buf));
		}
;

boph:		'*'
		{
			$$ = _Mul;
		}
	|	'/'
		{
			$$ = _Div;
		}
;

bop:		'+'
		{
			$$ = _Plus;
		}
	|	'-'
		{
			$$ = _Minus;
		}
;

lbop:		AND
		{
			$$ = _And;
		}
	|	OR
		{
			$$ = _Or;
		}
;

relop:		'<'
		{
			$$ = _Less;
		}
	|	'>'
		{
			$$ = _Greater;
		}
	|	'='
		{
			$$ = _Equal;
		}
	|	LTE
		{
			$$ = _LessEqual;
		}
	|	GTE
		{
			$$ = _GreatrEqual;
		}
	|	NOTEQ
		{
			$$ = _NotEqual;
		}
;

likeop:		LIKE
		{
			$$ = _Like;
		}
	|	NOTLIKE
		{
			$$ = _NotLike;
		}
;

/* Note:  Only OSL/SQL should recognize the ESCAPE keyword (and hence,
** the escape production.)  OSL/QUEL should not support the ESCAPE
** clause for the LIKE operators.
*/
escape:		ESCAPE SCONST
		{
			$$ = osmkconst(tkSCONST, $2);
		}
	|	ESCAPE XCONST
		{
			$$ = osmkconst(tkXCONST, $2);
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;


/*
** Name:	qualification -	OSL QUALIFICATION Predicate Production.
**
** Syntax:
**	QUALIFICATION '(' ID '.' ID '=' [ ':' ] ID[.ID] [ ',' ... ] ')'
**
** History:
**	07/90 (jhw) -- Check that only visible fields are specified. Bug #30784.
**	12/90 (Mike S) -- Allow qualification in tablefields
**	08/15/91 (emerson)
**		Put out a more informative message if the QUALIFICATION function
**		is used in a repeated query.  Also make it just a warning
**		(and mark the query non-repeatable).
*/
qualification:	qual_key '(' qual_list ')'
		{
			u_ptr[0].u_nodep = $3;
			$$ = osmknode(NPRED, &u_ptr[0], (U_ARG*)NULL, (U_ARG*)NULL);
		}
;
qual_key:	QUALIFICATION
		{
			if ( RepeatState )
			{
				oswarn( E_OS015B_QualRepeat, 0 );
				RepeatState = FALSE;
			}
		}
;
qual_list:	qual_list ',' qual_ele
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	qual_ele
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
qual_ele:	ID '.' ID '=' qual_ref
		{
			u_ptr[0].u_cp = $1;
			u_ptr[1].u_cp = $3;
			u_ptr[2].u_symp = $5;
			$$ = osmknode(PREDE, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	ID '=' qual_ref
		{
			register OSSYM	*sym;

			if (QUEL)
				oscerr(OSQUALID, 0);
			u_ptr[0].u_cp = $1;
			u_ptr[1].u_cp = NULL;
			u_ptr[2].u_symp = $3;
			$$ = osmknode(PREDE, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
qual_ref:	id_or_colid
		{
			register OSSYM  *sym;

			/* Get the symbol table entry, if possible */
			sym = osfld(FormSym, $1, OSRHSUNDEF);
			if ( sym->s_kind == OSVAR )
				oscerr(OSHIDPRED, 1, $1);
			else if ( sym->s_kind != OSFIELD )
				oscerr(OSBADQUAL, 1, $1);
			$$ = sym;
		}
	|	id_or_colid '.' ID
		{
			register OSSYM  *sym;

			/* 
			** ostab will issue an error message if this isn't a
			** valid tablefield/column pair.
			*/
			sym = ostab(FormSym, $1, $3);
			if ( sym->s_kind == OSHIDCOL)
				oscerr(OSHIDCOLPRED, 2, $1, $3);
			$$ = sym;
		}
;

id_or_colid :	ID
		{
			$$ = $1;
		}

	|	COLID
		{
			$$ = $1;
		}
;

/**-
** OSL References.
**
** Includes:
**	OSLvar		OSLvalue		OSLname
*/
/*
** Name:	OSLvar -	OSL Name as Reference in an Assignment.
**
** Description:
**	A reference to an OSL field object (hidden or table field column) that
**	is unambiguously an OSL object reference not dereferenced by ":" in an
**	assignment statement.
**	This is an LHS of an assignment.
*/

OSLvar:		var_nocolon
		{ /* Note:  FORM was allowed */
			OSSYM	*idsym;

			IGstartStmt(osscnlno(), IL_LB_NONE);
			idsym = osqryobjchk(FormSym, $1);
			if ( idsym != NULL )
			{
				FormObj = idsym;
				if ( FormObj != FormSym
					       && FormObj->s_kind != OSTABLE )
					QryTarget = $1;
				$$ = iiosRefGen($1, TRUE /* assign */);
			}
			else
			{
				$$ = os_lhs($1);
				FormObj = osnodesym($$);
			}
		}
;
param_lhs:	ID
		{
			u_ptr[0].u_cp = $1;
			u_ptr[1].u_cp = NULL;
			$$ = osmknode(ATTR, &u_ptr[0], &u_ptr[1], (U_ARG*)NULL);
			FormObj = NULL;
		}
	|	ID '.' ID
		{
			u_ptr[0].u_cp = $1;
			u_ptr[1].u_cp = $3;
			$$ = osmknode(ATTR, &u_ptr[0], &u_ptr[1], (U_ARG*)NULL);
			FormObj = NULL;
		}
;

/*
** Name:	OSLname_all
*/

OSLname_all:	var_nocolon '.' ALL
		{ /* Note:  FORM was allowed */
			$$ = osall(FormSym, $1);
		}
;

assign_op:	COLEQ
	|	'='
;

/*
** Name:	OSLname -	OSL Name as Reference.
**
** Description:
**	A reference to an OSL field object (hidden or table field column) that
**	is unambiguously an OSL object reference not dereferenced by ":".
**	This is an LHS.
*/
OSLname:	{AllowForm = FALSE;} var_nocolon
		{
			$$ = os_lhs($2);
		}
;
/*
** Name:	OSLvalue -	OSL Name as Value.
**
** Description:
**	A reference to an OSL field object (hidden or table field column) value
**	with optional dereferencing by `:'.  Generates code to access the value
**	on the form (i.e., transfer from), if necessary.  This is a value
**	reference, i.e., this is not a reference to assign to the data (not a
**	LHS.)
**
** History:
**	02/25/91 (emerson)
**		Fix for bug 36084: When a form contained a field with the same
**		name, an error was reported.  Instead, the field should be used.
**		Note on the fix:  I wanted to stick {AllowForm = FALSE;}
**		in front of var_nocolon, as is done in the productions for
**		table_name and OSLname, but that causes shift/reduce conflicts.
**		So instead, if the production for var_nocolon sets
**		FormSpecified = TRUE, I undo what var_nocolon did (by freeing
**		the node it created for FormSym), and do what it would have
**		done if AllowForm had been FALSE.
**	02-aug-1991 (davel)
**		Added production OSLnocol_var for parallelism, and to make 
**		it easier to catch illegal table field references used with 
**		or without colons as the fix for bug 35665.  
**	08/26/91 (emerson)
**		Fix a serious problem in the fix (08/02/91) that DaveL and I
**		came up with for bug 35665: Segmentation Violation in the
**		compiler if a r.h.s. contained a record.attribute (or an
**		array[row].attribute).  The problem was that the references
**		to $1->n_sym in OSLcol_var and OSLnocol_var were invalid
**		in the case where $1 wasn't a VALUE or ATTR node.  Fix:
**		Don't check for $1->n_sym->s_kind == OSTABLE unless
**		$1->n_token == VALUE.
**	30-dec-1991 (davel)
**		Fix bugs 37388 and 41635 - change var_colon production
**		to always use FormSym in the osdotnode() call (in the case
**		of var_colon '.' ID).  The problem is that FormObj was
**		being passed if in a query, and FormObj is null if in a 
**		callframe statement.  FormSym seems correct in all instances,
**		including the one described in bug 41635.
**	09/20/92 (emerson)
**		Revamp "var_colon: COLID" rule to fix bugs 38299, 44004, 44056,
**		and 46646.  There used to be a bunch of logic that attempted
**		to handle references to ":y" in "x = SELECT :y = DMLexpr FROM t"
**		or in "x = SELECT DMLexpr AS :y FROM t":  In some cases,
**		y was being interpreted as a child of x rather than as a child
**		of the current form or procedure (i.e. as a field or variable).
**		But such references were never documented as legal syntax,
**		and the logic was incomplete and caused problems when a COLID
**		appeared in a DMLexpr in a SELECT target list.  So the
**		"var_colon: COLID" rule now *always* treats y as a child of
**		the current form or procedure.  The "target_name: var_colon"
**		rule in sql.sy will now flag an error if "x = SELECT :y =
**		DMLexpr FROM t" or "x = SELECT DMLexpr AS :y FROM t" is coded,
**		unless x is the name of the form or procedure being compiled.
*/
OSLvalue:	OSLnocol_var
		{
			$$ = $1;
		}
	| 	OSLcol_var
		{
			$$ = $1;
		}
;

/**-
** Unambiguous OSL Variable References.
**
** Description:
**	These productions give an unambiguous reference to an OSL variable
**	that can never be taken for anything else (as "ID" can in different
**	contexts; for example, see <ingres_name>.)  This is achieved by
**	dereferencing the identifier with a `:' at the lexical level and
**	recognizing the resultant token here.
*/

/*
** OSLcol_var.
** first element is always a COLID.
** This is not an LHS.
*/
OSLcol_var:	var_colon
		{
			if (  $1->n_token == VALUE
			   && $1->n_sym->s_kind == OSTABLE )
			{  /* table field illegal in this context */
				oscerr (E_OS0268_BadTblFld, 1, 
					$1->n_sym->s_name);
			}
			$$ = osval($1);
		}
;
OSLnocol_var:	var_nocolon
		{
			if ( FormSpecified )
			{
				ostrfree($1);
				$1 = osvalnode(FormSym, FormSym->s_name);
				FormSpecified = FALSE;
			}
			if (  $1->n_token == VALUE
			   && $1->n_sym->s_kind == OSTABLE )
			{  /* table field illegal in this context */
				oscerr (E_OS0268_BadTblFld, 1, 
			   		$1->n_sym->s_name);
			}
			$$ = osval($1);
		}
;

/*
** utility rules
*/

var_nocolon:	ID
		{
			if ( !AllowForm || STbcompare( FormSym->s_name, 0,
							$1, 0, TRUE) != 0 )
			{ /* form not allowed or not the form */
				$$ = osvalnode(FormSym, $1);
				AllowForm = TRUE;
				FormSpecified = FALSE;
			}
			else
			{ /* special case:  form name */
				u_ptr[0].u_symp = FormSym;
				$$ = osmknode( VALUE, &u_ptr[0],
						(U_ARG *)NULL, (U_ARG *)NULL
				);
				$$->n_flags |= N_READONLY;
				FormSpecified = TRUE;
			}
		}
	|	var_nocolon '.' ID
		{
			if ( $1->n_token != VALUE || $1->n_sym != FormSym )
			{
				if ( FormSpecified )
				{
					oscerr(E_OS025A_BadFormRef, 0);
					FormSpecified = FALSE;
				}
				$$ = osdotnode(FormSym, $1, $3);
			}
			else
			{ /* <form> . ID */
				OSSYM	*sym;

				if ( (sym = ossympeek($3, FormSym))
							!= NULL
						&& sym->s_kind == OSTABLE )
				{ /* <form> . <tblfld> */
					ostrfree($1);
					$$ = osvalnode(FormSym, $3);
				}
				else if ( (sym =
					ossympeek(FormSym->s_name, FormSym))
							!= NULL
						&& sym->s_kind == OSTABLE )
				{ /* <tblfld> . <col> */
					ostrfree($1);
					$$ = osdotnode(FormSym,
							osvalnode(FormSym,
								FormSym->s_name
							), $3
					);
					FormSpecified = FALSE;
				}
				else
				{
					oscerr( OSNOTBLFLD,
							2, $3, $1->n_sym->s_name
					);
					ostrfree($1);
					$$ = osvalnode(FormSym, $3);
				}
			}
		}
	|	var_nocolon row_number
		{
			if ( $1->n_token == VALUE && $1->n_sym == FormSym )
			{ /* cannot be form */
				ostrfree($1);
				$1 = osvalnode(FormSym, FormSym->s_name);
				FormSpecified = FALSE;
			}
			$$ = osarraynode($1, $2, FALSE);
		}
;
var_colon:	COLID
		{
			$$ = osvalnode(FormSym, $1);
		}
	|	var_colon '.' ID
		{
			$$ = osdotnode(FormSym, $1, $3);
		}
	|	var_colon row_number
		{
			$$ = osarraynode($1, $2, TRUE);
		}
;

/**-
** OSL Ingres References.
**
** Includes:
**	id_or_sconst	ingres_name	ingres_qname
**	ing_name_list	column_list	col_name_list
**	ingres_int	ing_int_list	ingres_ref
**	qual_table_ref	owner_id	disallow_repeat
*/

/*
** Name:	id_or_sconst -	An Ingres Constant.
**
** Description:
**	A constant name valid in an Ingres DB or Forms statement context within
**	OSL.  This is interpreted as a literal name of the DB or Forms System
**	object.	 It is either an identifier or a quoted string.
*/
id_or_sconst:	ID
		{
			$$ = $1;
		}
	|	SCONST
		{
			$$ = $1;
		}
;

/*
** Name:	ingres_name -	An INGRES (4GL) Name.
**
** Description:
**	A name valid in an DML, DDL, or Forms statement context within an OSL
**	frame or procedure.  This is either the literal name of the DB or Forms
**	System object, or is an unambiguous OSL (string) variable reference.  In
**	particular, both "ID" and "SCONST" are taken to be a literal identifier
**	(string) that is the name of the object.
*/
ingres_name: 	id_or_sconst
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;	/* special case */
		}
	|	OSLcol_var disallow_repeat
		{
			if (!oschkstr($1->n_type))
				oscerr(OSNOTSTR, 1, ERget(_FrsName));
			else if ( AFE_NULLABLE_MACRO($1->n_type) )
				oswarn(OSNULVCHK, 0);
			$$ = $1;
		}
;

/*
** Name:	ingres_qname -	A Qualified INGRES (4GL) Name.
**
** Description:
**	A qualified name valid in an DML, DDL, or Forms statement context within
**	an OSL frame or procedure.  This is either the literal or qualified 
**	(quoted) name of the DB or Forms System object, or is an unambiguous OSL
**	(string) variable reference.  Unlike <ingres_name> qualified names must
**	include the quotes with which they were specified, and any variable
**	references must also be quoted to guarantee that they are qualified.
*/
ingres_qname:	ID
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	SCONST
		{
			$$ = osmkconst(tkSCONST, $1);
		}
	|	OSLcol_var disallow_repeat
		{
			if ($1 == NULL || !oschkstr($1->n_type))
				oscerr(OSNOTSTR, 1, ERget(_FrsName));
			else if ( AFE_NULLABLE_MACRO($1->n_type) )
				oswarn(OSNULVCHK, 0);
			$$ = $1;
		}
;

/*
** Name:	ing_name_list -	A List of Ingres Names.
**
** Description:
**	A comma separated list of Ingres names.
*/
ing_name_list:	ing_name_list ',' ingres_name
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	ingres_name
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;

/*
** Name:	column_list -	Parenthesized Column Name List.
*/
column_list:	ingres_name
		{
			$$ = $1;
		}
	|	column_list ',' ingres_name
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = $3;
			$$ = osmknode(COMMA, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
		}
;
col_name_list:	'(' column_list ')'
		{
			u_ptr[0].u_nodep = $2;
			$$ = osmknode(PARENS, (U_ARG*)NULL, &u_ptr[0], (U_ARG*)NULL);
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*
** Name:	ingres_int -	An Ingres Integer.
**
** Description:
**	An integer valid in an Ingres DB or Forms statement context within an
**	OSL frame or procedure.	 This is either an integer constant or is an
**	unambiguous OSL (integer) variable reference.
**
**	(General OSL variable references of the form "ID ..." could be accepted
**	here, but for consistency, and since in certain cases both integers and
**	name references can be accepted, dereferencing is required here as well)
**
** History:
**	12/14/91 (emerson)
**		When building a parse tree node for '-' ICONST, don't
**		make it point to a string in an automatic variable (buf);
**		instead, call iiIG_string to make a permanent copy of the
**		string in the string table.  (Fix for bug 40908).
*/
ingres_int:	uconstant_int
		{
			$$ = $1;
		}
	|	OSLcol_var disallow_repeat
		{
			if ($1 == NULL || !ADE_CHK_TYPE($1->n_type, DB_INT_TYPE))
				oscerr(OSNOTINT, 0);
			else if ( AFE_NULLABLE_MACRO($1->n_type) )
				oswarn(OSNULVCHK, 0);
			$$ = $1;
		}
;

/*
** Name:	ing_int_list -	A List of Ingres Integers.
**
** Description:
**	A comma separated list of Ingres integers.
*/
ing_int_list:	ing_int_list ',' ingres_int
		{
			u_ptr[0].u_nodep = $3;
			u_ptr[1].u_nodep = $1;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
	|	ingres_int
		{
			u_ptr[0].u_nodep = $1;
			u_ptr[1].u_nodep = NULL;
			u_ptr[2].u_nodep = NULL;
			$$ = osmknode(NLIST, &u_ptr[0], &u_ptr[1], &u_ptr[2]);
		}
;
ingres_str:	constant_str
		{
			$$ = $1;
		}
	|	OSLcol_var disallow_repeat
		{
			if ( !oschkstr($1->n_type) )
				oscerr(OSNOTSTR, 0);
			else if ( AFE_NULLABLE_MACRO($1->n_type) )
				oswarn(OSNULVCHK, 0);
			$$ = $1;
		}
;

opt_ingres_str:	ingres_str
		{
			$$ = $1;
		}
	|	/* empty */
		{
			$$ = NULL;
		}
;

/*
** Name:	ingres_ref -	An Ingres Reference.
**
** Description:
**	Either an Ingres name or an Ingres integer.  Note that only string
**	or integer types are allowed.
**
** History:
**	12/14/91 (emerson)
**		When building a parse tree node for '-' ICONST, don't
**		make it point to a string in an automatic variable (buf);
**		instead, call iiIG_string to make a permanent copy of the
**		string in the string table.  (Fix for bug 40908).
*/
ingres_ref:	id_or_sconst
		{
			$$ = osmkident($1, (OSNODE *)NULL);
			$$->n_type = DB_CHA_TYPE;	/* special case */
		}
	|	OSLcol_var disallow_repeat
		{
			if ( !ADE_CHK_TYPE($1->n_type, DB_INT_TYPE) &&
					!oschkstr($1->n_type) )
				oscerr(OSNOTREF, 0);
			else if ( AFE_NULLABLE_MACRO($1->n_type) )
				oswarn(OSNULVCHK, 0);
			$$ = $1;
		}
	|	uconstant_int
		{
			$$ = $1;
		}
;

qual_table_ref:
    	ingres_name
        {
    	    $$ = $1;
        }
    |	owner_id '.' ID   	/* Owner . Table/View */
        {
            u_ptr[0].u_nodep = $1;
    	    u_ptr[0].u_nodep->n_type = DB_CHA_TYPE; /* see ingres_name def. */
            u_ptr[1].u_nodep = osmkident($3, (OSNODE *)NULL);
    	    u_ptr[1].u_nodep->n_type = DB_CHA_TYPE;  /* see ingres_name def. */
            $$ = osmknode(DOT|DML, (U_ARG*)NULL, &u_ptr[0], &u_ptr[1]);
        }
;

owner_id:	ID
        	{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	OWNER_INGRES
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
	|	SESSION
		{
			$$ = osmkident($1, (OSNODE *)NULL);
		}
;
qual_id:
    	ingres_name
        {
    	    $$ = $1;
        }
    |	owner_str '.' ID   	/* Owner.object - as an Identifier, not a DOT */
        {
	    char    buf[OSBUFSIZE];

	    _VOID_ STprintf(buf, ERx("%s.%s"), $1, $3);
	    $$ = osmkident( iiIG_string(buf), (OSNODE *)NULL);
	    $$->n_type = DB_CHA_TYPE;		/* special case */
        }
;

owner_str:	ID
        	{
			$$ = $1;
		}
	|	OWNER_INGRES
		{
			$$ = $1;
		}
;
/*
** Name:	disallow_repeat -	Invalid variable ref in a REPEAT query
**
** Description:
**	This empty production is used to flag invalid variable references
**	in REPEAT queries.  It typically follows a reference to OSLcol_var.
**	If disallow_repeat occurs (directly or indirectly) within a REPEAT
**	query, the query will be made non-repeatable.  (A warning will be
**	issued).
**
**	Disallow_repeat is appropriate for such things as entire WHERE
**	clauses or names of DBMS objects such as tables and columns.
**	(These would all cause unpredictable results in a REPEAT query:
**	if the contents of the variable change and the query is re-executed,
**	the change may or may not take effect, depending on whether the
**	query plan happens to get rebuilt).
**
**	Disallow_repeat is used after OSLcol_var in the ingres_name and
**	ingres_ref productions, because they represent INGRES names, and
**	names of DBMS objects such as tables and columns are all INGRES names.
**	Note that the ingres_name and ingres_ref productions are *not*
**	used in portions of repeatable queries where variable references
**	*are* allowed (e.g. DMLprimary in DMLexpr).  [When ingres_name and
**	ingres_ref are used outside a query, or in a query that can't be
**	made repeatable, the disallow_repeat production has no effect, because
**	RepeatState is always FALSE outside of potentially repeatable queries.]
**
**	I've also used disallow_repeat in the ingres_qname and ingres_int
**	productions, even though they don't seem to be currently used
**	in repeatable queries.  They're similar to ingres_name and ingres_ref,
**	and if they ever *are* used in repeatable queries, they too should,
**	if specified as a variable reference, cause the query to be made
**	non-repeatable.
**
**	Note that global constants are currently treated like true variables;
**	that is, a global constant in a forbidden context will make the query
**	non-repeatable.  This is because global string constants can come
**	in different flavors for different languages, which could cause
**	trouble with shared query plans in a multilingual installation.
**	A possible future enhancement would be to mark such a query as
**	"repeatable, but language-dependent".  At execution time, the ABF
**	runtime system would, for such a query, take the constant query ID
**	generated at compile time and add some sort of language code to it
**	before shipping it to the DBMS.
**
** History:
**	08/15/91 (emerson)
**		Created (for bug 35468).
*/
disallow_repeat: /* empty */
		{
			if ( RepeatState )
			{
				oswarn( E_OS015A_BadRepeat, 0 );
				RepeatState = FALSE;
			}
		}
;

/*
** opt_not - simply return indication of whether present.
*/
opt_not:	NOT
		{
			$$ = 1;
		}
	|	/* empty */
		{
			$$ = 0;
		}
;
/*
** ip_postfix_op - previously nullop
**
** This section of the grammer parses out the postfix IS operators
** which include the IS NULL and IS OF ( datatype ) forms.
**
** This rule returns the actual ADF POSTFIX operator name that will
** later be looked up for the ADF operator routine.
*/
is_postfix_op:	IS opt_not NULLK
		{
			$$ = ($2 == 0) ? _IsNull : _IsNotNull;
		}
	|
		IS opt_not ID
		{
		    if ( SQL )
		    {
			if (osw_compare(ERx("integer"), $3))
				$$ = ($2 == 0) ? _IsInteger : _IsNotInteger;
			else if (osw_compare(ERx("decimal"), $3))
				$$ = ($2 == 0) ? _IsDecimal : _IsNotDecimal;
			else if (osw_compare(ERx("float"), $3))
				$$ = ($2 == 0) ? _IsFloat : _IsNotFloat;
			else
				yyerror(ERx("IS datatype error"));
		    }
		    else
			yyerror(ERx("IS datatype error"));
		}
	|
		IS opt_not OF db_lparen ID db_rparen
		{
		    if ( SQL )
		    {
			if (osw_compare(ERx("integer"), $5))
				$$ = ($2 == 0) ? _IsInteger : _IsNotInteger;
			else if (osw_compare(ERx("decimal"), $5))
				$$ = ($2 == 0) ? _IsDecimal : _IsNotDecimal;
			else if (osw_compare(ERx("float"), $5))
				$$ = ($2 == 0) ? _IsFloat : _IsNotFloat;
			else
				yyerror(ERx("IS datatype error"));
		    }
		    else
			yyerror(ERx("IS datatype error"));
		}
;
%%

/* %L Routines */
/* %L Routines begin */

/*
** Name:	insert_all() -	Check INSERT Name List of Unexpanded "*".
**
** Description:
**	Searches through the column name list (which is a tree of COMMA nodes)
**	of an INSERT statement looking for any unexpanded "*" nodes (which
**	should have been a VALUES clause list with a ".all" object in it
**	corresponding to the "*" node rather than a sub-query object.)
**
** Input:
**	list	{OSNODE *}  Column name list for INSERT.
**
** Returns:
**	{bool}	TRUE if unexpanded "*" node found.
**		FALSE if none found.
**
** History:
**	06/87 (jhw) -- Written.
*/
static bool
insert_all (list)
register OSNODE *list;
{
	if (list->n_token == COMMA)
		return (bool)(insert_all(list->n_left) && insert_all(list->n_right));
	else
		return (bool)(list->n_token != tkID || *list->n_value != '*');
}

/*
** Name:	insert_column() -	Search for Column Name Element at Depth.
**
** Description:
**	Traverses the column name list (which is a tree of COMMA nodes) of an
**	INSERT statement for the column name element at the input depth.  This
**	is used to return the column name element corresponding to an element in
**	the VALUES clause list of the INSERT (by order.)  (The first element is
**	at the maximum depth for the tree; the last is at depth 1.)
**
** Input:
**	list	{OSNODE *}  Column name list for INSERT.
**	depth	{nat}  Depth of desired column element.
**
** Returns:
**	{OSNODE *}  The column name element at 'depth' in the list.
**
** History:
**	06/87 (jhw) -- Written.
*/
static OSNODE *
insert_column (list, depth)
register OSNODE *list;
register i4	depth;
{
	if (depth == 1)
		return list->n_token == COMMA ? list->n_right : list;
	else
		return insert_column(list->n_left, --depth);
}

/*
** Name:	expand_insert() -	Expand the ".all" Object in an Insert.
**
** Description:
**	This routine expands the (NLIST) value list for a ".all" object found in**	a VALUE clause of an INSERT statement into a (COMMA) name list and value
**	list.  The name list replaces the corresponding "*" constant node in the
**	column list (by reference.)  The original (NLIST) value list is freed,
**	(but its elements were transfered to the (COMMA) value list.)  The new
**	value list is returned.
**
** Input:
**	list	{OSNODE *}  A NLIST of the values for a ".all" in an INSERT.
**
** Output:
**	node	{OSNODE *}  The "*" constant node from the INSERT column list.
**				Replaced by the expanded name list.
**
** Returns:
**	{OSNODE *}  A COMMA list of the values.
**
** History:
**	06/87 (jhw) -- Written.
**	31-aug-1993 (mgw)
**		Fixed casting of MEcopy() args for prototyping.
*/
static OSNODE *
expand_insert (list, node)
OSNODE	*list;
OSNODE	*node;
{
	register OSNODE	*lp;
	U_ARG		nlst;
	U_ARG		vlst;

	if (list == NULL)
		return NULL;

	for (lp = list ; lp != NULL ; lp = lp->n_next)
	{
		register OSNODE *ele = lp->n_ele;
		U_ARG	name;
		U_ARG	value;

		name.u_nodep = osmkident(ele->n_tfref == NULL
						? ele->n_sym->s_name
						: ele->n_tfref->s_name,
					(OSNODE *)NULL
			);
		value.u_nodep = ele;
		nlst.u_nodep = (list == lp) ? name.u_nodep
					: osmknode(COMMA, (U_ARG*)NULL, &nlst, &name);
		vlst.u_nodep = (list == lp) ? value.u_nodep
					: osmknode(COMMA, (U_ARG*)NULL, &vlst, &value);
		lp->n_ele = NULL;	/* re-used above, save by NULLing */
	}
	/* Free (NLIST) value list */
	ostrfree(list);	/* elements save above */

	/* Copy (COMMA) name list into node */
	MEcopy((PTR)nlst.u_nodep, (u_i2)sizeof(*node), (PTR)node);
	nlst.u_nodep->n_left = nlst.u_nodep->n_right = NULL;
	ostrfree(nlst.u_nodep);

	/* Return new (COMMA) value list */
	return vlst.u_nodep;
}

/*
** Name:	open_targ_IL() -	Open IL fragment for SELECT target
**
** Description:
**	If we're in the target list of a SELECT statement (before any UNION),
**	this routine will open a fragment of IL which will represent either
**	the lhs or the rhs of a SELECT target item (we don't know which yet).
**
**	We also begin a new temp block, which will be merged into an enclosing
**	temp block by the matching close_lhs_targ_IL or close_rhs_targ_IL.
**
** History:
**	09/20/92 (emerson)
**		Written (for bug 34846).
*/
static VOID
open_targ_IL()
{
	if (QryState)
	{
		ostmpbeg();
		iiIGofOpenFragment();
	}
}

/*
** Name:	close_lhs_targ_IL() -	Close IL fragment for SELECT target lhs
**
** Description:
**	If we're in the target list of a SELECT statement (before any UNION),
**	this routine will close a fragment of IL which represents the lhs
**	of a SELECT target item and include it in TargListFrag (the fragment
**	of IL that will compute all lhs's of the current target list).
**
**	We also merge the temp block that we began when opened the IL fragment
**	into the enclosing (parent) temp block, which represents the lhs's
**	of target items.
**
**	Before doing the above merge, we "freeze" all temporaries that were
**	freed by nested temp blocks.  This prevents subsequent rhs IL from
**	reusing any of these temps.  (That could cause problems when we're
**	allocating a temp in outermost temp block associated with the SELECT,
**	because the lhs IL may get executed after the rhs IL even when it was
**	generated before).
**
** History:
**	09/20/92 (emerson)
**		Written (for bug 34846).
*/
static VOID
close_lhs_targ_IL()
{
	PTR	targ_item_frag;

	if (QryState)
	{
		ostmpfreeze();
		ostmppromote(1);
		targ_item_frag = iiIGcfCloseFragment();
		iiIGrfReopenFragment(TargListFrag);
		iiIGifIncludeFragment(targ_item_frag);
		TargListFrag = iiIGcfCloseFragment();
	}
}

/*
** Name:	close_rhs_targ_IL() -	Close IL fragment for SELECT target rhs
**
** Description:
**	If we're in the target list of a SELECT statement (before any UNION),
**	this routine will close a fragment of IL which represents the rhs
**	of a SELECT target item and include it in the "default" fragment.
**
**	We also merge the temp block that we began when opened the IL fragment
**	into the "grandparent" temp block (the 2nd-levl enclosing temp block).
**	This "grandparent" temp block represents the rhs's of target items,
**	plus temporaries that span the entire SELECT.
**
** History:
**	09/20/92 (emerson)
**		Written (for bug 34846).
*/
static VOID
close_rhs_targ_IL()
{
	PTR	targ_item_frag;

	if (QryState)
	{
		ostmppromote(2);
		targ_item_frag = iiIGcfCloseFragment();
		iiIGifIncludeFragment(targ_item_frag);
	}
}

/*
** Name:	connect_clauses() -	Emit IL_TL2ELMs for connect clause
**
** Description:	Traverse a tree of COMMA and TLASSIGN nodes, emitting
**		the IL_TL2ELM statements for the connect clauses in a
**		CONNECT or DISCONNECT statement.
**
** Input:
**	list	{OSNODE *}  A COMMA list or single TLASSIGN node.
**
** Output:
**	NONE.
**
** Returns:
**	NONE.
**
** History:
**	09/92 (davel) -- Written.
*/
static void
connect_clauses (list)
OSNODE	*list;
{
	switch (list->n_token)
	{
		case COMMA:
			connect_clauses(list->n_left);
			connect_clauses(list->n_right);
			ostrfree(list);
			break;

		case TLASSIGN:
			ostl2elm(list);
			/* ostl2elm() does its own ostrfree() */
			break;
		default:
			osuerr(OSBUG, 1, ERx("connect_clauses(default)"));
	}
}

/* %L Routines end */

static
clrfld (expr)
OSNODE	*expr;
{
	IGgenStmt(IL_CLRFLD, (IGSID *)NULL, 1, osvalref(expr));
}

static
resumecolumn (table, column)
char	*table;
OSNODE	*column;
{
	if (column->n_token == tkID || column->n_token == tkSCONST)
	{
		char *p = (column->n_token == tkID ? column->n_value : column->n_const);

		oscolcheck(FormSym, table, p);
		IGgenStmt(IL_RESCOL, (IGSID *)NULL,
			2, IGsetConst(DB_CHA_TYPE, table),
				IGsetConst(DB_CHA_TYPE, p)
		);
		ostrfree(column);
	}
	else
	{
		IGgenStmt(IL_RESCOL, (IGSID *)NULL,
			2, IGsetConst(DB_CHA_TYPE, table), osvalref(column)
		);
	}
}

osevallist (list, func)
OSNODE		*list;
register i4	(*func)();
{
	register OSNODE	*lp;

	for (lp = list ; lp != NULL ; lp = lp->n_next)
	{
		if (lp->n_ele != NULL)
		{
			(*func)(lp->n_ele, (lp->n_next != NULL));
			lp->n_ele = NULL;	/* freed by "(*func)()" */
		}
	}

	if (list != NULL)
		ostrfree(list);
}

ostl1elm (elp)
register OSNODE *elp;
{
	IGgenStmt(IL_TL1ELM, (IGSID *)NULL, 1, osvalref(elp));
	ostrfree(elp);
}

ostl2elm (elp)
register OSNODE *elp;
{
	if (elp->n_token == tkASSIGN)
		IGgenStmt(IL_TL2ELM, (IGSID *)NULL,
			2, elp->n_lhs->s_ilref, osvalref(elp->n_rhs)
			);
	else if (elp->n_token == TLASSIGN)
		IGgenStmt(IL_TL2ELM, (IGSID *)NULL, 2, elp->n_coln, elp->n_tlexpr);
	ostrfree(elp);
}

operr ()
{
	if (!OpErr)
	{
		oscerr(QloopState ? OSEERROP : OSEINVOP, 0);
		if (QloopState)
			OpErr = TRUE;
	}
}

static
scroll ( form, table, row )
register OSNODE	*form;
register OSNODE	*table;
OSNODE		*row;
{
	if ( table->n_token == tkID && ( form == NULL ||
			(form->n_token == tkID &&
			STbcompare( FormSym->s_name, 0, form->n_value, 0,
						TRUE) == 0 ) ) )
		_VOID_ ostblcheck( FormSym, table->n_value );

	IGgenStmt( IL_SCROLL, (IGSID *)NULL,
			3, form == NULL ? 0 : osvalref( form ),
				osvalref( table ), osvalref( row )
	);
}

/* History:
**	02/90 (jhw) -- Moved out of 'IGoutput()' in "ilg!igoutput.c" where
**		bobm had put it; now ILG does not have any dependencies on OSL.
*/
static
os_output ()
{
	i4		iflags;
	char		lbuf[MAX_LOC+1];
	LOCATION	loc;
	LOINFORMATION	inf;

	/*
	** Get date on source file for 'IIAMwcWrtCommit()'.  If we can't, simply
	** pass in epoch date so that IL will just get stamped with "now" (file
	** assumed very old.)
	*/
	iflags = LO_I_LAST;
	if ( osIfile == stdin || STlcopy(osIfilname, lbuf, sizeof(lbuf)) == 0
		|| LOfroms(PATH&FILENAME, lbuf, &loc) != OK
			|| LOinfo(&loc, &iflags, &inf) != OK
				|| !(iflags & LO_I_LAST) )
	{
		inf.li_last.TM_secs = 0;
	}

	IGoutput(osFid, (osDebugIL ? osOfile : NULL), &inf.li_last, &osIGframe);
}

/*
** Name:        is_state -       Test for symbol _STATE
**
** Description:
**      This returns TRUE if the passed in string is _STATE
**      (case insensitive). Otherwise it will return FALSE.
**
*/

is_state(char *name)
{
   char buf[50];

   STcopy(name,buf);
   CVlower(buf);

   if  (STcompare(buf,"_state") == 0)
       return TRUE;
   else
       return FALSE;
}

