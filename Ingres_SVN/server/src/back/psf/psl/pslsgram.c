#define	YYFUNCTIONS
#define	YY_1HANDLER	psls_1handle
#define	YY_2HANDLER	psls_2handle
#define	YYREENTER
#define	YYPRINTF	TRdisplay

/* # line 7 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
#include    <compat.h>
#ifdef i64_aix
#define MAX 403
#define MIN 405
#endif
#include    <gl.h>
#include    <cs.h>
#include    <me.h>
#include    <bt.h>
#include    <ci.h>
#include    <cv.h>
#include    <mh.h>
#include    <qu.h>
#include    <st.h>
#include    <tr.h>
#include    <tm.h>
#include    <tmtz.h>
#include    <cm.h>
#include    <er.h>
#include    <pc.h>
#include    <iicommon.h>
#include    <dbdbms.h>
#include    <gca.h>
#include    <ddb.h>
#include    <dmf.h>
#include    <dmacb.h>
#include    <dmccb.h>
#include    <dmtcb.h>
#include    <dmrcb.h>
#include    <dmucb.h>
#include    <adf.h>
#include    <ade.h>
#include    <adfops.h>
#include    <adudate.h>
#include    <ulf.h>
#include    <ulm.h>
#include    <qsf.h>
#include    <qefrcb.h>
#include    <rdf.h>
#include    <sxf.h>
#include    <copy.h>
#include    <qefmain.h>
#include    <qefqeu.h>
#include    <qeuqcb.h>
#include    <qefcopy.h>
#include    <qefcb.h>
#include    <qefnode.h>
#include    <psfparse.h>
#include    <qefact.h>
#include    <qefqp.h>
#include    <opfcb.h>
#include    <scf.h>
#include    <ex.h>
#include    <psfindep.h>
#include    <pshparse.h>
#include    "pslsgram.h"
#include    "pslscan.h"
#include    <yacc.h>
#include    <usererror.h>
#include    <dudbms.h>
#include    <psftrmwh.h>
#include    <psqcvtdw.h>
#include    <psqmonth.h>
#include    <psttprpnd.h>
#include    <psyaudit.h>
#include    <uld.h>
#include    <cui.h>

/* Mark that we want the static array in this function */
#define GM_WANT_ARRAY
#include    <gwf.h>

/*
** NO_OPTIM = rs4_us5 dgi_us5 int_lnx int_rpl ibm_lnx usl_us5 i64_aix
*/

#define YYDEBUG 1
#define YACC_VARS 1
#define	MAX_GW_REG_CHARS 2
#define DROP_BASETABLE	1
#define DROP_VIEW	2
#define DROP_INDEX	3
#define DROP_LINK	9
#define REMOVE_OBJ	10
#define REMOVE_TBL	11
#define REMOVE_VIEW	12
#define REMOVE_INDEX	13
#define REMOVE_PROCEDURE	14

#ifndef ADFI_845_STDDEV_SAMP_FLT
/* Primary definition in adf/hdr/adffiids.h */
# define ADFI_845_STDDEV_SAMP_FLT 845
#endif

/*
** used to distinguish AVG, MIN, MAX, SUM when they are reduced to
** avg_min_max_sum
*/
#define	    AGGR_AVG	0
#define	    AGGR_MIN	1
#define	    AGGR_MAX	2
#define	    AGGR_SUM	3

static char	*aggr_func_names[] = {"avg", "min", "max", "sum"};

/* define the component fields of a year to month or day to second interval */
#define INT_YEAR	1
#define	INT_MONTH	2
#define INT_DAY		3
#define	INT_HOUR	4
#define	INT_MINUTE	5
#define	INT_SECOND	6

static char	interval_filler[] = {'0', '-', '0', '0', ' ', '0',
				':', '0', ':', '0'};  /* 0-00 0:0:0 */

static char	*extract_fields[] = {"year", "month", "day", "hour", 
		"minute", "second", "microsecond", "nanosecond",
		"timezone_hour", "timezone_minute"};
#define	EXTRACT_FIELDS_COUNT 10

/*
** Array to reverse comparison ops for backwards subsel compare.
** Note that this is straight reversal, not inversion (NOT compop)!
*/
static ADI_OP_ID revops[] = {ADI_NE_OP, -1, -1, -1, -1, -1, ADI_GT_OP, 
		ADI_GE_OP, ADI_EQ_OP, ADI_LT_OP, ADI_LE_OP};

/*
** List of valid collation names (and count thereof).
** NOTE: this list must be consistent with the set of #define's of
** collation codes in iicommon.h.
*/
#define	VALID_COLLATION_COUNT	6
static char	*collname_array[] = {"unicode", "unicode_case_insensitive", 
	"sql_character", "multi", "spanish", "unicode_french"};
static char	*type_array[] = {"NCHAR, NVARCHAR", "CHAR, VARCHAR, C, TXT"};

/*
** the following constants are used to distinguish between ANY, ALL, and SOME
** in predicates involving comparisons with subselect
*/
#define	    ANY_SUBSEL		1
#define	    ALL_SUBSEL		2
#define     SOME_SUBSEL		3

/*
** values that can be returned by drop_behaviour production
*/
#define	    CASCADING_DESTRUCTION	1
#define	    RESTRICTED_DESTRUCTION	2

/*
** the following macro is an optimization for the check for
** reserved identifiers;  by using this macro, we only call the
** psl_reserved_ident function if the identifier actually begins
** with a '$'
*/
#define	    PSL_IS_RESERVED_IDENT(name, sess_cb, psq_cb, force_check)	\
		((CMcmpcase(name, ERx("$")) == 0) 			\
		 && psl_reserved_ident(name, sess_cb, psq_cb, force_check))

/* There are a few places (ok, at least 1) where a keyword is treated
** like an identifier, by simply returning the appropriate string.
** If the ID is an object name, like a column name, it has to obey the
** case rules in effect.  It's tedious to write the necessary if or ?:
** expression over and over, define a macro:
*/
#define	    REG_ID_CASE_STRING(sess_cb,lcstring,ucstring) \
		((*sess_cb->pss_dbxlate & CUI_ID_REG_U) ? lcstring : ucstring)


/* # line 3171 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
/*[@forward_type_references@]*/

/*
**  Forward and/or External function references.
*/

GLOBALREF PSF_SERVBLK *Psf_srvblk;
FUNC_EXTERN DB_STATUS	gwf_call();
FUNC_EXTERN DB_STATUS	rdf_call();
FUNC_EXTERN DB_STATUS	qsf_call();

static DB_STATUS
chkcnst(
	PST_QNODE *tp);
static bool
psl_valid_session_schema_use(
	i4		qmode,
	PSS_SESBLK	*sess_cb,
	char		*obj_name,
	DB_ERROR	*err_blk);
static DB_STATUS
psl_tbl_ref(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*sess_cb,
	PSS_COL_REF	*col_ref,
	i4		in_target_clause,
	i4		cur_scope,
	PSS_TBL_REF	**tbl_refs,
	PSS_RNGTAB	**rngtab);
static DB_STATUS
psl_reg_struct(
	i4     *pst_struct,
	DMU_CB      *dmu_cb,
	char        *ssname,
	i4         dmu_c_flag,
	DB_ERROR    *err_blk);
static DB_STATUS
psl_usr_func(
	     char	    *fname,
	     PSS_SESBLK	    *sess_cb,
	     bool	    in_join_cond,
	     PSS_JOIN_INFO  *join_info,
	     PST_QNODE	    **newnode,
	     DB_ERROR	    *err_blk);
static DB_STATUS
psl_vrule_tree_convert(
	    PST_QNODE	*rootnode,
	    PST_QNODE	*vtree,
	    PSS_SESBLK	*sess_cb,
	    DB_ERROR	*err_blk);
static DB_STATUS
psl_set_function(
	    PSS_SESBLK	*sess_cb,
	    PSQ_CB	*psq_cb,
	    PSS_YYVARS	*yyvarsp,
	    char	*func_name,
	    i4		distinct,
	    i4		count_or_any,
	    PST_QNODE	*expr1_node,
	    PST_QNODE	*expr2_node,
	    PST_QNODE	**aghdnodep);
static bool
psl_validate_collation_name(
	char	*collname,
	i4	*collID);
static bool
psl_validate_collation_mix(
	i2	collID1,
	i2	collID2);
static DB_STATUS
psl_vrule_subtree(
	    PSS_SESBLK	*sess_cb,
	    PST_QNODE	**subtree,
	    PST_QNODE	*vtree,
	    PSS_DUPRB	*dup_rb);
static void
psl_bld_tid_descr(
	    DMT_ATT_ENTRY	*attribute,
	    PSS_SESBLK		*cb);
static i4
psl_reserved_ident(
	char		*name,
	PSS_SESBLK	*sess_cb,
	PSQ_CB		*psq_cb,
	i4		force_check);
static DB_STATUS
psl_simple_compare(
	PSS_SESBLK	*sess_cb,
	PST_QNODE	*operand1,
	PST_QNODE	*operand2,
	ADI_OP_ID	operator,
	i4		is_escape,
	char		escape_char,
	PSS_TREEINFO	**treeinfo,
	bool		in_join_search,
	bool		in_target_clause,
	PSS_JOIN_INFO	*join_info,
	PSQ_CB		*psq_cb);


static DB_STATUS
psl_subsel_compare(
	PSS_SESBLK	*sess_cb,
	PST_QNODE	*expr,
	PST_QNODE	*subsel,
	ADI_OP_ID	operator,
	i4		meta_op,
	PSS_TREEINFO	**treeinfo,
	bool		in_join_search,
	PSS_JOIN_INFO	*join_info,
	bool		subsel_illegal,
	i4		err_msgno,
	PSQ_CB		*psq_cb);
static DB_STATUS
psl_1ary_func_extra_proc(
	    PSS_SESBLK	    *sess_cb,
	    i4		    op_id,
	    PST_QNODE	    *arg1,
	    PST_QNODE	    **prec_scale,
	    DB_ERROR	    *err_blk);
static DB_STATUS
psl_2ary_func_extra_proc(
	    PSS_SESBLK	    *sess_cb,
	    i4		    op_id,
	    PST_QNODE	    *arg1,
	    PST_QNODE	    *arg2,
	    DB_ERROR	    *err_blk);
static DB_STATUS
psl_3ary_func_extra_proc(
	    i4		    op_id,
	    PST_QNODE	    *arg2,
	    PST_QNODE	    *arg3,
	    DB_ERROR	    *err_blk);

static DB_STATUS psl_arg_room(
	PSS_SESBLK *cb,
	PSQ_CB *psq_cb,
	PSS_YYVARS *yyvarsp,
	i4 n);

static DB_STATUS psl_nary_func(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PSS_YYVARS	*yyvarsp,
	ADI_OPINFO	*func,
	PST_QNODE	**result_ptr);

static DB_STATUS
psl_mfunc_param(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	PST_QNODE	*argument,
	PST_QNODE	**result);

static DB_STATUS
psl_bld_col_spec_grant_template(
	PTR		txt_chain,
	char		*priv_str,
	bool		cols_excluded,
	PSF_QUEUE	*colq,
	DB_ERROR	*err_blk);
static DB_STATUS
psl_add_grantee(
	PSS_SESBLK	*sess_cb,
	char		*grantee_name,
	PSS_ID_TYPE	grantee_type,
	DB_ERROR	*err_blk);
static DB_STATUS
psl_remove_single_quotes(
	char		*text_chain,
	char		*identifier,
	DB_ERROR	*err_blk);
static DB_STATUS
psl_prepend_schemaname(
	char		*text_chain,
	char		*obj_name,
	u_char		*schema_name,
	DB_ERROR	*err_blk);
static bool
psl_seqop_search(
	PST_QNODE	*nodep);
static DB_STATUS
psl_push_yyvars(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*sess_cb,
	PSS_YYVARS	**yyvpp);
static bool
psl_aop_nooj(
	PST_QNODE	*nodep,
	PSS_YYVARS	*yyvarsp);
static bool 
psl_agginExpr(
	PST_QNODE	*nodep);
static DB_STATUS
psl_groupingsets_fromcr(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	i4		crtype,
	PST_QNODE	*listp,
	PST_QNODE	**newnodep);
static DB_STATUS
psl_groupingsets_normalize(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**rootp);
static DB_STATUS
psl_groupingsets_expand(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**rootp,
	bool		*alldonep);
static DB_STATUS
psl_groupingsets_tidy(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*nodep,
	i4		*rsdmnop);
static DB_STATUS
psl_ansi_strtodt(
        PSS_SESBLK      *cb,
        PSQ_CB          *psq_cb,
	DB_DT_ID	ansitype,
	i4		intparts,
        DB_TEXT_STRING	*instr,
        PST_QNODE       **newnode,
	DB_DATA_VALUE	*dataval,
	i2		secfrac);
/*[@function_reference@]...*/

/*
**  Defines of other constants.
*/

/* define flags known to psl_fatt() */	    
					  /* only try to find attribute */
#define			FIND_ONLY	(i4) 0x01
/* if attr was found, and FIND_ONLY is not set, allocate space for a VAR node */
#define			ALLOC_NODE	(i4) 0x02
/*
** when processing a join_search qualification, we only want to consider
** relations involved in the join
*/
#define			JOINREL_MASK 	(i4) 0x04

/*
** used to distinguish between select * and select " ".
** Intended to add a flag member to the PST_VAR_NODE, but
** doing so would require change of the RDF tree version
** number and possibly upgradedb (VAR nodes are 
** part of the RDF query trees). 
*/ 
#define			PST_STAR_SEEN	-1

/*[@group_of_defined_constants@]...*/
/*[@type_definitions@]*/
/*[@global_variable_definitions@]*/
/*[@static_variable_or_function_definitions@]*/

/* # line 3440 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
#define yyclearin pslschar = -1
#define yyerrok pslserrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
typedef i4  yytabelem;
# define YYERRCODE 256

/* # line 44669 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */



/*{
** Name: chkcnst: - Checks whether an expression is equivalent to a constant.
**
** Description:
**      For some SQL statements list elements can be entered as expressions
**	of constants (including scalar functions).
**	This routine checks the subtree to ensure that the represented
**	expression can be considered a constant.
**
** Inputs:
**      Pointer to the root of the subtree.
**
** Outputs:
**	Returns:
**	    Status.
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	11-feb-87 (stec)
*/
static DB_STATUS
chkcnst(
	PST_QNODE *tp)
{
    DB_STATUS	    status;

    if (tp != (PST_QNODE *) NULL)
    {
	/* check left child */
	status = chkcnst(tp->pst_left);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* check right child */
	status = chkcnst(tp->pst_right);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* check self */
	if (tp->pst_sym.pst_type == PST_VAR)
        {
	    return (E_DB_ERROR);
	}
    }

    return (E_DB_OK);
}

/*
** PSL_FATT - find attribute in range table.
** If (fatt_flag & FIND_ONLY)
** {
**     try to find attribute.
**     if not found, just return
**     do not report errors through psf_error
** else
** {
**     if (fatt_flag & ALLOC_NODE)
**     {
**         allocate VAR node
**     }
**     fill in the node
**     do report errors.
** }
**
** History:
**	    unknown (someone)
**		written
**	    24-jul-89 (andre)
**		modified to pass a flag rather than a bool, so that more info
**		can be passed.  Also, remove the line that would set *node to
**		NULL, since sometimes this may result in a perfectly legitimate
**		node being wiped out, and there is no reason at all to do it.
**	    21-sep-89 (andre)
**		For some cases we only want to look for attributes in a subset
**		of relations.  If so, *rel_mask will contain mask of acceptable
**		relations.
**	    07-may-93 (andre)
**		produce a separate "column not found" message if processing a
**		CHECK constraint.
**	26-nov-02 (inkdo01)
**	    Range table expansion (i4 becomes PST_J_MASK).
*/
DB_STATUS
psl_fatt(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	i4		same_scope,
	DB_ATT_NAME 	*att_name,
	PST_QNODE	**node,
	PSS_RNGTAB	**rngvarp,
	i4 		fatt_flag,
	PST_J_MASK	*rel_mask)
{
    DMT_ATT_ENTRY	*attribute;
    DMT_ATT_ENTRY	*t_attribute;
    PST_VAR_NODE	varnode;
    i4		err_code;
    DB_STATUS	        status;
    PSS_RNGTAB		*t_rngvar;
    PSS_RNGTAB		*rngvar;
    i4		        att_c_match_count = 0;
    i4			att_l_match_level = 0;
    i4			i;

    /* for each variable, look up the column name */
    for (i = 0; i < PST_NUMVARS; i++)
    {
	t_rngvar = &cb->pss_auxrng.pss_rngtab[i];
	/* only examine if used */
	if (!t_rngvar->pss_used || t_rngvar->pss_rgno < 0)
	    continue;
	/*
	** If use of mask is specified, only examine the relation if a bit
	** corresponding to it is set in rel_mask
	*/
	if (fatt_flag & JOINREL_MASK    &&
	    !BTtest((i4) t_rngvar->pss_rgno, (char *) rel_mask))
	{
	    continue;
	}
	/* if processing target list, must be at our scope */
	if (same_scope && t_rngvar->pss_rgparent != cb->pss_qualdepth)
	    continue;
	/* In general must be at our scope or greater */
	if (t_rngvar->pss_rgparent > cb->pss_qualdepth)
	    continue;
	/* Look up the attribute */
	t_attribute = pst_coldesc(t_rngvar, att_name);

	/* If attribute found, remember it, the range var, and the scope */
	if (t_attribute != (DMT_ATT_ENTRY *) NULL)
	{
	    /* if first one, remember it */
	    if (att_c_match_count == 0)
	    {
		att_c_match_count++;
		att_l_match_level = t_rngvar->pss_rgparent;
		attribute   = t_attribute;
		rngvar	    = t_rngvar;
		continue;
	    }
	    /* if at higher scope than than current, ignore */
	    if (t_rngvar->pss_rgparent < att_l_match_level)
		continue;
	    /* if at lower scope, use the lower scope */
	    if (t_rngvar->pss_rgparent > att_l_match_level)
	    {
		att_c_match_count = 1;
		att_l_match_level = t_rngvar->pss_rgparent;
		attribute   = t_attribute;
		rngvar	    = t_rngvar;
		continue;
	    }		
	    /* we must be at same level.
	    ** This is a problem only if the range definition differs from
	    ** our current one.
	    */
	    if (MEcmp(rngvar->pss_rgname, t_rngvar->pss_rgname, DB_MAXNAME) ||
		MEcmp(rngvar->pss_tabname.db_tab_name, 
		      t_rngvar->pss_tabname.db_tab_name, DB_MAXNAME))
	    {
		att_c_match_count++;
	    }
	}
    }

    /* Check for attribute not found */
    if (att_c_match_count == 0)
    {
	if (~fatt_flag & FIND_ONLY)
	{
	    if (fatt_flag & JOINREL_MASK)
	    {
		/*
		** we ARE processing join_search condition and the user tried
		** to refer to a column not found in left or right relations
		*/
		(VOID) psf_error(E_PS03A3_COL_NOT_IN_JREL, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, att_name->db_att_name),
		    att_name->db_att_name);
		return(E_DB_ERROR);
	    }
	    else if (cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
	    {
		char        command[PSL_MAX_COMM_STRING];
		i4     length;

		psl_command_string(psq_cb->psq_mode, DB_SQL, command, &length);

		_VOID_ psf_error(E_PS0483_CONS_NO_COL, 0L,
		    PSF_USERERR, &err_code, &psq_cb->psq_error, 3,
		    length, command,
		    psf_trmwhite(DB_MAXNAME, att_name->db_att_name),
		    att_name->db_att_name,
		    sizeof(ERx("CHECK")) - 1, ERx("CHECK"));
	    }
	    else
	    {
		(VOID) psf_error(2102L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
		    &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, att_name->db_att_name),
		    att_name->db_att_name);
	    }
	}
	return (E_DB_ERROR);
    }

    /* Check for too many attributes - ambiguous attribute */
    if (att_c_match_count > 1)
    {
	if (~fatt_flag & FIND_ONLY)
	{
	    (VOID) psf_error(2101L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, att_name->db_att_name),
		att_name->db_att_name);
	}
	return (E_DB_ERROR);
    }
	    
    /*
    ** Search was successful, we found exactly one var. with this
    ** attribute name for this scope.
    */
    *rngvarp = rngvar;

    if (~fatt_flag & FIND_ONLY)
    {
	/* Set up var node for copy into tree */
	varnode.pst_vno = rngvar->pss_rgno;
	varnode.pst_atno.db_att_id = attribute->att_number;
	STRUCT_ASSIGN_MACRO(*att_name, varnode.pst_atname);

	/* Create the node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode, sizeof(varnode),
	    (DB_DT_ID) attribute->att_type, (i2) attribute->att_prec,
	    (i4) attribute->att_width, (DB_ANYTYPE *) NULL, node,
	    &psq_cb->psq_error,
	    (fatt_flag & ALLOC_NODE) ? (i4) 0 : PSS_NOALLOC);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	(*node)->pst_sym.pst_dataval.db_collID = attribute->att_collID;
    }

    return (E_DB_OK);
}

/*
** psl_subsel	-- verify that the subselect node is legal
**
**  Description:
**	Verify that this is a legal subselect (only one select element).
**	Also, set the data type and length to that of the underlying
**	resdom.
**
**  History
**	27-feb-87 (daved)
**	    written
*/
DB_STATUS
psl_subsel(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*subnode)
{
    DB_DATA_VALUE	*d1;
    DB_DATA_VALUE	*d2;
    i4		err_code;

    /* perform check */
    if (subnode->pst_left && subnode->pst_left->pst_left &&
          subnode->pst_left->pst_left->pst_sym.pst_type != PST_TREE)
    {
	(VOID) psf_error(2916L, 0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
	    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	return (E_DB_ERROR);
    }
    d1 = &subnode->pst_sym.pst_dataval;
    d2 = &subnode->pst_left->pst_sym.pst_dataval;
    STRUCT_ASSIGN_MACRO(*d2, *d1);

    cb->pss_stmt_flags |= PSS_SUBINTREE; /* pss_subintree = TRUE */
    
    return (E_DB_OK);
}

/*
** PSL_ORDGROUP - processes group list element consisting of constant value
**	(which must be ordinal select list expression number). Verifies
**	existence of "nth" select list entry and copies to group list in
**	place of constant node.
*/
DB_STATUS psl_ordGroup(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*gptr,
	PST_QNODE	*tlist)

{
    i4		targnum;
    PST_QNODE	*cptr = gptr->pst_right;
    PST_QNODE	*tptr;
    PSS_DUPRB	dup_rb;
    DB_STATUS	status;
    bool	found = FALSE;

    if (cptr->pst_sym.pst_dataval.db_datatype == DB_INT_TYPE &&
	cptr->pst_sym.pst_dataval.db_data != NULL)
    switch (cptr->pst_sym.pst_dataval.db_length) {
      case 1:
	targnum = *((i1 *)cptr->pst_sym.pst_dataval.db_data);
	break;

      case 2:
	targnum = *((i2 *)cptr->pst_sym.pst_dataval.db_data);
	break;

      case 4:
	targnum = *((i4 *)cptr->pst_sym.pst_dataval.db_data);
	break;
    }
    else return(E_DB_ERROR);

    /* Got the ordinal number. Now search the target list for it. */
    for (tptr = tlist; tptr && tptr->pst_sym.pst_type == PST_RESDOM;
					tptr = tptr->pst_left)
     if (tptr->pst_sym.pst_value.pst_s_rsdm.pst_rsno == targnum) 
     {
	found = TRUE;
	break;
     }

    if (!found) return(E_DB_ERROR);

    /* If there's an agg in the expression, treat it just like a 
    ** constant - in the manner of the big O. We simply leave the original
    ** ordinal constant in the group by list and it will effectively
    ** do nothing. */
    if (psl_agginExpr(tptr->pst_right))
	return(E_DB_OK);

    if (tptr->pst_right->pst_sym.pst_type == PST_AGHEAD)
    {
       /* b109012, the group by expression contains an aggregate */
       psq_cb->psq_error.err_code = E_PS03AB_AGGR_IN_GROUP_BY;
       return (E_DB_ERROR);
    }

    if (tptr->pst_right->pst_sym.pst_type == PST_CONST)
    {
	/*
        ** If it's a constant just ignore it. This is an
        ** improvement since constants have no effect on
        ** group_by ordering - the same results are returned
        ** whether the constant is specified in the group_by
        ** or not. Additionally this removes a number of
        ** bugs with VLUPS & aggregates (b114883 & b112053).
        */
        return (E_DB_OK);

    }

    /* Found the expression - now copy it to replace original constant in
    ** group list. */

    dup_rb.pss_op_mask = 0;
    dup_rb.pss_num_joins = PST_NOJOIN;
    dup_rb.pss_tree_info = (i4 *) NULL;
    dup_rb.pss_mstream = &cb->pss_ostream;
    dup_rb.pss_err_blk = &psq_cb->psq_error;
    dup_rb.pss_tree = tptr->pst_right;
    dup_rb.pss_dup = &gptr->pst_right;

    status = pst_treedup(cb, &dup_rb);

    STRUCT_ASSIGN_MACRO(tptr->pst_sym.pst_dataval, gptr->pst_sym.pst_dataval);
					/* copy dataval to group list */
    return(status);
}

/* PSL_AGGINEXPR - returns TRUE if a PST_AGHEAD is found in the given
**	expression parse tree.
**	13-Feb-2008 (kiria01) b119908
**	    Eliminated Klocwork 4534 and tail recursion.
*/
static bool psl_agginExpr(PST_QNODE	*nodep)
{
    while (nodep)
    {
	switch(nodep->pst_sym.pst_type)
	{
	case PST_AGHEAD:
	case PST_AOP:
	    return(TRUE);
	}
	if (nodep->pst_left && psl_agginExpr(nodep->pst_left))
	    return(TRUE);
    	nodep = nodep->pst_right;
    }
    return(FALSE);
}

/*
** PSL_TINGX - returns DBSTATUS E_DB_OK if target list expression matches some 
**	entry in group list. Expressions must match in every way, except that
**	constants may not have to be equal. An enhancement to make Ingres behave
**	like DB/2 would be to allow the select list entry to include the group by
**	expression in some other constant-based expression, but with no other 
**	columns. E.g. select a+b -25 ... group by a+b ...
*/
DB_STATUS psl_tingx(PST_QNODE	*targ,
	PST_QNODE		*groupex,
	bool			top)

{
    bool	started_here = top;	/* TRUE - if current group expression
					** examination started at this recursion
					** level */
    DB_STATUS	status;


    /* The function simply compares the target expression and group list 
    ** expression, node by node. If a mismatch is found, we return to the 
    ** start point of the current examination (where started_here is TRUE).
    ** This will be the top of the target expression, and from there, we restart
    ** the examination one level down (one nesting level deeper) in the group 
    ** expression. */

    if (targ == NULL && groupex == NULL) return(E_DB_OK);
					/* at bottom, and all matched */
    if (targ && targ->pst_sym.pst_type == PST_CONST) return(E_DB_OK);
					/* constants are ok */
    if (targ == NULL || groupex == NULL ||
	targ->pst_sym.pst_type != groupex->pst_sym.pst_type) return(E_DB_ERROR);
					/* simple rejection tests */

    /* Non-null nodes and they're the same type. Now do type-specific checks. */

    switch (targ->pst_sym.pst_type) {
      case PST_BOP:
      case PST_UOP:
      case PST_AND:
      case PST_OR:
	if (targ->pst_sym.pst_value.pst_s_op.pst_opno !=
		groupex->pst_sym.pst_value.pst_s_op.pst_opno) return(E_DB_ERROR);
      case PST_CASEOP:
      case PST_MOP:
      case PST_OPERAND:
      case PST_WHLIST:
      case PST_WHOP:
	/* Check target/group expression recursively. */
	status = psl_tingx(targ->pst_left, groupex->pst_left, FALSE);
	if (status == E_DB_OK) status = psl_tingx(targ->pst_right, 
						groupex->pst_right, FALSE);
	break;

      case PST_VAR:
	if (targ->pst_sym.pst_value.pst_s_var.pst_vno ==
		groupex->pst_sym.pst_value.pst_s_var.pst_vno &&
	    targ->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id ==
		groupex->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
	 status = E_DB_OK;
	else status = E_DB_ERROR;
	break;

      case PST_CONST:
	status = E_DB_OK;
	break;

      default:
	status = E_DB_ERROR;
	break;
    }	/* end of node type switch */

    /* Ok so far. Just return computed status. */

    return(status);

}	/* end of psl_tingx */

/*
** PSL_TING  - boolean returning OK if target list exists in group by list
*/
DB_STATUS
psl_ting(
	PST_QNODE	*targ,
	PST_QNODE	*group)
{
    DB_STATUS		    status = E_DB_OK;
    register PST_QNODE	    *ptr;

    if (targ == (PST_QNODE*) NULL || targ->pst_sym.pst_type == PST_AGHEAD)
	status = E_DB_OK;
    /* check var nodes */
    else if (targ->pst_sym.pst_type == PST_VAR)
    {
	status = E_DB_ERROR;
	for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM &&
		status == E_DB_ERROR; ptr = ptr->pst_left)
	{
	    if (ptr->pst_right->pst_sym.pst_type == PST_VAR &&
		targ->pst_sym.pst_value.pst_s_var.pst_vno ==
		ptr->pst_right->pst_sym.pst_value.pst_s_var.pst_vno 
		&&
		targ->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id ==
		ptr->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id
	    )
		status = E_DB_OK;
	}
    }
    else if (targ->pst_left || targ->pst_right)
    {
	/* for each target list element, ensure that it is in group list. If
	** target element is NOT a simple column reference, make a quick pass
	** through the group list looking for a group expression. They require
	** trickier validation than column reference group elements. */
	if (targ->pst_sym.pst_type != PST_RESDOM)
					/* !RESDOM, !VAR - must be expression */
	{
	    for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM;
						ptr = ptr->pst_left)
	     if (ptr->pst_right->pst_sym.pst_type != PST_VAR &&
		psl_tingx(targ, ptr->pst_right, TRUE) == E_DB_OK) return(E_DB_OK);

	    /* If we get here, there was no match for the target entry amongst the
	    ** group by list. Last chance is to check if it is a "constant" 
	    ** expression (constants and aggregates). */
	    return(psl_constx(targ, group));
	}
	
	/* Target node is RESDOM, so we're still going down the list. Recurse on
	** next RESDOM, then recurse on actual target expression. */
	status = psl_ting(targ->pst_left, group);
	if (status == E_DB_OK)
	    status = psl_ting(targ->pst_right, group);
    }
    return (status);
}

/*
** psl_constx()	- search expression for constants and aggregates ONLY. 
**
** Description: Given expression doesn't match anything in group by list. Last
**		chance is to assure that it is an expression involving only
**		constants and aggregates.
**
** Input:
**		expr - PST_QNODE ptr to subtree being checked.
**		group - root of RESDOMs of group by list
**
** Output:
**	None
**
** Returns:
**	status of search (E_DB_OK means expression is ok)
**
** History:
**	28-oct-99 (inkdo01)
**	    Written.
*/

DB_STATUS
psl_constx(
	PST_QNODE	*expr,
	PST_QNODE	*group)

{
    PST_QNODE	*varp, *ptr;
    DB_STATUS	status = E_DB_OK;

    /* Recursively descend the parse tree, looking for operators, constants 
    ** or PST_AGHEADs. Anything else is illegal. */

    switch (expr->pst_sym.pst_type) {

      case PST_AGHEAD:
      case PST_CONST:
	return(E_DB_OK);
      case PST_VAR:
	/* If a column is in the expression, it better also be in the 
	** group by list. */
	status = E_DB_ERROR;
	for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM;
		ptr = ptr->pst_left)
	 if ((varp = ptr->pst_right)->pst_sym.pst_type == PST_VAR &&
		expr->pst_sym.pst_value.pst_s_var.pst_vno ==
		 varp->pst_sym.pst_value.pst_s_var.pst_vno &&
		expr->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id ==
		 varp->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
	 {
	    status = E_DB_OK;
	    break;
	 }
	return(status);
      default:
	if (expr->pst_left) status = psl_constx(expr->pst_left, group);
	if (status != E_DB_OK) return(status);
	if (expr->pst_right) return(psl_constx(expr->pst_right, group));
	return(E_DB_OK);
    }

}

/*
** psl_find_node()  - find a node of specified type in a tree.
**
** Description: Given a pointer to a tree, find a node of specified type.
**		Once the first node has been located, search will be terminated.
** Input:
**	node	- root of a tree
**	type    - node type
**
** Output:
**	None
**
** Returns:
**	pointer to a node of a specified type if one was found; NULL otherwise
**
** History:
**	05-16-90 (andre)
**	    written
*/
PST_QNODE *
psl_find_node(
	PST_QNODE   *node,
	i4	    type)
{
    PST_QNODE	*p;

    if (node == (PST_QNODE *) NULL || node->pst_sym.pst_type == type)
    {
	p = node;
    }
    else if ((p = psl_find_node(node->pst_left, type)) == (PST_QNODE *) NULL)
    {
	p = psl_find_node(node->pst_right, type);
    }

    return(p);
}

/* PSL_HCHECK - make sure that vars in having include atts in the group
**	by or in different scope. Ignore subselects and aggregates.
*/
DB_STATUS
psl_hcheck(
	PSS_SESBLK	*cb,
	PST_QNODE	*having,
	PST_QNODE	*group,
	PST_J_MASK	*fromlist)
{
    register PST_QNODE	    *ptr;
    ADI_OPINFO	            opinfo;
    ADF_CB		    *adf_scb = (ADF_CB*) cb->pss_adfcb;
    DB_STATUS		    status = E_DB_OK;
    bool		    leftdone = FALSE, rightdone = FALSE;

    if (having == (PST_QNODE*) NULL)
	return (status);
    /* step over aggregates and subselects, they are checked elsewhere */
    if (having->pst_sym.pst_type == PST_AGHEAD ||
	having->pst_sym.pst_type == PST_SUBSEL)
	return (status);

    /* Next, check for comparison predicates involving atomic columns (i.e.,
    ** NOT column expressions). */

    if ((having->pst_sym.pst_type == PST_BOP ||
	having->pst_sym.pst_type == PST_UOP))
    {
	status = adi_op_info(adf_scb, having->pst_sym.pst_value.pst_s_op.pst_opno, &opinfo);
	if (status != E_DB_OK)
	    return(status);
	if (opinfo.adi_optype == ADI_COMPARISON)
	{
	    /* Got a comparison (not AND, OR, NOT), check for VAR on either side. */
	    if (having->pst_left->pst_sym.pst_type == PST_VAR)
	    {
		status = psl_hcheckvar(having->pst_left, group, fromlist);
		if (status != E_DB_OK) return(status);
		leftdone = TRUE;
	    }
	    else if (having->pst_left->pst_sym.pst_type == PST_CONST) leftdone = TRUE;
	    if (having->pst_right && having->pst_right->pst_sym.pst_type == PST_VAR)
	    {
		status = psl_hcheckvar(having->pst_right, group, fromlist);
		if (status != E_DB_OK) return(status);
		rightdone = TRUE;
	    }
	    if (having->pst_right && having->pst_right->pst_sym.pst_type == PST_CONST)
		rightdone = TRUE;
	}
    }

    /* Switch the having node type to perform the various checks. */
    switch (having->pst_sym.pst_type) {

      case PST_AND:
      case PST_OR:
	if (status = psl_hcheck(cb, having->pst_right, group, fromlist))
		return(status);
      case PST_NOT:
	return(psl_hcheck(cb, having->pst_left, group, fromlist));
      case PST_BOP:
	/* To get here, this must be a binary or unary comparison. Call
	** psl_tingx with right and/or left subtree to find matching expressions 
	** in the group list. */
	if (!rightdone)
	{
	    for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM;
						ptr = ptr->pst_left)
	     if (ptr->pst_right->pst_sym.pst_type != PST_VAR &&
		(status = psl_tingx(having->pst_right, ptr->pst_right, TRUE)) 
			== E_DB_OK) break;	/* got a match */

	    /* Last chance is to check for aggregate/constant expression. */
	    if (status != E_DB_OK) return(psl_constx(having->pst_right, group));
	}
      case PST_UOP:
	if (!leftdone) 
	{
	    for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM;
						ptr = ptr->pst_left)
	     if (ptr->pst_right->pst_sym.pst_type != PST_VAR &&
		(status = psl_tingx(having->pst_left, ptr->pst_right, TRUE)) 
			== E_DB_OK) break;	/* got a match */
	}
	/* Last chance is to check for aggregate/constant expression. */
	if (status != E_DB_OK) status = psl_constx(having->pst_left, group);
	return(status);
    }

    return(E_DB_ERROR);		/* we shouldn't really get to here */
}


/* PSL_HCHECKVAR - for "having" comparisons involving only VARs, verify the
**	VAR here. Expressions are handled in psl_hcheck.
*/
DB_STATUS
psl_hcheckvar(
	PST_QNODE	*having,
	PST_QNODE	*group,
	PST_J_MASK	*fromlist)
{
    DB_STATUS		    status = E_DB_OK;
    register PST_QNODE	    *ptr;

    /* check var nodes */
    if (having->pst_sym.pst_type == PST_VAR)
    {
	status = E_DB_ERROR;
	for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM &&
		status == E_DB_ERROR; ptr = ptr->pst_left)
	{
	    if (ptr->pst_right->pst_sym.pst_type == PST_VAR &&
		having->pst_sym.pst_value.pst_s_var.pst_vno ==
		ptr->pst_right->pst_sym.pst_value.pst_s_var.pst_vno 
	        &&
		having->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id ==
		ptr->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id
	    )
		status = E_DB_OK;
	}
	/* if attribute is not in group by list, check for correlated */
	/* if not in our from list, assume it is correlated */
	if (status != E_DB_OK)
	    if (BTtest(having->pst_sym.pst_value.pst_s_var.pst_vno, 
		       (char *) fromlist)
		 == 0)
		status = E_DB_OK;
    }
    return (status);
}

/*
** This routine processes subtrees hanging off of resdom nodes of the
** tree generated for positioned update. It searches recursively for
** PST_VAR nodes and converts them into PST_CURVAL nodes. Conversion
** must not be done in place, because of different node size. New nodes
** have to be allocated.
**
**  28-jul-1987 (stec)
**	written.
**  04-may-88 (stec)
**	Allocate new nodes instead of converting in place.
**  15-feb-88 (stec)
**	Change error handling.
**  02-apr-93 (andre)
**	(fix for bug 42691)
**	psl_curval() gets called in the course of processing UPDATE CURSOR to
**	replace VAR nodes found in the subtree rooted in RESDOM with CURVAL
**	nodes.  Obviously, there is no requirement that only nodes which
**	appeared in FOR UPDATE clause may be used on the RHS of assignment
**	in UPDATE CURSOR.  Consequently, it is a very bad idea to call
**	psq_ccol().  Instead, we shall quietly create a CURVAL node using the
**	attribute number found in the VAR node.
**	
**	And the other reason why it is a lousy idea is that psy_qrymod() may now
**	actually do something to the query tree before psl_curval gets called
**	which means that if the cursor was defined on a view, then names of
**	attributes found in the tree will be those of attributes of the view's
**	underlying base table and not of the view (which means that even if you
**	find a matching name, the chances that the attribute number is correct
**	may be rather remote.)
*/
DB_STATUS
psl_curval(
	PSS_SESBLK  *cb,
	PSQ_CB	    *psq_cb,
	PSC_CURBLK  *cursor,
	PST_QNODE   **tree)
{
    DB_STATUS		    status;
    PST_CRVAL_NODE	    curval;
    PST_QNODE		    *node;

    node = *tree;
    if (node->pst_left != (PST_QNODE *) NULL)
    {
	status = psl_curval(cb, psq_cb, cursor, &node->pst_left);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
    if (node->pst_right != (PST_QNODE *) NULL)
    {
	status = psl_curval(cb, psq_cb, cursor, &node->pst_right);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }

    if (node->pst_sym.pst_type == PST_VAR)
    {
	DB_DATA_VALUE	    *dataval = &node->pst_sym.pst_dataval;
	
	STRUCT_ASSIGN_MACRO(cursor->psc_blkid, curval.pst_cursor);
	curval.pst_curcol.db_att_id =
	    node->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CURVAL, (char *) &curval,
	    sizeof(curval), dataval->db_datatype, dataval->db_prec,
	    dataval->db_length, (DB_ANYTYPE *) NULL, tree, &psq_cb->psq_error,
	    (i4) 0);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
    }

    return (E_DB_OK);
}

/*
**  psl_shareable    -	determines Query Plan shareability based on ownership
**			of tables/views used in an SQL repeat query. It is
**			required that all object be DBA owned or be catalogs.
**			(29-jan-91 andre) this function may also be called to
**			help determine shareability of QUEL repeat queries.
**
**  25-jan-1988 (stec)
**	Written.
**  19-oct-88 (stec)
**	Change criteria for shareable QPs (include catalogs).
**  12-dec-89 (andre)
**	As a result of the changes introduced by the FIPS project, queries will
**	be considered shareable if all objects are owned by the DBA, are
**	catalogs, OR are explicitly qualified.
**  29-jan-91 (andre)
**	Add support for trace point ps132.
**  15-jun-92 (barbara)
**	Sybil merge: Star comments
**	13-mar-92 (barbara)
**	    To fix bug 42625 (Star shared query plans even after distributed
**	    table had been reregistered), save away table ids of a given
**	    shareable repeat query by calling psl_rptqry_tblids().  Added
**	    new parameters psq_cb and qry_info.
**  30-nov-92 (teresa)
**      fixed uninitialized variable first_ldb_desc.
**  11-oct-93 (swm)
**	Bug #56448
**	Made psf_display() portable. The old psf_display() took a variable
**	number of variable-sized arguments. It could not be re-written as
**	a varargs function as this practice is outlawed in main line code.
**	The problem was solved by invoking a varargs function, TRformat,
**	directly.
**	The psf_display() function has now been deleted, but for flexibilty
**	psf_display has been #defined to TRformat to accomodate future
**	change.
**	All calls to psf_display() changed to pass additional arguments
**	required by TRformat:
**	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1, ...)
**	this emulates the behaviour of the old psf_display() except that
**	the trbuf must be supplied.
*/
DB_STATUS
psl_shareable(
	PSQ_CB	   		*psq_cb,
	PSS_SESBLK 		*cb,
	bool	    		*shareable,
	DB_SHR_RPTQRY_INFO	**qry_info)
{
    PSS_USRRANGE	*rngtab = (cb->pss_lang == DB_SQL) ? &cb->pss_auxrng
							   : &cb->pss_usrrange;
    register PSS_RNGTAB *rngvar, *lim;
    bool		ps132;
    DD_2LDB_TAB_INFO	*ldb_tab_info;
    DD_LDB_DESC		*first_ldb_desc = NULL;
    DD_LDB_DESC		*ldb_desc;
    char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

    /* determine if trace point PS132 has been set */
    {
	i4		val1=0, val2=0;

	ps132 = ult_check_macro(&cb->pss_trace, 4, &val1, &val2);
    }

    /* Assume the query is shareable. */
    *shareable = TRUE;

    /* scan all variables in the range table */
    for (rngvar = rngtab->pss_rngtab, lim = rngtab->pss_rngtab + PST_NUMVARS;
	 rngvar < lim;
	 rngvar++
	)
    {
	/* skip empty entries in the range table */
	if (!rngvar->pss_used || rngvar->pss_rgno == -1)
	    continue;

	/* validate non-empty entry */
	if (~rngvar->pss_var_mask & PSS_EXPLICIT_QUAL
	    &&
	    MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_dba,
	    sizeof(DB_TAB_OWN))
	    &&
	    !(rngvar->pss_tabdesc->tbl_status_mask &
		(DMT_CATALOG|DMT_EXTENDED_CAT))
	   )
	{
	    /*
	    ** One non-dba owned entry that is not a catalog and is not
	    ** explicitly qualified is enough to make the query non-shareable.
	    */

	    if (ps132)
	    {
		if (*shareable)	    
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nRepeat query is not shareable\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"because it involves table(s) which are neither catalogs\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"nor are owned by the DBA, and were not explicitly qualified.\n");
	    
		    *shareable = FALSE;

		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"These tables are:\n\n");
		}

		psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"****'%t' owned by '%t'\n",
			    sizeof(DB_TAB_NAME), &rngvar->pss_tabname,
			    sizeof(DB_OWN_NAME), &rngvar->pss_ownname);
	    }
	    else
	    {
		*shareable = FALSE;

		/*
		** if trace point ps132 has not been set, then, once we know
		** that the query is not sahreable, there is no reason to look
		** at the rest of range table entries
		*/
		return (E_DB_OK);
	    }
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* Query is not currently shareable if multi-site */

	    ldb_tab_info = &rngvar->pss_rdrinfo->rdr_obj_desc->dd_o9_tab_info;

	    if (first_ldb_desc == (DD_LDB_DESC *) NULL)
	    {
		/* Save away first LDB description */
		first_ldb_desc = &ldb_tab_info->dd_t9_ldb_p->dd_i1_ldb_desc;
		continue;
	    }

	    /* Compare site */
	    ldb_desc = &ldb_tab_info->dd_t9_ldb_p->dd_i1_ldb_desc;
	    *shareable = psq_same_site(first_ldb_desc, ldb_desc);

	    if (*shareable == FALSE)
		return(E_DB_OK);
	}
    }

    /* scan result range var in the range table */
    rngvar = &rngtab->pss_rsrng;
    if (rngvar->pss_used && rngvar->pss_rgno != -1)
    {
	/* Check this entry */
	if (~rngvar->pss_var_mask & PSS_EXPLICIT_QUAL
	    &&
	    MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_dba,
	    sizeof(DB_TAB_OWN))
	    &&
	    !(rngvar->pss_tabdesc->tbl_status_mask &
		(DMT_CATALOG|DMT_EXTENDED_CAT))
	   )
	{
	    /*
	    ** One non-dba owned entry that is not a catalog and is not
	    ** explicitly qualified is enough to make the query non-shareable.
	    */

	    if (ps132)
	    {
		/*
		** Note that in order to get this far, either *shareable == TRUE
		** or trace point ps132 was set
		*/
		if (*shareable)	    
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nRepeat query is not shareable\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"because it involves a table which is neither a catalog\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"nor is owned by the DBA, and was not explicitly qualified.\n");
	    
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"This table is:\n\n");
		}

		psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"****'%t' owned by '%t'\n",
			    sizeof(DB_TAB_NAME), &rngvar->pss_tabname,
			    sizeof(DB_OWN_NAME), &rngvar->pss_ownname);
	    }

	    *shareable = FALSE;
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* Query is not currently shareable if multi-site */

	    ldb_tab_info = &rngvar->pss_rdrinfo->rdr_obj_desc->dd_o9_tab_info;

	    if (first_ldb_desc != (DD_LDB_DESC *) NULL)
	    {
		/* Compare site */
		ldb_desc = &ldb_tab_info->dd_t9_ldb_p->dd_i1_ldb_desc;
		*shareable = psq_same_site(first_ldb_desc, ldb_desc);

		if (*shareable == FALSE)
		    return(E_DB_OK);
	    }
	}
    }

    if (cb->pss_distrib & DB_3_DDB_SESS)
    {
	DB_STATUS		status;

	/* allocate memory for DB_SHR_RPTQRY_INFO structure */
	status = psf_malloc(cb, &cb->pss_ostream,
	    (i4) sizeof(DB_SHR_RPTQRY_INFO), (PTR *) qry_info,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Initialize text fields (these are only used by QUEL). */
	(*qry_info)->db_qry_len = 0;
	(*qry_info)->db_qry = (u_char *) NULL;

	/* Build a list of table ids of tables used in the query. */

	status = psl_rptqry_tblids(cb, &cb->pss_auxrng, &cb->pss_ostream,
	    psq_cb->psq_mode, &(*qry_info)->db_num_tblids,
	    &(*qry_info)->db_tblids, &psq_cb->psq_error);

    	if (DB_FAILURE_MACRO(status))
	    return(status);

    }

    return (E_DB_OK);
}

/*
**  psl_backpatch - patches statement pointers.
**
**  Description:
**  psl_backpatch patches pst_next, pst_true and pst_false pointers
**  in statement nodes. The idea is that the last stmt in a stmt chain
**  has to point to the next stmt at the higher level (i.e. the next
**  statement in the stmt chain of the parent. The very first stmt that
**  this routine is going to be called with is always going to be PST_DECVAR
**  since by definition it is at the top of the tree. The statement tree
**  after patching should reflect the flow of control. OPC will map this
**  tree into a serious of actions to be executed by QEF. The mapping is
**  pretty much 1:1. In case of the WHILE statement, the last statements
**  in the statement chains hanging off of the node need to point to the
**  IF node representing the WHILE. The only exception is the case where
**  a statement was followed by an ENDLOOP, in this case its pst_next ptr
**  needs to be patched to the next statement that follows the corresponding
**  IF (respresenting WHILE stmt) node.
**
**  Inputes:
**
**
**  Outputs:
**
**
**  Returns:
**	None.
**
**  Side effects:
**	Modifies tree pointers.
**
**  8-jul-88 (stec)
**	Written.
**  11-feb-91 (andre)
**	The following changes wre made as a part of the fix for bug 35659:
**	    1) fix blocks created for ENDLOOP statements immediately following
**	       IF...ENDIF statement will be processed BEFORE processing the BODY
**	       of the WHILE statement;
**	    2) if the IF statement block is followed by ENDLOOP statement block,
**	       use ENDLOOP->pst_next rather than IF->pst_next to patch pointers
**	       inside the IF statement body
**  21-Feb-96 (mckba01)
**	Fix for 66715, For WHILE stmts must check pst_next for ENDLOOP
**	statement, if present make WHILE.pst_next = ENDLOOP.pst_next
**	Then remove the ENDLOOP stmt.
**	25-sep-98 (inkdo01)
**	    Added FOR loop support.
*/
VOID
psl_backpatch(
	PST_STATEMENT   *stmt,
	PST_STATEMENT   *patch)
{
    bool    last = FALSE;
    register PST_STATEMENT   *s;

    /* Return if there's nothing to do */
    if (stmt == (PST_STATEMENT *) NULL)
	return;

    /* Scan the stmt list at this level looking
    ** for the last one to patch; process recursively
    ** IF and WHILE stmts encountered.
    */
    for (s = stmt; last == FALSE; s = s->pst_next)
    {
	if (s->pst_next == (PST_STATEMENT *) NULL)
	{
	    last = TRUE;
	    s->pst_next = patch;
	}

	if (s->pst_type == PST_IF_TYPE)
	{
	    PST_STATEMENT	*next_stmt;

	    /*
	    ** usually, pst_next will point at the next statement; however, if
	    ** there was an ENDLOOP immediately following IF...ENDIF, pst_next
	    ** of the IF statement block will point to the ENDLOOP statement
	    ** block which will contain the address of the next statement;
	    */

	    if(!last && s->pst_next->pst_type == PST_ENDLOOP_TYPE)
	    {
		/* 
		** ENDLOOP is guaranteed to be the last statement in the
		** innermost block.
		**
		** Our algorithm amounts to "pushing" ENDLOOP into the body of
		** the IF statement which it follows (so the result would be
		** undistinguishable from the case when ENDLOOP was the last
		** statement in both TRUE and FALSE branches of the IF
		** statement, except that we would realize that any current
		** block statements following ENDLOOP are unreachable)
		**
		*/

		next_stmt = s->pst_next->pst_next;
		last = TRUE;
		
		/* now remove ENDLOOP block from the chain of statements */
		s->pst_next = patch;
	    }
	    else
	    {
		next_stmt = s->pst_next;
	    }

	    /* Remember to patch the last stmts in an IF's
	    ** pst_true and pst_false stmt lists.
	    */

	    /* If null stmt block patch manually */
	    if (s->pst_specific.pst_if.pst_true == (PST_STATEMENT *) NULL)
	    {
		s->pst_specific.pst_if.pst_true = next_stmt;
	    }
	    else
	    {
		(VOID) psl_backpatch(s->pst_specific.pst_if.pst_true,
		    next_stmt);
	    }

	    /* If null stmt block just patch manually */
	    if (s->pst_specific.pst_if.pst_false == (PST_STATEMENT *) NULL)
	    {
		s->pst_specific.pst_if.pst_false = next_stmt;
	    }
	    else
	    {
		(VOID) psl_backpatch(s->pst_specific.pst_if.pst_false,
		    next_stmt);
	    }
	}
	else if (s->pst_type == PST_WH_TYPE || s->pst_type == PST_RP_TYPE)
	{
	    PSS_LOOP 	    *wnode = (PSS_LOOP *) s->pst_opf;
	    PSS_FIXSTMT	    *fix,
			    *last_fix = (PSS_FIXSTMT *) &wnode->pss_fixq;
	    i4		    stype = s->pst_type;

	    /* Fix up the statement node */
	    s->pst_type = PST_IF_TYPE;
	    s->pst_opf = (PTR) NULL;

	    /*  #66715:
	     *  IF a loop stmt is immediately followed by an endloop
	     *  .pst_next will now contain an ENDLOOP statement to
	     *  point to the correct next statement
	     */

             if(!last && s->pst_next->pst_type == PST_ENDLOOP_TYPE)
	     {
	         last = TRUE;

	         /* now remove ENDLOOP block from the chain of statements */
	         s->pst_next = s->pst_next->pst_next;
	     }


	    /* Remember to patch the last stmts in a WHILE/REPEAT's
	    ** pst_true and pst_false stmt lists.
	    */


	    /* If null stmt block patch manually */
	    if (s->pst_specific.pst_if.pst_true == (PST_STATEMENT *) NULL)
	    {
		/* This case indicates that ENDLOOP was the first stmt,
		** (see cdbp_stmtlst defn), so instead of pointing at itself
		** we will make it point at the next stmt.
		*/
		s->pst_specific.pst_if.pst_true = s->pst_next;
	    }
	    else if (stype == PST_WH_TYPE)
	    {
		/*
		** For a WHILE statement fix all ENDLOOP statements which
		** immediately followed IF...ENDIF statements (they are recorded
		** as entries in the fix queue, and the pss_flags field in this
		** entries has PSS_FIX_EARLY set) BEFORE processing the body of
		** the WHILE statement.  This is required since
		** ENDLOOP->pst_next will be used to patch the last statements
		** in the TRUE and FALSE branches of the IF statement.  This is
		** done as a part of the fix for bug #35659
		*/
		for (fix = (PSS_FIXSTMT *) wnode->pss_fixq.q_next;
		     fix != last_fix;
		     fix = (PSS_FIXSTMT *) fix->pss_queue.q_next
		    )
		{
		    if (fix->pss_flags & PSS_FIX_EARLY)
		    {
			*(fix->pss_stmt_ptr) = s->pst_next;
		    }
		}

		if (stype == PST_WH_TYPE)
		    (VOID) psl_backpatch(s->pst_specific.pst_if.pst_true, s);
	    }

	    /* pst_false stmt block always null; patch manually */
	    if (s->pst_specific.pst_if.pst_false == (PST_STATEMENT *) NULL)
	    {
		s->pst_specific.pst_if.pst_false = s->pst_next;
	    }

	    /* For a loop stmt fix all stmts followed by ENDLOOP (they are
	    ** recorded as entries in the fix queue).
	    ** Traverse the fix queue and initialize all
	    ** listed statements with proper value of pst_next ptr.
	    */
	    for (fix = (PSS_FIXSTMT *) wnode->pss_fixq.q_next;
		 fix != last_fix;
		 fix = (PSS_FIXSTMT *) fix->pss_queue.q_next
		)
	    {
		/* if we haven't fixed it already, do it now */
		if (~fix->pss_flags & PSS_FIX_EARLY)
		{
		    *(fix->pss_stmt_ptr) = s->pst_next;
		}
	    }

	    /* This fixq has been fixed */
	    (VOID) QUinit(&wnode->pss_fixq);
	}
	else if (s->pst_type == PST_FOR_TYPE)
	{
	    PSS_LOOP 	    *wnode = (PSS_LOOP *) s->pst_opf;
	    PSS_FIXSTMT	    *fix,
			    *last_fix = (PSS_FIXSTMT *) &wnode->pss_fixq;
	    PST_STATEMENT   *ifstmtp = 
				s->pst_specific.pst_for.pst_forhead->pst_next;
	    i4		    stype = s->pst_type;

	    /* Fix up the statement node */
	    s->pst_opf = (PTR) NULL;

	    /*  #66715:
	     *  IF a loop stmt is immediately followed by an endloop
	     *  .pst_next will now contain an ENDLOOP statement to
	     *  point to the correct next statement
	    */

            if(!last && s->pst_next->pst_type == PST_ENDLOOP_TYPE)
	    {
	        last = TRUE;

	        /* now remove ENDLOOP block from the chain of statements */
	        s->pst_next = s->pst_next->pst_next;
	    }

	    /* Fix the FOR's IF's pst_false and if's next must exit the loop. */
	    ifstmtp->pst_specific.pst_if.pst_false = s->pst_next;
	    ifstmtp->pst_next = s->pst_next;

	    /* If 1st stmt in FOR-loop is ENDLOOP, just skip it all. */
	    if (ifstmtp->pst_specific.pst_if.pst_true == (PST_STATEMENT *)NULL)
		s->pst_specific.pst_for.pst_forhead = s->pst_next;
	    else
	    {
		/*
		** For a loop statement fix all ENDLOOP statements which
		** immediately followed IF...ENDIF statements (they are recorded
		** as entries in the fix queue, and the pss_flags field in this
		** entries has PSS_FIX_EARLY set) BEFORE processing the body of
		** the loop statement.  This is required since
		** ENDLOOP->pst_next will be used to patch the last statements
		** in the TRUE and FALSE branches of the IF statement.  This is
		** done as a part of the fix for bug #35659
		*/
		for (fix = (PSS_FIXSTMT *) wnode->pss_fixq.q_next;
		     fix != last_fix;
		     fix = (PSS_FIXSTMT *) fix->pss_queue.q_next
		    )
		{
		    if (fix->pss_flags & PSS_FIX_EARLY)
		    {
			*(fix->pss_stmt_ptr) = s->pst_next;
		    }
		}

		/* Recurse to patch stmtlist statements and direct last 
		** stmt in loop back to select's QTREE. */
		(VOID) psl_backpatch(ifstmtp->pst_specific.pst_if.pst_true, 
			s->pst_specific.pst_for.pst_forhead);
	    }


	    /* For a loop stmt fix all stmts followed by ENDLOOP (they are
	    ** recorded as entries in the fix queue).
	    ** Traverse the fix queue and initialize all
	    ** listed statements with proper value of pst_next ptr.
	    */
	    for (fix = (PSS_FIXSTMT *) wnode->pss_fixq.q_next;
		 fix != last_fix;
		 fix = (PSS_FIXSTMT *) fix->pss_queue.q_next
		)
	    {
		/* if we haven't fixed it already, do it now */
		if (~fix->pss_flags & PSS_FIX_EARLY)
		{
		    *(fix->pss_stmt_ptr) = s->pst_next;
		}
	    }

	    /* This fixq has been fixed */
	    (VOID) QUinit(&wnode->pss_fixq);
	}
    }
}   

/*
**  PSL_AGFCN  - return TRUE if an AGHEAD node found.
**
**  Description:
**	Tree is checked through recursive calls for
**	presence of an AGHEAD node.
**
**  Inputes:
**	node	    root of the subtree to be checked.
**
**  Outputs:
**	None.
**
**  Returns:
**	TRUE if AGHEAD node found, FALSE otherwise.
**
**  Side effects:
**	None.
**
**  21-oct-88 (stec)
**	Written.
*/
bool
psl_agfcn(
	PST_QNODE *node)
{
    if (node == (PST_QNODE *) NULL)
	return (FALSE);

    /* look at current node */
    if (node->pst_sym.pst_type == PST_AGHEAD)
	return (TRUE);

    /* look at both children */
    if ((node->pst_left && psl_agfcn(node->pst_left))
	||
	(node->pst_right && psl_agfcn(node->pst_right))
       )
    {
	return (TRUE);
    }

    return (FALSE);
}   

/*
**  psl_up - Checks updatability of a tree in a declare cursor
**	     statement.
**
**  Description:
**	This routine checks whether a tree representing a define
**	cursor query should reslut in creation of an updateable
**	cursor.
**	    Cursor is updateable unless:
**		- data is to be sorted with duplicates removed
**		- distinct/unique have been specified at the outermost
**		  level
**		- UNION is specified for outermost level.
**		- the count of range vars at the outermost scope is
**		  not one.
**		- the count of range vars at the outermost scope is
**		  one and the range var represent nonmergeable view
**		  and it is not updateable (UNION view).
**		- index is the target relation
**		- there are aggregates in the target list
**		
**	
**
**  Inputes:
**	    hdr		    query tree header
**	    flag	    ptr to boolean flag
**			    which may already be set
**			    to indicate updateability
**	    reason	    reason if nonupdateable
**
**  Outputs:
**	    flag	    ptr to boolean flag
**			    indicating updateability
**			    of the cursor
**			    (TRUE means nonupdateable)
**	    reason
**
**  Returns:
**	None.
**
**  Side effects:
**
**  17-oct-88 (stec)
**	Written.
**  02-dec-88 (stec)
**	Change the way aggregate test is done; do not check
**	cb->pss_agintree, since this may or may not be set,
**	just check the target list.
*/
VOID
psl_up(
	PSS_SESBLK		*cb,
	PSS_USRRANGE		*rngtab,
	register PST_QTREE	*hdr,
	bool			*flag,
	i4			*reason)
{
    register PST_QNODE	*rt = hdr->pst_qtree;

    /* no reason given yet */
    *reason = 0;

    /* See if already nonupdatable */
    if (*flag)
    {
	*reason = 1;
	return;
    }

    /* Check if distinct specified */
    if (rt->pst_sym.pst_value.pst_s_root.pst_dups
	    == PST_NODUPS)
    {
	*reason = 2;
	*flag = TRUE;
	return;
    }

    /* Check if union */
    if (rt->pst_sym.pst_value.pst_s_root.pst_union.pst_next
	    != (PST_QNODE *) NULL)
    {
	*reason = 3;
	*flag = TRUE;
	return;
    }

    /* Check if one range var in the target list */
    if (rt->pst_sym.pst_value.pst_s_root.pst_tvrc != 1)
    {
	*reason = 4;
	*flag = TRUE;
	return;
    }
    else
    {
	i4	i = -1;
	register PSS_RNGTAB *rngvar, *lim;

	i = BTnext(i, (char *) &rt->pst_sym.pst_value.pst_s_root.pst_tvrm,
		   PST_NUMVARS);

	for (rngvar = &rngtab->pss_rngtab[0],
	     lim = &rngtab->pss_rngtab[PST_NUMVARS];
	     rngvar < lim;
	     rngvar++
	    )
	{
	    if (!rngvar->pss_used || rngvar->pss_rgno != i)
		continue;

	    if (rngvar->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	    {
		*reason = 5;
		*flag = TRUE;
		return;
	    }
	}
    }

    /* Check if index */
    if (cb->pss_resrng &&
	cb->pss_resrng->pss_tabdesc->tbl_status_mask & DMT_IDX)
    {
	*reason = 6;
	*flag = TRUE;
	return;
    }

    /* check for aggregate functions in the target list */
    if ((i4)psl_agfcn(rt->pst_left))
    {
	*reason = 7;
	*flag = TRUE;
	return;
    }
}

/*
**  psl_crsopen - Executes code shared by a number of semantic
**		  routines.
**
**  Description:
**	Executes code related to the cursor open request. This code
**	is executed from a number of places, so it is is a good
**	idea to encapsulate it in a routine.
**	
**
**  Inputes:
**	cb		    session ctrl blk
**	psq_cb		    psf request block
**	crblk		    cursor control block ptr
**	tree		    pointer to tree header
**	for_rdonly	    boolean indicating presence
**			    of FOR READONLY clause
**	updcollst	    pointer to subtree representing
**			    list of updateable columns
**	nonupdt		    boolean indicator set to TRUE
**			    if we already know that query
**			    is not updateable
**	num_joins	    number of joins found in the query tree so far
**	dynqp_comp	    TRUE if dynamic query already compiled to cache
**
**  Outputs:
**	cb		    session ctrl blk
**	    .pss_resrng	    set to NULL if query not updateable
**	psq_cb		    psf request block
**	    .psq_error	    describes nature of problem if error
**			    encountered.
**	crblk		    cursor control block
**	    .psc_delall	    indicates whether cursor deleteable
**	    .psc_forupd	    indicates whether cursor updateable
**	    .psc_lang	    set to current query language
**	    .psc_tbl_descr_queue
**			    list of descriptions of table/views over which the
**			    cursor is defined
**		.psc_tbl_mask
**			    copy of the relstat
**		.psc_flags  initialized to indicate that we haven't checked for
**			    existence of rules on this table/view
**	    
**	tree		    pointer to tree header
**	    .pst_updtmode   may be altered if FOR READONLY spec'd
**  
**  Returns:
**	status
**
**  Side effects:
**	Qrymod process may alter the tree.
**	Header of the tree may be altered.
**	Memory may be allocated.
**
**  16-nov-88 (stec)
**	Written.
**  24-apr-89 (neil)
**	Added initialization in support for rules and cursors.
**  08-sep-89 (andre)
**	receive number of joins found in the tree so far as an argument.
**  08-mar-93 (andre)
**	if a user has not specified either FOR UPDATE, FOR READONLY, or ORDER BY
**	and the <query expression> is updatable, the cursor will support UPDATE
**	of all columns.  In our unending quest for improved concurrency, we will
**	notify OPF that the user has NOT explicitly specified FOR UPDATE so that
**	we will be acquiring shared locks on pages read through the cursor
**	until/unless the user tries to UPDATE/DELETE through it.
**  06-apr-93 (andre)
**	removed code initializing psc_rchecked, psc_tbl_mask, psc_rules, and
**	psc_stmt_rules.  The first became a bit (PSC_RULES_CHECKED) over
**	PSC_TBL_DESCR.psc_flags while the rest have migrated into PSC_TBL_DESCR
**
**	before calling psy_qrymod(), allocate and populate a PSC_TBL_DESCR
**	structure for the table/view on which a cursor has been defined and
**	insert it into psc_tbl_descr_queue
**  31-dec-93 (andre)
**	(fix for bug 57384:)
**	if the cursor is being opened without specifying FOR READONLY, ORDER BY,
**	or FOR UPDATE, we may still allow user to perform updated through it - 
**	however, it is wrong for PSF to tell OPC that the cursor will be used 
**	for DEFERRED update since this will break lots of existing applications
**	+ if the user intended to do DEFERRED update, it is not unreasonable to
**	expect him to say FOR [DEFERRED] UPDATE
**	29-nov-2007 (dougi)
**	    Add dynqp_comp parm for cached dynamic queries.
*/
DB_STATUS
psl_crsopen(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PSC_CURBLK	*crblk,
	PST_QTREE	*tree,
	bool		for_rdonly,
	PST_QNODE	*updcollst,
	bool		nonupdt,
	PST_J_ID	num_joins,
	bool		dynqp_comp)
{
    DB_STATUS		status;
    register PST_QNODE	*qnode;
    i4		err_code;
    i4		qrymod_resp_mask;
    PSC_UPDM		updtmask;
    PSC_COLMAP		updcolmap;

    if (!cb->pss_resrng)
    {
	/* Force readonly ('select constant' statement) */
	for_rdonly = TRUE;
    }

    updtmask = 0;	/* initialize mask to read only */

    if (for_rdonly == TRUE)
    {
	/* FOR READONLY specified at cursor open time */
	tree->pst_updtmode = PST_READONLY;

	/* no result table for READ ONLY case */
	cb->pss_resrng = 0;
    }
    else if (tree->pst_updtmode != PST_READONLY)
    {
	/*
	** FOR UPDATE clause has been specified (or at least ORDER BY has not
	** been specified and the query appeared updatable so far in which case
	** tree->pst_updtmode pst_updtmode would be set to PST_UNSPECIFIED)
	** indicate update request in the cursor control block (this
	** automatically implies request for delete privileges).
	*/
	crblk->psc_forupd = TRUE;
	updtmask |= (PST_UP | PST_DL);
    }
    else
    {
	/*Set the config.dat entry value if cursor mode is not specified */
       	if( Psf_srvblk->psf_flags & PSF_DFLT_READONLY_CRSR)
       	{
         	tree->pst_updtmode = PST_READONLY;
		cb->pss_resrng = 0;
       	}
	else
	{
	/* no update requested
	** but consider cursor deleteable
	*/
		updtmask |= PST_DL;
	}
    }

    if (updtmask & PST_UP)
    {
	i4			colno;
	i4			count;
	PST_RSDM_NODE	*resdom;
	register DB_DATA_VALUE *dt;

	/* Initialize "for update" column map. */
	(VOID) MEfill(sizeof (PSC_COLMAP), (u_char) 0, 
	    (PTR) &updcolmap);

	/* Create the hash table for descriptions of updateable
	** columns for this cursor. 
	*/
	for (qnode = updcollst, count = 0;
	     qnode && qnode->pst_sym.pst_type == PST_RESDOM;
	     qnode = qnode->pst_left
	    )
	{
	    count++;
	    (VOID) BTset((i4) qnode->
		pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id,
		(char *) &updcolmap);

	    /* This column needs to have update permissions checked on it. */
	    qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsupdt = TRUE;
	}

	status = psq_cltab(crblk, count, &cb->pss_memleft, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Run down the updateable col list, and add them
	** to the cursor control block. This must be done before
	** QRYMOD is done, because column descriptions will be
	** referenced from within UPDATE statements and
	** we want to keep user's perspective here.
	*/
	for (qnode = updcollst;
	    qnode && qnode->pst_sym.pst_type == PST_RESDOM;
	    qnode = qnode->pst_left)
	{
	    resdom = &qnode->pst_sym.pst_value.pst_s_rsdm;
	    dt = &qnode->pst_sym.pst_dataval;
	     colno =
	      qnode->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id;

	    status = psq_clent(colno, (DB_ATT_NAME *) resdom->pst_rsname,
		dt->db_datatype, dt->db_length, dt->db_prec, crblk,
		&cb->pss_memleft, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	/* Now add our mini-target list of updateable columns
	** to the main target list (to be removed after
	** execution of qrymod).
	*/
	(VOID) pst_tlprpnd(updcollst, tree->pst_qtree);
    }

    if (updtmask & (PST_UP | PST_DL))
    {
	PSC_TBL_DESCR	    *crs_tbl_descr;

	/*
	** Store name of the table and its owner in the cursor control block.
	** Name should be stored in the cursor control block independent
	** of the mode in which cursor is opened. These names are retrieved
	** for storage before querymod is run so that "delete" and
	** "update" actions which compare them with the names spec'd
	** in those stmnts can return an error message naming the object
	** specified by the user rather than the name of underlying base
	** table (if object is a view).
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabname,	
	    crblk->psc_tabnm);
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_ownname,
	    crblk->psc_ownnm);

	/*
	** allocate, populate, and insert a PSC_TBL_DESCR structure describing
	** the object on which the cursor was defined
	*/
	status = psf_umalloc(cb, crblk->psc_stream, sizeof(*crs_tbl_descr),
	    (PTR *) &crs_tbl_descr, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid,
			    crs_tbl_descr->psc_tabid);
	crs_tbl_descr->psc_tbl_mask =
	    cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	    
	crs_tbl_descr->psc_row_lvl_usr_rules =
	crs_tbl_descr->psc_row_lvl_sys_rules =
	crs_tbl_descr->psc_stmt_lvl_usr_rules =
	crs_tbl_descr->psc_stmt_lvl_sys_rules =
	crs_tbl_descr->psc_row_lvl_usr_before_rules =
	crs_tbl_descr->psc_row_lvl_sys_before_rules =
	crs_tbl_descr->psc_stmt_lvl_usr_before_rules =
	crs_tbl_descr->psc_stmt_lvl_sys_before_rules = (PST_STATEMENT *) NULL;

	crs_tbl_descr->psc_flags = 0;
	QUinsert(&crs_tbl_descr->psc_queue, crblk->psc_tbl_descr_queue.q_prev);
    }

    status = psy_qrymod(tree->pst_qtree, cb, psq_cb, &num_joins,
	&qrymod_resp_mask);
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    if (psq_cb->psq_pnode != (PTR)NULL)
    {
	/* Assign the qrymod audit information from session pointer. */

	PST_PROCEDURE *pnode = (PST_PROCEDURE *)psq_cb->psq_pnode;

	pnode->pst_stmts->pst_audit = cb->pss_audit;
	psq_cb->psq_pnode = 0;
    }
    cb->pss_audit = (PTR)NULL;

    if (updtmask & PST_UP)
    {
	PST_QNODE	 *treenode;

	/*
	** Now set the internal update map representing attribute
	** numbers of base relation(s).
	**
	** EXTRA! EXTRA! READ ALL ABOUT IT...
	**  - psy_protect() could have determined that a user does not possess
	**    UPDATE privilege on some attribute(s) appearing in the FOR UPDATE
	**    list and indicate it by resetting pst_rsupdt in the appropriate
	**    RESDOM node.  In a departure from the way things used to work
	**    before, rather than returning an error in such case, we will
	**    simply remember that a user may not update that particular column
	**    by resetting the corresponding bit in psc_updmap
	**  - if a right subtree of a RESDOM node representing an attribute
	**    EXPLICITLY named in the FOR UPDATE does not consist of a PST_VAR
	**    node, we will continue to report an error; however, if the user
	**    has not specified none of FOR UPDATE, ORDER BY, or FOR READONLY,
	**    then we will assume that the cursor can be used for updating
	**    attributes of the cursor's underlying table unless proven
	**    otherwise.  In this second scenario, if a right subtree of a
	**    RESDOM node does not consist of a PST_VAR node, we will simply
	**    remember that this attribute may not be updated
	*/
	for (qnode = updcollst;
	     qnode && qnode->pst_sym.pst_type == PST_RESDOM;
	     qnode = qnode->pst_left
	    )
	{
	    /* Check if updateable columns are really updateable */
	    if (qnode->pst_right->pst_sym.pst_type == PST_VAR)
	    {
		if (qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsupdt)
		{
		    (VOID) BTset((i4) qnode->pst_right->
			pst_sym.pst_value.pst_s_var.pst_atno.db_att_id,
			(char *) &crblk->psc_iupdmap);
		}
		else
		{
		    /*
		    ** we need to find the number of the attribute of the table
		    ** or view on which the cursor is based and reset the
		    ** corresponding bit in updcolmap (which will be copied into
		    ** psc_updmap)
		    */
		    PSC_RESCOL	    *nonupdt_col;
		    DB_ATT_NAME	    att_name;

		    MEcopy((PTR) qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
			DB_MAXNAME, (PTR) &att_name);
			
		    nonupdt_col = psq_ccol(crblk, &att_name);
		    if (nonupdt_col == (PSC_RESCOL *) NULL)
		    {
			/* something is very wrong */
			psq_cb->psq_error.err_code = E_PS0002_INTERNAL_ERROR;
			return(E_DB_SEVERE);
		    }
		    
		    /*
		    ** remember that this attribute may not be updated because
		    ** the user lacks UPDATE privilege
		    */
		    BTclear((i4) nonupdt_col->psc_attid.db_att_id,
			(char *) &updcolmap);
		}
	    }
	    else
	    {
		/*
		** if a cursor has been EXPLICITLY declared FOR UPDATE of an
		** attribute of a view which is not a simple attribute (i.e. it
		** is based on an expression), we will report an error.
		** If however, the user has omitted FOR UPDATE/READONLY
		** altogether or has specified FOR UPDATE without a <column name
		** list>, we simply need to remember that the user may not
		** update this attribute
		*/
		if (   tree->pst_updtmode != PST_UNSPECIFIED
		    && ~cb->pss_stmt_flags & PSS_IMPL_COL_LIST_IN_DECL_CURS)
		{
		    (VOID) psf_error(2224L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 3,
			sizeof(cb->pss_lineno), &cb->pss_lineno,
			psf_trmwhite(DB_MAXNAME,
			    cb->pss_crsr->psc_blkid.db_cur_name),
			cb->pss_crsr->psc_blkid.db_cur_name,
			psf_trmwhite(DB_MAXNAME,
			    qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
		    return (E_DB_ERROR);
		}
		else
		{
		    /*
		    ** find a PSC_RESCOL structure describing this attribute of
		    ** a view and set a bit in psc_expmap to remember that this
		    ** attribute cannot be updated because it is not a simple
		    ** attribute
		    */
		    PSC_RESCOL	    *nonupdt_col;
		    DB_ATT_NAME	    att_name;

		    MEcopy((PTR) qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
			DB_MAXNAME, (PTR) &att_name);
			
		    nonupdt_col = psq_ccol(crblk, &att_name);
		    if (nonupdt_col == (PSC_RESCOL *) NULL)
		    {
			/* something is very wrong */
			psq_cb->psq_error.err_code = E_PS0002_INTERNAL_ERROR;
			return(E_DB_SEVERE);
		    }
		    
		    BTset((i4) nonupdt_col->psc_attid.db_att_id,
			(char *) &crblk->psc_expmap);

		    /*
		    ** while at it, reset the corresponding bit in updcolmap
		    ** since the user will never be able to update
		    ** that attribute
		    */
		    BTclear((i4) nonupdt_col->psc_attid.db_att_id,
			(char *) &updcolmap);
		}
	    }
	}

	treenode = qnode;

	/* Remove the update columns list from the target list, i.e.,
	** restore the target list to the original shape.
	*/
	for (qnode = tree->pst_qtree;
	     qnode->pst_left != updcollst;
	     qnode = qnode->pst_left
	    )
	;

	qnode->pst_left = treenode;
    }

    /* Verify updateablity/deleteability of the query. */
    if (updtmask & PST_UP)
    {
	i4		reason;
	i4		mask;
	i4		mask2;

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/*
	** Make sure base table is updateable; if a non-extended
	** catalog, catalog update privilege must be on.
	** If security catalog session must have security privilege
	*/
        if (mask2 & DMT_READONLY)
        {
            (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L, PSF_USERERR,
                         &err_code, &psq_cb->psq_error, 0);
            return(E_DB_ERROR);
        }

	else if ( ( (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
	    && ~mask & DMT_EXTENDED_CAT
	    && !(cb->pss_ses_flag & PSS_CATUPD)
	   )
	   ||
	   ((mask & DMT_SECURE) &&
	    !(cb->pss_ustat & DU_USECURITY)))
	{
	    /*
	    ** if the user has explicitly specified FOR UPDATE, report error,
	    ** otherwise (i.e. user has omitted FOR UPDATE/READONLY), simply
	    ** remember that the user may neither UPDATE nor DELETE through this
	    ** cursor
	    */
	    if (tree->pst_updtmode == PST_UNSPECIFIED)
	    {
		nonupdt = TRUE;
	    }
	    else
	    {
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_DELETE, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_DELETE, &e_error);
		if (local_status > status)
		    status = local_status;
		(VOID) psf_error(2107L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), 
				&cb->pss_lineno,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return (E_DB_ERROR);
	    }
	}

	(VOID) psl_up(cb, &cb->pss_auxrng, tree, &nonupdt, &reason);

	if (nonupdt && tree->pst_updtmode != PST_UNSPECIFIED)
	{
	    /* Report the error - then exit. */
	    psl_nonupdt_err(psq_cb, cb, reason, &err_code);
	    return (E_DB_ERROR);
	}

	if (nonupdt)
	{
	    /*
	    ** at this point this can only happen if the user omitted FOR
	    ** UPDATE/READONLY
	    ** reset updtmask; code below will take care of resetting
	    ** appropriate fields in the tree header
	    */
	    updtmask = 0;
	}

	/*
	** If this point in code is reached and updtmask != 0, the query is
	** updateable; it is also deletable because the requirements are the
	** same.
	*/
    }
    else if (updtmask & PST_DL)
    {
	i4		reason;
	i4		mask;
	i4		mask2;

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/* Make sure base table is deleteable; if a non-extended
	** catalog, catalog update privilege must be on.
	** if security catalog session must have security privilege active
	*/
        if (mask2 & DMT_READONLY)
        {
            (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L, PSF_USERERR,
                         &err_code, &psq_cb->psq_error, 0);
            return(E_DB_ERROR);
        }

	else if (  ( (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
	    && ~mask & DMT_EXTENDED_CAT
	    && !(cb->pss_ses_flag & PSS_CATUPD)
	   )
	   ||
	   ((mask & DMT_SECURE) &&
	    !(cb->pss_ustat & DU_USECURITY)))
	{
	    updtmask &= ~PST_DL;
	}
	else
	{
	    (VOID) psl_up(cb, &cb->pss_auxrng, tree, &nonupdt, &reason);

	    if (nonupdt)
	    {
		updtmask &= ~PST_DL;
	    }
	}
    }

    /* set pst_numjoins */
    tree->pst_numjoins = num_joins;

    /* If the query turns out to be deleteable/updateable
    ** we need to append a TID node to the target list.
    */
    if (updtmask & (PST_UP | PST_DL) )
    {
	PST_VAR_NODE	tidvar;
	PST_RSDM_NODE	rsdm;
	PST_QNODE	*rsdmnode;
	PST_QNODE	*tidnode;

	tidvar.pst_vno = cb->pss_resrng->pss_rgno;
	tidvar.pst_atno.db_att_id = 0;	    /* tid is always column 0 */
	STmove(((*cb->pss_dbxlate & CUI_ID_REG_U) ? "TID" : "tid"),
		' ', DB_MAXNAME, tidvar.pst_atname.db_att_name);

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &tidvar, sizeof(tidvar),
	    DB_TID8_TYPE, (i2) 0, (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL,
	    &tidnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	    /* non-zero return means error */
	}

	/* Set up a resdom result domain representing a tid. */
	rsdm.pst_rsno = 0;
	rsdm.pst_rsupdt = FALSE;
	rsdm.pst_rsflags = 0; /* no PST_RS_PRINT */
	MEcopy((PTR)&tidvar.pst_atname.db_att_name, DB_MAXNAME,
		(PTR)&rsdm.pst_rsname);

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, tidnode,
	    PST_RESDOM, (PTR) &rsdm, sizeof(rsdm), DB_TID8_TYPE, (i2) 0, 
	    (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL, &rsdmnode, 
	    &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* Prepend the tid node to the target list */
	(VOID) pst_tlprpnd(rsdmnode, tree->pst_qtree);

	if (updtmask & PST_UP)
	{
	    /* Remember the updateable columns in the cursor control block */
	    STRUCT_ASSIGN_MACRO(updcolmap, crblk->psc_updmap);
	}

	tree->pst_delete = crblk->psc_delall;

	/*
	** if a user failed to specify FOR UPDATE/READONLY or ORDER BY, and it
	** looks like the user will be able to UPDATE/DELETE through this
	** cursor, we need to set tree->pst_updtmode to indicate DIRECT UPDATE +
	** we need to tell OPC that the user has not explicitly specified 
	** FOR UPDATE;
	** NOTE: that if the user has not explicitly specified FOR UPDATE, we 
	** 	 will allow only DIRECT update through it; doing otherwise would
	**	 break pre-6.5 applications and seems like an all-around bad 
	**	 idea (bug 57384 was filed to that effect)
	*/
	if (tree->pst_updtmode == PST_UNSPECIFIED)
	{
	    tree->pst_mask1 |= PST_IMPLICIT_CURSOR_UPDATE;
	    tree->pst_updtmode = PST_DIRECT;
	    if (cb->pss_stmt_flags & PSS_SCROLL)
		cb->pss_stmt_flags |= PSS_KEYSET;
	}
    }
    else
    {   /* For read only */
	tree->pst_delete = FALSE;		/* tree header */
	tree->pst_updtmode = PST_READONLY;	/* tree header */
	tree->pst_restab.pst_resvno = -1;	/* tree header */
	crblk->psc_delall = FALSE;		/* cursor ctrl block */
	crblk->psc_forupd = FALSE;		/* cursor ctrl block */
	/*
	** Clear out "for update" column map.
	*/
	(VOID) MEfill(sizeof (PSC_COLMAP), (u_char) 0, 
	    (PTR) &crblk->psc_iupdmap);
    }

    /* Modify the query tree header */
    status = pst_modhdr(cb, psq_cb, tree->pst_updtmode, tree);
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    /* Copy the cursor id from the cursor control block to here */
    STRUCT_ASSIGN_MACRO(crblk->psc_blkid, tree->pst_cursid);

    /*
    ** remember the language using which the cursor was defined; will be mighty
    ** useful in determining whether any permission checking is needed when 
    ** processing UPDATE WHERE CURRENT OF <cursor> (if a cursor was declared
    ** using SQL, we are guaranteed that the user can SELECT from the table/view
    ** on which the cursor is defined whereas if the cursor was defined in QUEL,
    ** we may have to determine whether the user possesses RETRIEVE on columns
    ** appearing on the RHS of assignment; psc_lang is also used during DELETE
    ** CURSOR processing
    */
    crblk->psc_lang = psq_cb->psq_qlang;

#ifdef	xDEBUG
    {
	i4 val1;
	i4 val2;

	if (ult_check_macro(&cb->pss_trace, 13, &val1, &val2))
	{
	    (VOID) pst_display("\n\nCursor `%t' characteristics for:\n\t%s\n",
		psf_trmwhite(DB_MAXNAME, cb->pss_crsr->psc_blkid.db_cur_name),
		cb->pss_crsr->psc_blkid.db_cur_name, cb->pss_bgnstmt);
	    if (tree->pst_delete == FALSE)
		(VOID) pst_display("\n\ttree header: delete = FALSE");
	    else
		(VOID) pst_display("\n\ttree header: delete = TRUE");
	    if (tree->pst_updtmode == PST_DIRECT)
		(VOID) pst_display("\n\ttree header: updtmode = DIRECT UPDATE");
	    else if (tree->pst_updtmode == PST_DEFER)
		(VOID) pst_display("\n\ttree header: updtmode = DEFERRED UPDATE");
	    else
		(VOID) pst_display("\n\ttree header: updtmode = READ ONLY");
	    (VOID) pst_display("\n\ttree header: pst_restab.pst_resvno = %d",
		tree->pst_restab.pst_resvno);
	    if (crblk->psc_delall == FALSE)
		(VOID) pst_display("\n\tPSF cursor control block: delall = FALSE");
	    else
		(VOID) pst_display("\n\tPSF cursor control block: delall = TRUE");
	    if (crblk->psc_forupd == FALSE)
		(VOID) pst_display("\n\tPSF cursor control block: forupd = FALSE");
	    else
		(VOID) pst_display("\n\tPSF cursor control block: forupd = TRUE");

	    (VOID) psq_crdump(psq_cb, cb);
	}
    }
#endif

    return (E_DB_OK);
}

/*
**  psl_crskeyflag - flag key columns for updateable scrollable cursors
**
**  Description:
**
**	Flag columns in the first primary key or index we find that is
**	unique and is covered by the result set. Return an error if none
**	such is found.
**
**  Inputs:
**	    cb		ptr to session control block
**	    tree	query tree fragment
**
**  Outputs:
**
**  Returns:
**	    DB_STATUS
**
**  History:
**
**	24-may-2007 (toumi01)
**	    Created.
*/
i4
psl_crskeyflag(
	PSS_SESBLK	*cb,
	PST_QTREE	*tree)
{
	DB_STATUS	status = E_DB_OK;
	DB_ERROR	err_blk;
	i4		err_code, err_num;
	PST_QNODE	*resdomp;
	RDF_CB		rdfcb, *rdf_cb = &rdfcb;
	RDR_RB		*rdf_rb = &rdf_cb->rdf_rb;
	RDR_INFO	*rdrinfo;
	DMT_IDX_ENTRY	*idx_entry;
	i4		i, j, count, keys_set;

	/* call RDF to get key info about the cursor's base table */
	pst_rdfcb_init(rdf_cb, cb);
	rdf_rb->rdr_types_mask = RDR_RELATION | RDR_ATTRIBUTES |
	    RDR_BLD_PHYS | RDR_INDEXES | RDR_BY_NAME;
	MEcopy(tree->pst_restab.pst_resname.db_tab_name, DB_MAXNAME,
	    rdf_rb->rdr_name.rdr_tabname.db_tab_name);
	MEcopy(tree->pst_restab.pst_resown.db_own_name, DB_MAXNAME,
	    rdf_rb->rdr_owner.db_own_name);
	rdf_rb->rdr_rec_access_id = NULL;
	rdf_cb->rdf_info_blk = NULL;

	status = rdf_call(RDF_GETDESC, (PTR)rdf_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    if (rdf_cb->rdf_error.err_code == E_RD0002_UNKNOWN_TBL)
	    {
		(VOID) psf_error(E_PS0903_TAB_NOTFOUND, 
		    rdf_cb->rdf_error.err_code, PSF_INTERR,
		    &err_code, err_blk, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &tree->pst_restab.pst_resname.db_tab_name),
		    &tree->pst_restab.pst_resname.db_tab_name);
	    }
	    else
	    {
		(VOID)psf_rdf_error(RDF_GETDESC, &rdf_cb->rdf_error, &err_blk);
	    }
	    return(status);
	}

	rdrinfo = rdf_cb->rdf_info_blk;

	/* flag primary key columns */
	count = keys_set = 0;
	/* only a unique key is a candidate for keyset flagging */
	if (rdrinfo->rdr_keys &&
	    rdrinfo->rdr_rel->tbl_status_mask & DMT_UNIQUEKEYS)
	    count = rdrinfo->rdr_keys->key_count;
	if (count)
	{
	    for ( i = 0; i < count; i++ )
	    {
		for (resdomp = tree->pst_qtree->pst_left;
		    resdomp != (PST_QNODE *) NULL &&
		    resdomp->pst_sym.pst_type == PST_RESDOM;
		    resdomp = resdomp->pst_left)
		{
		    if (resdomp->pst_right &&
			resdomp->pst_right->pst_sym.pst_type == PST_VAR &&
			rdrinfo->rdr_keys->key_array[i] ==
			resdomp->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
		    {
			resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsflags
			    |= PST_RS_KEYSET;
			keys_set++;
		    }
		}
	    }
	}

	/* result set didn't include all key cols? skip it! */
	if (keys_set > 0 && keys_set < count)
	{
	    keys_set = 0;
	    for (resdomp = tree->pst_qtree->pst_left;
		resdomp != (PST_QNODE *) NULL &&
		resdomp->pst_sym.pst_type == PST_RESDOM;
		resdomp = resdomp->pst_left)
	    {
		resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsflags
		    &= ~PST_RS_KEYSET;
	    }
	}

	/* try flagging index key columns if primary key not usable */
	count = 0;
	if (rdrinfo->rdr_indx)
	{
	    idx_entry = rdrinfo->rdr_indx[0];
	    count = rdrinfo->rdr_no_index;
	    i = 0;
	}
	/* loop over indexes until we get a good one or run out */
	while (count > 0 && keys_set == 0 && i < count )
	{
	    for ( ; i < count; i++ )
	    {
		bool ix_usable = FALSE;

		/* only use ix if all columns are in result set */
		for ( j = 0; idx_entry[i].idx_attr_id[j] != 0; j++ )
		{
		    ix_usable = TRUE;
		    for (resdomp = tree->pst_qtree->pst_left;
			resdomp != (PST_QNODE *) NULL &&
			resdomp->pst_sym.pst_type == PST_RESDOM;
			resdomp = resdomp->pst_left)
		    {
			if (resdomp->pst_right &&
			    resdomp->pst_right->pst_sym.pst_type == PST_VAR &&
			    idx_entry[i].idx_attr_id[j] ==
			    resdomp->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
				break;
		    }
		    if (resdomp == (PST_QNODE *) NULL ||
			resdomp->pst_sym.pst_type != PST_RESDOM)
			ix_usable = FALSE;
		}
		/* make sure ix is unique */
		if (ix_usable == TRUE)
		{
		    RDF_CB	ixrdfcb, *ixrdf_cb = &ixrdfcb;
		    RDR_RB	*ixrdf_rb = &ixrdf_cb->rdf_rb;

		    STRUCT_ASSIGN_MACRO(rdfcb, ixrdfcb);
		    MEcopy(idx_entry[i].idx_name.db_tab_name, DB_MAXNAME,
			ixrdf_rb->rdr_name.rdr_tabname.db_tab_name);
		    ixrdf_rb->rdr_rec_access_id = NULL;
		    ixrdf_cb->rdf_info_blk = NULL;
		    status = rdf_call(RDF_GETDESC, (PTR)ixrdf_cb);
		    if (DB_FAILURE_MACRO(status))
		    {
			if (ixrdf_cb->rdf_error.err_code ==
			    E_RD0002_UNKNOWN_TBL)
			{
			    (VOID) psf_error(E_PS0903_TAB_NOTFOUND, 
				ixrdf_cb->rdf_error.err_code, PSF_INTERR,
				&err_code, err_blk, 1,
				psf_trmwhite(sizeof(DB_TAB_NAME), 
				(char *) &idx_entry[i].idx_name.db_tab_name),
				&idx_entry[i].idx_name.db_tab_name);
			}
			else
			{
			    (VOID)psf_rdf_error(RDF_GETDESC,
				&ixrdf_cb->rdf_error, &err_blk);
			}
			return(status);
		    }
		    if (!(ixrdf_cb->rdf_info_blk->rdr_rel->tbl_status_mask
			    & DMT_UNIQUEKEYS))
			ix_usable = FALSE;
		    status = rdf_call(RDF_UNFIX, (PTR)ixrdf_cb);
		    if (DB_FAILURE_MACRO(status))
		    {
			(VOID)psf_rdf_error(RDF_UNFIX, &ixrdf_cb->rdf_error,
			    &err_blk);
			return(status);
		    }
		}
		/* we have a unique index in result set so flag it */
		if (ix_usable == TRUE)
		{
		    for ( j = 0; idx_entry[i].idx_attr_id[j] != 0; j++ )
		    {
			for (resdomp = tree->pst_qtree->pst_left;
			    resdomp != (PST_QNODE *) NULL &&
			    resdomp->pst_sym.pst_type == PST_RESDOM;
			    resdomp = resdomp->pst_left)
			{
			    if (resdomp->pst_right &&
				resdomp->pst_right->pst_sym.pst_type == PST_VAR &&
				idx_entry[i].idx_attr_id[j] ==
				resdomp->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
			    {
				resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsflags
				    |= PST_RS_KEYSET;
				keys_set++;
			    }
			}
		    }
		}
		/* we only need to flag one index */
		if (keys_set > 0)
		    break;
	    }
	}

	/* unfix the RDF cache entry */
	{
	    status = rdf_call(RDF_UNFIX, (PTR)rdf_cb);
	    if (DB_FAILURE_MACRO(status))
	    {
		(VOID)psf_rdf_error(RDF_UNFIX, &rdf_cb->rdf_error, &err_blk);
		return(status);
	    }
	}

	/* if no unique key/ix then can't have scrollable updateable cursor */
	if (keys_set == 0)
	{
	    status = E_DB_ERROR;
	}

	return(status);
}

/*
**  psl_nonupdt_err - display error for attempt to use nonupdateable
**	cursor for update.
**
**  Description:
**	Cursor was opened for update, or as SCROLLABLE KEYSET, both
**	implying the need to be updateable. This function uses the reason
**	code to display appropriate error message.
**
**  Inputes:
**	    cb		    ptr to session control block
**	    psq_cb	    ptr to request control block
**	    reason	    code indicating why cursor is non-updateable
**	    err_code	    ptr to returned err_code
**
**  Outputs:
**
**  Returns:
**
**  History:
**
**	10-apr-2007 (dougi)
**	    Abstracted from psl_crsopen() to allow messages to be displayed
**	    from different contexts (regular FOR UPDATE cursor and SCROLL
**	    KEYSET cursor).
*/
i4
psl_nonupdt_err(
	PSQ_CB	*psq_cb,
	PSS_SESBLK *cb,
	i4	reason,
	i4	*err_code)
{


    /* Switch the reason code and issue the error. */
	    switch (reason)
	    {
	    case 1:
		/* Nonupdateability discovered during parsing (syntax check). */
		(VOID) psf_error(2925L, 0L, PSF_USERERR,
		    err_code, &psq_cb->psq_error, 0);
		break;
	    case 2:
		/* Error if duplicates removed at the outermost scope. */
		(VOID) psf_error(2219L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 3:
		/* Error if UNION at the outermost scope. */
		(VOID) psf_error(2220L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 4:
		/* Error if other than one range var at the outermost scope. */
		(VOID) psf_error(2203L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 5:
		/* Error if the only range var is a non-mergeable view. */
		(VOID) psf_error(2221L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),&cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 6:
		/* Error if index */
		(VOID) psf_error(2222L, 0L, PSF_USERERR, err_code,
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 7:
		/* Error if aggregate in target list */
		(VOID) psf_error(2223L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    }

}

/*
**  psl_do_insert - complete building a tree for the insert, check for possible
**                  errors, build query header, if necessary
**
**  Description:
**	This procedure will
**	1) check that all mandatory columns (in the user-specified table, as
**	   well as the underlying base table, if the user-specified table is a
**	   view,
**	2) Mark QP as shareable, if appropriate,
**	3) invoke qrymod() to replace all views in the tree,
**	4) Make sure that the underlying table is updatable, and
**	5) invoke pst_header() to build the query header
**
**  Inputes:
**	    cb		    ptr to session control block
**	    psq_cb	    ptr to request control block
**	    root_node	    ptr to the root node of the query
**	    shareable_qp    ptr to indicator if the QP is shareable
**	    tree	    addr of the ptr to the tree header to be constructed
**	    isdbp	    indicator if the statement is a part of dbproc
**	    num_joins	    number of joins in the query
**	    xlated_qry	    Info on query site, etc.
**	    qry_info	    Address of pointer to table_id information to be
**				allocated by psl_shareable().
**
**  Outputs:
**	    *tree	    will point to the query header
**	    *shareable_qp   will indicate if the QP is shareable
**
**  Returns:
**	    E_DB_OK	    query tree has been build successfully
**	    E_DB_ERROR	    got some problems.
**
**  Side effects:
**	    will allocate memory for the header
**
**  22-may-89 (andre)     
**	Written.
**  08-sep-89 (andre)
**	pass number of joins to be stored in the header
**  15-jun-92 (barbara)
**	Sybil merge.  Star comments:
**	19-mar-92 (barbara)
**	    Pass in qry_info pointer for psl_shareable to use to store table
**	    info for repeat queries (part of fix for bug 42625) and xlated_qry.
**  15-oct-92 (rblumer)
**	make sure NOT NULL <no default> is treated as a mandatory column.
**  25-jan-93 (rblumer)
**	Move mandatory column checks (for both tables and views) to new routine
**	psl_check_defaults, and call that function from here.  That routine
**	will also generate nodes for default columns, instead of postponing
**	it to compile time (OPF). 
**  17-may-95 (dilma04)
**      Add table status checks and error handling when attempting to perform
**      INSERT against a READONLY table. 
**	15-feb-2008 (dougi)
**	    Add support for offset/first "n".
*/
DB_STATUS
psl_do_insert(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*root_node,
	bool		*shareable_qp,
	PST_QTREE	**tree,
	i4		isdbp,
	PST_J_ID	num_joins,
	PSS_Q_XLATE	*xlated_qry,
	DB_SHR_RPTQRY_INFO	**qry_info,
	PST_QNODE	*sort_list,
	PST_QNODE	*first_n,
	PST_QNODE	*offset_n)
{
    DB_TAB_NAME		    view_name;
    PST_QNODE		    *node;
    PST_QNODE		    *subsel;
    i4			    insert_into_view;
    DB_STATUS		    status;
    i4		    err_code;
    register PSS_RNGTAB	    *resrng = cb->pss_resrng;
    PST_PROCEDURE	    *pnode;
    i4		    mask;
    i4                 mask2;
    i4                 qrymod_resp_mask;

    /*
    ** Check the target list to see if there are any
    ** resdoms with pst_ttargtype of PST_USER, if so
    ** convert them to PST_ATTNO.
    */
    for (node = root_node->pst_left;
	 node != (PST_QNODE *) NULL && node->pst_sym.pst_type == PST_RESDOM;
	 node = node->pst_left)
    {
	if (node->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype == PST_USER)
	{
	    node->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_ATTNO;
	}
    }

    /* For repeat queries we must determine if the query is shareable.
    ** We already know that this is an SQL query, so the only criterion
    ** to be checked out is whether all relations/views are DBA owned or
    ** are catalogs.
    */
    if (cb->pss_defqry == PSQ_DEFQRY)
    {
	status = psl_shareable(psq_cb, cb, shareable_qp, qry_info);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }

    /* If inserting into a view save view name for error reporting */

    if (insert_into_view = resrng->pss_tabdesc->tbl_status_mask & DMT_VIEW)
    {
	STRUCT_ASSIGN_MACRO(resrng->pss_tabname, view_name);
    }

    /* Apply qrymod (views, permits, & integrities) */
    status = psy_qrymod(root_node, cb, psq_cb, &num_joins, &qrymod_resp_mask);
    if (status != E_DB_OK)
    {
	return (status);
    }

    /* make sure all mandatory columns have been specified,
    ** and build default CONST nodes for any columns that haven't been specified
    */
    for (subsel = root_node; subsel;
		    subsel = subsel->pst_sym.pst_value.pst_s_root.pst_union.pst_next)
    {
	status = psl_check_defaults(cb, resrng, subsel,
				insert_into_view, &view_name, 
				&psq_cb->psq_error);
	if DB_FAILURE_MACRO(status)
	    return(status);
    }
    
    mask = resrng->pss_tabdesc->tbl_status_mask;
    mask2 = resrng->pss_tabdesc->tbl_2_status_mask;

    /* Make sure base table is updateable;
    ** In case of an index or a non-extended catalog
    ** catalog update privilege must be on.
    ** In case of security catalog make sure 
    ** session has security privilege active
    ** Bug 34079, since 6.0 you were never supposed to be 
    ** able to update a secondary index.  Fixed it so 
    ** the same error is returned whether you have update 
    ** syscat or not (jennifer)
    **
    ** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
    ** allow UPDATE on indexes which are non-extended catalogs
    */
    if (mask & DMT_IDX)
    {
	if (!(   mask & DMT_CATALOG && ~mask & DMT_EXTENDED_CAT
	      && cb->pss_ses_flag & PSS_CATUPD
	      && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
	     )
	   )
	{
	    _VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrng->pss_tabname),
		&resrng->pss_tabname);
	    return(E_DB_ERROR);
	}
    }
    else if (((mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
	     && ~mask & DMT_EXTENDED_CAT
	     && !(cb->pss_ses_flag & PSS_CATUPD))
	     ||
	     ((mask & DMT_SECURE) &&
	       !(cb->pss_ustat & DU_USECURITY)))
    {
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrng->pss_tabname,
			    &resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_INSERT, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				resrng, PSQ_APPEND, &e_error);
		if (local_status > status)
		    status = local_status;

	_VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
	    psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &resrng->pss_tabname),
	    &resrng->pss_tabname);
	return (E_DB_ERROR);
    }
    else if (mask2 & DMT_READONLY)
    {
        (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L, PSF_USERERR, 
                         &err_code, &psq_cb->psq_error, 0);
         return(E_DB_ERROR);
    } 

    /* Create the query tree header */
    status = pst_header(cb, psq_cb, PST_UNSPECIFIED, sort_list,
			root_node, tree, &pnode,
			(isdbp) ? 0 : PST_0FULL_HEADER, xlated_qry);
    if (status != E_DB_OK)
    {
	return (status);
    }

    /* set pst_numjoins.  $Yjoin_id contains the highest join id */
    (*tree)->pst_numjoins = num_joins;

    /* set pst_offsetn, pst_firstn. */
    (*tree)->pst_offsetn = offset_n;
    (*tree)->pst_firstn = first_n;
    
    /* Fix the root in QSF */
    if (pnode != (PST_PROCEDURE *) NULL)
    {
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
    }

    return(status);
}

/*********************************************************************/

DB_STATUS
psl_p_tlist(
	PST_QNODE	**tlist,
	PSS_YYVARS	*yyvarsp,
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb)
{
    register PST_QNODE	    *last_resdom = (PST_QNODE *) NULL;
    register PST_QNODE	    *rsdmnode;
    i4			    reset = FALSE;
    i4		    err_code;
    char		    emptycol[DB_MAXNAME];
    bool		    got_last=FALSE;
    
    (VOID) MEfill(DB_MAXNAME, ' ', (PTR) emptycol);

    cb->pss_stmt_flags |= PSS_PARSING_TARGET_LIST;
    for (rsdmnode = *tlist; rsdmnode != (PST_QNODE *) NULL;
	 rsdmnode = rsdmnode->pst_left)
    {
	PST_SYMBOL	*sym = &rsdmnode->pst_right->pst_sym;

	/*
	** Note that if the right child of a RESDOM is a PST_VAR_NODE, target
	** element must be one of the following:
	** 1) <column name> 
	**    (sym->pst_dataval.db_data==NULL &&
	**    !CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name))
	** 2) [<schema name>.]<table name>.<column name>
	**    (sym->pst_dataval.db_data!=NULL &&
	**     !CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name))
	** 3) [<schema name>.]<table name>.* 
	**    (sym->pst_dataval.db_data!=NULL &&
	**    CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name))
	** 4) plain ol' *
	**    (sym->pst_dataval.db_data==NULL &&
	**    CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name))
	**
	** Cases (3) and (4) will be handled here.  Cases (1) and (2) will
	** be handled (along with all other possible right children of a
	** a RESDOM) psl_p_telem()
	*/

	/*
	** When we process a target list consisting of "*", we create a VAR node
	** with blank attribute name and pst_dataval.db_data == NULL
	*/
	if (sym->pst_type == PST_VAR  &&
	    CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name) &&
	    (sym->pst_value.pst_s_var.pst_atno.db_att_id == PST_STAR_SEEN) &&
	    sym->pst_dataval.db_data == NULL)
	{
	    PST_J_MASK			flist_map;
	    i4				rgno;
	    PST_VAR_NODE		var;
	    register DMT_ATT_ENTRY	**attribute;
	    PST_QNODE			*varnode, *last;
	    PST_QNODE			*rsdm = rsdmnode->pst_left;
	    PSS_RNGTAB			*rngvar;
	    register i4		i;
	    DB_STATUS		status;
	    DB_DT_ID		att_type;
	    i4			att_width;

	    MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&flist_map);
	    cb->pss_rsdmno--;   /*
				** pss_rsdmno was incremented for this dummy
				** RESDOM.  Now we undo it.
				*/
	    
	    /*
	    ** list all attributes
	    **
	    ** make sure that we list columns of tables in the same order as the
	    ** tables have appeared in the FROM-list
	    */

	    for (rgno = -1, got_last = FALSE;
	         (rgno = BTnext(rgno, (char *) &flist_map, PST_NUMVARS)) != -1;
		)
	    {
		rngvar = yyvarsp->rng_vars[rgno];

		var.pst_vno = rngvar->pss_rgno;
		
		/* Start at first attribute */
		for (i = 0, attribute = rngvar->pss_attdesc + 1;
		     i < rngvar->pss_tabdesc->tbl_attr_count;
		     i++, attribute++)
		{
		    if ((*attribute)->att_flags & DMT_F_HIDDEN)
			continue;

		    /* Set up var node for copy into tree */
		    var.pst_atno.db_att_id = (*attribute)->att_number;
		    STRUCT_ASSIGN_MACRO((*attribute)->att_name, var.pst_atname);

		    if ((cb->pss_defqry == PSQ_PREPARE ||
                        psq_cb->psq_mode == PSQ_VIEW) &&
                	rngvar != NULL &&
                	rngvar->pss_inner_rel.pst_j_mask != 0 &&
                	rngvar->pss_var_mask & PSS_INNER_RNGVAR &&
                	(*attribute)->att_type > 0 )
		    {
                	att_type = -(*attribute)->att_type;
			att_width = (*attribute)->att_width+1;
		    }
		    else
		    {
                	att_type = (*attribute)->att_type;
			att_width = (*attribute)->att_width;
		    }


		    /* Create the PST_VAR_NODE */
		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
			(DB_DT_ID) (*attribute)->att_type,
			(i2) (*attribute)->att_prec,
			(i4) (*attribute)->att_width, (DB_ANYTYPE *) NULL,
			&varnode, &psq_cb->psq_error, (i4) 0);
		    if (DB_FAILURE_MACRO(status))
			return (status);
		    varnode->pst_sym.pst_dataval.db_collID =
						(*attribute)->att_collID;

		    /* Create the corresponding result domain node */
		    status = pst_adresdom((char *) &(*attribute)->att_name, 
			rsdm, varnode, cb, psq_cb, &rsdm);
		    if (DB_FAILURE_MACRO(status))
			return (status);

		    if (!got_last)
		    {
			/* remember the bottom element of the new resdom chain*/
			last = rsdm;
			got_last=TRUE;
		    }
		    
		    /* if (check_tuple_width)
		    {
			/* 
			** add width of this attribute to the width of the tuple
			** if, prior to entering this loop, we have determined 
			** that we need to verify that the width of the tuple 
		        tuple_width += (*attribute)->att_width;
		    }*/
		}	/* end of columns in table */
	    }	/* end of tables in flist_map */

	    /*
	    ** To prevent problems with "select * X" where X != "from"
	    ** we have to check whether rsdmnode exists.
	    */
	    if (rsdm == (PST_QNODE *) NULL)
	    {
		(VOID) psf_error(2104L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    /*
	    ** now we need to make sure that the top element of the new
	    ** chain of RESDOMs is properly linked into the existing chain
	    */
	    if (last_resdom != (PST_QNODE *) NULL)
	    {
		last_resdom->pst_left = rsdm;
		if (i != 1)
		{
		    /*
		    ** if number of attributes is different from 1, and this
		    ** RESDOM node was not the top node in the chain, resdom
		    ** numbers will have to be reset
		    */
		    reset = TRUE;
		}
	    }
	    else
	    {
		/*
		** var.* was the last element of the target list (the
		** corresponding RESDOM node was the first node in the chain of
		** RESDOMs representing the target list)
		*/
		*tlist = rsdm;
	    }
	    
	    /*
	    ** remember the last resdom node of the new chain as the last
	    ** node processed; 
	    */
	    last_resdom = /* rsdmnode = */ last;
	}	/* end of "select *, ..." */
	
	else if (sym->pst_type == PST_VAR		&&
	    sym->pst_dataval.db_data != NULL 	&&
	    MEcmp((PTR)(sym->pst_value.pst_s_var.pst_atname.db_att_name), 
		(PTR)emptycol, DB_MAXNAME) == 0  &&
	    (sym->pst_value.pst_s_var.pst_atno.db_att_id == PST_STAR_SEEN)
	   )
	{
	    i4		err_code;
	    PST_VAR_NODE	var;
	    DMT_ATT_ENTRY	**attribute;
	    register i4	i;
	    PST_QNODE		*varnode;
	    /*
	    ** rsdm is set to the left child of the current resdom  node to
	    ** ensure that the new RESDOM chain is linked properly into the
	    ** target list
	    */
	    PST_QNODE		*rsdm = rsdmnode->pst_left;
	    PST_QNODE		*last;
	    char		tabname[sizeof(DB_TAB_NAME) + 1];
	    PSS_TBL_REF		*tbl_ref;
	    PSS_RNGTAB		*rngtab;
	    DB_STATUS		status;
	    DB_DT_ID		att_type;
	    i4			att_width;

            reset = TRUE;            /* any "x.*" requires reset */         
	    tbl_ref = (PSS_TBL_REF *) sym->pst_dataval.db_data;
	    MEcopy((PTR) &tbl_ref->pss_tab_name, sizeof(DB_TAB_NAME),
	           (PTR) tabname);
	    tabname[sizeof(DB_TAB_NAME)] = '\0';
	    (VOID) STtrmwhite(tabname);

	    /* need to look for range var at proper scope */

	    /* Look for an already-existing range var of this name */
	    status = pst_slook(&cb->pss_auxrng, cb, tbl_ref->pss_schema_name,
		tabname, &rngtab, &psq_cb->psq_error, TRUE);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /* If not found, error - table not in from list */
	    if (rngtab == (PSS_RNGTAB *) NULL)
	    {
		/* table not found */
		(VOID) psf_error(2118L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1, STlength(tabname),
				 tabname);
		return (E_DB_ERROR);
	    }

	    cb->pss_rsdmno--;		/* account for a dummy RESDOM */
	    /* Start at first attribute */
	    got_last=FALSE;
	    for (i = 0, attribute = rngtab->pss_attdesc + 1;
		 i < rngtab->pss_tabdesc->tbl_attr_count;
		 i++, attribute++)
	    {
		/*
		** Skip hidden attributes (makes x.* and * consistent)
		*/
	        if ((*attribute)->att_flags & DMT_F_HIDDEN)
			continue;

		/* Set up var node for copy into tree */
		var.pst_vno = rngtab->pss_rgno;
		var.pst_atno.db_att_id = (*attribute)->att_number;
		STRUCT_ASSIGN_MACRO((*attribute)->att_name, var.pst_atname);

                if ((cb->pss_defqry == PSQ_PREPARE ||
                        psq_cb->psq_mode == PSQ_VIEW) &&
                    rngtab != NULL &&
                    rngtab->pss_inner_rel.pst_j_mask != 0 &&
                    rngtab->pss_var_mask & PSS_INNER_RNGVAR &&
                    (*attribute)->att_type > 0 )
		{
                    att_type = -(*attribute)->att_type;
		    att_width = (*attribute)->att_width+1;
		}
		else
		{
                    att_type = (*attribute)->att_type;
		    att_width = (*attribute)->att_width;
		}

		/* Create the PST_VAR_NODE */
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
		    att_type, (i2) (*attribute)->att_prec, att_width,
		    (DB_ANYTYPE *) NULL, &varnode, &psq_cb->psq_error, (i4) 0);
		if (DB_FAILURE_MACRO(status))
		    return (status);
		varnode->pst_sym.pst_dataval.db_collID =
						(*attribute)->att_collID;

		/* Create the corresponding result domain node */
		status = pst_adresdom((char *) &(*attribute)->att_name,
		    rsdm, varnode, cb, psq_cb, &rsdm);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		if (!got_last)
		{
		    /* remember the bottom element of the new resdom chain*/
		    last = rsdm;
		    got_last=TRUE;
		}
	    }

	    /*
	    ** now we need to make sure that the top element of the new
	    ** chain of RESDOMs is properly linked into the existing chain
	    */
	    if (last_resdom != (PST_QNODE *) NULL)
	    {
		last_resdom->pst_left = rsdm;
		if (i != 1)
		{
		    /*
		    ** if number of attributes is different from 1, and this
		    ** RESDOM node was not the top node in the chain, resdom
		    ** numbers will have to be reset
		    */
		    reset = TRUE;
		}
	    }
	    else
	    {
		/*
		** var.* was the last element of the target list (the
		** corresponding RESDOM node was the first node in the chain of
		** RESDOMs representing the target list)
		*/
		*tlist = rsdm;
	    }
	    
	    /*
	    ** remember the last resdom node of the new chain as the last
	    ** node processed; 
	    */
	    last_resdom = /* rsdmnode = */ last;
	}
	else
	{
	    PSS_RNGTAB  *rngtable = NULL;
	    DB_STATUS	status;
	    i4		save_type = sym->pst_type;
	    
	    status = psl_p_telem(cb, psq_cb, &rsdmnode->pst_right, yyvarsp,
				&rngtable, (i4)0);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	    
	    last_resdom = rsdmnode;

	    /*
	    ** Now we need to change some fields inside the RESDOM node.
	    ** 1) if (type of the right child changed from PST_VAR to PST_CONST
	    **        AND (RESDOM represents a local dbproc variable OR
	    **	           user has not explicitly named the RESDOM)
	    **	     )
	    **	  {
	    **	      reset pst_rsname to all blanks.
	    **	  }
	    ** 2) if RESDOM represents a local dbproc variable
	    **	  {
	    **	      invoke pst_parm_resolve();
	    **	  }
	    **	  else
	    **	  {
	    **	      reset RESDOM's db_datavalue (except for db_data) to that
	    **	      of its right child.
	    **	  }
	    */

	    if (save_type == PST_VAR				    &&
	        rsdmnode->pst_right->pst_sym.pst_type == PST_CONST  &&
		(rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype ==
		     PST_LOCALVARNO ||
		 rsdmnode->pst_sym.pst_type == PST_RESDOM
		)
	       )
	    {
		MEfill(sizeof(DB_ATT_NAME), (u_char) ' ',
		    (PTR) rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
	    }

	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype ==
		     PST_LOCALVARNO)
	    {
		status = pst_parm_resolve(cb, psq_cb, rsdmnode);
		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
	    }
	    else 
	    {
		/*
		** Note that the right subtree may have contained PST_VAR(s), so
		** we would have no idea as to its datavalue
		*/

		DMT_ATT_ENTRY		coldesc;

		status = pst_rsdm_dt_resolve(rsdmnode->pst_right, &coldesc, 
                    cb, psq_cb);
		if (DB_FAILURE_MACRO(status))
		    return(status);

		rsdmnode->pst_sym.pst_dataval.db_datatype = coldesc.att_type;
		rsdmnode->pst_sym.pst_dataval.db_length   = coldesc.att_width;
		rsdmnode->pst_sym.pst_dataval.db_prec     = coldesc.att_prec;
		rsdmnode->pst_sym.pst_dataval.db_collID   = coldesc.att_collID;

		if ((cb->pss_defqry == PSQ_PREPARE || psq_cb->psq_mode == PSQ_VIEW) &&
		    rngtable != NULL &&
		    rngtable->pss_inner_rel.pst_j_mask != 0 &&
		    rsdmnode->pst_sym.pst_dataval.db_datatype > 0 &&
		    rngtable->pss_var_mask & PSS_INNER_RNGVAR)
		{
		    rsdmnode->pst_sym.pst_dataval.db_datatype = 
			- (rsdmnode->pst_sym.pst_dataval.db_datatype);
		    rsdmnode->pst_sym.pst_dataval.db_length++;
		}
	    }

	    /*
	    ** pst_type may have been set to PSS_2RESDOM if the user has
	    ** explicitly named the RESDOM
	    */
	    rsdmnode->pst_sym.pst_type = PST_RESDOM;
	}
    }
    /* If we have to reset resdom numbers, we'll do it here */
    if (reset)
    {
	register i4	    i;

	for (rsdmnode = *tlist, i = cb->pss_rsdmno;
	     i > 0;
	     i--, rsdmnode = rsdmnode->pst_left)
	{
	    rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_rsno = i;

	    /*
	    ** Note that if RESDOM represents local dbproc variable, pst_ntargno
	    ** would be reset and no longer needs to be equal to pst_rsno
	    */
	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype !=
		     PST_LOCALVARNO)
	    {
		rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = i;
	    }
	}
    }
    cb->pss_stmt_flags &= ~PSS_PARSING_TARGET_LIST;
    return(E_DB_OK);
}

/**********************************************************************/
/*
** Name: psl_p_telem - process prototype target list tree elements including
**		       PST_VAR nodes representing column references of form
**		       [[<schema>.]<table>.]<column>
** Description:
**
**	This routine re-scans a target list, doing type resolution.
**	Since SQL puts the result list before the FROM list, when the
**	result list (target list) is parsed, we may not have complete
**	type information (or any type information at all).  This routine
**	walks a target list tree node, performing type resolution.
**	Operator nodes are handled by walking the children and applying
**	type resolution to the operator.  Constants and sequence operators
**	have known type already, so there's nothing to do.
**
**	VAR nodes are the most interesting.  If it's a qualified
**	table.column reference, we verify that the table name is in
**	the FROM list, and extract and apply column type info.
**	If it's an unqualified name, it might be a DB procedure variable,
**	or an unqualified column name;  we dig around to resolve the
**	name reference, and then apply the proper type.
**
**	A similar sort of type-deferral is done when parsing CHECK
**	constraints defined as part of a CREATE TABLE, or ALTER TABLE
**	ADD COLUMN.  (i.e. not alter table add constraint.)  The
**	CHECK predicate may refer to columns not yet (fully) defined,
**	so a prototype tree is build and later handed here for resolution.
**	To distinguish this case from the normal call, the
**	PSS_RESOLVING_CHECK_CONS flag is set in pss_stmt_flags.
**
**	This is where we apply "i4 tid" compatability.  Tids have been
**	i4 for forever, until release 3 when they became i8 (at least
**	outside of DMF).  Even though everyone knows you're not supposed
**	to materialize tids into a user app, everyone does it, including
**	QBF.  It would be nice to allow older client binaries running
**	e.g. over Ingres-Net to still work, since most tids still look
**	like i4's.  (The current exception being partitioned tables.)
**	If the i4 tid compatability flag is on, and we're doing a pure
**	select (not insert/select or create/select), and we're not in a
**	database procedure, and we're in the outermost subquery nesting
**	level, make tids look like i4's instead of i8.  (All the conditions
**	are intended to only hack tids that actually return to the
**	client, not tids that are unmaterialized or only materialized
**	into database procedures.)  This way, we won't confuse the
**	presumably older-version client with our i8 type information.
**
** Input:
**	cb			PSS_SESBLK Parser session block
**	psq_cb			Query parse control block
**	node			PST_QNODE ** Ptr to pointer to tree node
**	yyvarsp			Pointer to yacc state information
**	rngtable		PSS_RNGTAB ** an output
**
** Output:
**	rngtable		If VAR encountered, set to range table
**				entry for the column-ref's table.  Pass
**				NULL if caller doesn't care.
**
** Returns:
**
** Side effects:
**
** History:
**	...
**
**	11-feb-93 (andre)
**	    add support for referencing a TID of a base table through an
**	    updatable views based on that table.
**	07-may-93 (andre)
**	    psl_p_telem() may now be called to process a prototype tree built to
**	    represent <search condition> of a CHECK constraint specified inside
**	    CREATE TABLE statement
**	27-may-93 (rblumer)
**	    added a case for AND, OR, and NOT nodes, now that this function is
**	    used for CHECK constraints, too.
**	03-feb-95 (forky01)
**	    Add check for SELECT COUNT(*) to have FROM list. Fixes bug 66610.
**	20-Apr-1999 (shero03)
**	    Support PST_MOP (3 & 4 operands)
**	3-sep-99 (inkdo01)
**	    Add support of case function.
**	11-mar-02 (inkdo01)
**	    Added sequence support.
**	3-Feb-2005 (schka24)
**	    Added i4 tid hack; add routine description; changed call sequence
**	    (unnecessarily, as it turned out, but it's shorter this way).
**	4-july-05 (inkdo01)
**	    Transform COUNT(expr) to COUNT(*) if expr is not nullable. This 
**	    allows reduction in number of COUNTs to be done in the face of 
**	    multiple AVG expressions (SIR 114788).
**	12-aug-05 (inkdo01)
**	    Unmodify parse tree in the case of avg() on date/decimal types.
**	30-Aug-2005 (schka24)
**	    Extend i4-tid hack to sum(int), since we're now forcing sum
**	    to return an i8 in the FI definitions.  Pre-r3 clients don't
**	    know what to do with i8's, so for those clients, make sum
**	    in the result list look like i4 again.
**	1-nov-05 (inkdo01)
**	    Add Star dbs into Karl's hack for i4 sums.
**	04-nov-05 (toumi01)
**	    Hack the hack for avg(x) to sum(x)/count(x) tranformation
**	    for the decimal datatype, to fix precision/scale. This is
**	    because the scale for sum(x) is that of the operand, but
**	    it is that value plus one for avg(x).
**	    Pass PST_XFORM_AVG down to operands via the xform_avg
**	    function argument and use this to set PSS_XFORM_AVG to be
**	    used when we create the operand node.
**	    While doing this change noticed and removed redundant test
**	    "if (aop_node->pst_left)".
**	14-nov-05 (toumi01)
**	    Adjust Star test for hack for i4 sums to take into account other
**	    conditions before decrementing pst_sym.pst_dataval.db_length.
**	23-mar-06 (dougi)
**	    Verify that "count(expr)" being converted to "count(*)" isn't
**	    based on column that's inner to an outer join.
**	12-dec-06 (gupsh01)
**	    Sum and Avg operations are not supported for ANSI date/time types,
**	    it is valid only for interval types.
*/
DB_STATUS
psl_p_telem(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**node,
	PSS_YYVARS	*yyvarsp,
        PSS_RNGTAB      **rngtable,
	i4		xform_avg)
{
    PST_J_MASK	    *from_list_stack = &yyvarsp->flists[0];
    PST_SYMBOL	    *sym;
    DB_STATUS	    status = E_DB_OK;
    i4	    	    err_code;
        
    if (*node == (PST_QNODE *) NULL)
    {
	return(E_DB_OK);
    }
    
    sym = &(*node)->pst_sym;

    if (((sym->pst_type == PST_UOP) || (sym->pst_type == PST_BOP)) &&
	(sym->pst_value.pst_s_op.pst_flags & PST_XFORM_AVG))
	xform_avg = TRUE;

    switch (sym->pst_type)
    {
	case PST_CONST:
	case PST_COP:
	case PST_SEQOP:
	{
	    break;
	}
	case PST_BOP:
	{
	    /*
	    ** here we will call psl_p_telem() recursively to process both
	    ** children of a PST_BOP before doing type resolution
	    */
	    if ((*node)->pst_left)
		status = psl_p_telem(cb, psq_cb, &(*node)->pst_left, yyvarsp,
				rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }

	    /* If this is a "/" introduced for the transformation of 
	    ** "avg(x)" to "float8(sum(x)) / count(x)" AND "x" is date
	    ** date type, the whole expression is turned back into "avg(x)". */
	    if ((*node)->pst_sym.pst_value.pst_s_op.pst_flags & PST_XFORM_AVG)
	    {
		DB_DT_ID	dtype = abs((*node)->pst_left->
					pst_sym.pst_dataval.db_datatype);

		if ((dtype == DB_ADTE_TYPE) ||
		    (dtype == DB_TMWO_TYPE) ||
		    (dtype == DB_TMW_TYPE)  ||
		    (dtype == DB_TME_TYPE)  ||
		    (dtype == DB_TSWO_TYPE) ||
		    (dtype == DB_TSW_TYPE)  ||
		    (dtype == DB_TSTMP_TYPE)) 
	        {
		    /* Avg operation is not supported for these types */
		    (VOID) psf_error(9362, 0L, PSF_INTERR,
		        &err_code, &psq_cb->psq_error, 0);
		    return(E_DB_ERROR);
	        }

		if ((dtype == DB_DTE_TYPE) ||
		    (dtype == DB_INDS_TYPE) ||
		    (dtype == DB_INYM_TYPE))
		{
		    *node = (*node)->pst_left;	/* skip the whole xform */
		    (*node)->pst_left->pst_sym.pst_value.pst_s_op.
						pst_opno = ADI_AVG_OP;
						/* update AOP under AGHEAD */

		    /* Redo type res to locate AVG fi stuff. */
		    status = pst_node(cb, &cb->pss_ostream, (*node)->
			pst_left->pst_left, (*node)->pst_left->pst_right, 
			PST_AOP, (char *) NULL, 0, DB_NODT, (i2) 0, (i4) 0, 
			(DB_ANYTYPE *) NULL, &(*node)->pst_left, 
			&psq_cb->psq_error, PSS_TYPERES_ONLY);

		    if (status != E_DB_OK)
		    {
			return(status);
		    }
		    break;
		}
	    }

	    if ((*node)->pst_right)
	       status = psl_p_telem(cb, psq_cb, &(*node)->pst_right, yyvarsp,
				 rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }

	    /*
	    ** we use a hack to represent ternary functions: 2-nd and third args
	    ** are represented by children of a dummy PST_CONST node hanging off
	    ** pst_right ptr of the PST_BOP node.
	    */
	    if (   (*node)->pst_right->pst_sym.pst_type == PST_CONST
		&& (*node)->pst_right->pst_left  != (PST_QNODE *) NULL
		&& (*node)->pst_right->pst_right != (PST_QNODE *) NULL
	       )
	    {
		PST_QNODE	    *dummy = (*node)->pst_right;

		/*
		** a ternary function masquerading as a binary.  2-nd and 3-rd
		** parameters are represented by left and right children of a
		** dummy PST_CONST node.  We have already dealt with the first
		** parameter, now handle the remaining two
		*/
		
		/* Process the 2-nd arg */
	        if (dummy->pst_left)
		   status = psl_p_telem(cb, psq_cb, &dummy->pst_left, yyvarsp,
		       rngtable, xform_avg);
		if (status != E_DB_OK)
		{
		    return(status);
		}

		/* Process the 3-rd arg */
	        if (dummy->pst_right)
		    status = psl_p_telem(cb, psq_cb, &dummy->pst_right, yyvarsp,
		        rngtable, xform_avg);
		if (status != E_DB_OK)
		{
		    return(status);
		}

		/*
		** perform additional processing for ternary functions
		** for the time being it consists of verifying that function is
		** DECIMAL(), validating specified precision and scale, and
		** combining precision and scale inside the node describing
		** precision (i.e. the second argument)
		*/
		status = psl_3ary_func_extra_proc(
		    (i4) sym->pst_value.pst_s_op.pst_opno,
		    dummy->pst_left, dummy->pst_right,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);

		/* We no longer need the dummy PST_CONST node */
		(*node)->pst_right = dummy->pst_left;
	    }
	    else
	    {
		/*
		** a truly binary function
		** 
		** perform additional processing for binary functions
		** for the time being it consists of checking types of second
		** attribute passed to several of binary functions or, if
		** function was DECIMAL(), of validating specified precision,
		** determining scale and combining precision and scale inside
		** the node describing precision
		*/
		status = psl_2ary_func_extra_proc(cb,
		    (i4) sym->pst_value.pst_s_op.pst_opno,
		    (*node)->pst_left, (*node)->pst_right,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	    
	    /* Finally we are ready to perform type reslolution */
	    status = pst_node(cb, &cb->pss_ostream, (*node)->pst_left,
	        (*node)->pst_right, PST_BOP, (char *) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, node, &psq_cb->psq_error,
		PSS_TYPERES_ONLY);

	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    break;
	}
	case PST_UOP:
	{
	    /* First we process the left child */
	    if ((*node)->pst_left)
		status = psl_p_telem(cb, psq_cb, &(*node)->pst_left, yyvarsp,
				rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }

	    /* If this is a "float8()" introduced for the transformation of 
	    ** "avg(x)" to "float8(sum(x)) / count(x)" AND "x" is either
	    ** decimal or date type, the "float8" is removed for the decimal
	    ** case, and the whole transform is reversed for the date case. */
	    if ((*node)->pst_sym.pst_value.pst_s_op.pst_flags & PST_XFORM_AVG)
	    {
		DB_DT_ID	dtype = abs((*node)->pst_left->
					pst_sym.pst_dataval.db_datatype);

		if ((dtype == DB_DEC_TYPE) || (dtype == DB_DTE_TYPE) || 
			(dtype == DB_INYM_TYPE) || (dtype == DB_INDS_TYPE))
		{
		    *node = (*node)->pst_left;	/* skip the float8() */
		    break;
		}
		if ( dtype == DB_ADTE_TYPE || dtype == DB_TME_TYPE || 
		     dtype == DB_TMWO_TYPE || dtype == DB_TMW_TYPE || 
		     dtype == DB_TSW_TYPE  || dtype == DB_TSWO_TYPE ||
		     dtype == DB_TSTMP_TYPE )
		{
		    (VOID) psf_error(9362, 0L, PSF_INTERR,
				&err_code, &psq_cb->psq_error, 0);
		    return(E_DB_ERROR);
		}
	    }

	    /*
	    ** additional processing for unary functions.  For the time
	    ** being, it will consist of setting default precision and scale
	    ** for specified argument to decimal() function (now that we
	    ** know what that argument is)
	    */
	    status = psl_1ary_func_extra_proc(cb,
		(i4) sym->pst_value.pst_s_op.pst_opno, (*node)->pst_left,
		&(*node)->pst_right, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    if (sym->pst_value.pst_s_op.pst_opno == ADI_DEC_OP)
	    {
		/* Our opnode has just become a BOP */
		sym->pst_type = PST_BOP;
	    }

	    /* now call pst_node() to perform type resolution */
	    status = pst_node(cb, &cb->pss_ostream, (*node)->pst_left,
	        (*node)->pst_right, sym->pst_type,
		(char *) &(*node)->pst_sym.pst_value.pst_s_op,
		sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, node, &psq_cb->psq_error,
		PSS_TYPERES_ONLY);

	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    break;
	}
	case PST_MOP:
	{
	    PST_QNODE	*lqnode;
	    /*
	    ** here we will call psl_p_telem() recursively to process all
	    ** children of a PST_MOP before doing type resolution
	    */
	    lqnode = *node;
	    while (lqnode)
	    {
	        if (lqnode->pst_right)
	           status = psl_p_telem(cb, psq_cb, &lqnode->pst_right,
				 yyvarsp, rngtable, xform_avg);
	        if (status != E_DB_OK)
	        {
		    return(status);
	        }
		lqnode = lqnode->pst_left;
	    }

	    /*  Currently there is no other processing for 3rd or 4th operands */
	    
	    /* Finally we are ready to perform type reslolution */
	    status = pst_node(cb, &cb->pss_ostream, (*node)->pst_left,
	        (*node)->pst_right, PST_MOP, (char *) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, node, &psq_cb->psq_error,
		PSS_TYPERES_ONLY);

	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    break;
	}
	case PST_AGHEAD:
	{
	    PST_QNODE		*aop_node;
	    PST_QNODE           *var_node;
	    YYAGG_NODE_PTR	*agglist_elem;
            ADF_CB              *adf_scb = (ADF_CB*) cb->pss_adfcb;

	    /*
	    ** PST_AGHEAD nodes should not happen if we are resolving a
	    ** prototype tree built to represent <search condition> of a CHECK
	    ** constraint specified inside CREATE TABLE statement
	    */
	    if (cb->pss_stmt_flags & PSS_RESOLVING_CHECK_CONS)
	    {
		(VOID) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		    &err_code, &psq_cb->psq_error, 0);
		return(E_DB_ERROR);
	    }


	    /*
	    ** AGHEAD will have AOP as a left child.  AOP may or may not have a
	    ** left child.  First we will process AOP's left child, then we will
	    ** perform type resolution on AOP, and finally we will copy AOP's
	    ** db_dataval into AGHEAD's db_dataval.
	    */
	    /* process AOP's left child, if any */
	    aop_node = (*node)->pst_left;
	    if (aop_node->pst_left != (PST_QNODE *) NULL)
	    {
		status = psl_p_telem(cb, psq_cb, &aop_node->pst_left,
				     yyvarsp, rngtable, xform_avg);
		if (status != E_DB_OK)
		{
		    return(status);
		}
	    }

	    /*
	    ** With the advent of binary staistical aggregate functions, AOP may
	    ** also have a right child to resolve. We do that here.
	    */
	    if (aop_node->pst_right != (PST_QNODE *) NULL)
	    {
		status = psl_p_telem(cb, psq_cb, &aop_node->pst_right,
				     yyvarsp, rngtable, xform_avg);
		if (status != E_DB_OK)
		{
		    return(status);
		}
	    }

	    /* COUNT(expr) becomes COUNT(*) when "expr" is not nullable and
	    ** COUNT is not DISTINCT. */
	    if (aop_node->pst_sym.pst_value.pst_s_op.pst_opno == ADI_CNT_OP
	      && aop_node->pst_sym.pst_value.pst_s_op.pst_distinct == PST_NDISTINCT
	      && aop_node->pst_left->pst_sym.pst_dataval.db_datatype > 0
	      && psl_aop_nooj(aop_node->pst_left, yyvarsp))
	    {
		aop_node->pst_sym.pst_value.pst_s_op.pst_opno = ADI_CNTAL_OP;
		aop_node->pst_left = (PST_QNODE *) NULL;
	    }

	    /* SELECT COUNT(*) must have a from list */
	    if ( aop_node->pst_sym.pst_value.pst_s_op.pst_opno == ADI_CNTAL_OP
	      && ( BTcount((char *)&from_list_stack[cb->pss_qualdepth],
			PST_NUMVARS) == 0))
	    {
		(VOID) psf_error(2440L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return(E_DB_ERROR);
	    }

	    /*
	    ** now call pst_node() to perform type resolution on AGHEAD's left
	    ** child
	    */

	    {
		int		pss_flags = PSS_TYPERES_ONLY;
		/*
		** if this is an avg(x) to sum(x)/count(x) transformation then
		** we have to adjust the result precision - tell pst_node that
		*/
		if (xform_avg == TRUE)
		    pss_flags |= PSS_XFORM_AVG;
		status = pst_node(cb, &cb->pss_ostream, aop_node->pst_left,
		    aop_node->pst_right, PST_AOP, (char *) NULL, 0, DB_NODT,
		    (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &aop_node,
		    &psq_cb->psq_error, pss_flags);
	    }

	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    (*node)->pst_left = aop_node;

            /* If this AOP is sum(int), and it's not from the avg transform,
            ** and it's really in the result list and not in some other
            ** context like an insert/select or a DBP, and we're in i4-tid
            ** compatibility mode (meaning that we have an old-fashioned
            ** client that doesn't understand i8's), reset the sum result
            ** length back to i4.  Normally sum(int) is forced to i8 so
            ** that we can do maximum CSE elimination with avg's.
            **
            ** If the compatibility hack applies, reduce i8's to i4's,
            ** watching out for nullables...
            */
            if (!(adf_scb->adf_proto_level & AD_I8_PROTO)
              && aop_node->pst_sym.pst_value.pst_s_op.pst_opno == ADI_SUM_OP
              && (aop_node->pst_sym.pst_value.pst_s_op.pst_flags & PST_AVG_AOP) == 0
              && ! yyvarsp->isdbp
              && abs(aop_node->pst_sym.pst_dataval.db_datatype) == DB_INT_TYPE
              && cb->pss_qualdepth == 1
              && (psq_cb->psq_mode == PSQ_RETRIEVE || psq_cb->psq_mode == PSQ_DEFCURS)
              && (cb->pss_stmt_flags & PSS_PARSING_INSERT_SUBSEL) == 0 )
                aop_node->pst_sym.pst_dataval.db_length -= 4;

	    /* Finally copy db_dataval from AOP to AGHEAD */
	    STRUCT_ASSIGN_MACRO(aop_node->pst_sym.pst_dataval,
				(*node)->pst_sym.pst_dataval);

	    (*node)->pst_sym.pst_dataval.db_data = (PTR) NULL;
	    
	    /*
	    ** we had to wait until now before checking for illegal use of
	    ** aggregates in where_clause and appending AGGHEAD to the
	    ** appropriate AGGHEAD list
	    */
	    if ((var_node = psl_find_node(aop_node, PST_VAR)) !=
		    (PST_QNODE *) NULL
		&&
	        BTtest(var_node->pst_sym.pst_value.pst_s_var.pst_vno,
		       (char *) &yyvarsp->illegal_agg_relmask))
	    {
		(VOID) psf_error(2930L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    /* allocate a new element of AGGHEAD list */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(YYAGG_NODE_PTR),
		(PTR *) &agglist_elem, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    agglist_elem->agg_node = *node;

	    /* insert it into approprite AGGHEAD list */
	    psl_insert_into_agg_list(var_node, agglist_elem, 
				&yyvarsp->agg_list_stack[0],
				     cb->pss_qualdepth, from_list_stack);
	    break;
	}
	case PST_VAR:
	{
	    register DB_ATT_NAME    *colname =
					&sym->pst_value.pst_s_var.pst_atname;

	    /*
	    ** PST_VAR nodes found in a prototype tree representing <search
	    ** condition> of a CHECK constraint specified inside CREATE TABLE
	    ** statement are handled differently from those in a prototype tree
	    ** representing <target list>
	    */
	    if (cb->pss_stmt_flags & PSS_RESOLVING_CHECK_CONS)
	    {
		QEU_CB			*qeu_cb = (QEU_CB *) cb->pss_object;
		DMU_CB			*dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
		i4			col_id;
		PST_CREATE_INTEGRITY	*crt_integ;
		DB_COLUMN_BITMAP	*integ_cols;
		DMU_ATTR_ENTRY		**attrs, *cur_attr;
		PST_VAR_NODE		varnode;

		col_id = psl_find_column_number(dmu_cb, colname);

		if (col_id == -1)
		{
		    /* attribute with specified name not found */
		    char        command[PSL_MAX_COMM_STRING];
		    i4	length;
		    
		    psl_command_string(psq_cb->psq_mode, DB_SQL,
			command, &length);

		    if (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN)
		    {
		    /* 
		    ** the following ugly logic gets triggered when a 
		    ** check constraint expression which accompanies a column 
		    ** defined with an "alter table add column" statement
		    ** references a column other than the one being added. 
		    ** This is illegal in a column constraint. The ugly
		    ** part is that we can only recognize this condition
		    ** based upon the failure of the PST_VAR resolution 
		    ** call. And it fails because for architectural reasons,
		    ** the list of other columns in the table is not 
		    ** currently available.
		    */
			char	    *tabname;
			DMU_ATTR_ENTRY	**attrs = (DMU_ATTR_ENTRY **) 
			    dmu_cb->dmu_attr_array.ptr_address;

			/*
			** column-level constraint can only be specified using
			** CREATE TABLE statement, so look in dmu_cb for info.
			*/
		    
			tabname = dmu_cb->dmu_table_name.db_tab_name;
			colname = (DB_ATT_NAME *)attrs[0];

			_VOID_ psf_error(E_PS0472_COL_CHECK_CONSTRAINT, 0L,
			    PSF_USERERR, &err_code, &psq_cb->psq_error,
			    3, length, command,
			    psf_trmwhite(sizeof(DB_ATT_NAME), 
			    colname->db_att_name), colname->db_att_name,
			    psf_trmwhite(sizeof(DB_TAB_NAME), tabname), 
			    tabname);
			return(E_DB_ERROR);
		    }
		
		    _VOID_ psf_error(E_PS0483_CONS_NO_COL, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 3,
			length, command,
			psf_trmwhite(sizeof(DB_ATT_NAME), colname->db_att_name),
			colname->db_att_name,
			sizeof(ERx("CHECK")) - 1, ERx("CHECK"));
		    return (E_DB_ERROR);
		}

		/*
		** set the bit corresponding to this attribute in the attribute
		** map inside DB_INTEGRITY
		*/
		crt_integ =
		    &cb->pss_cur_cons_stmt->pst_specific.pst_createIntegrity;
		integ_cols = &crt_integ->pst_integrityTuple->dbi_columns;

		BTset(col_id, (char *) integ_cols);

		/*
		** now that we know the number, type, length, etc. of the
		** attribute, place that info into PST_VAR node
		*/
		attrs = (DMU_ATTR_ENTRY **) dmu_cb->dmu_attr_array.ptr_address;
		cur_attr = attrs[col_id - 1];

		varnode.pst_vno = 0;
		varnode.pst_atno.db_att_id = col_id;
		STRUCT_ASSIGN_MACRO((*colname), varnode.pst_atname);

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
		    sizeof(varnode), (DB_DT_ID) cur_attr->attr_type,
		    (i2) cur_attr->attr_precision, (i4) cur_attr->attr_size,
		    (DB_ANYTYPE *) NULL, node, &psq_cb->psq_error, PSS_NOALLOC);

		if (DB_FAILURE_MACRO(status))
		    return(status);
		(*node)->pst_sym.pst_dataval.db_collID =
						cur_attr->attr_collID;

		/* there is no more to be done for this node */
		break;
	    }
	    
	    /*
	    ** colname->db_att_name is guaranteed to be non-blank (i.e. we are
	    ** dealing with [var.]cname since the cases when it would be blank
	    ** would have been handled elsewhere
	    **
	    ** if db_data was set to NULL, attribute name was not qualified
	    ** by variable name.
	    */
	    if (sym->pst_dataval.db_data == NULL)
	    {
		PST_QNODE	        *newnode = (PST_QNODE *) NULL;
		DB_STATUS		status;
		PST_J_MASK		*from_list =
					    &from_list_stack[cb->pss_qualdepth];
		PSS_RNGTAB		*rngvar = NULL;
		bool			found = FALSE;
		PSS_DECVAR		*var;

		if (yyvarsp->isdbp)
		{
		    /* Search for the variable; innermost scope first. */
		    for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
			 var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
			 var = (PSS_DECVAR *) var->pss_queue.q_next
			)
		    {
			if (var->pss_out)
			    continue;

			if (MEcmp((PTR) colname, (PTR) &var->pss_varname,
			    sizeof(var->pss_varname)) == 0
			   )
			{
			    found = TRUE;
			    break;
			}
		    }
		}

		/*
		** For each range entry look for attribute in relation in
		** the FROM list.  If there is no FROM list, do not bother
		** to call psl_fatt()
		*/

		if (BTcount((char *)from_list, PST_NUMVARS) == 0)
		{
		    /* If column was not found but there is a var */
		    if (yyvarsp->isdbp && found)
		    {
			/*
			** Fill in a CONST node.  We may have to allocate
			** additional space to hold the data value.
			*/
			PST_CNST_NODE	cconst;

			/* Parm or local variable */
			cconst.pst_tparmtype = PST_LOCALVARNO;
			cconst.pst_parm_no = var->pss_no;
			cconst.pst_pmspec  = PST_PMNOTUSED;
			cconst.pst_cqlang = DB_SQL;
			cconst.pst_origtxt = (char *) NULL;
			status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
			    sizeof(cconst), var->pss_dbdata.db_datatype,
			    (i2) var->pss_dbdata.db_prec,
			    (i4) var->pss_dbdata.db_length, 
			    (DB_ANYTYPE *) var->pss_dbdata.db_data,
			    node, &psq_cb->psq_error, PSS_NOALLOC);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }
		    else
		    {
			(VOID) psf_error(2103L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 2,
			    (i4) sizeof(cb->pss_lineno),
			    &cb->pss_lineno,
			    psf_trmwhite(DB_MAXNAME, colname->db_att_name),
			    colname->db_att_name);
			return (E_DB_ERROR);
		    }
		}
		else
		{
		    if (!found)	/* there must be a column */
		    {
			/* find attribute */
			status = psl_fatt(cb, psq_cb, TRUE, colname, node,
			    &rngvar, (i4) 0, (PST_J_MASK *) NULL);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }    
		    else			/* there is a var */
		    {
			/* There is a local var and we do not want any error
			** messages to be send to user yet.
			*/

			/* find if there is also an attribute (check only)*/
			status = psl_fatt(cb, psq_cb, TRUE, colname, node,
			    &rngvar, FIND_ONLY, (PST_J_MASK *) NULL);

			if (DB_FAILURE_MACRO(status))
			{
			    /* Column was not found, therefore
			    ** create a CNST node for the var.
			    */
			    PST_CNST_NODE	cconst;

			    /* Parm or local variable */
			    cconst.pst_tparmtype = PST_LOCALVARNO;
			    cconst.pst_parm_no = var->pss_no;
			    cconst.pst_pmspec  = PST_PMNOTUSED;
			    cconst.pst_cqlang = DB_SQL;
			    cconst.pst_origtxt = (char *) NULL;
			    status = pst_node(cb, &cb->pss_ostream,
				(PST_QNODE *) NULL, (PST_QNODE *) NULL,
				PST_CONST, (char *) &cconst, sizeof(cconst),
				var->pss_dbdata.db_datatype,
				(i2) var->pss_dbdata.db_prec,
				(i4) var->pss_dbdata.db_length, 
				(DB_ANYTYPE *) var->pss_dbdata.db_data, node,
				&psq_cb->psq_error, PSS_NOALLOC);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}
			else
			{
			    /* Column was found, reexecute call to psl_fatt,
			    ** this time create a var node for the column.
			    */
			    status = psl_fatt(cb, psq_cb, TRUE, colname,
				node, &rngvar, (i4) 0, (PST_J_MASK *) NULL);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}
		    }
		    if (rngtable != NULL)
                        *rngtable = rngvar;
		}
	    }
	    else	/* [<schema>.]var.cname has been specified */
	    {
		char			tabname[sizeof(DB_TAB_NAME) + 1];
		PSS_TBL_REF		*tbl_ref;
		PSS_RNGTAB		*rngtab;
		DMT_ATT_ENTRY		*attribute;
		PST_VAR_NODE		varnode;
		DB_STATUS		status;
		DMT_ATT_ENTRY		tid_att;

		tbl_ref = (PSS_TBL_REF *) sym->pst_dataval.db_data;
		MEcopy((PTR) &tbl_ref->pss_tab_name, sizeof(DB_TAB_NAME),
		       (PTR) tabname);
		tabname[sizeof(DB_TAB_NAME)] = '\0';
		(VOID) STtrmwhite(tabname);
		
		/* need to look for range var at proper scope */

		/* Look for an already-existing range var of this name */
		status = pst_slook(&cb->pss_auxrng, cb, 
		    tbl_ref->pss_schema_name, tabname, &rngtab, 
		    &psq_cb->psq_error, TRUE);
		if (status != E_DB_OK)
		{
		    return (status);
		}

		/* If not found, error- table not in from list */
		if (rngtab == (PSS_RNGTAB *) NULL)
		{
		    /* table not found */
		    (VOID) psf_error(2118L, 0L, PSF_USERERR, &err_code,
			       &psq_cb->psq_error, 1, STlength(tabname),
			       tabname);
		    return (E_DB_ERROR);
		}
		if (rngtable != NULL)
		    *rngtable = rngtab;

		STRUCT_ASSIGN_MACRO(sym->pst_value.pst_s_var.pst_atname,
				    varnode.pst_atname);
		/* Look up the attribute */
		attribute = pst_coldesc(rngtab, &varnode.pst_atname);

		/* Check for attribute not found */
		if (attribute == (DMT_ATT_ENTRY *) NULL)
		{
		    DB_ATT_NAME	    tid;

		    MEmove((sizeof("tid") - 1),
			(PTR)((*cb->pss_dbxlate & CUI_ID_REG_U) ?
			      "TID" : "tid"), ' ',
			sizeof(tid), (PTR) &tid);

		    /*
		    ** if rngtab represents a view V and column name was TID, we
		    ** will fabricate an attribute entry for V.TID and remember
		    ** that TID attribute of V was referenced;
		    ** at qrymod time, if the V is updatable, we will translate
		    ** the reference to V.TID to the the reference to TID of V's
		    ** underlying base table, otherwise, an error will be issued
		    */
		    if (   rngtab->pss_tabdesc->tbl_status_mask & DMT_VIEW
			&& !MEcmp((PTR) &tid, (PTR) &varnode.pst_atname,
				sizeof(tid)))
		    {
			rngtab->pss_var_mask |= PSS_TID_REFERENCE;
			
			attribute = &tid_att;
			psl_bld_tid_descr(attribute, cb);
		    }
		    else
		    {
			(VOID) psf_error(2100L, 0L, PSF_USERERR, 
			    &err_code, &psq_cb->psq_error, 4,
			    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(sizeof(DB_TAB_NAME),
					 (char *) &rngtab->pss_tabname),
			    &rngtab->pss_tabname,
			    psf_trmwhite(sizeof(DB_OWN_NAME),
					 (char *) &rngtab->pss_ownname),
			    &rngtab->pss_ownname, 
			    psf_trmwhite(sizeof(DB_ATT_NAME),
					 (char *) &varnode.pst_atname),
			    &varnode.pst_atname);
			return (E_DB_ERROR);
		    }
		}
			
		/* Set up var node for copy into tree */
		varnode.pst_vno = rngtab->pss_rgno;
		varnode.pst_atno.db_att_id = attribute->att_number;

		/* Create the node */
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
		    sizeof(varnode), (DB_DT_ID) attribute->att_type,
		    (i2) attribute->att_prec, (i4) attribute->att_width,
		    (DB_ANYTYPE *) NULL, node, &psq_cb->psq_error, PSS_NOALLOC);
		if (status != E_DB_OK)
		{
		    return (status);
		}
		(*node)->pst_sym.pst_dataval.db_collID =
						attribute->att_collID;
	    }	    /* var.cname */
	    /* See if we want to apply i4-tid hackery */
	    if (cb->pss_parser_compat & PSQ_I4_TIDS)
	    {
		/* Only if (*node) is still a VAR, and is a tid column,
		** and it's a real outermost select result-list.
		** Note that psq_mode gets tricked out in several cases,
		** but all but one are DB proc things.  The one exception is
		** insert as select, which we need to check for -- luckily
		** the select production sets a flag before whacking psq_mode.
		*/
		if (! yyvarsp->isdbp
		  && (*node)->pst_sym.pst_type == PST_VAR
		  && (*node)->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id == DB_IMTID
		  && (*node)->pst_sym.pst_dataval.db_datatype == DB_TID8_TYPE
		  && cb->pss_qualdepth == 1
		  && (psq_cb->psq_mode == PSQ_RETRIEVE || psq_cb->psq_mode == PSQ_DEFCURS)
		  && (cb->pss_stmt_flags & PSS_PARSING_INSERT_SUBSEL) == 0)
		    (*node)->pst_sym.pst_dataval.db_length = DB_TID_LENGTH;
	    }
	    break;
	}	/* case PST_VAR */

	case PST_CASEOP:
	{
	    PST_QNODE	**whlistpp;

	    /* For the "case" function, loop over each PST_WHLIST on the case
	    ** chain, and recurse. At the end, call pst_node to do type resolution. */

	    for (whlistpp = &(*node)->pst_left; (*whlistpp) != (PST_QNODE *) NULL;
		whlistpp = &(*whlistpp)->pst_left)
	    {
		status = psl_p_telem(cb, psq_cb, &(*whlistpp)->pst_right,
				yyvarsp, rngtable, xform_avg);
		if (status != E_DB_OK) 
		{
		    return(status);
		}
	    }

	    /* Resolve the source expression (if this is simple case). */
	    if ((*node)->pst_right)
	    {
		status = psl_p_telem(cb, psq_cb, &(*node)->pst_right,
				 yyvarsp, rngtable, xform_avg);
		if (status != E_DB_OK) return(status);
	    }

	    status = pst_node(cb, &cb->pss_ostream, (*node)->pst_left,
	        (*node)->pst_right, sym->pst_type,
		(char *) &(*node)->pst_sym.pst_value.pst_s_op,
		sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, node, &psq_cb->psq_error,
		PSS_TYPERES_ONLY);

	    if (status != E_DB_OK) 
	    {
		return(status);
	    }
	    break;
	}	/* case PST_CASEOP */
 
	case PST_AND:
	case PST_OR:
	case PST_NOT:
	case PST_WHOP:
	{
	    /* recursively process the rest of the tree
	    ** (note that this works even if one of the children is NULL).
	    ** Note also that we assume the node doesn't need to be
	    ** type-resolved, and don't call pst_node here.
	    */
	    if ((*node)->pst_left)
	       status = psl_p_telem(cb, psq_cb, &(*node)->pst_left, yyvarsp,
				 rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }

	    if ((*node)->pst_right)
	       status = psl_p_telem(cb, psq_cb, &(*node)->pst_right, yyvarsp,
				 rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    break;
	}
	default:
	    /* should never happen */
	    (void) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);

    }	    /* end switch */
    return(E_DB_OK);
}

/*
** Name: psl_aop_nooj	- check for columns from inner tables of outer joins
**
** Description:
**	Checks the contents of a "count(expr)" to determine if the expression
**	has a column that is inner to an OJ. It will then be nullable and the
**	count can't be converted to a count(*).
**	for the type.
**
** Input:
**	nodep		ptr to expr subtree
**	yyvarsp		ptr to YACC locals (including rng_vars array)
**
** Output:
**
** Returns:
**	TRUE - if the expression isn't based on inner columns of OJs
**	FALSE - otherwise
**
** Side effects:
**	none
**
** History:
**	23-mar-06 (dougi)
**	    Written for count(expr) to count(*) optimization.
**	28-apr-06 (dougi)
**	    rngtable was wrong. Uses yyvarsp to address rng_vars array
**	    which really does contain range entries.
*/
static bool
psl_aop_nooj(
	PST_QNODE	*nodep,
	PSS_YYVARS	*yyvarsp)

{
    PSS_RNGTAB	*rngentry;
    bool	retval = TRUE;


    /* Switch, looking for PST_VARs to test for OJs, and recurse
    ** on the rest. */

    switch(nodep->pst_sym.pst_type) {
      case PST_VAR:
	rngentry = yyvarsp->rng_vars[nodep->pst_sym.pst_value.
				pst_s_var.pst_vno];
	if (!rngentry || BTcount((char *)&rngentry->pss_inner_rel, 
		(i4)BITS_IN(PST_J_MASK)) != 0)	/* col is from OJ inner */
	    return(FALSE);
	else return(TRUE);

      default:
	if (nodep->pst_left)
	    retval = psl_aop_nooj(nodep->pst_left, yyvarsp);
	if (retval && nodep->pst_right)
	    retval = psl_aop_nooj(nodep->pst_right, yyvarsp);
	return(retval);
    }

}

/*
**  psl_set_jrel - set the inner and outer relation masks for a given join_id
**		   given masks representing inner and outer relations and the
**		   join id.
**
**  Description:
**	This procedure will set join_id-th bit in the
**	pss_outer_rel/pss_inner_rel masks of relations marked in
**	outer_rels/inner_rels masks.
**
**  Inputs:
**	    rng_tab	    address of the first element of the range table
**	    inner_rels	    mask representing inner relations of this join
**	    outer_rels 	    mask representing outer relations of this join
**	    join_id	    join id
**	    rng_vars	    ptr to an array of ptrs to range table entries.
**			    i-th element of this array points to range var with
**			    range number equal to i.  Otherwise, it is set to
**			    NULL.
**
**  Outputs:
**	    None
**
**  Returns:
**	    None
**
**  Side effects:
**	    (join_id)-th bit will be set in the pss_outer_rel/pss_inner_rel
**	    mask for all relations represented by outer_rels/inner_rels
**
**  22-may-89 (andre)     
**	Written.
**	9-june-99 (inkdo01)
**	    Don't set pss_inner_rel for topmost inner joins (SIR 94906).
**	13-sep-00 (inkdo01)
**	    Remove above change - 94906 is being fixed elsewhere.
**	26-nov-02 (inkdo01)
**	    Expansion of range table changes inner/outer_rels to PST_J_MASK.
**	 8-sep-03 (hayke02)
**	    Remove the test for two vars in rel_mask/inner_rels for full
**	    joins. This now allows nested full joins to have nullability set
**	    correctly for the attributes in all full joined vars. This
**	    change fixes bug 110869.
*/
VOID
psl_set_jrel(
	PSS_RNGTAB		*rng_tab,
	PST_J_MASK		*inner_rels,
	PST_J_MASK		*outer_rels,
	i4			join_id,
	register PSS_RNGTAB	**rng_vars,
	DB_JNTYPE               join_type)
{
    register i4	    i;
    register char	    *rel_mask;

    if (inner_rels)
     for (i = -1, rel_mask = (char *) inner_rels;
         (i = BTnext(i, rel_mask, PST_NUMVARS)) != -1;
	)
    {
	BTset(join_id, (char *) &rng_vars[i]->pss_inner_rel);
        if (((join_type == DB_LEFT_JOIN) || (join_type == DB_RIGHT_JOIN)
            && (BTcount(rel_mask, PST_NUMVARS) == 1))
            ||
            (join_type == DB_FULL_JOIN))
            rng_vars[i]->pss_var_mask |= PSS_INNER_RNGVAR;
    }

    if (outer_rels)
     for (i = -1, rel_mask = (char *) outer_rels;
         (i = BTnext(i, rel_mask, PST_NUMVARS)) != -1;
	)
    {
	BTset(join_id, (char *) &rng_vars[i]->pss_outer_rel);
    }

    return;
}

/*{
** Name: psl_check_key	- Check datatype for keyability
**
** Description:
**      This routine returns E_DB_OK if a datatype can be used as a key.
**	If the datatype cannot (or if it cannot tell), the routine returns
**	E_DB_ERROR.
**
**	A datatype is keyable if it doesn't have the AD_NOKEY attribute.  Also,
**	to be a key, an attribute must be sortable (! AD_NOSORT) for the modify
**	to work. 
**
** Inputs:
**      cb                              The PSF session control block -- used to
**					generate errors and to obtain the adf
**					session control block (pss_adfcb).
**      att_type                        Attribute type to be checked.
**
** Outputs:
**      err_blk				filled if a disastrous ADF error occurs.
**
**	Returns:
**	    DB_STATUS
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      31-Oct-1989 (fred)
**          Created for Predator/Terminator II/Phoenix -- Large object support.
**	18-mar-91 (andre)
**	    changed interface to accept error block ptr instead of psq_cb;
**	    psq_error was the only field of psq_cb which we were using anyway.
**	28-jun-1996 (shero03)
**	    Added support for RTree - ensure there is a nbr(obj, BOX) function
[@history_template@]...
*/
DB_STATUS
psl_check_key(
	PSS_SESBLK	    *cb,
	DB_ERROR	    *err_blk,
	DB_DT_ID	    att_type)
{	
    ADF_CB		    *adf_scb = (ADF_CB *) cb->pss_adfcb;
    i4			    dt_bits;
    DB_STATUS		    status;
    i4		    err_code;
    
    status = adi_dtinfo(adf_scb, att_type, &dt_bits);
    if (status)
    {
	(VOID) psf_error(E_PS0C05_BAD_ADF_STATUS,
	    adf_scb->adf_errcb.ad_errcode, PSF_INTERR, &err_code,
	    err_blk, 0);
	return (E_DB_ERROR);
    }
    else if (dt_bits & (AD_NOKEY | AD_NOSORT))
    {
	/* Caller will pick & supply his/her/its own error */
	return(E_DB_ERROR);
    }

    return(E_DB_OK);
}

/*
** psl_syn_info_msg()	- print a message notifying the user that the name
**			  supplied by him was that of a synonym
**
** History:
**	...
**	22-may-93 (andre)
**	    upcase (a bool) was being assigned a result of &'ing a u_i4
**	    field and long constant.  On machines where bool is char, this
**	    assignment will not produce the expected result
*/
VOID
psl_syn_info_msg(
	PSS_SESBLK	*sess_cb,
	PSS_RNGTAB	*rngvar,
	PSS_OBJ_NAME	*obj_spec,
	i4		owned_by,
	i4		qry_len,
	char		*qry,
	DB_ERROR	*err_blk)
{
    PTR		owner;
    i4	err_code;
    i4		len = sizeof(DB_OWN_NAME);
    bool	upcase = ((*sess_cb->pss_dbxlate & CUI_ID_REG_U) != 0);

    if (rngvar->pss_var_mask & PSS_EXPLICIT_QUAL)
    {
	/* if name was explicitly qualified, use owner name */
	owner = (PTR) &obj_spec->pss_owner;    
    }
    else if (owned_by & PSS_USR_OBJ)
    {
	owner = (PTR) &sess_cb->pss_user;
    }
    else if (owned_by & PSS_DBA_OBJ)
    {
	owner = (PTR) &sess_cb->pss_dba.db_tab_own;
    }
    else	    /* owner must have been $ingres */
    {
	/*@FIX_ME@ Should use pss_cat_owner? */
	owner = (upcase ? (PTR) "$INGRES" : (PTR) "$ingres");
	len   = sizeof("$ingres");
    }

    (VOID) psf_error(I_PS0451_SYN_WAS_SPECIFIED, 0L, PSF_USERERR,
	&err_code, err_blk, 5, qry_len, qry,
	psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &obj_spec->pss_obj_name),
	&obj_spec->pss_obj_name,
	psf_trmwhite(len, owner), owner,
	psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &rngvar->pss_tabname),
	&rngvar->pss_tabname,
	psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &rngvar->pss_ownname),
	&rngvar->pss_ownname);
}

/*
** psl_comment_col()	- process name of the column on which a comment is being
**			  created.  Column will always be qualified by the table
**			  name and, possibly, by the owner name.
**
**  Input:
**	sess_cb				    PSF session CB
**	  pss_auxrng			    range table
**	  pss_user			    current user
**	psq_cb				    PSF control block
**	  psq_mode			    query mode
**	col_ref				    description of a <column reference>
**	  pss_schema_name		    schema name (used to be owner name)
**	  pss_tab_name			    table name
**	  pss_col_name			    column name
**	  pss_flags			    useful info
**	    PSS_TBL_OR_CORR_NAME_SPECIFIED  table name (but no schema name)
**					    was specified
**	    PSS_TBL_SPECIFIED		    table name was specified (along
**					    with schema name)
**	    PSS_SCHEMA_SPECIFIED	    schema name was specified
**	    PSS_ALL_COLUMNS		    [schema.]tbl.* was specified
**
**  Output:
**	psq_cb
**	    psq_error	    filled in if an error is encountered
**
**  somewhere, somehow (andre)
**	written
**  25-sep-92 (andre)
**	instead of receiving owner, table, and column names, we will receive a
**	(PSS_COR_REF *).  This is done oin conjunction with introduction of
**	col_ref production
*/
DB_STATUS
psl_comment_col(
	PSS_SESBLK	*sess_cb,
	PSQ_CB		*psq_cb,
	PSS_COL_REF	*col_ref)
{
    PSY_COL	    *psy_col;
    PSS_RNGTAB      *resrange;
    DB_STATUS       status;
    i4		    rngvar_info;
    DB_TAB_NAME	    comment_tbl;

    /*
    ** make sure that table name was specified
    */
    if (!(col_ref->pss_flags &
	      (PSS_TBL_OR_CORR_NAME_SPECIFIED | PSS_TBL_SPECIFIED)))
    {
	psl_yerror(3, sess_cb, psq_cb);
	return(E_DB_ERROR);
    }

    STmove(col_ref->pss_tab_name, ' ', sizeof(DB_TAB_NAME),
	(char *) &comment_tbl);

    if (~col_ref->pss_flags & PSS_SCHEMA_SPECIFIED)
    {
	status = psl_rngent(&sess_cb->pss_auxrng, -1, "", &comment_tbl, sess_cb,
	    FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info);
	if (status == E_DB_INFO)
	{
	    status = E_DB_OK;
	    if (!psl_valid_session_schema_use(psq_cb->psq_mode, sess_cb,
		(char *)&comment_tbl, &psq_cb->psq_error))
	    {
		return(E_DB_ERROR);
	    }
	}
    }
    else
    {
	status = psl_orngent(&sess_cb->pss_auxrng, -1, "",
	    &col_ref->pss_schema_name, &comment_tbl, sess_cb, FALSE, &resrange,
	    psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
    }

    if (DB_FAILURE_MACRO(status))
    {
	return(status);
    }

    if (MEcmp((PTR) &resrange->pss_ownname, (PTR) &sess_cb->pss_user,
	      sizeof(DB_OWN_NAME)))
    {
	i4	    err_code;
	DB_ERROR    e_error;

	/*
	** let user know if name supplied by the user was resolved to a
	** synonym
	*/
	if (rngvar_info & PSS_BY_SYNONYM)
	{
	    PSS_OBJ_NAME	    obj_spec;

	    /* set up obj_spec for calling psl_syn_info_msg */
	    STRUCT_ASSIGN_MACRO(comment_tbl, obj_spec.pss_obj_name);

	    if (~col_ref->pss_flags & PSS_SCHEMA_SPECIFIED)
	    {
		MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &obj_spec.pss_owner);
		obj_spec.pss_objspec_flags = 0;
	    }
	    else
	    {
		STRUCT_ASSIGN_MACRO(col_ref->pss_schema_name,
		    obj_spec.pss_owner);
		obj_spec.pss_objspec_flags = PSS_OBJSPEC_EXPL_SCHEMA;
	    }

	    obj_spec.pss_orig_obj_name = col_ref->pss_tab_name;

	    psl_syn_info_msg(sess_cb, resrange, &obj_spec, rngvar_info,
		sizeof("COMMENT") - 1, "COMMENT", &psq_cb->psq_error);
	}
	/*
	** must audit failure to comment
	*/
	if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	{
	    status = psy_secaudit(FALSE, sess_cb, resrange->pss_tabname.db_tab_name,
		    &resrange->pss_ownname, sizeof(resrange->pss_tabname),
		    SXF_E_TABLE, I_SX2039_TBL_COMMENT,
		    SXF_A_FAIL | SXF_A_CONTROL, 
		    &e_error);
	}

	/*
	** user definitely may not add/change a comment on someone else's
	** table
	*/
	(VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 3,
	    sizeof("COMMENT") - 1, "COMMENT",
	    psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &resrange->pss_tabname),
	    &resrange->pss_tabname,
	    psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &resrange->pss_ownname),
	    &resrange->pss_ownname);

	return(E_DB_ERROR);
    }

    /* store table name for later use */
    STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
			((PSY_CB *) sess_cb->pss_object)->psy_tabname[0]);

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, (i4) sizeof(PSY_COL), 
	(PTR *) &psy_col, &psq_cb->psq_error);
    if (status != E_DB_OK)
    {
	return (status);
    }

    /* Normalize the attribute name for later use */
    STmove(col_ref->pss_col_name, ' ', sizeof(DB_ATT_NAME),
	   (char *) &psy_col->psy_colnm);

    /*
    ** Attach element to the list.
    */
    (VOID) QUinsert((QUEUE *) psy_col,
	(QUEUE *) &((PSY_CB *) sess_cb->pss_object)->psy_colq);

    sess_cb->pss_resrng = resrange;

    return(E_DB_OK);
}

/*
** psl_insert_into_agg_list() -	attach preallocated AGGHEAD list element to the
**				appropriate AGGHEAD list.
** Description:		Since we now may allow correlated aggregates
**			(restrictions may be found in YYVARS.H comment for
**			illegal_agg_relmask), we no longer can blindly attach
**			newly built AGGHEAD node to the current AGGHEAD list.
**			Instead, we need to determine the scope of relation (if
**			any) referenced inside the AGGHEAD.  In case of
**			COUNT(*), there is no relation, so we will attach
**			AGGHEAD to the current AGGHEAD list, otherwise we will
**			consult masks representing relations at various scopes
**			and attach the newly built AGGHEAD node to the
**			appropriate AGGHEAD list.
** Input:
**	var_node	var_node found in the tree rooted in AGGHEAD node; this
**			node contains info which will enable us to determine
**			which relation is referenced in the AGGHEAD;
**	agglist_elem	preallocated AGGHEAD list element to be inserted into
**			appropriate AGGHEAD list;
**	agg_list_stack	stack of AGGHEAD lists at higher scopes, if any
**	cur_scope	current scope
**	rel_list	list of masks representing relations used at various
**			scopes
** Output:
**	the new element will be inserted into the appropriate list in
**	agg_list_stack 
** Returns:
**	None
**
** History:
**	17-may-90 (andre)
**	    written
*/
VOID
psl_insert_into_agg_list(
	PST_QNODE	*var_node,
	YYAGG_NODE_PTR	*agglist_elem,
	YYAGG_NODE_PTR	**agg_list_stack,
	i4		cur_scope,
	PST_J_MASK	*rel_list)
{
    YYAGG_NODE_PTR      **agg_list;

    /*
    ** we need to determine to which of the AGGHEAD lists the new
    ** AGGHEAD node must be attached; this is done by determining the scope of
    ** the relation referenced in the VAR node.  Note that we never need to
    ** worry about scope 0, since SELECT doesn't use it, and for DELETE and
    ** UPDATE it would be illegal to correlate to relations at scope 0 (i.e.
    ** relations being updated/deleted from) anyway.
    */

    agg_list = agg_list_stack + cur_scope;	    /* assume current scope */

    if (var_node != (PST_QNODE *) NULL)	    /* could happen with COUNT(*) */
    {
	i4     var_no = var_node->pst_sym.pst_value.pst_s_var.pst_vno;
	i4	scope;

	for (scope = cur_scope;
	     (scope > 0 && !BTtest(var_no, (char*) (rel_list + scope)));
	     scope--)
	;

	if (scope < cur_scope)
	{
	    agg_list = agg_list_stack + scope;
	}
    }

    /* insert preallocated element into the appropriate list */
    agglist_elem->agg_next = *agg_list;
    *agg_list = agglist_elem;
}

/*
** Name: psl_for_cond	this procedure builds the condition expression evaluated
**			after the select is executed for each iteration of a
**			for loop. Specifically, the expression is:
**			  (iirowcount > 0)
** Input:
**	sess_cb		    PSF session CB
**	psq_cb		    PSF request block
**	dbpinfo		    internal structure used to maintain info about the
**			    dbproc being parsed
**
** Output:
**	condition	    points to pst_condition in the IF node being 
**			    constructed
**
** Returns:
**	    E_DB_OK, E_DB_ERROR
**
** Side effects:   memory will be allocated; 
**
** History:
**	    24-aug-98 (inkdo01)
**		written.
*/
DB_STATUS
psl_for_cond(
	PSS_SESBLK	*sess_cb,
	PSQ_CB		*psq_cb,
	PSS_DBPINFO	*dbpinfo,
	PST_QNODE	**condition)
{
    DB_STATUS		    status;
    PST_QNODE		    *rownode, *constnode;
    PST_CNST_NODE	    rowcnt, const0;
    PST_OP_NODE		    gtop;
    i2			    zero = 0;
    /*
    ** Create a constant node for system variable "iirowcount".
    */
    rowcnt.pst_tparmtype = PST_LOCALVARNO;
    rowcnt.pst_parm_no = 0;
    rowcnt.pst_pmspec = PST_PMNOTUSED;
    rowcnt.pst_cqlang = DB_SQL;
    rowcnt.pst_origtxt = (char *) NULL;
    status = pst_node(sess_cb, &sess_cb->pss_ostream, (PST_QNODE *) NULL,
	(PST_QNODE *) NULL, PST_CONST, (char *) &rowcnt,
	sizeof (PST_CNST_NODE), DB_INT_TYPE, 0, 4,
	(DB_ANYTYPE *) NULL, &rownode, &psq_cb->psq_error, (i4) 0);
    if (status != E_DB_OK)
    {
	return (status);
    }
	
    /*
    ** Create a constant node for 0 to compare to iirowcount.
    */
    const0.pst_tparmtype = PST_USER;
    const0.pst_parm_no = 0;
    const0.pst_pmspec = PST_PMNOTUSED;
    const0.pst_cqlang = DB_SQL;
    const0.pst_origtxt = (char *) NULL;
    status = pst_node(sess_cb, &sess_cb->pss_ostream, (PST_QNODE *) NULL,
	(PST_QNODE *) NULL, PST_CONST, (char *) &const0,
	sizeof (PST_CNST_NODE), DB_INT_TYPE, 0, 2,
	(DB_ANYTYPE *) &zero, &constnode, &psq_cb->psq_error, (i4) 0);
    if (status != E_DB_OK)
    {
	return (status);
    }

    /*
    ** Create binary operation node to implement the comparison.
    */
    gtop.pst_opno = ADI_GT_OP;
    gtop.pst_opmeta = PST_NOMETA;
    gtop.pst_isescape = PST_DOESNT_APPLY;

    status = pst_node(sess_cb, &sess_cb->pss_ostream, rownode, constnode,
	    PST_BOP, (char *) &gtop, sizeof(gtop), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, condition, &psq_cb->psq_error, 0);

    if (DB_FAILURE_MACRO(status))
	return (status);


    return(E_DB_OK);
}

/*
** Name: psl_ifkwd -	this procedure will perform processing incidental to IF
**			and ELSEIF keywords encountered as a part of processing
**			[CREATE] PROCEDURE statement.
** Input:
**	sess_cb		    PSF session CB
**	psq_cb		    PSF request block
**	dbpinfo		    internal structure used to maintain info about the
**			    dbproc being parsed
**
** Output:
**	if_stmt_node	    will point to the newly allocated IF statement node
**
** Returns:
**	    E_DB_OK, E_DB_ERROR
**
** Side effiects:   memory will be allocated; some fields in dbpinfo block will
**		    be changed
**
** History:
**	    11-jun-90 (andre)
**		borrowed from the cdbp_ifkwd production.
**	    25-mar-91 (andre)
**		use the newly defined function, psl_init_dbp_stmt(), to allocate
**		and initialize the IF statement block.
*/
DB_STATUS
psl_ifkwd(
	PSS_SESBLK	*sess_cb,
	PSQ_CB		*psq_cb,
	PSS_DBPINFO	*dbpinfo,
	PST_STATEMENT	**if_stmt_node)
{
    DB_STATUS		    status;
    PSS_IFSTMT		    *pss_if;

    /* Allocate statement node. */
    status = psl_init_dbp_stmt(sess_cb, dbpinfo, psq_cb->psq_mode = PSQ_IF,
	PST_IF_TYPE, if_stmt_node, &psq_cb->psq_error);
    if (DB_FAILURE_MACRO(status))
	return (status);

    dbpinfo->pss_flags |= PSS_INCOND;

    /* Allocate PSS_IFSTMT node. */
    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PSS_IFSTMT),
	(PTR *) &pss_if, &psq_cb->psq_error);
    if (DB_FAILURE_MACRO(status))
	return (status);

    pss_if->pss_stmt = *if_stmt_node;

    /* Push onto the IF queue */
    (VOID) QUinsert((QUEUE *) pss_if, &dbpinfo->pss_ifq);

    return(E_DB_OK);
}

/*
** psl_thenkwd	-   process THEN keyword appearing inside a dbproc.
**
** Input:
**	dbpinfo		structure describing a dbproc being parsed
** Output:
**	none
** Returns:
**	none
**
** History:
**	11-jun-90 (andre)
**	    copied from the cdbp_thenkwd production
**	25-mar-91 (andre)
**	    removed code setting dbpinfo->pss_patch since it gets set to the
**	    address of pst_true when the statement block representing IF or
**	    ELSEIF gets built
*/
VOID
psl_thenkwd(
	PSS_DBPINFO     *dbpinfo)
{
    /*
    ** dbpinfo->pss_patch gets set to the address of pst_true when the
    ** statement block representing IF or ELSEIF gets built
    */

    dbpinfo->pss_flags &= ~PSS_INCOND;

    return;
}

/*
** psl_elsekwd	-   process ELSE keyword appearing inside a dbproc.
**
** Input:
**	dbpinfo		structure describing a dbproc being parsed
** Output:
**	none
** Returns:
**	none
**
** History:
**	11-jun-90 (andre)
**	    copied from the cdbp_elsekwd production
*/
VOID
psl_elsekwd(
	PSS_DBPINFO     *dbpinfo)
{
    PST_STATEMENT *s;

    s = ((PSS_IFSTMT *) dbpinfo->pss_ifq.q_next)->pss_stmt;
    dbpinfo->pss_patch = &s->pst_specific.pst_if.pst_false;

    return;
}

/*
** psl_ifstmt()	    -	wrap up processing of the IF statement inside a dbproc.
**
** Input:
**	if_node		node representing IF statement
**	condition	root of the condition tree
**	if_action	root of the tree representing action to be taken if
**			condition evaluates to TRUE
**	else_action	root of the tree representing action to be taken if
**			condition evaluates to FALSE
**	dbpinfo		structure describing a dbproc being parsed
** Output:
**	none
** Returns:
**	none
**
** History:
**	11-jun-90 (andre)
**	    borrowed from cdbp_ifstmt production
**	25-mar-91 (andre)
**	    set dbpinfo->pss_patch to NULL so that if ENDLOOP occurs immediately
**	    following ENDIF, a new ENDLOOP statement block will be generated
**	20-sep-92 (andre)
**	    we can no longer assume that the description of the IF statement
**	    will be on top of the stack.  If the IF statement involved some
**	    ELSEIFs, their descriptions will be left on the stack until we
**	    finish processing of the whole IF statement.  Accordingly, here we
**	    will keep popping off the stack descriptions of statements until
**	    that associated with the IF statement is reached
*/
VOID
psl_ifstmt(
	PST_STATEMENT	    *if_node,
	PST_QNODE	    *condition,
	PST_STATEMENT	    *if_action,
	PST_STATEMENT	    *else_action,
	PSS_DBPINFO	    *dbpinfo)
{
    PSS_IFSTMT      *pss_if;
    
    if_node->pst_specific.pst_if.pst_condition = condition;
    if_node->pst_specific.pst_if.pst_true = if_action;
    if_node->pst_specific.pst_if.pst_false = else_action;

    /*
    ** Pop descriptions of statements until that of the IF statement is reached
    */
    do
    {
	pss_if = (PSS_IFSTMT *) QUremove(dbpinfo->pss_ifq.q_next);
    } while (pss_if->pss_stmt != if_node);

    /*
    ** set dbpinfo->pss_patch to NULL so that if ENDLOOP occurs
    ** immediately following ENDIF, a new ENDLOOP statement block will be
    ** generated
    */
    dbpinfo->pss_patch = (PST_STATEMENT **) NULL;
    
    return;
}

/*
** Name:	psl_simple_compare
**
** Description:	this function performs the semantic action associated with
**		productions where an expression is compared with an expression
**		which doesn't involve a subselect.  This function will not
**		handle BETWEEN and IN (list) type comparisons.
**		It will handle 	comparisons of 2 select_expr's
**		(including select_expr [NOT] IN select_expr), comparisons with
**		NULL and comparisons involving LIKE
**
** Input:
**	sess_cb			PSF session CB
**	    .pss_ostream	stream used to allocate memory
**	operand1		tree representing a value being compared;
**	operand2		for comparisons with NULL, this argument will be
**				set to NULL; for comparisions involving LIKE,
**				this will be set to the string with which a
**				column must be compared (if parsing a database
**				procedure, this may also be a dbproc parameter)
**	operator		comparison operator
**	is_escape		indicates whether the escape character was
**				specified, or even relevant; can be one of
**				PST_DOESNT_APPLY (for comparisons with NULL),
**				PST_NO_ESCAPE, or PST_HAS_ESCAPE
**	escape_char		escape character, if one was specified (i.e. if
**				is_escape == PST_HAS_ESCAPE)
**	in_join_search		TRUE <==> processing a join search condition
**	in_target_clause	TRUE <==> processing a select list
**	join_info		ptr to structure describing outer joins (if any)
**				encountered so far
**
** Output:
**	treeinfo		will contain addr of a pointer to a structure
**				consisting of:
**	    pss_tree		pointer to the new tree and
**	    pss_mask		initialized mask field
**	err_blk			may be filled in if an error occurs
**
** Side effects:
**	will allocate memory
**
** Returns:
**	E_DB_OK, E_DB_ERROR
**
** History:
**	10-31-90 (andre)
**	    written
**	15-oct-92 (rblumer)
**	    if parsing a constraint, don't do type resolution yet
**	02-may-93 (andre)
**	    changed function scope to static (it is used only in this file)
**
**	    we will avoid type resolution only if CHECK constraint was specified
**	    inside CREATE TABLE statement
**	    
**	    replaced err_blk with psq_cb since we need to access psq_mode and
**	    psq_cb->psq_error gives us the error block
**	10-sep-99 (inkdo01)
**	    Added target list check to nores_flag set, for case functions.
*/
static DB_STATUS
psl_simple_compare(
	PSS_SESBLK	*sess_cb,
	PST_QNODE	*operand1,
	PST_QNODE	*operand2,
	ADI_OP_ID	operator,
	i4		is_escape,
	char		escape_char,
	PSS_TREEINFO	**treeinfo,
	bool		in_join_search,
	bool		in_target_clause,
	PSS_JOIN_INFO	*join_info,
	PSQ_CB		*psq_cb)
{
    PST_OP_NODE	    opnode;
    DB_STATUS	    status;
    DB_ERROR        *err_blk = &psq_cb->psq_error;
    i4		    nores_flag;

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PSS_TREEINFO),
	     (PTR *) treeinfo, err_blk);
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    opnode.pst_opno = operator;
    opnode.pst_opmeta = PST_NOMETA;

    if ((opnode.pst_isescape = (i1) is_escape) == PST_HAS_ESCAPE)
    {
	opnode.pst_escape = escape_char;
    }

    /*
    ** don't do type resolution if parsing a check constraint specified as a
    ** part of CREATE TABLE statement, as we may not know the type of the column
    ** (e.g. if it hasn't been defined yet). Also, if in target list (since
    ** predicates may now appear inside case functions in select list.
    */
    if (   in_target_clause
	||  (	sess_cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	     && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
	     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
    {
	nores_flag = PSS_NORES;
    }
    else
    {
	nores_flag = 0;
    }

    status = pst_node(sess_cb, &sess_cb->pss_ostream, operand1, operand2,
	(operand2 == (PST_QNODE *) NULL) ? PST_UOP : PST_BOP,
	(char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	(DB_ANYTYPE *) NULL, &(*treeinfo)->pss_tree, err_blk, nores_flag);

    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    if (operand1 != (PST_QNODE *) NULL && operand2 != (PST_QNODE *) NULL &&
	!(psl_validate_collation_mix(operand1->pst_sym.pst_dataval.db_collID,
	operand2->pst_sym.pst_dataval.db_collID)))
    {
	i4	err_code;
	(VOID) psf_error(6427L, 0L, PSF_USERERR, &err_code, err_blk, 0);
	return (E_DB_ERROR);
    }

    if (((*treeinfo)->pss_tree->pst_sym.pst_type != PST_CONST) &&
        (in_join_search))
    {
	/*
	** If we are processing a join_search condition, set the joinid
	** field appropriately.  It has been initialized to PST_NOJOIN in
	** pst_node().
	*/
	(*treeinfo)->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		join_info->pss_join[join_info->depth].join_id;
    }

    (*treeinfo)->pss_mask = (i4) 0;

    return(E_DB_OK);
}

/*
** Name:	psl_subsel_compare
**
** Description:	this function performs the semantic action associated with
**		productions where an expression is compared with a subselect.
**
** Input:
**	sess_cb			PSF session CB
**	    .pss_ostream	stream used to allocate memory
**	expr			tree representing the expression being compared
**				(may be NULL if processing EXISTS predicate)
**	subsel			tree representing the subselect being compared
**	operator		comparison operator
**	meta_op			modifier for the above operator
**	in_join_search		TRUE <==> processing a join search condition
**	join_info		ptr to structure describing outer joins (if any)
**				encountered so far
**	subsel_illegal		TRUE <==> subselect is illegal in this context
**	err_msgno		number of the error message to display if
**				subsel_illegal
**	psq_cb			ptr to PSF request block
**
** Output
**	sess_cb
**	    pss_flattening_flags
**				flag field used to collect information needed 
**				for determining whether the query being parsed 
**				should be flattened
**	        PSS_ALL_IN_TREE	will be set if the query involved a comparison
**				with "ALL (subselect)"; this will cause the
**				query to not be flattened
**		PSS_SINGLETON_SUBSELECT
**				will be set if this subselect is a singleton 
**				subselect; if we were told to avoid flattening 
**				queries involving singleton subselects, will 
**				remind us to tell OPF to not flatten this query
**
**	treeinfo		will contain addr of a pointer to a structure
**				consisting of:
**	    pss_tree		pointer to the new tree and
**	    pss_mask		initialized mask field
**	psq_cb.
**	    psq_error		filled in if an error occurs
**
** Side effects:
**	will allocate memory
**
** Returns:
**	E_DB_OK, E_DB_ERROR
**
** History:
**	10-31-90 (andre)
**	    written
**	27-nov-90 (andre)
**	    if this predicate involves ALL (or it was "NOT IN" which got
**	    translated into "!= ALL" - of course, here we cannot tell the
**	    difference), we will decide if this fact should figure in
**	    determining if the query tree is to be flattened
**	29-sep-92 (andre)
**	    if a predicate involved a singleton subselect, set
**	    PSS_SINGLETON_SUBSELECT in sess_cb->pss_flattening_flags.
**	15-oct-92 (rblumer)
**	    if parsing a constraint, don't do type resolution yet
**	02-may-93 (andre)
**	    avoid type resolution only if processing CHECK constraint specified
**	    as a part of CREATE TABLE statement
**
**	    changed function scope to static
**	15-nov-93 (andre)
**	    PSS_SINGLETON_SUBSELECT got moved from pss_stmt_flags to 
**	    pss_flattening_flags
**
**	    PSS_ALL_IN_TREE got moved from PSS_YYVARS.qry_mask to 
**	    sess_cb->pss_flattening_flags.  
**
**	    removed qry_mask from the arg list as it is no longer needed (at 
**	    least for now)
*/
static DB_STATUS
psl_subsel_compare(
	PSS_SESBLK	*sess_cb,
	PST_QNODE	*expr,
	PST_QNODE	*subsel,
	ADI_OP_ID	operator,
	i4		meta_op,
	PSS_TREEINFO	**treeinfo,
	bool		in_join_search,
	PSS_JOIN_INFO	*join_info,
	bool		subsel_illegal,
	i4		err_msgno,
	PSQ_CB		*psq_cb)
{
    PST_OP_NODE	opnode;
    DB_STATUS	status;
    i4		nores_flag;

    if (subsel_illegal)
    {
	i4	    err_code;

	/*
	** Not allowed in conditions in DB proc control statements or CREATE
	** RULE statments.
	*/
	(VOID) psf_error(err_msgno, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 1,
	    sizeof(sess_cb->pss_lineno), &sess_cb->pss_lineno);
	return (E_DB_ERROR);
    }

    /*
    ** expr will be set to NULL for EXISTS predicate, in which case we should
    ** not call psl_subsel(), as it will return an error if the target list of
    ** the subselect involved more than one RESDOM
    */
    if (expr != (PST_QNODE *) NULL)
    {
	if (status = psl_subsel(sess_cb, psq_cb, subsel))
	{
	    return (status);
	}
    }

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PSS_TREEINFO),
	     (PTR *) treeinfo, &psq_cb->psq_error);
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    opnode.pst_opno = operator;
    opnode.pst_opmeta = meta_op;
    opnode.pst_isescape = PST_DOESNT_APPLY;

    /*
    ** don't do type resolution if parsing a check constraint specified as a
    ** part of CREATE TABLE statement, as we may not know the type of the column
    ** (e.g. if it hasn't been defined yet)
    */
    if (   sess_cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
	     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) )
    {
	nores_flag = PSS_NORES;
    }
    else
    {
	nores_flag = 0;
    }

    if (expr != NULL)	    /* will be true except for the EXISTS predicate */
    {
	status = pst_node(sess_cb, &sess_cb->pss_ostream, expr, subsel, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &(*treeinfo)->pss_tree, &psq_cb->psq_error,
	    nores_flag);
    }
    else
    {
	status = pst_node(sess_cb, &sess_cb->pss_ostream, subsel,
	    (PST_QNODE *) NULL, PST_UOP, (char *) &opnode, sizeof(opnode),
	    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &(*treeinfo)->pss_tree, &psq_cb->psq_error, nores_flag);
    }

    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    if (((*treeinfo)->pss_tree->pst_sym.pst_type != PST_CONST) &&
        (in_join_search))
    {
	/*
	** If we are processing a join_search condition, set the joinid
	** field appropriately.  It has been initialized to PST_NOJOIN in
	** pst_node().
	*/
	(*treeinfo)->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		join_info->pss_join[join_info->depth].join_id;
    }

    (*treeinfo)->pss_mask = PSS_SUBSEL_IN_TREE;

    if (meta_op == PST_ALL_SUBSELECT)
    {
	/*
	** setting PSS_ALL_IN_TREE in sess_cb->pss_flattening_flags eventually 
	** results in PSF telling OPF to NOT flatten the query tree.  However, 
	** we need to disregard presense of ALL if the following holds:
	**	- "comparsion" is ADI_NE_OP (!= or <>) AND
	**	- both subtrees of the opnode represent non-nullable expressions
	**	  (recall that for non-nullable expressions,
	**	   PSQ_QNODE.pst_sym.pst_dataval.db_datatype > 0)
	** In this case OPF will decide to do equi-join, and that is exactly
	** what should happen
	*/

	if (   operator != ADI_NE_OP
	    || expr->pst_sym.pst_dataval.db_datatype < 0
	    || subsel->pst_sym.pst_dataval.db_datatype < 0)
	{
	    /*
	    ** Remember that query contains ALL, so the tree will not be
	    ** flattened
	    */
	    sess_cb->pss_flattening_flags |= PSS_ALL_IN_TREE;
	}
    }
    else if (meta_op == PST_ONE_SUBSELECT)
    {
	/* remember that a query involved a singleton subselect */
	sess_cb->pss_flattening_flags |= PSS_SINGLETON_SUBSELECT;
    }

    return(E_DB_OK);
}

/*
** Name:    psl_repeat_qry_id - translate or define a repeat query id
**
** Description: Given the front-end object id and a BE id, this function will
**		call QSO_TRANS_OR_DEFINE to either define a new translation or
**		find an existing one to enable sharing of repeat query QEPs
**
** Input:
**	psq_cb			request CB
**	    psq_cursid		BE query id; it may be overwritten if it is
**				determined that a QEP for this query is already
**				in memory
**	sess_cb			sesion CB
**	fe_id			pointer to front-end query id
**	header			query header
**	    pst_info		pointer to q query info structure
**	qry_info		Additional information about the repeat query
**				which was just parsed.  At least for now, this
**				will only be used for QUEL repeat queries to
**				verify that the query whose existing QEP is a
**				candidate for sharing and the current query are,
**				in fact, identical (it is a bit crude, but
**				hopefully effective); for now this will be
**				disregarded for SQL queries
**	    db_qry_len		length of text
**	    db_qry		slightly massaged query text
**	    db_num_tblids	number of table ids in the following list
**	    db_tblids		ORDERED list of ids of tables used in the query
**
** Output:
**	psq_cb
**	    psq_cursid		may be reset if an existing translation for this
**				FE id is found
**	sess_cb
**	    pss_ostream		stream may be closed if an existing translation
**				for this FE id is found
**	header			the following apply only if we are NOT reusing
**				an existing query plan or if none was found:
**	    pst_mask1		will be OR'd with PST_SHAREABLE_QRY if the query
**				was determined to be shareable and no
**				translation was found
**	    pst_info		structure will be allocated and initialized 
**		pst_1_usage	PST_SHR_RPTQRY will be set
**		pst_1_info
**		    pst_shr_rptqry  will point at a structure providing
**				    additional information which will be used
**				    when determining shareability of the QEP for
**				    this query
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:
**	memory may be allocated (for PST_QRYHDR_INFO);
**	can close sess_cb->ps_ostream if we determined that some existing QEP
**	should be used.
**
** History:
**	21-jan-91 (andre)
**	    plagiarized from define_query: production as a part of adding
**	    support for shareable QUEL repeat queries
**	25-jan-91 (andre)
**	    Modified interface to receive additional query information
**	    describing the current query.  At least for now, this will only
**	    be used for QUEL repeat queries to verify that the query whose
**	    existing QEP is a candidate for sharing and the current query are,
**	    in fact, identical (it is a bit crude, but hopefully effective)
**	    Also pass a pointer to the query tree header
**	08-may-91 (rog)
**	    If neither of the queries had a table_id list associated with it, do
**	    not compare them.  (fix for bug 37410)
**	15-jun-92 (barbara)
**	    Sybil merge.  Star comment:
**	    12-mar-92 (barbara)
**		Imported this function into the Star line to fix bug 42625
**		(Star was improperly sharing repeat query plans).
**	11-oct-93 (swm)
**	    Bug #56448
**	    Declared trbuf for psf_display() to pass to TRformat.
**	    TRformat removes `\n' chars, so to ensure that psf_scctrace()
**	    outputs a logical line (which it is supposed to do), we allocate
**	    a buffer with one extra char for NL and will hide it from TRformat
**	    by specifying length of 1 byte less. The NL char will be inserted
**	    at the end of the message by psf_scctrace().
** 4-mar-1996 (angusm)
**      If repeat qry contains global temp tables, include the unique
**      session id so that other sessions executing this query are not
**      bound to the same global temporary (bug 74863)
*/
DB_STATUS
psl_repeat_qry_id(
	PSQ_CB			*psq_cb,
	PSS_SESBLK		*sess_cb,
	DB_CURSOR_ID		*fe_id,
	PST_QTREE		*header,
	DB_SHR_RPTQRY_INFO	*qry_info)
{
    QSF_RCB	    qsf_rb;
    i4	    err_code;
    DB_STATUS	    status;
    char	    *p;
    char	    trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

    qsf_rb.qsf_type = QSFRB_CB;
    qsf_rb.qsf_ascii_id = QSFRB_ASCII_ID;
    qsf_rb.qsf_length = sizeof(qsf_rb);
    qsf_rb.qsf_owner = (PTR)DB_PSF_ID;
    qsf_rb.qsf_sid = sess_cb->pss_sessid;
    qsf_rb.qsf_feobj_id.qso_type = QSO_ALIAS_OBJ;
    qsf_rb.qsf_feobj_id.qso_lname = sizeof(DB_CURSOR_ID) + sizeof(i4);

	MEfill(sizeof(qsf_rb.qsf_feobj_id.qso_name), 0,
						qsf_rb.qsf_feobj_id.qso_name);

    (VOID)MEcopy((PTR) fe_id, sizeof(DB_CURSOR_ID),
	(PTR) qsf_rb.qsf_feobj_id.qso_name);

    p = (char *) qsf_rb.qsf_feobj_id.qso_name + sizeof(DB_CURSOR_ID);
    I4ASSIGN_MACRO(sess_cb->pss_udbid, *(i4 *) p);

    qsf_rb.qsf_obj_id.qso_type = QSO_QP_OBJ;
    qsf_rb.qsf_obj_id.qso_lname = sizeof(DB_CURSOR_ID);
    (VOID)MEcopy((PTR) &psq_cb->psq_cursid, sizeof(DB_CURSOR_ID),
	(PTR) qsf_rb.qsf_obj_id.qso_name);
    /*
	** extend length of alias and master ids: add 'session id'
	*/
	if (sess_cb->pss_stmt_flags & PSS_HAS_DGTT)
	{
		PTR     off = NULL;
		sess_cb->pss_stmt_flags &= ~PSS_HAS_DGTT;
		off = qsf_rb.qsf_feobj_id.qso_name + sizeof(DB_CURSOR_ID);
		MEcopy((PTR)&sess_cb->pss_sess_owner,
		sizeof(sess_cb->pss_sess_owner), off);
		p = (char *) qsf_rb.qsf_feobj_id.qso_name + sizeof(DB_CURSOR_ID)
			+ sizeof(sess_cb->pss_sess_owner);
		I4ASSIGN_MACRO(sess_cb->pss_udbid, *(i4 *) p);
		qsf_rb.qsf_feobj_id.qso_lname = sizeof(qsf_rb.qsf_feobj_id.qso_name);
	}

    /*
    ** if QEP exists and we are processing a QUEL query, we need to look at a
    ** part of QEP object, so we set lk_state to QSO_SHLOCK
    */
    qsf_rb.qsf_lk_state =
	(sess_cb->pss_lang == DB_SQL && ~sess_cb->pss_distrib & DB_3_DDB_SESS)
	? QSO_FREE : QSO_SHLOCK;

    status = qsf_call(QSO_TRANS_OR_DEFINE, &qsf_rb);

    if (DB_FAILURE_MACRO(status))
    {
	(VOID) psf_error(E_PS0379_QSF_T_OR_D_ERR,
	    qsf_rb.qsf_error.err_code, PSF_INTERR,
	    &err_code, &psq_cb->psq_error, 0);
	return (status);
    }	

    if (qsf_rb.qsf_t_or_d == QSO_WASTRANSLATED)
    {
	/* we don't do anything special for SQL */
	if (   sess_cb->pss_lang == DB_SQL
	    && ~sess_cb->pss_distrib & DB_3_DDB_SESS
	    )
	{
	    psq_cb->psq_mode = PSQ_QRYDEFED;
	}
	else
	{
	    /*
	    ** if processing a QUEL query we need to examine a copy of
	    ** DB_SHR_RPTQRY_INFO structure in the existing QEP; if it matches
	    ** qry_info, we can reuse the existing query plan
	    */

	    DB_SHR_RPTQRY_INFO		*info_p;

	    /* first get the root of the QSF object */
	    status = qsf_call(QSO_INFO, &qsf_rb);

	    if (DB_FAILURE_MACRO(status))
	    {
		DB_STATUS	stat;

		(VOID) psf_error(E_PS0A0A_CANTGETINFO,
		    qsf_rb.qsf_error.err_code, PSF_INTERR,
		    &err_code, &psq_cb->psq_error, 0);

		/*
		** QEP object was locked by QSO_TRANS_OR_DEFINE - unlock it
		** before returning error
		*/
		stat = qsf_call(QSO_UNLOCK, &qsf_rb);

		if (DB_FAILURE_MACRO(stat))
		{
		    (VOID) psf_error(E_PS0D1C_QSF_UNLOCK,
		        qsf_rb.qsf_error.err_code, PSF_INTERR, &err_code,
			&psq_cb->psq_error, 0);
		    if (stat > status)
			status = stat;
		}

		return(status);
	    }
	    
	    /*
	    ** make info_p point at PST_SHR_RPTQRY_INFO structure in the
	    ** existing QEP
	    */

	    info_p = ((QEF_QP_CB *) qsf_rb.qsf_root)->qp_shr_rptqry_info;

	    /*
	    ** all of the following must hold in order for us to reuse the
	    ** existing query plan:
	    ** 
	    **	    - info_p must be non-null
	    **	    - number of characters in the query text stored with the QEP
	    **	      must be the same as the number of characters in the text
	    **	      stored for this query
	    **	    - number of table ids stored with the QEP must be the same
	    **	      as the number of ids stored for this query
	    **	    - table ids stored with the QEP must be the same as the ids
	    **	      stored for this query
	    **	    - text stored with the QEP must be the same as the text
	    **	      stored for this query
	    */
	    if (info_p == (DB_SHR_RPTQRY_INFO *) NULL)
	    {
		i4	val1=0, val2=0;

		if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nQUEL repeat query cannot use existing QEP because the QEP does not\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"contain information required to determine if it can be shared.\n");
		}
	    }
	    /* will compare the lists only if they are of the same size AND are
	    ** not empty (fix for bug 37410)
	    */
	    else if (info_p->db_num_tblids != qry_info->db_num_tblids ||
		     (info_p->db_num_tblids != 0
		      &&
		      MEcmp((PTR) info_p->db_tblids, (PTR) qry_info->db_tblids,
		            (info_p->db_num_tblids * sizeof(DB_TAB_ID)))
		     )
		    )
	    {
		i4	    val1=0, val2=0;

		if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
		{
		    DB_TAB_ID   *qry_curid, *qep_curid;
		    i4		qry_idno, qep_idno;

		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nQUEL repeat query cannot use existing \
QEP because its list of table IDs\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"is different from that associated with the QEP.\n");

		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n\nTable IDs for the current query    \
Table IDs associated with the QEP\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n");

		    for (qry_idno  = qry_info->db_num_tblids,
			 qry_curid = qry_info->db_tblids,
		         qep_idno  = info_p->db_num_tblids,
			 qep_curid = info_p->db_tblids;

			 (qry_idno > 0 && qep_idno > 0);

			 qry_idno--, qry_curid++, qep_idno--, qep_curid++
			)
		    {
			psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
				"(%8d,%8d)                 (%8d,%8d)\n",
			    qry_curid->db_tab_base, qry_curid->db_tab_index,
			    qep_curid->db_tab_base, qep_curid->db_tab_index);
		    }

		    /*
		    ** if there were more ids in the list associated with the
		    ** query
		    */
		    for (; qry_idno > 0; qry_idno--, qry_curid++)
		    {
			psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
				"(%8d,%8d)\n",
			    qry_curid->db_tab_base, qry_curid->db_tab_index);
		    }

		    /*
		    ** if there were more ids in the list associated with the
		    ** QEP
		    */
		    
		    for (; qep_idno > 0; qep_idno--, qep_curid++)
		    {
			psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
				"                                    (%8d,%8d)\n",
			    qep_curid->db_tab_base, qep_curid->db_tab_index);
		    }

		}
	    }
	    else if (   (~sess_cb->pss_distrib & DB_3_DDB_SESS)
		     && 
			(info_p->db_qry_len != qry_info->db_qry_len
	                 ||
			 MEcmp((PTR) info_p->db_qry, (PTR) qry_info->db_qry,
			   info_p->db_qry_len))
		    )
	    {
		i4	val1=0, val2=0;

		if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nQUEL repeat query cannot use existing QEP because its text\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"is different from that associated with the QEP.\n");

		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n    Text of the query being parsed:\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n<<<\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"%t\n", qry_info->db_qry_len, qry_info->db_qry);
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			">>>\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n    Text of the query associated with the QEP:\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n<<<\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"%t\n", info_p->db_qry_len, info_p->db_qry);
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			">>>\n");

		}
	    }
	    else
	    {
		psq_cb->psq_mode = PSQ_QRYDEFED;
	    }

	    /* QEP object was locked by QSO_TRANS_OR_DEFINE - unlock it now */
	    status = qsf_call(QSO_UNLOCK, &qsf_rb);

	    if (DB_FAILURE_MACRO(status))
	    {
		(VOID) psf_error(E_PS0D1C_QSF_UNLOCK, qsf_rb.qsf_error.err_code,
		    PSF_INTERR, &err_code, &psq_cb->psq_error, 0);
		return(status);
	    }
	}

	if (psq_cb->psq_mode == PSQ_QRYDEFED)
	{
	    /* OK to use existing QEP */
	    (VOID)MEcopy((PTR) qsf_rb.qsf_obj_id.qso_name,
		sizeof(DB_CURSOR_ID), (PTR) &psq_cb->psq_cursid);

	    /* The generated tree is useless, because shared QEP
	    ** mechanism will be used, so close the QTREE memory stream
	    ** to delete memory.
	    */
	    status = psf_mclose(sess_cb, &sess_cb->pss_ostream, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	    sess_cb->pss_ostream.psf_mstream.qso_handle = (PTR) NULL;

	    {
		i4	val1=0, val2=0;

		if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nRepeat query is shareable - will use existing QEP.\n");
		}
	    }
	}
    }
    else
    {
	/*
	** no QEP was found;
	** for SQL we will simply OR PST_SHAREABLE_QRY into header->pst_mask1;
	** for QUEL we need to allocate and initialize PST_QRYHDR_INFO structure
	** and set header->pst_info to point to it to enable PSF to determine if
	** some other query with the same FE object id can reuse the query plan
	** + we will OR PST_SHAREABLE_QRY into header->pst_mask1
	*/
	header->pst_mask1 |= PST_SHAREABLE_QRY;

	if (sess_cb->pss_lang == DB_QUEL
	    ||
	    sess_cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /*
	    ** PST_QRYHDR_INFO structure was allocated by pst_header(); now
	    ** check for possible conflict in its usage
	    */
	    if (PST_1_INFO_USED(header))
	    {
		(VOID) psf_error(E_PS0522_QRYHDR_INFO_CONFLICT, 0L,
		    PSF_INTERR, &err_code, &psq_cb->psq_error, 0);
		return(E_DB_ERROR);
	    }

	    header->pst_info->pst_1_usage = PST_SHR_RPTQRY;
	    header->pst_info->pst_1_info.pst_shr_rptqry = qry_info;
	}

	{
	    i4	val1=0, val2=0;

	    if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
	    {
		psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nRepeat query is shareable - will build a new QEP\
.\n");
	    }
	}
    }

    return(E_DB_OK);
}

/* Name:    psl_qeucb - allocate QEU_CB and initialize its header
**
** Description:
**	Open a memory stream, allocate QEU_CB and initialize its header, and
**	place it at the root of the QSF object.
**
** Input:
**	sess_cb			PSF session CB
**	    pss_ostream		memory stream from which QEU_CB will be
**				allocated
**	    pss_dbid		database id for this session
**	    pss_sessid		session id
**	operation		opcode to store in QEU_CB
**
** Output:
**	sess_cb
**	    pss_object		will contain address of the newly allocated
**				QEU_CB
**	err_blk			filled in if an error occured.
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:
**	will allocate memory
**
** History:
**	06-mar-91 (andre)
**	    written;
**	04-aug-93 (andre)
**	    zero-fill QEU_CB to ensure that some newly added QEU_CB fields are
**	    not left uninitialized.
*/
DB_STATUS
psl_qeucb(
	PSS_SESBLK	*sess_cb,
	i4		operation,
	DB_ERROR	*err_blk)
{
    DB_STATUS	    status;
    QEU_CB	    *qeu_cb;
    
    status = psf_mopen(sess_cb, QSO_QP_OBJ, &sess_cb->pss_ostream, err_blk);
    if (status != E_DB_OK)
	return (status);

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(QEU_CB),
	&sess_cb->pss_object, err_blk);
    if (status != E_DB_OK)
	return (status);

    status = psf_mroot(sess_cb, &sess_cb->pss_ostream, sess_cb->pss_object, err_blk);
    if (status != E_DB_OK)
	return (status);

    MEfill(sizeof(QEU_CB), (u_char) 0, sess_cb->pss_object);
    
    qeu_cb = (QEU_CB *) sess_cb->pss_object;

    /* Fill in the control block header */
    qeu_cb->qeu_length	    = sizeof(QEU_CB);
    qeu_cb->qeu_type	    = QEUCB_CB;
    qeu_cb->qeu_owner	    = (PTR)DB_PSF_ID;
    qeu_cb->qeu_ascii_id    = QEUCB_ASCII_ID;
    qeu_cb->qeu_db_id	    = sess_cb->pss_dbid;
    qeu_cb->qeu_d_id	    = sess_cb->pss_sessid;
    qeu_cb->qeu_eflag	    = QEF_EXTERNAL;
    qeu_cb->qeu_mask	    = 0;

    /* Give QEF the opcode */
    qeu_cb->qeu_d_op	= operation;

    return(E_DB_OK);
}

/*
** Name: psl_init_dbp_stmt() - allocate and initialize a database procedure
**			       statement block
**
** Description: allocate and initialize a database procedure statement block
**		any additional statement-specific initialization must be
**		performed by the caller
**
** Input:
**	sess_cb		    session control block
**	    pss_ostream	    memory stream to use for allocating statement node
**	    pss_lineno	    current line number (STMT.pst_lineno)
**	dbpinfo		    dbproc info structure
**	    pss_link	    pointer to the last REACHABLE statement block
**			    allocated so far
**	    pss_patch	    patch address (may be NULL if we are parsing a
**			    statement immediately following IF...ENDIF
**	qmode		    mode of the statement (STMT.pst_node)
**	type		    type of the statement (STMT.pst_type)
**	err_blk		    error block
**
** Output:
**	*stmt		    pointer to a newly allocated and initialized
**			    statement block (if the statement type is
**			    PST_ENDLOOP and dbpinfo->pss_patch was not null, new
**			    statement block will not be allocated)
**	dbpinfo
**	    pss_link	    will be reset if a new statement block was allocated
**			    and the statement was REACHABLE and was not ENDLOOP
**	    pss_last_stmt   if a new statement block is allocated, this pointer
**			    will be reset to point at it
**	    pss_patch	    patch address may be reset for the new statement
**	err_blk		    will be filled in if an error occurs
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:    may allocate memory
**
** History:
**
**	07-feb-91 (andre)
**	    written
**	30-oct-92 (rblumer)
**	    initialize structure to zero's after mallocing it, so new fields 
**          get initialized; also replaces several lines of NULL assignments.
**	08-apr-93 (andre)
**	    rules will be collected in four distinct lists: user- and
**	    system-generated row-level rules and user- and system-generated
**	    statement-level rules.  pst_after_stmt will point at coalesced
**	    row-level rules and pst_statementEndRules will point at coalesced
**	    statement-level rules.  Row-level and statement-level rules will
**	    also be coalesced for the benefit of OPF
**	17-sep-93 (robf)
**          Save audit information for QT statements.
**	25-sep-98 (inkdo01)
**	    Add FOR-loop support.
**	29-may-06 (dougi)
**	    Assign pss_stmtno to pst_lineno.
*/
DB_STATUS
psl_init_dbp_stmt(
	PSS_SESBLK	*sess_cb,
	PSS_DBPINFO	*dbpinfo,
	i4		qmode,
	i4		type,
	PST_STATEMENT	**stmt,
	DB_ERROR	*err_blk)
{
    DB_STATUS	    status;

    *stmt = (PST_STATEMENT *) NULL;

    /*
    ** processing for ENDLOOP is different from all other statements in that if
    ** dbpinfo->pss_patch is set, then ENDLOOP statement block need not be
    ** allocated since we simply need to remember to "fix" the pointer whose
    ** address is found in pss_patch
    */
    if (type == PST_ENDLOOP_TYPE &&
	dbpinfo->pss_patch != (PST_STATEMENT **) NULL)
    {
	return(E_DB_OK);
    }
    else
    {
	PST_STATEMENT	    *s;

	status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PST_STATEMENT),
	    (PTR *) stmt, err_blk);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	MEfill(sizeof(PST_STATEMENT), (u_char) 0, (PTR) *stmt);

	s = dbpinfo->pss_last_stmt = *stmt;

	s->pst_mode = qmode;

#ifdef xDEBUG
	s->pst_lineno = sess_cb->pss_lineno;
#endif
	s->pst_lineno = sess_cb->pss_stmtno;
	if (type == PST_IP_TYPE || type == PST_QT_TYPE)
	{
	    /*
	    ** Assign row-level and statement-level rules from saved rule lists 
	    */

	    /*
	    ** make pst_after_stmt point at user-defined row-level rules and
	    ** then append system-generated row-level rules to the end of the
	    ** list
	    */
	    s->pst_after_stmt = sess_cb->pss_row_lvl_usr_rules;
	    psy_rl_coalesce(&s->pst_after_stmt, sess_cb->pss_row_lvl_sys_rules);

	    /*
	    ** make pst_statementEndRules point at user-defined statement-level
	    ** rules and then append system-generated statement-level rules to
	    ** the end of the list
	    */
	    s->pst_statementEndRules = sess_cb->pss_stmt_lvl_usr_rules;
	    psy_rl_coalesce(&s->pst_statementEndRules,
		sess_cb->pss_stmt_lvl_sys_rules);

	    /*
	    ** do the same with all the "before" rules.
	    */
	    s->pst_before_stmt = sess_cb->pss_row_lvl_usr_before_rules;
	    psy_rl_coalesce(&s->pst_before_stmt, 
				sess_cb->pss_row_lvl_sys_before_rules);

	    s->pst_before_statementEndRules = 
				sess_cb->pss_stmt_lvl_usr_before_rules;
	    psy_rl_coalesce(&s->pst_before_statementEndRules,
				sess_cb->pss_stmt_lvl_sys_before_rules);
	    /*
	    ** finally, unless we are processing PREPARE (which would never
	    ** happen in 6.5, but maybe later), append statement-level
	    ** rules to the end of the list of row-level rules
	    */
	    if (sess_cb->pss_defqry != PSQ_PREPARE)
	    {
		psy_rl_coalesce(&s->pst_after_stmt, s->pst_statementEndRules);
	    }
	}
	else
	{
	    s->pst_after_stmt =
	    s->pst_statementEndRules = (PST_STATEMENT *) NULL;
	}

	switch (s->pst_type = type)
	{
	    case PST_QT_TYPE:
	    {
		s->pst_audit=sess_cb->pss_audit;
		sess_cb->pss_audit=NULL;
		break;
	    }
	    case PST_IP_TYPE:
	    {
		STRUCT_ASSIGN_MACRO(dbpinfo->pss_ptuple.db_owner,
				    s->pst_specific.pst_iproc.pst_ownname);
		STRUCT_ASSIGN_MACRO(dbpinfo->pss_ptuple.db_dbpname,
				    s->pst_specific.pst_iproc.pst_procname);
		break;
	    }
	    case PST_CMT_TYPE:
	    {
		s->pst_specific.pst_commit.pst_unused = '\0';
		break;
	    }
	    case PST_RBK_TYPE:
	    {
		s->pst_specific.pst_rollback.pst_unused = '\0';
		break;
	    }
	    case PST_FOR_TYPE:
	    {
		s->pst_specific.pst_for.pst_forhead = (PST_STATEMENT *)NULL;
		break;
	    }
	    case PST_IF_TYPE:
	    case PST_WH_TYPE:
	    case PST_RP_TYPE:
	    {
		s->pst_specific.pst_if.pst_condition = (PST_QNODE *) NULL;
		s->pst_specific.pst_if.pst_true =
		    s->pst_specific.pst_if.pst_false = (PST_STATEMENT *) NULL;

		dbpinfo->pss_patch = &s->pst_specific.pst_if.pst_true;

		break;
	    }
	}

	/*
	** ENDLOOP statement is used only internally by PSF, so there is no
	** reason to attach it to the linked list of statements used by OPF;
	** also, if this statement is not reachable, do not attach it to the
	** linked list of statements used by OPF (to save the cost of optimizing
	** it)
	*/
	if (type != PST_ENDLOOP_TYPE &&
	    dbpinfo->pss_unreachable_stmt_lvl == 0)
	{
	    if (dbpinfo->pss_link != (PST_STATEMENT *) NULL)
	    {
		dbpinfo->pss_link->pst_link = s;
	    }

	    dbpinfo->pss_link = s;
	}

	if (type != PST_IF_TYPE && type != PST_WH_TYPE && type != PST_RP_TYPE)
	{
	    /* for IF, ELSEIF, and WHILE, pss_patch was set above */
	    dbpinfo->pss_patch = &s->pst_next;
	}
    }

    return(E_DB_OK);
}

/*
** Name: psl_add_grantee() - add a name to a grantee list
**
** Description: add a grantee name (can be user, group, or role name) to a
**		grantee list unless the name has already been added to the list.
**
** Input:
**	sess_cb		    session control block
**	    pss_ostream	    memory stream to use for allocating statement node
**	    pss_object	    pointer to a PSY_CB structure
**	grantee_name	    NULL-terminated name to be added to the grantee list
**	grantee_type	    type of identifier used to express grantee name
**
** Output:
**	err_blk		    will be filled in if an error occurs
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:    may allocate memory
**
** History:
**
**	13-jun-91 (andre)
**	    written
**	17-aug-93 (andre)
**	    made function static
**
**	    added grantee_type to the interface
**
**	    added code to remember whether the grantee name has been expressed 
**	    as a regular identifier
*/
static DB_STATUS
psl_add_grantee(
	PSS_SESBLK	*sess_cb,
	char		*grantee_name,
	PSS_ID_TYPE     grantee_type,
	DB_ERROR	*err_blk)
{
    PSY_CB		*psy_cb = (PSY_CB *) sess_cb->pss_object;
    PSY_USR		*psy_usr;
    bool		found = FALSE;
    DB_STATUS		status;
    DB_OWN_NAME		name_buf;

    /* Normalize the user name */
    STmove(grantee_name, ' ', sizeof(DB_OWN_NAME), (char *) &name_buf);

    /*
    ** Check if grantee specified for the first time.
    */
    for (psy_usr = (PSY_USR *) psy_cb->psy_usrq.q_next;
	 psy_usr != (PSY_USR *) &psy_cb->psy_usrq;
	 psy_usr = (PSY_USR *) psy_usr->queue.q_next
	)
    {
	if (MEcmp((PTR) &name_buf, (PTR) &psy_usr->psy_usrnm,
	    sizeof(psy_usr->psy_usrnm)) == 0
	   )
	{
	    found = TRUE;

	    /*
	    ** remember whether the grantee name was expressed using a regular
	    ** identifier
	    */
	    if (   ~psy_usr->psy_usr_flags & PSY_REGID_USRSPEC 
		&& grantee_type == PSS_ID_REG)
	    {
		psy_usr->psy_usr_flags |= PSY_REGID_USRSPEC;
	    }

	    break;
	}
    }

    /*
    ** Store only if not found. No need to keep duplicates.
    */
    if (!found)
    {
	/* Allocate memory for a user entry */
	status = psf_malloc(sess_cb, &sess_cb->pss_ostream, (i4) sizeof(PSY_USR), 
	    (PTR *) &psy_usr, err_blk);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** Copy user name to user entry.
	*/
	STRUCT_ASSIGN_MACRO(name_buf, psy_usr->psy_usrnm);

	psy_usr->psy_usr_flags = 0;

	/*
	** remember whether the grantee name was expressed using a regular
	** identifier
	*/
	if (grantee_type == PSS_ID_REG)
        {
	    psy_usr->psy_usr_flags |= PSY_REGID_USRSPEC;
        }

	/*
	** Attach element to the list.
	*/
	(VOID) QUinsert((QUEUE *) psy_usr, (QUEUE *) &psy_cb->psy_usrq);
    }

    return(E_DB_OK);
}

/*
** Name:    psl_cdbp_typedesc - semantic action for cdbp_typedesc production
**
** Description:
**
**	Perform the semantic action associated with cdbp_typedesc production.
**	Primarily, this envolves storing encoded column specification in the
**	dbproc descriptor
**
** Input parameters:
**	sess_cb		    PSF session CB
**	dbpinfo		    dbproc descriptor
**	type_name	    dbproc variable type as specified by the user
**	num_len_prec_vals   indicator of whether length and/or precision have
**			    been specified
**	    0		    neither length nor precision have been specified
**	    1		    length but no precision has been specified
**	    2		    both length and precision have been specified
**	len_prec	    array containing length and precision, if they were
**			    specified (num_len_prec_vals contains the size of
**			    this array)
**	null_def	    indicator of whether the variable has a default, is
**			    nullable and/or system_maintained (code which must
**			    be executed if the last one is true is yet to be
**			    written)
**	psq_cb		    PSF request CB
**
** Output
**	dbpinfo
**	    pss_curvar	    descriptor for the current dbproc variable will have
**			    been filled in
**	psq_cb
**	    psq_error	    filled in if an error occurs
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:
**	none
**
** History:
**
**	04-nov-91 (andre)
**	    plagiarized from typedesc: production
**	04-mar-93 (rblumer)
**	    change parameter to psf_adf_error to be psq_error
**	10-jan-94 (andre)
**	    (fix for bug 58020)
**	    if provided,nullability/defaultability specification for a dbproc
**	    parameter or variable must be one of:
**		WITH NULL
**		NOT NULL
**		NOT NULL WITH DEFAULT
**		NOT NULL NOT DEFAULT
*/
DB_STATUS
psl_cdbp_typedesc(
	PSS_SESBLK	*sess_cb,
	PSS_DBPINFO	*dbpinfo,
	char		*type_name,
	i4		num_len_prec_vals,
	i4		*len_prec,
	i4		null_def,
	PSQ_CB		*psq_cb)
{
    ADF_CB		*adf_scb = (ADF_CB *) sess_cb->pss_adfcb;
    DB_STATUS		status;
    DB_DATA_VALUE	dt_dv;
    i4		err_code;
    i4			adi_flags = 0;

    /*
    ** make sure that the nullability/defaultability specification, if 
    ** explicitly provided by the user, is valid.  It must be one of
    ** 		WITH NULL	(default if the user specified nothing)
    **		NOT NULL
    **		NOT NULL WITH DEFAULT
    **		NOT NULL NOT DEFAULT
    */
    if (   null_def != PSS_TYPE_NULL
	&& null_def != PSS_TYPE_NOT_NULL
	&& null_def != (PSS_TYPE_NOT_NULL | PSS_TYPE_DEFAULT)
	&& null_def != (PSS_TYPE_NOT_NULL | PSS_TYPE_NDEFAULT))
    {
	/* 
	** different messages will be generated depending on whether an invalid 
	** nullability/defaultability specification was provided for a parameter
	** or a variable
	*/
	i4		err_number = (psq_cb->psq_mode == PSQ_CREDBP)
					? E_PS048B_NULDEF_SPEC_IN_DBPPARM
					: E_PS048C_NULDEF_SPEC_IN_DBPVAR;

	(VOID) psf_error(err_number, 0L, PSF_USERERR, &err_code, 
	    &psq_cb->psq_error, 1,
	    psf_trmwhite(sizeof(dbpinfo->pss_curvar->pss_varname),
		(char *) &dbpinfo->pss_curvar->pss_varname),
	    (PTR) &dbpinfo->pss_curvar->pss_varname);
	
	return(E_DB_ERROR);
    }

    /*
    ** set up nullability; since this is SQL, either "with null" or
    ** nothing specified means that the column will be nullable; otherwise
    ** it's not nullable
    */
    if (null_def & PSS_TYPE_NULL)
    {   /* with null or nothing specified */
	adi_flags |= ADI_F1_WITH_NULL;
    }

    status = adi_encode_colspec(adf_scb, type_name, num_len_prec_vals,
	len_prec, adi_flags, &dt_dv);

    if (status != E_DB_OK)
    {
	(VOID) psf_error(2402L, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 1, STtrmwhite(type_name), type_name);

	if (adf_scb->adf_errcb.ad_errclass == ADF_USER_ERROR)
	    psf_adf_error(&adf_scb->adf_errcb, &psq_cb->psq_error, sess_cb);

	return(status);
    }

    dbpinfo->pss_curvar->pss_dbdata.db_data     = (PTR) NULL;
    dbpinfo->pss_curvar->pss_dbdata.db_prec     = dt_dv.db_prec;
    dbpinfo->pss_curvar->pss_dbdata.db_length   = dt_dv.db_length;
    dbpinfo->pss_curvar->pss_dbdata.db_datatype = dt_dv.db_datatype;
    dbpinfo->pss_curvar->pss_default = 0;

    /* Set up defaultibility; this really indicates
    ** whether adc_getempty is to be called.
    **
    ** NOTE: user-defined defaults for procedures have not been implemented yet.
    */
    /* set up defaultibility and system maintained */
    if (!(null_def & PSS_TYPE_NDEFAULT))
    {   
	/* defaults enabled */
	dbpinfo->pss_curvar->pss_default = 1;
    }

    return(E_DB_OK);
}

/*
**  psl_send_setqry - Build QEF_RCB to be passed to QEF for a SET query to be
**		      sent to LDB
**
**  Description:
**	This function will allocate QEF_RCB and initialize it for QEF to pass a
**	SET query to LDB.
**
**  Inputes:
**	sess_cb		    ptr to PSF session control block
**	str_2_send	    NULL-terminated string to be sent
**	err_blk		    error block
**
**  Outputs:
**	sess_cb->pss_object points to initialized QEF_RCB.
**  
**  Returns:
**	E_DB_OK	    -- allocated and initialized QEF_RCB successfully
**	E_DB_ERROR  -- error trying to allocate memory; quit
**
**  Side effects:
**	Will allocate memory
**
**  19-apr-89 (andre)
**	Written.
**  15-jun-92 (barbara)
**	Imported unchanged from 6.4 Star grammar.
**  4-dec-92 (barbara)
**	If call to QEF fails, error has already been reported.  PSF
**	must set psq_error (or SCF will complain); however, we want to
**	avoid PSF retry so we also set PSQ_REDO to pretend we are already
**	in server retry.
*/
DB_STATUS
psl_send_setqry(
	PSS_SESBLK	*sess_cb,
	char		*str_2_send,
	PSQ_CB		*psq_cb)
{
    QEF_RCB		*qef_rcb;
    DD_PACKET		*pkt;
    DB_STATUS           status;
    DB_ERROR		*err_blk = &psq_cb->psq_error;

    /* Allocate QEF control block for set decimal */
    status = psf_mopen(sess_cb, QSO_QP_OBJ, &sess_cb->pss_ostream, err_blk);
    if (status != E_DB_OK)
	return (E_DB_ERROR);

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(QEF_RCB),
			&sess_cb->pss_object, err_blk);

    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }
    
    status = psf_mroot(sess_cb, &sess_cb->pss_ostream, sess_cb->pss_object, err_blk);
	
    if (status != E_DB_OK)
    {
	return (E_DB_ERROR);
    }

    /* Fill in the QEF control block */
    qef_rcb = (QEF_RCB *) sess_cb->pss_object;
    qef_rcb->qef_length = sizeof(QEF_RCB);
    qef_rcb->qef_type = QEFRCB_CB;
    qef_rcb->qef_owner = (PTR)DB_PSF_ID;
    qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
    qef_rcb->qef_sess_id = sess_cb->pss_sessid;
    qef_rcb->qef_eflag = QEF_EXTERNAL;
    qef_rcb->qef_modifier = QEF_MSTRAN;
    qef_rcb->qef_cb = (QEF_CB *) NULL;
    qef_rcb->qef_r3_ddb_req.qer_d1_ddb_p = (DD_DDB_DESC *) NULL;
    qef_rcb->qef_r3_ddb_req.qer_d2_ldb_info_p = (DD_1LDB_INFO *) NULL;
    qef_rcb->qef_r3_ddb_req.qer_d4_qry_info.qed_q2_lang = DB_SQL;
    
    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(DD_PACKET), (PTR *) &pkt,
			err_blk);

    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    pkt->dd_p1_len = STlength(str_2_send);
    pkt->dd_p3_nxt_p = (DD_PACKET *) NULL;
    
    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, (i4) pkt->dd_p1_len,
			(PTR *) &pkt->dd_p2_pkt_p, err_blk);
	
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    MEcopy((PTR) str_2_send, pkt->dd_p1_len, (PTR) pkt->dd_p2_pkt_p);

    qef_rcb->qef_r3_ddb_req.qer_d4_qry_info.qed_q4_pkt_p = pkt;
    
    status = qef_call(QED_SET_FOR_RQF, ( PTR ) qef_rcb);

    if (DB_FAILURE_MACRO(status))
    {
	err_blk->err_code = E_PS0001_USER_ERROR;

	/*
	** Make it appear as if query is already in retry so that psq_call
	** won't retry this failed statement.
	*/
	psq_cb->psq_flag |= PSQ_REDO;
    }

    return(status);
}

/*
** Name:    psl_grantee_type_to_str - convert grantee type to string
**
** Description: given grantee type, generate corresponding text string
**
** Input:
**	grantee_type	    grantee type; one of DBGR_DEFAULT,
**			    DBGR_USER, DBGR_GROUP, or DBGR_APLID
**
** Output:
**	str		    string corresponding to the grantee type;
**			    NULL if unknown grantee type was passed
**			    
**	str_len		    length of string pointed to by str
**
** Returns:
**	none
**
** Side effects:
**	none
**
** History:
**
**	07-feb-92 (andre)
**	    written
**	19-jul-92 (andre)
**	    we will no longer expect to see grantee type of DBGR_PUBLIC here
**	    since PUBLIC will be allowed as one of user authorization
**	    identifiers
**	24-nov-93 (robf)
**	    Add by_word param which makes BY... be generated instead of
**	    TO..., used with security alarms, made public.
*/
VOID
psl_grantee_type_to_str(
	i4	grantee_type,
	char	**str,
	i4	*str_len,
	bool	by_word)
{
    switch (grantee_type)
    {
	case DBGR_DEFAULT:
	{
	    if(by_word)
	    {
	        *str = " by ";
	        *str_len = sizeof(" by ") - 1;
	    }
	    else 
	    {
	        *str = " to ";
	        *str_len = sizeof(" to ") - 1;
	    }
	    break;
	}
	case DBGR_USER:
	{
	    if(by_word)
	    {
	        *str = " by user ";
	        *str_len = sizeof(" by user ") - 1;
	    }
	    else
	    {
	        *str = " to user ";
	        *str_len = sizeof(" to user ") - 1;
	    }
	    break;
	}
	case DBGR_GROUP:
	{
	    if(by_word)
	    {
	        *str = " by group ";
	        *str_len = sizeof(" by group ") - 1;
	    }
	    else
	    {
	        *str = " to group ";
	        *str_len = sizeof(" to group ") - 1;
	    }
	    break;
	}
	case DBGR_APLID:
	{
	    if(by_word)
	    {
	        *str = " by role ";
	        *str_len = sizeof(" by role ") - 1;
	    }
	    else
	    {
	        *str = " to role ";
	        *str_len = sizeof(" to role ") - 1;
	    }
	    break;
	}
	default:
	{
	    /* this is very bad */
	    *str = (char *) NULL;
	    *str_len = 0;
	    break;
	}
    }

    return;
}

/*
** Name:    psl_valid_session_schema_use -  determine whether use of SESSION
**					    as the schema name is valid
**
** Description:
**	use of SESSION as the schema name is NOT valid when processing one of
**	the following:
**	    - COMMENT
**	    - CREATE DBEVENT
**	    - CREATE INDEX
**	    - CREATE INTEGRITY
**	    - CREATE PERMIT
**	    - CREATE RULE
**	    - CREATE TABLE [AS SELECT]  (handled elsewhere)
**	    - CREATE SYNONYM
**	    - CREATE VIEW
**	    - CREATE SECURITY_ALARM
**	    - CREATE PROCEDURE
**	    - SELECT/INSERT/DELETE/UPDATE inside a dbproc
**	    - DROP DBEVENT
**	    - DROP PROCEDURE
**	    - DROP INTEGRITY
**	    - DROP PERMIT
**	    - DROP SECURITY_ALARM
**	    - EXECUTE PROCEDURE
**	    - GRANT
**	    - REGISTER BEVENT
**	    - REMOVE DBEVENT
**	    - RAISE DBEVENT
**	    - REVOKE
**	    - SAVE
**	    - SET JOURNALING
**	    - SET LOCKMODE
**	    - DROP {VIEW|INDEX|SYNONYM}	(handled elsewhere)
**	    
**	If use of SESSION is illegal, this function will produce an appropriate
**	message and return FALSE; otherwise it will return TRUE
**
** Input:
**	qmode			    query mode
**	sess_cb			    PSF session CB
**	    pss_qualdepth	    if > 0, we are processing a subselect
**	    pss_dbp_flags	    flags related to processing a dbproc
**		PSS_DBPROC	    if set, we are processing a dbproc
**		
**	    pss_stmt_flags	    flags related to processing of the current
**				    statement
**		PSS_NEW_OBJ_NAME    processing new object name as a pat of
**				    CREATE {TABLE, PROCEDURE, RULE, etc.}
**				    statement
**	obj_name		    name of object as specified by the user
** Output:
**	err_blk			    will be filled in if use of SESSION schema
**				    name was deemed invalid
**
** Return:
**	TRUE if use of SESSION schema name appears to be valid; FALSE otherwise
**
** Side effects:
**	none
**
** Exceptions:
**	none
**
** History:
**
**	27-may-92 (andre)
**	    written
**	25-sep-92 (andre)
**	    changed datatype of obj_name to (char *)
**	20-apr-2004 (gupsh01)
**	    Add alter table alter column to this list.
**	15-Aug-2006 (jonj)
**	    One may now create indexes on Session Temp tables,
**	    (create index blah_index on session.blah)
**	    but may not prefix any index name with "SESSION.".
*/
static bool
psl_valid_session_schema_use(
	i4		qmode,
	PSS_SESBLK	*sess_cb,
	char		*obj_name,
	DB_ERROR	*err_blk)
{
    char	    *stmt;
    i4		    stmt_len = 0;
    bool	    err = FALSE;
    i4	    err_no;

    stmt = uld_psq_modestr(qmode);
    stmt_len = STlength(stmt);
    switch (qmode)
    {
	case PSQ_COMMENT:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	    
	    break;
	}
	case PSQ_EVENT:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_INDEX:
	{
	    /* 
	    ** One may create an index on a Session Temp,
	    ** but may not prefix any index name with "SESSION."
	    */
	    if ( sess_cb->pss_stmt_flags & PSS_NEW_OBJ_NAME )
	    {
		err = TRUE;
		err_no = E_PS0BD8_SESSION_INDEX_ILLEGAL;
	    }

	    break;
	}
	case PSQ_INTEG:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	
	    break;
	}
	case PSQ_PROT:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_RULE:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_CREATE:
	{
	    /*
	    ** use of SESSION in the new object name is handled in
	    ** psl_ct12_crname()
	    */
	    break;
	}
	case PSQ_CSYNONYM:
	{
	    /*
	    ** use of SESSION in the new object name is handled in
	    ** psl_ct12_crname()
	    */

	    if (~sess_cb->pss_stmt_flags & PSS_NEW_OBJ_NAME)
	    {
		err = TRUE;
		err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	    }
	    
	    break;
	}
	case PSQ_VIEW:
	{
	    /*
	    ** use of SESSION in the new object name is handled in
	    ** psl_ct12_crname()
	    */

	    if (~sess_cb->pss_stmt_flags & PSS_NEW_OBJ_NAME)
	    {
		err = TRUE;
		stmt = obj_name;
		stmt_len = STlength(obj_name);
		err_no = E_PS0BD4_TTBL_NOT_IN_VIEW;
	    }
	    
	    break;
	}
	case PSQ_CALARM:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_CREDBP:
	{
	    err = TRUE;
	    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;

	    break;
	}
	case PSQ_CSEQUENCE:
	{
	    err = TRUE;
	    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;

	    break;
	}
	case PSQ_ASEQUENCE:
	{
	    err = TRUE;
	    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;

	    break;
	}
	case PSQ_DELETE:
	case PSQ_REPLACE:
	case PSQ_APPEND:
	case PSQ_RETRIEVE:
	{
	    /* DGTT's may not be used in DML statements inside a dbproc */
	    if (sess_cb->pss_dbp_flags & PSS_DBPROC)
	    {
		err = TRUE;
		stmt = obj_name;
		stmt_len = STlength(obj_name);
		err_no = E_PS0BD5_TTBL_NOT_IN_DBP;
	    }

	    break;
	}
	case PSQ_EVDROP:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_DRODBP:
	{
	    err = TRUE;
	    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;

	    break;
	}
	case PSQ_DSEQUENCE:
	{
	    err = TRUE;
	    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;

	    break;
	}
	case PSQ_DSTINTEG:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	
	    break;
	}
	case PSQ_DSTPERM:
	{
	    PSY_CB	*psy_cb = (PSY_CB *) sess_cb->pss_object;

	    err = TRUE;

	    switch (psy_cb->psy_grant)
	    {
		case PSY_TDROP:
		{
		    stmt = "DROP PERMIT";
		    stmt_len = sizeof("DROP PERMIT") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
		case PSY_EVDROP:
		{
		    stmt = "DROP PERMIT ON DBEVENT";
		    stmt_len = sizeof("DROP PERMIT ON DBEVENT") - 1;
		    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;
		    break;
		}
		case PSY_PDROP:
		{
		    stmt = "DROP PERMIT ON PROCEDURE";
		    stmt_len = sizeof("DROP PERMIT ON PROCEDURE") - 1;
		    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;
		    break;
		}
		case PSY_SQDROP:
		{
		    stmt = "DROP PERMIT ON SEQUENCE";
		    stmt_len = sizeof("DROP PERMIT ON SEQUENCE") - 1;
		    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;
		    break;
		}
		default:
		{
		    stmt = "DROP PERMIT ON UNKNOWN";
		    stmt_len = sizeof("DROP PERMIT ON UNKNOWN") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
	    }

	    break;
	}
	case PSQ_KALARM:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_CALLPROC:
	{
	    err = TRUE;
	    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;

	    break;
	}
	case PSQ_GRANT:
	{
	    PSY_CB	*psy_cb = (PSY_CB *) sess_cb->pss_object;

	    err = TRUE;

	    switch (psy_cb->psy_grant)
	    {
		case PSY_TGRANT:
		{
		    stmt = "GRANT";
		    stmt_len = sizeof("GRANT") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
		case PSY_PGRANT:
		{
		    stmt = "GRANT ON PROCEDURE";
		    stmt_len = sizeof("GRANT ON PROCEDURE") - 1;
		    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;
		    break;
		}
		case PSY_EVGRANT:
		{
		    stmt = "GRANT ON DBEVENT";
		    stmt_len = sizeof("GRANT ON DBEVENT") - 1;
		    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;
		    break;
		}
		case PSY_SQGRANT:
		{
		    stmt = "GRANT ON SEQUENCE";
		    stmt_len = sizeof("GRANT ON SEQUENCE") - 1;
		    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;
		    break;
		}
		default:
		{
		    stmt = "GRANT ON UNKNOWN";
		    stmt_len = sizeof("GRANT ON UNKNOWN") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
	    }

	    break;
	}
	case PSQ_REVOKE:
	{
	    PSY_CB	*psy_cb = (PSY_CB *) sess_cb->pss_object;

	    err = TRUE;

	    switch (psy_cb->psy_grant)
	    {
		case PSY_TREVOKE:
		{
		    stmt = "REVOKE";
		    stmt_len = sizeof("REVOKE") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
		case PSY_PREVOKE:
		{
		    stmt = "REVOKE ON PROCEDURE";
		    stmt_len = sizeof("REVOKE ON PROCEDURE") - 1;
		    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;
		    break;
		}
		case PSY_EVREVOKE:
		{
		    stmt = "REVOKE ON DBEVENT";
		    stmt_len = sizeof("REVOKE ON DBEVENT") - 1;
		    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;
		    break;
		}
		case PSY_SQREVOKE:
		{
		    stmt = "REVOKE ON SEQUENCE";
		    stmt_len = sizeof("REVOKE ON SEQUENCE") - 1;
		    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;
		    break;
		}
		default:
		{
		    stmt = "REVOKE ON UNKNOWN";
		    stmt_len = sizeof("REVOKE ON UNKNOWN") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
	    }

	    break;
	}
	case PSQ_EVREGISTER:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_EVDEREG:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_EVRAISE:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_SAVE:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	
	    break;
	}
	case PSQ_SJOURNAL:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_SLOCKMODE:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_ALTERTABLE:
	case PSQ_ATBL_ADD_COLUMN:
	case PSQ_ATBL_ALTER_COLUMN:
	case PSQ_ATBL_DROP_COLUMN:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
    }

    if (err)
    {
	i4	    err_code;

	(VOID) psf_error(err_no, 0L, PSF_USERERR, &err_code, err_blk, 1,
	    stmt_len, stmt);
    }
	
    return(!err);
}

/*
** Name:    psl_reg_struct --  semantic for gateway register table structure
**
** Description:	    This function implements the semantic actions for
**		    the production
**                  reg_dbms_or_struct_parm : NAME EQUAL NAME
**                                       | NAME EQUAL UNIQUE NAME
** 
**
** Input:
**      dmu_cb     -- pointer to DMU_CB structure
**      ssname     -- pointer to the NAME after EQUAL [UNIQUE]
**      dmu_c_flag -- flag telling if the structure object is unique
**
** Output:
**      pst_struct -- set to indicate type of storage.
**      err_blk    -- set if error.
**	
** Returns:
**	E_DB_{OK, ERROR}
**
** History:
**      22-jun-92 (schang)
**          add the above documentation. Created for 06-15-92 integration.
*/
static DB_STATUS
psl_reg_struct(
	i4	    *pst_struct,
	DMU_CB	    *dmu_cb,
	char	    *ssname,
	i4	    dmu_c_flag,
	DB_ERROR    *err_blk)
{
    i4  err_code;
    i4	     storestruct;
    DMU_CHAR_ENTRY  *chr;

    /*
    ** If this is the first structure parameter, pst_struct should be
    ** 0L.  If pst_struct is non-NULL then issue error message for
    ** duplicate parameter.
    */
    if (*pst_struct != 0L)
    {
        /* duplicate parm found  */
	(VOID) psf_error(9309L, 0L, PSF_USERERR, &err_code, err_blk, 1,
			 (i4) sizeof("structure") - 1, "structure");
	return (E_DB_ERROR);
    }

    /* First entry in characteristics array is storage structure */
    chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_char_array.data_address;
 
    /*
    ** statements for decoding compressed storage structure are deleted,
    ** as no storage structure is compressed in REGISTER TABLE command
    */
    if (!STcasecmp(ssname, "keyed"))
    {
        storestruct = DB_ISAM_STORE;
    }
    else if (!STcasecmp(ssname, "fullkey"))
    {
        storestruct = DB_HASH_STORE;
    }
    else if (!STcasecmp(ssname, "sortkeyed"))
    {
        storestruct = DB_BTRE_STORE;
    }
    else if (!STcasecmp(ssname, "none"))
    {
    /* schang : if unique, then specifying "none" is an error */
        if (dmu_c_flag == DMU_C_ON)
        {
            (VOID) psf_error(9321L, 0L, PSF_USERERR, &err_code, err_blk, 0);
	    return (E_DB_ERROR);
        }
        else
        {
	    storestruct = DB_HEAP_STORE;
	}
    }
    else
    {
        (VOID) psf_error(8002L, 0L, PSF_USERERR, &err_code, err_blk, 1,
	    (i4) STtrmwhite(ssname), ssname);
        return (E_DB_ERROR);
    }

    chr->char_value = storestruct;
    *pst_struct = (i4) storestruct;

    /*
    ** replace default NOUNIQUENESS by UNIQUENESS in the second entry
    ** of characteristics array
    */
    chr++;
    chr->char_id = DMU_UNIQUE;
    chr->char_value = dmu_c_flag;
    return(E_DB_OK);   
}

/*
** Name: psl_tbl_ref - process <table name> found in a <column reference>
**
** Description:
**	This function will determine whether <table name> or <correlation name>
**	specified in <column reference> is valid.  The rules are a bit more
**	complicated than they used to be before we added support for
**	<schema>.<table>.<column>.  For more details, take a look at pst_slook()
**	    
** Input:
**	psq_cb			PSF query CB
**	    psq_mode		mode of a query
**	sess_cb			PSF session CB
**	col_ref			structure describing column reference
**	in_target_clause	TRUE if we are parsing a target clause
**	cur_scope		TRUE if we are only interested in rabge vars at
**				current scope
**	tbl_refs		address of array of <table reference>
**				descriptions
**
** Output
**	psq_cb
**	    psq_error		filled in if an error occurred
**	*tbl_refs		if a new description had to be allocated,
**				*tbl_refs will contains its address
**	rngtab			will contain address of a range variable
**				corresponding to the specified <table reference>
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**
**	25-sep-92 (andre)
**	    written
**	30-mar-93 (rblumer)
**	    added check for PSS_PARSING_CHECK_CONS, in addition
**	    to in_target_clause
**	02-may-93 (andre)
**	    avoid looking for a range variable if processing CHECK constraint
**	    specified as a part of CREATE TABLE statement
**	04-may-93 (andre)
**	    if range variable was not found while processing CHECK constraint
**	    specified in ALTER TABLE statement, produce an appropriate message
**	06-may-93 (andre)
**	    (this undoes changes mentioned in (30-mar-93 (rblumer)) and
**	    (02-may-93 (andre)))
**	    if processing CHECK constraint specified inside CREATE TABLE, verify
**	    that the <table reference> refers to the table being created;
**	    there is no reason to build a PSS_TBL_REF structure since all
**	    <column reference>s MUST refer to the table being created
*/
static DB_STATUS
psl_tbl_ref(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*sess_cb,
	PSS_COL_REF	*col_ref,
	i4		in_target_clause,
	i4		cur_scope,
	PSS_TBL_REF	**tbl_refs,
	PSS_RNGTAB	**rngtab)
{
    DB_STATUS		status;
    i4		err_code;
    DB_OWN_NAME		*schema_name;
    bool		bad_tbl_ref = FALSE;

    /* Just plain syntax error if in EXECUTE PROCEDURE target list */
    if (psq_cb->psq_mode == PSQ_CALLPROC)
    {
	(VOID) psf_error(E_US0986_2438_EXEC_COL, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 1,
	    STtrmwhite(col_ref->pss_tab_name), col_ref->pss_tab_name);
	return (E_DB_ERROR);
    }

    schema_name = (col_ref->pss_flags & PSS_SCHEMA_SPECIFIED)
	? &col_ref->pss_schema_name : (DB_OWN_NAME *) NULL;

    if (in_target_clause)
    {
	DB_TAB_NAME		tab_name;
	PSS_TBL_REF		*tbl_ref;

	if (tbl_ref = *tbl_refs)
	{
	    /* list of <table reference> descriptions is non-empty */
	    STmove(col_ref->pss_tab_name, ' ', sizeof(DB_TAB_NAME), 
		(char *) &tab_name);
	
	    for (; tbl_ref; tbl_ref = tbl_ref->pss_next)
	    {
		/* 
		** we are looking for a perfect match, i.e. if the <column
		** reference> passed by the caller involved <schema name>, we
		** will look for an element with non-NULL 
		** tbl_ref->pss_schema_name and *tbl_ref->pss_schema_name equal
		** to *schema_name + of course, table names must match
		*/
		if (   (   (!schema_name && !tbl_ref->pss_schema_name)
		    	|| (schema_name && tbl_ref->pss_schema_name 
			    && !MEcmp((PTR) schema_name, 
				      (PTR) tbl_ref->pss_schema_name,
				      sizeof(*schema_name)))
		       )
		    && !MEcmp((PTR) &tab_name, (PTR) &tbl_ref->pss_tab_name,
			    sizeof(tab_name))
		   )
		{
		    break;
		}
	    }
        }

	if (!tbl_ref)
	{
	    /* need to allocate a new <table reference> description */

	    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PSS_TBL_REF),
		(PTR *) &tbl_ref, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return(status);

	    if (schema_name)
	    {
		status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(DB_OWN_NAME),
		    (PTR *) &tbl_ref->pss_schema_name, &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return(status);
		
		STRUCT_ASSIGN_MACRO(*schema_name, *tbl_ref->pss_schema_name);
	    }
	    else
	    {
		tbl_ref->pss_schema_name = (DB_OWN_NAME *) NULL;
	    }
	    
	    tbl_ref->pss_next = *tbl_refs;
	    *tbl_refs = tbl_ref;
	    STmove(col_ref->pss_tab_name, ' ', sizeof(DB_TAB_NAME), 
		(char *) &tbl_ref->pss_tab_name);
	}

	/*
	** This is not very clean, but it doesn't look like it could
	** cause any problems.
	*/
	*rngtab = (PSS_RNGTAB *) tbl_ref;
    }
    else if (   sess_cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	     && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
	          ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) )
    {
	/*
	** processing CHECK constraint specified inside CREATE TABLE; make sure
	** that the <table reference> refers to the table being created
	*/
	QEU_CB		*qeu_cb = (QEU_CB *) sess_cb->pss_object;
	DMU_CB		*dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	DB_TAB_NAME	tab_name;

	STmove(col_ref->pss_tab_name, ' ', sizeof(DB_TAB_NAME), 
	    (char *) &tab_name);

	/*
	** if <table reference> consists of <table name>, it must be the same
	** as that of the table being created;
	** otherwise, if <table reference> is of format <schema name>.<table
	** name>, <schema name> must be the same as the name of the schema to
	** which the new table will belong (for 6.5, this is the same as the
	** table owner) and <table name> must be the same as the name of the
	** table being created
	*/
	if (   !MEcmp((PTR) &tab_name, (PTR) &dmu_cb->dmu_table_name,
		    sizeof(tab_name))
	    && (   !schema_name
		|| !MEcmp((PTR) schema_name, (PTR) &dmu_cb->dmu_owner,
			sizeof(*schema_name))
	       )
	   )
	{
	    *rngtab = (PSS_RNGTAB *) NULL;
	}
	else
	{
	    /* we got ourselves a bad <table reference> */
	    bad_tbl_ref = TRUE;
	}
    }
    else
    {
	/* need to look for range var at proper scope */

	/* 
	** Look for an already-existing range var corresponding to this
	** <table reference>
	*/
	status = pst_slook(&sess_cb->pss_auxrng, sess_cb, schema_name,
	    col_ref->pss_tab_name, rngtab, &psq_cb->psq_error, 
	    (bool) cur_scope);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** If not found, error - <qualifier> (table/correlation name or
	** schema.table) does not correspond to any <table reference> within
	** whose scope the <column reference> appeared
	*/
	if (*rngtab == (PSS_RNGTAB *) NULL)
	{
	    bad_tbl_ref = TRUE;
	}
    }


    if (bad_tbl_ref)
    {
# ifndef DOUBLEBYTE
	char	qualifier[2 * DB_MAXNAME + CMbytecnt(".")];
# else
	u_char	qualifier[2 * DB_MAXNAME + 1];
# endif /* #ifndef DOUBLEBYTE */
	i4	qual_len;

	if (schema_name)
	{
	    i4	schema_len;

	    schema_len = cus_trmwhite((u_i4) sizeof(*schema_name),
		(char *) schema_name);
	    MEcopy((PTR) schema_name, schema_len, (PTR) qualifier);
	    CMcpychar((u_char *)".", (qualifier + schema_len));
	    qual_len = schema_len + CMbytecnt(".");
	}
	else
	{
	    qual_len = 0;
	}

	{
	    i4	tbl_len;
	    
	    tbl_len = STlength(col_ref->pss_tab_name);

	    MEcopy((PTR) col_ref->pss_tab_name, tbl_len,
		(PTR) (qualifier + qual_len));

	    qual_len += tbl_len;
	}
	
	(VOID) psf_error(E_PS0461_BAD_COL_REF_QUAL, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 1,
	    (i4) qual_len, (PTR) qualifier);

	return (E_DB_ERROR);
    }

    return(E_DB_OK);
}

/*
** Name: psl_dbproc_param - process parameter of procedure
**
** Description:
**	This function generates a node representing one dbproc parameter.
**	    
** Input:
**	name			NAME of parameter
**	argument		argument value
**	is_byref       		is this being passed byref
**	result			pointer to result
**
** Output
**	*result			generated node
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**
**	26-oct-92 (jhahn)
**	    written
*/
static DB_STATUS
psl_dbproc_param(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	char		*name,
	PST_QNODE	*argument,
	bool		is_byref,
	PST_QNODE	**result)
{
    DB_STATUS	    status;
    PST_RSDM_NODE	    resdom;
    
    /* Allocate and return a resdon node with "arg_val" as right child */
    STmove(name, ' ', sizeof(resdom.pst_rsname), (char *)resdom.pst_rsname);
    /* pst_rsno and pst_ntargno are set in list construction above */
    resdom.pst_rsupdt  = FALSE;	/* Unused */
    resdom.pst_rsflags = 0; /* no PST_RS_PRINT - Unused */
    if (is_byref)
	resdom.pst_ttargtype = PST_BYREF_DBPARAMNO;
    else
	resdom.pst_ttargtype = PST_DBPARAMNO;
    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, argument,
		      PST_RESDOM, (char *)&resdom, sizeof(PST_RSDM_NODE),
		      argument->pst_sym.pst_dataval.db_datatype,
		      argument->pst_sym.pst_dataval.db_prec,
		      argument->pst_sym.pst_dataval.db_length,
		      (DB_ANYTYPE *)NULL,
		      result, &psq_cb->psq_error, (i4) 0);
    if (status != E_DB_OK)
	return (status);
    return (E_DB_OK);

} /* end psl_dbproc_param */

/*
** Name: psl_mfunc_param - process parameter of procedure
**
** Description:
**	This function generates a node representing one parameter of a 
**	multivariate function.
**	    
** Input:
**	argument		argument value
**	argument_num		which argument is this?
**	result			pointer to result
**
** Output
**	*result			generated node
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**
**	20-apr-1999 (shero03)
**	    written based on dbproc_param
*/
static DB_STATUS
psl_mfunc_param(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	PST_QNODE	*argument,
	PST_QNODE	**result)
{
    DB_STATUS		status;
    
    /* Allocate and return a resdon node with "arg_val" as right child */
    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, argument,
		      PST_OPERAND, (char *)NULL, 0,
		      argument->pst_sym.pst_dataval.db_datatype,
		      argument->pst_sym.pst_dataval.db_prec,
		      argument->pst_sym.pst_dataval.db_length,
		      (DB_ANYTYPE *)NULL,
		      result, &psq_cb->psq_error, PSS_NORES);
    if (status != E_DB_OK)
	return (status);
    return (E_DB_OK);

} /* end psl_mfunc_param */


/*
** Name: psl_usr_func - semantic action for CURRENT_USER, USER, SESSION_USER,
**			SYSTEM_USER, and INITIAL_USER
**
** Description:
**	This functions implements the semantic action for constant functions
**	CURRENT_USER, USER, SESSION_USER, SYSTEM_USER, and INITIAL_USER.
**	First we call ADF to get the right function instance, then we build a
**	query tree node for the function
**
** Input:
**	fname		NULL-terminated function name
**	sess_cb		PSF session CB
**	in_join_cond	TRUE if processing a join condition; FALSE otherwise
**	join_info	addr of a structure describing joins, if any, contained
**			in this query
**			
** Output:
**	*newnode	will point at a newly allocated query tree node
**	err_blk
**	    err_code	filled in if an error occurred
**
** Side effects:
**	will allocate memory
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	02-dec-92 (andre)
**	    written
*/
static DB_STATUS
psl_usr_func(
	     char	    *fname,
	     PSS_SESBLK	    *sess_cb,
	     bool	    in_join_cond,
	     PSS_JOIN_INFO  *join_info,
	     PST_QNODE	    **newnode,
	     DB_ERROR	    *err_blk)
{
    PST_OP_NODE	    opnode;
    DB_STATUS	    status;
    ADI_OP_NAME	    funcname;
    ADI_OP_ID	    opid;
    ADF_CB	    *adf_scb = (ADF_CB*) sess_cb->pss_adfcb;
    i4	    err_code;

    STmove(fname, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
    status = adi_opid(adf_scb, &funcname, &opid);
    if (status != E_DB_OK)
    {
	(VOID) psf_error(E_PS0C05_BAD_ADF_STATUS, adf_scb->adf_errcb.ad_errcode,
	    PSF_INTERR, &err_code, err_blk, 0);
	return (E_DB_ERROR);
    }

    opnode.pst_opno = opid;
    opnode.pst_opmeta = PST_NOMETA;
    opnode.pst_isescape = PST_DOESNT_APPLY;

    status = pst_node(sess_cb, &sess_cb->pss_ostream, (PST_QNODE *) NULL,
	(PST_QNODE *) NULL, PST_COP, (char *) &opnode, sizeof(opnode),
	DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, newnode,
	err_blk, (i4) 0);

    if (status != E_DB_OK)
    {
	return (status);
    }
    else if (in_join_cond)
    {
	/*
	** If we are processing a join_search condition, set the joinid field
	** appropriately.  It has been initialized to PST_NOJOIN in pst_node().
	*/
	(*newnode)->pst_sym.pst_value.pst_s_op.pst_joinid =
		join_info->pss_join[join_info->depth].join_id;
    }

    return(E_DB_OK);

} /* end psl_usr_func */

/*
** Name: psl_debug - an entry point on which to break for debugging
**
** Description:
**	This routine can be called in xDEBUG blocks for debugging purposes
**	
** Input:
**	(none)
**
** Output
**	(none)
**
** Returns:
**	(none)
**
** History:
**
**	24-nov-92 (ralph)
**	    written
*/
void psl_debug()
{
    return;
}

/*
** Name: psl_reserved_ident   -	make sure a new object name is NOT reserved
**				for internal use
**				(i.e. does NOT start with a dollar sign).
**
** Description:
**	Part of the name space for identifiers is reserved for internal use 
**	(for system-generated names).  This function looks at object names
**	that users are trying to create, and if the name is part of the
**	reserved name space, it will produce a message and return FALSE; 
**	otherwise it will return TRUE.
**	   This function is called in the few productions that are used for
**	new object names: obj_spec, auth_ident, col_spec, constraint_name,
**	and cdbp_varname. The PSS_NEW_OBJ_NAME bit in pss_stmt_flag must be
**	set for this routine to print and error and return TRUE.
**	
**	   Currently, the reserved name space is all names starting with
**	a dollar sign ('$').  This reserved space does not conflict with
**      the SQL92 name space in any way, as the dollar sign is not valid 
**	in SQL92 identifiers (not even in delimited identifiers).
**	It also follows existing INGRES internal names like $ingres and $dba.
**
**	The following commands can create an object, and have been changed to
**	set PSS_NEW_OBJ_NAME as necessary:
**
**	    - CREATE DBEVENT
**	    - CREATE GROUP
**	    - CREATE INDEX
**	    - CREATE PROCEDURE (incl. parameters and local variables)
**	    - CREATE ROLE
**	    - CREATE RULE
**	    - CREATE SCHEMA
**	    - CREATE TABLE [AS SELECT] (incl. new column names)
**	    - CREATE SYNONYM
**	    - CREATE USER
**	    - CREATE VIEW
**	    - DECLARE GLOBAL TEMP TABLE [AS SELECT]
**	    
**	Star commands
**	    - CREATE LINK (old version of REGISTER AS LINK)
**	    - CREATE TABLE
**	    - REGISTER .. AS IMPORT
**	    - REGISTER .. AS LINK
**	    - REGISTER INDEX    .. AS LINK
**	    - REGISTER PROCEDURE.. AS LINK
**	    
** Input:
**	name		    identifier to check
**	sess_cb		    ptr to PSF session CB
**	    pss_stmt_flags    stmt-level flags; looks for PSS_NEW_OBJ_NAME
**	    pss_lang	      query language (SQL or QUEL)
**	psq_cb		    parser control block
**	    psq_mode	    query mode
**	    psq_info	    info about execute immediate statements
**	      pst_execflags   special flags for execute immed statements
**	      		        PST_SYSTEM_GENERATED => system-generated
**	      		        	command and $ names are allowed
**	force_check	    TRUE  => name is definitely for a new object, 
**					so don't allow name starting with $
**			    FALSE => name MAY be a new object,
**					check for PSS_NEW_OBJ_NAME bit
** Output
**	psq_cb		    parser control block
**          psq_error	    will be filled in if an error occurs
**
** Returns:
**	TRUE  - name is reserved, so this function prints out an error message
**		and caller should return an error
**	FALSE - name is NOT reserved, caller may proceed as usual
**
** History:
**
**	26-nov-92 (rblumer)
**	    written
**	30-mar-93 (rblumer)
**	    changed to look at PSS_NEW_OBJ_NAME bit, and to allow '$' names
**	    for system-generated commands.
**	13-apr-93 (andre)
**	    do not check names on dbproc recreate.  Presumably, all the required
**	    checking was done at CREATE PROCEDURE time.  This helps us deal
**	    with the case when we are recreating a system-generated dbproc.
**	23-apr-93 (rblumer)
**	    change CREATE USER check to compare against pss_cat_owner, instead
**	    of DB_INGRES_NAME, in order to use correct upper- or lower-case.
**	12-Sep-2004 (schka24)
**	    Allow upgradedb to generate $identifiers, mostly so that it
**	    can reapply un-named (ie system named) ref constraints.
*/
static i4
psl_reserved_ident(
		   char		*name,
		   PSS_SESBLK	*sess_cb,
		   PSQ_CB	*psq_cb,
		   i4		force_check)
{
    char    command[PSL_MAX_COMM_STRING];
    i4 length;
    i4 err_code;

    /*
    ** if recreating a dbproc, don't check;
    ** checking was done at CREATE PROCEDURE time
    */
    if (   sess_cb->pss_dbp_flags & PSS_DBPROC
	&& sess_cb->pss_dbp_flags & PSS_RECREATE)
    {
	return(FALSE);
    }

    /* names beginning with '$' are reserved for internally-generated objects.
    ** 
    ** Thus, if the current name begins with a '$'
    **     AND this is a new object name
    **     AND this command is not a system-generated command
    **     AND it's not upgradedb
    ** print an error and return TRUE.
    ** 
    ** Note that DROP, MODIFY, other commands can still reference these $names.
    ** 
    ** Make an exception for upgradedb so that it can reapply system
    ** named referential constraints.
    */
    if ((CMcmpcase(name, ERx("$")) == 0)
	&& (force_check || (sess_cb->pss_stmt_flags & PSS_NEW_OBJ_NAME))
	&& ((psq_cb->psq_info == (PST_INFO *) NULL)
	    || (~psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED))
	&& (sess_cb->pss_ses_flag & PSS_RUNNING_UPGRADEDB) == 0
	)
    {
	/* make an exception for the CREATE USER command:
	** don't print error for $ingres,
	** as CREATEDB uses it create the $ingres user
	*/
	if ((psq_cb->psq_mode == PSQ_CUSER)
	    && (MEcmp(name, 
		      sess_cb->pss_cat_owner->db_own_name, DB_MAXNAME) == 0))
	    return(FALSE);

	psl_command_string(psq_cb->psq_mode, 
			   sess_cb->pss_lang, command, &length);

	_VOID_ psf_error(E_PS047B_RESERVED_IDENT, 0L, PSF_USERERR,
			 &err_code, &psq_cb->psq_error, 2,
			 length, command,
			 psf_trmwhite(DB_MAXNAME, name), name);
	return (TRUE);
    }
    return (FALSE);

}  /* end psl_reserved_ident */


/*
** Name: psl_set_function   -	handle aggregate functions
**
** Description:
**	Allocate and initialize an operator node for the function passed in,
**	then take the expression node and other info passed in and build both
**	an aggregate operator node and an aggregate head node.
**	
**	If this is a COUNT or ANY aggregate, also check for correlated
**	attributes in subselect & tell OPF not to flatten the query, if found.
**	    
** Input:
**	sess_cb		    ptr to PSF session CB
**	    pss_lang	    query language (SQL or QUEL)
**	psq_cb		    parser control block
**	    psq_mode	    query mode
**	yyvarsp		    yacc state variable;
**				many, many fields are used
**	func_name	    name of set aggregate function
**	distinct	    one of PST_DISTINCT, PST_NDISTINCT, or PST_DONTCARE
**	count_or_any	    whether this is a COUNT or ANY aggregate;
**			        used to decide whether to check for
**			        correlated attributes
**	expr1_node	    1st expression to apply aggregate to
**	expr2_node	    2nd expression to apply aggregate to (binary OLAPs)
**
** Output
**	agndnodep	    aggregate head node, to be put into query tree
**	psq_cb		    parser control block
**          psq_error	        will be filled in if an error occurs
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**
**	29-dec-92 (rblumer)
**	    written
**	27-may-93 (rblumer)
**	    add check to return an error if parsing a CHECK
**	    constraint, as aggregates are not allowed in a CHECK constraint.
**	    Modify to handle rest of aggregates, too (avg_min_max_sum).
**	20-sep-99 (inkdo01)
**	    Add support of PST_BDISTINCT for non-resword aggregates and added 
**	    2nd expression node parm for binary OLAP agg funcs.
**	30-june-05 (inkdo01)
**	    Replace "avg(x)" by "float8(sum(x)) / count(x)" to allow CX
**	    optimization to compute sum, count once each.
**	12-aug-05 (inkdo01)
**	    Add PST_XFORM_AVG flag to "div", "float8()" to allow later 
**	    detection of non-supported datatypes.
**	22-aug-05 (inkdo01)
**	    Add PST_AVG_AOP flag to "sum", "count" to help opa fix.
*/
static DB_STATUS
psl_set_function(
		 PSS_SESBLK	*sess_cb,
		 PSQ_CB		*psq_cb,
		 PSS_YYVARS	*yyvarsp,
		 char		*func_name,
		 i4		distinct,
		 i4		count_or_any,
		 PST_QNODE	*expr1_node,
		 PST_QNODE	*expr2_node,
		 PST_QNODE	**aghdnodep)
{
    PST_OP_NODE  operator;
    PST_QNODE	 *agopnode;
    PST_QNODE	 *aghdnode;
    PST_RT_NODE	 aghead;
    DB_STATUS	 status;
    ADI_OP_NAME	 adi_funcname;
    ADI_OP_ID	 opid;
    ADF_CB	 *adf_scb = (ADF_CB*) sess_cb->pss_adfcb;
    i4	 err_code;
    PST_J_ID	joinid;
    bool	avg = FALSE;

    if (distinct == PST_BDISTINCT) distinct = PST_NDISTINCT;
				/* empty set quantifier is same as ALL */
    /* aggregates are not allowed in CHECK constraints
     */
    if (sess_cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
    {
	(void) psf_error(E_PS0471_CHECK_CONSTRAINT, 0L, PSF_USERERR,
			 &err_code, &psq_cb->psq_error, 1,
			 sizeof(ERx("CREATE/ALTER TABLE"))-1,
			 ERx("CREATE/ALTER TABLE"));
	return (E_DB_ERROR);
    }

    /* Sequence operators are not allowed in aggregates. */
    if (psl_seqop_search(expr1_node) || psl_seqop_search(expr2_node))
    {
	(void)psf_error(6319L, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 0);
	return (E_DB_ERROR);    /* non-zero return means error */
    }

    /* Mark this SELECT stmnt as non-updatable */
    if (sess_cb->pss_qualdepth == 1)
    {
	yyvarsp->nonupdt = TRUE;
    }

    if (yyvarsp->aggr_allowed & PSS_STMT_AGG_ALLOWED)
	yyvarsp->aggr_allowed |= PSS_AGG_ALLOWED;

    /* Allocate the aggregate operator node 
     */
    STmove(func_name, '\0', sizeof(ADI_OP_NAME), adi_funcname.adi_opname);
    status = adi_opid(adf_scb, &adi_funcname, &opid);
    if (status != E_DB_OK)
    {
	(VOID) psf_error(E_PS0D1D_BAD_FUNC_NAME,
			 adf_scb->adf_errcb.ad_errcode, PSF_INTERR, &err_code,
			 &psq_cb->psq_error, 0);
	return (E_DB_ERROR);
    }

    if (opid == ADI_AVG_OP)
    {
	/* Replace avg by sum and set flag so we can complete
	** the transform later. */
	avg = TRUE;
	opid = ADI_SUM_OP;
    }
    operator.pst_opno     = opid;
    operator.pst_retnull  = (count_or_any) ? FALSE : TRUE;
    operator.pst_opmeta   = PST_NOMETA;
    operator.pst_isescape = PST_DOESNT_APPLY;
    operator.pst_distinct = distinct;
    operator.pst_flags 	  = 0;

    status = pst_node(sess_cb, &sess_cb->pss_ostream, 
		      expr1_node, expr2_node,
		      PST_AOP, (char *) &operator, sizeof(operator), 
		      DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, 
		      &agopnode, &psq_cb->psq_error,
		      (yyvarsp->in_target_clause) ? PSS_NORES : (i4) 0);

    if (status != E_DB_OK)
	return (status);

    if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
    {
	/*
	 ** If we are processing a join_search condition, set the joinid
	 ** field appropriately.  It has been initialized to PST_NOJOIN in
	 ** pst_node().
	 */
	joinid = agopnode->pst_sym.pst_value.pst_s_op.pst_joinid =
	    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
    }
    else joinid = PST_NOJOIN;

    aghead.pst_union.pst_next  = 0;
    aghead.pst_dups   = PST_ALLDUPS;
    aghead.pst_mask1 = 0x0;
    /* Allocate the aghead node */
    status = pst_node(sess_cb, &sess_cb->pss_ostream, agopnode, (PST_QNODE*) NULL, 
		      PST_AGHEAD, (PTR) &aghead,
		      sizeof(PST_RT_NODE), agopnode->pst_sym.pst_dataval.db_datatype,
		      agopnode->pst_sym.pst_dataval.db_prec,
		      agopnode->pst_sym.pst_dataval.db_length, (DB_ANYTYPE *) NULL,
		      &aghdnode, &psq_cb->psq_error, (i4) 0);
    if (status != E_DB_OK)
    {
	return (status);
    }

    if (avg)
    {
	PST_QNODE	*cntopnode, *f8opnode, *divopnode, *expr1copy;
	PST_QNODE	*aghd1node;
	PSS_DUPRB	dup_rb;
	DB_ERROR	err_blk;

	/* Add parse tree nodes for count(expr1), float8(sum()) and
	** division of float8(sum()) by count(). But first, copy 
	** sum subtree to stick under count. */

	dup_rb.pss_tree = expr1_node;
	dup_rb.pss_dup = &expr1copy;
	dup_rb.pss_1ptr = NULL;
	dup_rb.pss_op_mask = 0;
	dup_rb.pss_num_joins = PST_NOJOIN;
	dup_rb.pss_tree_info = (i4 *) NULL;
	dup_rb.pss_mstream = &sess_cb->pss_ostream;
	dup_rb.pss_err_blk = &err_blk;

	status = pst_treedup(sess_cb, &dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* Make it count(*) if count expr is not nullable and count
	** is NOT distinct. */
	if (!(yyvarsp->in_target_clause) &&
	    expr1copy->pst_sym.pst_dataval.db_datatype > 0 &&
	    operator.pst_distinct == PST_NDISTINCT)
	{
	    operator.pst_opno = ADI_CNTAL_OP;
	    expr1copy = (PST_QNODE *) NULL;
	}
	else operator.pst_opno = ADI_CNT_OP;
	operator.pst_retnull = FALSE;	/* cuz it's count */
	status = pst_node(sess_cb, &sess_cb->pss_ostream, expr1copy,
			(PST_QNODE *) NULL, PST_AOP, (char *)&operator,
			sizeof(operator), DB_NODT, (i2)0, (i4)0,
			(DB_ANYTYPE *) NULL, &cntopnode, &psq_cb->psq_error,
			(yyvarsp->in_target_clause) ? PSS_NORES : (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	cntopnode->pst_sym.pst_value.pst_s_op.pst_joinid = joinid;
	cntopnode->pst_sym.pst_value.pst_s_op.pst_flags |= PST_AVG_AOP;
	agopnode->pst_sym.pst_value.pst_s_op.pst_flags |= PST_AVG_AOP;

	/* Stick AGHEAD on top of count. */
	aghead.pst_union.pst_next  = 0;
	aghead.pst_dups   = PST_ALLDUPS;
	status = pst_node(sess_cb, &sess_cb->pss_ostream, cntopnode, (PST_QNODE*) NULL, 
		      PST_AGHEAD, (PTR) &aghead,
		      sizeof(PST_RT_NODE), agopnode->pst_sym.pst_dataval.db_datatype,
		      agopnode->pst_sym.pst_dataval.db_prec,
		      agopnode->pst_sym.pst_dataval.db_length, (DB_ANYTYPE *) NULL,
		      &aghd1node, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);

	operator.pst_opno = ADI_F8_OP;
	operator.pst_retnull = TRUE;
	status = pst_node(sess_cb, &sess_cb->pss_ostream, aghdnode,
			(PST_QNODE *) NULL, PST_UOP, (char *)&operator,
			sizeof(operator), DB_NODT, (i2)0, (i4)0,
			(DB_ANYTYPE *) NULL, &f8opnode, &psq_cb->psq_error,
			(yyvarsp->in_target_clause) ? PSS_NORES : (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	f8opnode->pst_sym.pst_value.pst_s_op.pst_joinid = joinid;
	f8opnode->pst_sym.pst_value.pst_s_op.pst_flags |=
						PST_XFORM_AVG;

	operator.pst_opno = ADI_DIV_OP;
	operator.pst_retnull = TRUE;
	status = pst_node(sess_cb, &sess_cb->pss_ostream, f8opnode,
			aghd1node, PST_BOP, (char *)&operator,
			sizeof(operator), DB_NODT, (i2)0, (i4)0,
			(DB_ANYTYPE *) NULL, &divopnode, &psq_cb->psq_error,
			(yyvarsp->in_target_clause) ? PSS_NORES : (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	divopnode->pst_sym.pst_value.pst_s_op.pst_joinid = joinid;
	divopnode->pst_sym.pst_value.pst_s_op.pst_flags |=
						PST_XFORM_AVG;

	aghdnode = divopnode;		/* return modified expr */
    }

    /* 
    ** check if count() or any() was found in the target list of a correlated
    ** subselect.  If so, and if yyvarsp->mult_corr_attrs.depth has not been
    ** previously set, we will set it to the current pss_qualdepth and start
    ** looking for correlated attributes.  If we find correlated attributes
    ** from at least 2 different relations within this subselect, we will
    ** indicate to the OPF that the query should not be flattened.  We will
    ** not be looking for multiple correlated references if 
    ** sess_cb->pss_flattening_flags indicates that we have already found an 
    ** occurrence
    */
    if (count_or_any &&
        ~sess_cb->pss_flattening_flags & PSS_MULT_CORR_ATTRS   &&
	yyvarsp->in_target_clause			&&
	yyvarsp->mult_corr_attrs.depth == -1	&&
	sess_cb->pss_qualdepth > 1)
    {
	yyvarsp->mult_corr_attrs.depth = sess_cb->pss_qualdepth;
	yyvarsp->mult_corr_attrs.found = FALSE;
	yyvarsp->mult_corr_attrs.rgno = -1;
    }
	
    *aghdnodep = aghdnode;

    return(E_DB_OK);
    
}  /* end psl_set_function */

/*
** Name: psl_vrule_tree_convert - call psl_vrule_subtree() to replace references
**				  to the attributes of the view with references
**				  to the attributes of its underlying base table
**				  in a rule tree
**
** Description:
**	This function will pass a (previously pumped through qrymod) copy of a
**	tree of the view on which a rule is being defined to psy_vrule_subtree()
**	to replace references to the attributes of the view with references to
**	the attributes of its underlying base table in a rule tree
**
** Input:
**	rootnode	    root node of the rule tree
**	    pst_left	    if non-NULL, points at the tree describing
**			    attributes to be passed to the dbproc fired by the
**			    rule
**	    pst_right	    if non-NULL, points at the rule qualification tree
**	vtree		    root of the view tree
**	sess_cb		    PSF sesion CB
**
** Output:
**	err_blk		    will be filled in if an error occurs
**
** Side effects:
**	memory will be allocated
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	04-jan-93 (andre)
**	    written
*/
static DB_STATUS
psl_vrule_tree_convert(
	PST_QNODE	*rootnode,
	PST_QNODE	*vtree,
	PSS_SESBLK	*sess_cb,
	DB_ERROR	*err_blk)
{
    PSS_DUPRB	    dup_rb;
    DB_STATUS	    status;

    dup_rb.pss_op_mask = PSS_MAP_VAR_TO_RULEVAR;
    dup_rb.pss_num_joins = PST_NOJOIN;
    dup_rb.pss_tree_info = (i4 *) NULL;
    dup_rb.pss_mstream = &sess_cb->pss_ostream;
    dup_rb.pss_err_blk = err_blk;
    
    if (rootnode->pst_left)
    {
	PST_QNODE	*resdom;
	
	/* non-empty parameter tree */
	for (resdom = rootnode->pst_left;
	     (resdom && resdom->pst_sym.pst_type == PST_RESDOM);
	     resdom = resdom->pst_left
	    )
	{
	    status = psl_vrule_subtree(sess_cb, &resdom->pst_right, vtree, &dup_rb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }

    if (rootnode->pst_right)
    {
	/* non-empty qualification tree */
	status = psl_vrule_subtree(sess_cb, &rootnode->pst_right, vtree, &dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
    
    return(E_DB_OK);
}

/*
** Name: psl_vrule_subtree - replace references to the attributes of the
**			     view with references to the attributes of its
**			     underlying base table in a subtree
**
** Description:
**	This function will use a (previously pumped through qrymod) copy of a
**	tree of the view on which a rule is being defined to replace references
**	to the attributes of the view with references to the attributes of its
**	underlying base table in a subtree.
**	In particular, for each PST_RULEVAR node in the subtree, we will find a
**	subtree in the view tree corresponding to that attribute of the view and
**	make a copy of it replacing PST_VAR nodes with PST_RULEVAR nodes.  The
**	resulting 
**
** Input:
**	subtree 	    address of a pointer to the root of a subtree to
**			    copy
**	vtree		    root of the view tree
**	dup_rb		    address of a pre-initialized control block to be
**			    passed to pst_treedup()
**
** Output:
**	dup_rb
**	    pss_err_blk	    will be filled in if an error occurs
**
** Side effects:
**	memory will be allocated
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	04-jan-93 (andre)
**	    written
**      25-feb-93 (andre)
**          rule could reference a TID node of updatable view; in that case we
**          just want to leave it alone since a node corresponding to a TID of
**          an updatable view is identical to the node represeting TID of the
**          view's base table (and well it should be since references to a TID
**          of a view get translated to references to TID of the view's
**          underlying base table.)
*/
static DB_STATUS
psl_vrule_subtree(
	PSS_SESBLK	*cb,
	PST_QNODE	**subtree,
	PST_QNODE	*vtree,
	PSS_DUPRB	*dup_rb)
{
    DB_STATUS	    status;

    if (*subtree == (PST_QNODE *) NULL)
	return(E_DB_OK);

    if ((*subtree)->pst_sym.pst_type == PST_RULEVAR)
    {
	PST_QNODE	    *resdom;
	PST_QNODE	    *copy;
	i4		    attno =
			     (*subtree)->pst_sym.pst_value.pst_s_rule.pst_rltno;
	
	/*
	** do not translate references to the TID of a base table through an
	** updatable view defined over it
	*/
	if (attno == 0)
	    return(E_DB_OK);

	/*
	** find subtree in the view target list that corresponds to this
	** attribute of the view
	*/
	for (resdom = vtree->pst_left;
	     resdom->pst_sym.pst_value.pst_s_rsdm.pst_rsno != attno;
	     resdom = resdom->pst_left
	    )
	;

	/*
	** now we need to duplicate a subtree pointed to by resdom->pst_right
	** taking care to replace every occurrence of PST_VAR with a
	** PST_RULEVAR; the result will replace *subtree
	*/
	dup_rb->pss_tree = resdom->pst_right;
	dup_rb->pss_dup = &copy;
	dup_rb->pss_1ptr = (PTR) *subtree;

	status = pst_treedup(cb, dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* overwrite reference to the attribute of the view */
	*subtree = copy;

	return(E_DB_OK);
    }

    if ((*subtree)->pst_left)
    {
	status = psl_vrule_subtree(cb, &(*subtree)->pst_left, vtree, dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }

    if ((*subtree)->pst_right)
    {
	status = psl_vrule_subtree(cb, &(*subtree)->pst_right, vtree, dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
    
    return(E_DB_OK);
}

/*
** Name: psl_bld_tid_descr - build a DMT_ATT_ENTRY entry describing a generic
**			     TID attribute
** Description:
**	Given a ptr to a DMT_ATT_ENTRY structure, populate it to describe a
**	generic TID attribute
**
** Input:
**	attribute	address of a DMT_ATT_ENTRY to populate
**
** Output:
**	attribute	populated DMT_ATT_ENTRY structure
**
** Side effects:
**	none
**
** Returns:
**	none
**
** History:
**	11-feb-93 (andre)
**	    written for CHECK OPTION project
**	08-apr-93 (ralph)
**	    DELIM_IDENT:  Use appropriate case for "tid"; pass in sess cb
**	12-feb-04 (inkdo01)
**	    Change to show 8-byte TID.
*/
static void
psl_bld_tid_descr(
	    DMT_ATT_ENTRY	*attribute,
	    PSS_SESBLK		*cb)
{
    MEmove((sizeof("tid") - 1),
	(PTR)((*cb->pss_dbxlate & CUI_ID_REG_U) ? "TID" : "tid"),
	' ',
	sizeof(attribute->att_name), (PTR) &attribute->att_name);
    attribute->att_number = 0;
    attribute->att_offset = 0;
    attribute->att_type = DB_TID8_TYPE;
    attribute->att_width = DB_TID8_LENGTH;
    attribute->att_prec = 0;
    attribute->att_flags = 0;
    attribute->att_key_seq_number = 0;
    attribute->att_defaultID.db_tab_base =
	attribute->att_defaultID.db_tab_index = 0;
    attribute->att_default = 0;

    return;
}

/*
** Name: psl_1ary_func_extra_proc - perform additional processing for unary
**				    functions
**
** Description:
**	If DECIMAL() function was called with 1 argument, figure out the correct
**	precision and scale and build a PST_CONST node describing precision and
**	scale
**
** Input:
**	sess_cb		    PSF session CB
**	    pss_ostream	    stream to be used to allocate PST_CONST node
**	    pss_adfcb	    ADF session CB
**	op_id		    operator id for the function
**	arg1		    node describing the argument passed to the function
**
** Output:
**	prec_scale	    if the function was decimal(), node describing
**			    default precision and scale for the specified
**			    argument
**	err_blk		    filled in if an error occurs
**
** Side effects:
**	memory may be allocated
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	04-may-93 (andre)
**	    plagiarized from scalar_function production to get rid of duplicate
**	    code in psl_p_telem()
**	20-jul-2004 (gupsh01)
**	    Added case to handle I8 to decimal conversion.
*/
static DB_STATUS
psl_1ary_func_extra_proc(
	    PSS_SESBLK	    *sess_cb,
	    i4		    op_id,
	    PST_QNODE	    *arg1,
	    PST_QNODE	    **prec_scale,
	    DB_ERROR	    *err_blk)
{
    switch (op_id)
    {
	case ADI_DEC_OP:
	{
	    DB_STATUS		status;
	    PST_CNST_NODE	cconst;
	    DB_DT_ID		type;
	    i4			len;
	    i2			ps;
	    i4		err_code;

	    type = arg1->pst_sym.pst_dataval.db_datatype;
	    len  = arg1->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);

	    switch (abs(type))
	    {
		case DB_FLT_TYPE:
		case DB_DEC_TYPE:
		case DB_MNY_TYPE:
		    ps = DB_PS_ENCODE_MACRO(AD_FP_TO_DEC_PREC,
			AD_FP_TO_DEC_SCALE);
		    break;

		case DB_INT_TYPE:
		    switch (len)
		    {
			case 1:
			    ps = DB_PS_ENCODE_MACRO(AD_I1_TO_DEC_PREC,
				AD_I1_TO_DEC_SCALE);
			    break;
			case 2:
			    ps = DB_PS_ENCODE_MACRO(AD_I2_TO_DEC_PREC,
				AD_I2_TO_DEC_SCALE);
			    break;
			case 4:
			    ps = DB_PS_ENCODE_MACRO(AD_I4_TO_DEC_PREC,
				AD_I4_TO_DEC_SCALE);
			    break;
			case 8:
			    ps = DB_PS_ENCODE_MACRO(AD_I8_TO_DEC_PREC,
				AD_I8_TO_DEC_SCALE);
			    break;
		    }
		    break;

		default:
		{
		    ADI_DT_NAME		dt_name;

		    /* can't default precision/scale for this datatype */
		    status = adi_tyname((ADF_CB *)sess_cb->pss_adfcb,
			abs(type), &dt_name);

		    (VOID) psf_error(E_PS0C80_NO_DEFLT_ON_DT, 0L, PSF_USERERR,
			&err_code, err_blk, 1,
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &dt_name), 
			&dt_name);
		    return (E_DB_ERROR);
		}
	    }

	    /*
	    ** Now we have the default precision and scale; build a const
	    ** node and put prec_scale in as an i2
	    */
	    cconst.pst_tparmtype = PST_USER;
	    cconst.pst_parm_no = 0;
	    cconst.pst_pmspec  = PST_PMNOTUSED;
	    cconst.pst_cqlang = DB_SQL;
	    cconst.pst_origtxt = (char *) NULL;
	    status = pst_node(sess_cb, &sess_cb->pss_ostream,
		(PST_QNODE *) NULL, (PST_QNODE *) NULL, PST_CONST, (char *)
		&cconst, sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 2,
		(DB_ANYTYPE *) &ps, prec_scale, err_blk, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    break;
	}
	default:
	{
	    break;
	}
    }
    
    return(E_DB_OK);
}

/*
** Name: psl_2ary_func_extra_proc - perform additional processing for binary
**				    functions
**
** Description:
**	If DECIMAL() function was called with 2 arguments, figure out the
**	correct scale and encode precision and scale in the PST_CONST node
**	representing precision (specified by the user).
**	For ascii(), text(), char() and varchar(), ascertain that the second
**	argument is an integer constant
**
** Input:
**	sess_cb		    PSF session CB
**	    pss_ostream	    stream to be used to allocate PST_CONST node
**	    pss_adfcb	    ADF session CB
**	op_id		    operator id for the function
**	arg1		    node describing the first argument
**	arg2		    node describing the second argument
**
** Output:
**	arg2		    if processing DECIMAL() function, both precision and
**			    scale will be encoded in this node that formerly
**			    contained only the precision
**	err_blk		    filled in if an error occurs
**
** Side effects:
**	may change the value inside the node representing the second argument
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	04-may-93 (andre)
**	    plagiarized from scalar_function production to get rid of duplicate
**	    code in psl_p_telem()
**	21-apr-1999 (shero03)
**	    add substring 
**	20-jul-2004 (gupsh01)
**	    Added case for supporting bigint to decimal conversion.
**	27-Jul-2007 (kiria01) b118856
**	    Check that PST_CONST node is of tparmtype PST_USER before asserting
**	    literal constant and dereferencing the pst_dataval.
**	04-Feb-2008 (kiria01) b119859
**	    Complete the set of datatypes that should be checked for constant
**	    second parameters.
*/
static DB_STATUS
psl_2ary_func_extra_proc(
	    PSS_SESBLK	    *sess_cb,
	    i4		    op_id,
	    PST_QNODE	    *arg1,
	    PST_QNODE	    *arg2,
	    DB_ERROR	    *err_blk)
{
    i4		err_code;

    switch (op_id)
    {
		/*
		** The second argument of the two argument version of
		** ascii(), text(), char() or varchar() functions have to
		** be an integer constant.
		*/
	case ADI_ASCII_OP:
	case ADI_TEXT_OP:
	case ADI_CHAR_OP:
	case ADI_VARCH_OP:
	case ADI_BYTE_OP:
	case ADI_VBYTE_OP:
	case ADI_NCHAR_OP:
	case ADI_NVCHAR_OP:
	{
	    if (   arg2->pst_sym.pst_type != PST_CONST
		|| abs(arg2->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE)
	    {
		(VOID) psf_error(E_PS0C90_MUSTBE_CONST_INT, 0L,
		    PSF_USERERR, &err_code, err_blk, 0);
		return (E_DB_ERROR);
	    }

	    break;
	}
        case ADI_SUBSTRING_OP:
	{
    	    if (abs(arg2->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE)
	    {
	        (VOID) psf_error(E_PS0C91_MUSTBE_NUMERIC, 0L, PSF_USERERR,
		    &err_code, err_blk, 
		    (i4) sizeof("SUBSTRING")-1, "SUBSTRING", sizeof(i4), (i4)1);
	        return (E_DB_ERROR);
	    }

	    break;
	}
	case ADI_DEC_OP:
	{
	    DB_STATUS		status;
	    DB_DT_ID		type;
	    i4			plen;
	    i4			len;
	    PTR			pdata;
	    i2			ps;

	    /* precision must be a const node */
	    if (arg2->pst_sym.pst_type != PST_CONST ||
	           arg2->pst_sym.pst_value.pst_s_cnst.pst_tparmtype != PST_USER)
	    {
		(VOID) psf_error(E_PS0C81_MUST_BE_CONST, 0L, PSF_USERERR,
		    &err_code, err_blk, 0);
		return (E_DB_ERROR);
	    }

	    type  = arg2->pst_sym.pst_dataval.db_datatype;
	    plen  = arg2->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	    pdata = arg2->pst_sym.pst_dataval.db_data;

	    /* must be an i2 with valid precision */
	    if (    abs(type) != DB_INT_TYPE  ||  plen != 2
		||  *(i2 *)pdata < 1  ||  *(i2 *)pdata > DB_MAX_DECPREC)
	    {
		(VOID) psf_error(E_PS0C82_BAD_PRECISION, 0L, PSF_USERERR,
		    &err_code, err_blk, 0);
		return (E_DB_ERROR);
	    }

	    /* check input type and get default scale based on it */
	    type = arg1->pst_sym.pst_dataval.db_datatype;
	    len  = arg1->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);

	    switch (abs(type))
	    {
		case DB_FLT_TYPE:
		case DB_DEC_TYPE:
		case DB_MNY_TYPE:
		{
		    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata, AD_FP_TO_DEC_SCALE);
		    break;
		}

		case DB_INT_TYPE:
		{
		    switch (len)
		    {
			case 1:
			    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata,
				AD_I1_TO_DEC_SCALE);
			    break;
			case 2:
			    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata,
				AD_I2_TO_DEC_SCALE);
			    break;
			case 4:
			    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata,
				AD_I4_TO_DEC_SCALE);
			    break;
			case 8:
			    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata,
				AD_I8_TO_DEC_SCALE);
			    break;
		    }
		    break;
		}

		default:
		{
		    ADI_DT_NAME		dt_name;

		    /* can't default precision/scale for this datatype */
		    status = adi_tyname((ADF_CB *)sess_cb->pss_adfcb, 
					abs(type), &dt_name);

		    (VOID) psf_error(E_PS0C80_NO_DEFLT_ON_DT, 0L, PSF_USERERR,
			&err_code, err_blk, 1,
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &dt_name), 
			&dt_name);
		    return (E_DB_ERROR);
		}
	    }

	    /*
	    ** store precision and scale back in const node representing the
	    ** second argument
	    */
	    *(i2 *)pdata = ps;

	    break;
	}
	default:
	{
	    break;
	}
    }
    
    return(E_DB_OK);
}

/*
** Name: psl_3ary_func_extra_proc - perform additional processing for ternary
**				    functions
**
** Description:
**	Verify that the function was DECIMAL() (since this is the only ternary
**	function supported so far), validate precision and scale speicfied by
**	the user, and encode them in the node representing precision (the second
**	argument.)
**
** Input:
**	op_id		    operator id for the function
**	arg2		    node describing the second argument
**	arg3		    node describing the third argument
**
** Output:
**	arg2		    if processing DECIMAL() function, both precision and
**			    scale will be encoded in this node that formerly
**			    contained only the precision
**	err_blk		    filled in if an error occurs
**
** Side effects:
**	may change the value inside the node representing the second argument
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	06-may-93 (andre)
**	    plagiarized from scalar_function production to get rid of duplicate
**	    code in psl_p_telem()
**	20-Apr-1999 (shero03)
**	    Support PST_MOP (3 & 4 operands)
**	27-Jul-2007 (kiria01) b118856
**	    Check that PST_CONST node is of tparmtype PST_USER before asserting
**	    literal constant and dereferencing the pst_dataval.
*/
static DB_STATUS
psl_3ary_func_extra_proc(
	    i4		    op_id,
	    PST_QNODE	    *arg2,
	    PST_QNODE	    *arg3,
	    DB_ERROR	    *err_blk)
{
    i4	    err_code;
    
    if (op_id == ADI_DEC_OP)
    {
	DB_DT_ID	    type;
	i4		    len;
	PTR		    pdata;
	PTR		    sdata;

	/* 2-nd and 3-rd args must be const nodes */
	if (arg2->pst_sym.pst_type != PST_CONST ||
		arg2->pst_sym.pst_value.pst_s_cnst.pst_tparmtype != PST_USER ||
	    arg3->pst_sym.pst_type != PST_CONST ||
		arg3->pst_sym.pst_value.pst_s_cnst.pst_tparmtype != PST_USER)
	{
	   (VOID) psf_error(E_PS0C81_MUST_BE_CONST, 0L, PSF_USERERR,
		    &err_code, err_blk, 0);
	   return (E_DB_ERROR);
	}

	type = arg2->pst_sym.pst_dataval.db_datatype;
	len =  arg2->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	pdata = arg2->pst_sym.pst_dataval.db_data;

	/* must be an i2 with valid precision */
	if (abs(type) != DB_INT_TYPE || len != 2
	    || *(i2 *)pdata < 1 || *(i2 *)pdata > DB_MAX_DECPREC)
	{
	   (VOID) psf_error(E_PS0C82_BAD_PRECISION, 0L, PSF_USERERR,
		    &err_code, err_blk, 0);
	   return (E_DB_ERROR);
	}

	type  = arg3->pst_sym.pst_dataval.db_datatype;
	len   = arg3->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	sdata = arg3->pst_sym.pst_dataval.db_data;

	/* must be an i2 with valid scale */
	if (   abs(type) != DB_INT_TYPE || len != 2
	    || *(i2 *)sdata < 0 || *(i2 *)sdata > *(i2 *)pdata)
	{
	    (VOID) psf_error(E_PS0C83_BAD_SCALE, 0L, PSF_USERERR,
		    &err_code, err_blk, 1, sizeof(i2), pdata);
	    return (E_DB_ERROR);
	}

	/*
	** combine prec and scale into the node representing the second arg
	*/
	*(i2 *)pdata = DB_PS_ENCODE_MACRO(*(i2 *)pdata, *(i2 *)sdata);
    }
    else if (op_id == ADI_SUBSTRING_OP || op_id == ADI_TABLEINFO_OP)
    {
	i2	opnum = 0;
	/* operand 2 and 3 need to be numeric */
    	if (abs(arg2->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE)
           opnum = 2;
    	else if (abs(arg3->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE)
           opnum = 3;
	if (opnum)
	{
	    (VOID) psf_error(E_PS0C91_MUSTBE_NUMERIC, 0L, PSF_USERERR,
		    &err_code, err_blk, 
			(i4) sizeof("SUBSTRING")-1, "SUBSTRING",
			sizeof(i2), opnum);
	    return (E_DB_ERROR);
	}
    }

    /* Allow other 3 parameter functions, including UDTs */
    /* Only decimal() may accept 3 parameters */
    /*    (VOID) psf_error(E_PS0C84_TERNARY_FUNC, 0L, PSF_USERERR, */
    /*	&err_code, err_blk, 0);   */

    return(E_DB_OK);
}

/*
** Name: psl_arg_room - Check for room in func_args for arg pointer
**
** Description:
**
**	Function arg expressions are collected in a stack, $Yfunc_args.
**	The max size of that stack is PSS_YYMAXDEPTH * ADI_MAX_OPERANDS,
**	which might be pretty big especially if someone has increased
**	ADI_MAX_OPERANDS.  Therefore, the parser YY-vars area has room
**	for a stack that will work with most rational queries, and if
**	it runs out, we allocate the big area.  (It would certainly be
**	possible to allocate a medium sized area and work up, but it
**	hardly seems worth the effort.)
**
**	This routine is called before stacking an expression node
**	pointer.  It checks that there is enough room in the stack for N
**	more pointers, and if there isn't, the stack is expanded.
**
** Inputs:
**	cb			PSS_SESBLK * Parser session block
**	psq_cb			PSQ_CB * Query parse control block
**	yyvarsp			Pointer to parser state variables
**	n			Number of args to make room for
**
** Outputs:
**	Returns E_DB_OK or error status
**	Can reallocate $Yfunc_args pointer
**
** History:
**	10-Apr-2006 (kschendel)
**	    Written.
*/

static DB_STATUS
psl_arg_room(PSS_SESBLK *cb, PSQ_CB *psq_cb, PSS_YYVARS *yyvarsp, i4 n)
{

    i4 err_code;
    i4 i;
    i4 newmax;
    i4 psize;
    PST_QNODE **newargs;

    /* arg_ix is used in ix++ mode, it's OK until > max_args */
    if (yyvarsp->arg_ix + n <= yyvarsp->max_args)
	return (E_DB_OK);

    /* Need to make it bigger */

    newmax = PSS_YYMAXDEPTH * ADI_MAX_OPERANDS;
    if (yyvarsp->max_args == newmax)
    {
	i4 lineno = 1;
	(void) psf_error(2800L, 0, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(lineno), &lineno);
	return (E_DB_ERROR);
    }

    psize = sizeof(PST_QNODE *) * newmax;
    if (cb->pss_funarg_stream == NULL)
    {
	ULM_RCB ulm;

	/* Open us up a PSF stream for funarg stacking */
	ulm.ulm_facility = DB_PSF_ID;
	ulm.ulm_poolid = Psf_srvblk->psf_poolid;
	ulm.ulm_blocksize = 0;
	ulm.ulm_memleft = &cb->pss_memleft;
	ulm.ulm_streamid_p = &cb->pss_funarg_stream;
	ulm.ulm_psize = psize;
	ulm.ulm_flags = ULM_PRIVATE_STREAM | ULM_OPEN_AND_PALLOC;
	if (ulm_openstream(&ulm) != E_DB_OK)
	{
	    if (ulm.ulm_error.err_code == E_UL0005_NOMEM)
	    {
		(VOID) psf_error(E_PS0F02_MEMORY_FULL, 0L, PSF_CALLERR, 
			&err_code, &psq_cb->psq_error, 0);
	    }
	    else
	    {
		(VOID) psf_error(E_PS0A02_BADALLOC, ulm.ulm_error.err_code,
		    PSF_INTERR, &err_code, &psq_cb->psq_error, 0);
	    }
	    return (E_DB_ERROR);
	}
	newargs = (PST_QNODE **) ulm.ulm_pptr;
    }
    else
    {
	/* Stream is open, ask for more */
	if (psf_umalloc(cb, cb->pss_funarg_stream, psize,
		(PTR *) &newargs, &psq_cb->psq_error) != E_DB_OK)
	    return (E_DB_ERROR);
    }
    /* Copy over existing pointers and clear the remainder */
    MEcopy(yyvarsp->func_args, sizeof(PST_QNODE *) * yyvarsp->max_args,
		newargs);
    MEfill(sizeof(PST_QNODE *) * newmax - sizeof(PST_QNODE *) * yyvarsp->max_args,
	0,
	&newargs[yyvarsp->max_args]);
    yyvarsp->func_args = newargs;
    yyvarsp->max_args = newmax;

    return (E_DB_OK);

} /* psl_arg_room */

/*
** Name: psl_nary_func - Generate tree node for N-ary func(arg,...)
**
** Description:
**
**	This routine is called after parsing a zero-or-more argument
**	function call.  It creates the proper tree node and returns
**	it to the caller.
**
**	The function args are in the yyvarsp->func_args[] array.  After
**	building the function call node, we unstack the function arg
**	indexes in case it was a nested function call.
**
**	The proper tree node for a function call depends on what the
**	function call is, and how many operands it has.  If the
**	function is a set function, we call psl_set_function to handle
**	it.  For normal scalar functions, we create a COP (no args),
**	UOP (unary), BOP (binary), or MOP (n-ary) tree node.  There's
**	one special case, which is the DECIMAL function;  it looks like
**	a ternary function in its general case DECIMAL(expr,p,s) but
**	the p,s part gets squished into a combo precision/scale.  So,
**	DECIMAL generates a BOP even in its 3-operand form.
**
** Inputs:
**	cb		PSS_SESBLK * parser session CB
**	psq_cb		PSQ_CB * query parse control block
**	yyvarsp		PSS_YYVARS * parser state variables
**	func		ADI_OPINFO * function operator info
**	result_ptr	PST_QNODE ** an output
**
** Outputs:
**	result_ptr	Pointer to generated xOP tree node returned here
**	Returns E_DB_OK or error status
**
** History:
**	8-Apr-2006 (kschendel)
**	    Extract from massive nonreswd-func production, generalize to
**	    N-ary functions.  (original parse was hardcoded up to 4 args!)
**	8-may-06 (dougi)
**	    Init pst_right for non-decimal UOPs.
*/

static DB_STATUS
psl_nary_func(PSS_SESBLK *cb, PSQ_CB *psq_cb,
	PSS_YYVARS *yyvarsp, ADI_OPINFO *func, PST_QNODE **result_ptr)

{
    DB_STATUS	status;
    i4		base = yyvarsp->arg_base;  /* For convenience */
    i4		i;
    i4		numargs;
    i4		pst_flags;		/* PSS_NORES or zero */
    i4		pst_type;		/* func node type */
    PST_OP_NODE	opnode;
    PST_QNODE	*dec_node;		/* CONST node for DECIMAL() func */

    dec_node = NULL;
    *result_ptr = NULL;
    numargs = yyvarsp->arg_ix - yyvarsp->arg_base;
    if (func->adi_optype == ADI_AGG_FUNC)
    {
	/* Unary or binary aggregate function, w/o distinct. */
	status = psl_set_function(cb, psq_cb, yyvarsp,
			(char *)&func->adi_opname, PST_NDISTINCT,
			FALSE,
			yyvarsp->func_args[base], yyvarsp->func_args[base+1],
			result_ptr);
	if (status != E_DB_OK)
	    return (status);
	/* Pop off arg base stack */
	if (numargs > 0)
	    MEfill(sizeof(PST_QNODE *) * numargs, 0,
			&yyvarsp->func_args[yyvarsp->arg_base]);
	yyvarsp->arg_ix = yyvarsp->arg_base;
	yyvarsp->arg_base = yyvarsp->arg_stack[--yyvarsp->arg_stack_ix];
	return (E_DB_OK);
    }
    /*
    ** delay arg type resolution if processing target list or a CHECK
    ** constraint specified as a part of CREATE TABLE statement until
    ** we have type info on attributes that may be involved in
    ** expressions passed to the function
    */
    if (numargs > 0 && yyvarsp->in_target_clause
	|| (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	    && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		 ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
    {
	pst_flags = PSS_NORES;
    }
    else
    {
	/* Not delaying type resolution, do extra type checking based on
	** number of function args.
	*/
	pst_flags = 0;
	status = E_DB_OK;
	if (numargs == 1)
	    status = psl_1ary_func_extra_proc(cb, func->adi_opid,
			yyvarsp->func_args[base], &dec_node,
			&psq_cb->psq_error);
	else if (numargs == 2)
	    status = psl_2ary_func_extra_proc(cb, func->adi_opid,
			yyvarsp->func_args[base], yyvarsp->func_args[base+1],
			&psq_cb->psq_error);
	else if (numargs == 3)
	    status = psl_3ary_func_extra_proc(func->adi_opid,
			yyvarsp->func_args[base+1], yyvarsp->func_args[base+2],
			&psq_cb->psq_error);

	if (status != E_DB_OK)
	    return (status);
    }

    /*
    ** Figure out which sort of node we're creating, based on the
    ** number of operands.  1 = UOP, 2 = BOP, 4 or more = MOP.
    ** 3 is screwy because if it's DECIMAL(a,b,c), we combine args
    ** 2 and 3 (prec/scale) and generate a BOP;  otherwise for 3
    ** we generate a MOP.
    */
    switch (numargs)
    {
    case 0:
	pst_type = PST_COP;
	yyvarsp->func_args[base] = (PST_QNODE *) NULL;
	yyvarsp->func_args[base+1] = (PST_QNODE *) NULL;
	break;

    case 1:
	pst_type = PST_UOP;
	if (dec_node != NULL)
	{
	    pst_type = PST_BOP;
	    yyvarsp->func_args[base+1] = dec_node;
	}
	else yyvarsp->func_args[base+1] = (PST_QNODE *) NULL;
	break;

    case 2:
	pst_type = PST_BOP;
	break;

    case 3:
	/* Decimal screwyness here -- DECIMAL(exp, p, s) ends up being a
	** BOP, because p and s have to be constant and we squish them into
	** one prec/scale value.  If we aren't resolving types yet, put
	** p and s into a temp CONST node, later call to 3ary_func_extra
	** will type-check things and remove the CONST.
	*/
	if (func->adi_opid == ADI_DEC_OP)
	{
	    if (pst_flags == PSS_NORES)
	    {
		PST_QNODE *dummy;

		status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_QNODE),
		    (PTR *) &dummy, &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);

		dummy->pst_sym.pst_type = PST_CONST;
		dummy->pst_left = yyvarsp->func_args[base+1];
		dummy->pst_right = yyvarsp->func_args[base+2];
		yyvarsp->func_args[base+1] = dummy;
	    }
	    pst_type = PST_BOP;
	    break;
	}
	/* else fall thru into MOP situation */
    default:
	/* For N-ary functions, we form a chain of PST_OPERAND nodes
	** linked thru pst_left, starting with the 2nd arg.  We'll
	** ultimately create a PST_MOP pointing to the first arg and to
	** the operand chain.
	*/
	{
	    PST_QNODE *first_op_node;
	    PST_QNODE *op_node;
	    PST_QNODE *prev_node;

	    for (i = 1; i < numargs; ++i)
	    {
		status = psl_mfunc_param(psq_cb, cb,
				yyvarsp->func_args[base+i], &op_node);
		if (status != E_DB_OK)
		    return (status);
		if (i == 1)
		    first_op_node = op_node;
		else
		    prev_node->pst_left = op_node;
		prev_node = op_node;
	    }
	    /* Nothing is ever easy.  For whatever reason, all the "real"
	    ** arg expr's have to be on right links.  So, we have to put
	    ** the PST_OPERAND chain just created on the left of the MOP.
	    ** Which means that we have to hook the chain where arg[0]
	    ** normally goes, putting the real arg[0] on the right of
	    ** the MOP, in the normal arg1 position.  Faugh!
	    */
	    yyvarsp->func_args[base+1] = yyvarsp->func_args[base];
	    yyvarsp->func_args[base] = first_op_node;
	    pst_type = PST_MOP;
	}
    } /* switch */

    opnode.pst_opno = func->adi_opid;
    opnode.pst_opmeta = PST_NOMETA;
    opnode.pst_isescape = PST_DOESNT_APPLY;
    status = pst_node(cb, &cb->pss_ostream,
		yyvarsp->func_args[base], yyvarsp->func_args[base+1],
		pst_type,
		(char *) &opnode, sizeof(opnode),
		DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
		result_ptr, &psq_cb->psq_error,
		pst_flags);
    if (status != E_DB_OK)
	return (status);

    if ((*result_ptr)->pst_sym.pst_type != PST_CONST
      && BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
    {
	/*
	** If we are processing a join_search condition, set the joinid
	** field appropriately.  It has been initialized to PST_NOJOIN in
	** pst_node().
	*/
	(*result_ptr)->pst_sym.pst_value.pst_s_op.pst_joinid =
		yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
    }
    if ( (cb->pss_distrib & DB_3_DDB_SESS) && numargs <= 1)
    {
	/* Dbmsinfo() & some constant funcs are evaluated to constants */
	status = psl_proc_func(cb, func->adi_opid, yyvarsp->func_args[base],
		result_ptr, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
    }
    /* Pop off arg base stack */
    if (numargs > 0)
	MEfill(sizeof(PST_QNODE *) * numargs, 0,
			&yyvarsp->func_args[yyvarsp->arg_base]);
    yyvarsp->arg_ix = yyvarsp->arg_base;
    yyvarsp->arg_base = yyvarsp->arg_stack[--yyvarsp->arg_stack_ix];

    return (E_DB_OK);

} /* psl_nary_func */

/*
** Name:    psl_must_be_string - verify that the specified value is of
**				 "character string" datatype
**
** Description:
**	This function will be called to verify that a value specified using a
**	language variable is of "character string" datatype.
**
** Input:
**	sess_cb		    PSF session CB
**	    pss_adfcb	    ADF cb
**	in_val		    DB_DATA_VALUE whose type needs validating
**	    db_datatype	    data type to validate
**
** Output:
**	err_blk		    filled in if the datatype a char string datatype
**
** Returns:
**	E_DB_{OK,ERROR}
**	
** Side effects:
**	none
**
** History:
**	26-may-93 (andre)
**	    written
*/
DB_STATUS
psl_must_be_string(
	PSS_SESBLK	*sess_cb,
	DB_DATA_VALUE	*in_val,
	DB_ERROR	*err_blk)
{
    DB_DT_ID	    in_type = abs(in_val->db_datatype);
    
    switch (in_type)
    {
	case DB_CHR_TYPE:
	case DB_TXT_TYPE:
	case DB_CHA_TYPE:
	case DB_VCH_TYPE:
	case DB_LTXT_TYPE:
	{
	    return(E_DB_OK);
	}
	
	default:
	{
	    /* bad datatype - report an error */
	    ADI_DT_NAME     type_name;
	    i4	    err_code;

	    STmove("<none>", ' ', sizeof (ADI_DT_NAME),
		(char *) &type_name);

	    (VOID) adi_tyname((ADF_CB *) sess_cb->pss_adfcb, in_type,
		&type_name);

	    (void) psf_error(2904L, 0L, PSF_USERERR, &err_code, err_blk, 1,
		psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &type_name),
		&type_name);

	    return(E_DB_ERROR);
	}
    }
}

/*
** Name: psl_bld_col_spec_grant_template - build template for column specific
**					   GRANT statement
**
** Description:
**	This function will build a template for column-specific GRANT template
**	using bits of information found in psy_cb and text put together by the 
**	caller
**
** Input:
**	txt_chain		text chain used to build a template
**	priv_str		NULL-terminated string describing privilege
**	cols_excluded		TRUE if the privilege is being granted on a 
**				table except for some columns; FALSE otherwise
**	colq			list of column descriptions
**
** Output:
**	err_blk			filled in if an error occurs
**
** Side-effects:
**	memory will be allocated
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
** 	17-aug-93 (andre)
**	    written   
*/
static DB_STATUS
psl_bld_col_spec_grant_template(
	PTR		txt_chain,
	char		*priv_str,
	bool		cols_excluded,
	PSF_QUEUE	*colq,
	DB_ERROR	*err_blk)
{
    char	*str;
    i4		str_len;
    DB_STATUS	status;
    PTR		piece;
    PSY_COL	*psy_col;
    bool	needcomma;

    status = psq_tadd(txt_chain, (u_char *) (ERx("grant ")),
	sizeof(ERx("grant ")) - 1, &piece, err_blk);
    if (DB_FAILURE_MACRO(status))
	return(status);
    
    status = psq_tadd(txt_chain, (u_char *) priv_str,
	STlength(priv_str), &piece, err_blk);
    if (DB_FAILURE_MACRO(status))
	return(status);
    
    if (cols_excluded)
    {
	str = ERx(" excluding (");
	str_len = sizeof(ERx(" excluding (")) - 1;
    }
    else
    {
	str = ERx(" (");
	str_len = sizeof(ERx(" (")) - 1;
    }

    status = psq_tadd(txt_chain, (u_char *) str, str_len, &piece, err_blk);
    if (DB_FAILURE_MACRO(status))
	return(status);

    for (psy_col = (PSY_COL *) colq->q_next, needcomma = FALSE;
	 psy_col != (PSY_COL *) colq;
	 psy_col = (PSY_COL *) psy_col->queue.q_next
	)
    {
	u_char		*col_name;
	i4		col_nm_len;
	u_char		delim_col_name[DB_MAX_DELIMID];

	if (needcomma)
	{
	    status = psq_tadd(txt_chain, (u_char *) ERx(", "),
		sizeof(ERx(", ")) - 1, &piece, err_blk);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
	else
	{
	    needcomma = TRUE;
	}

	/*
	** if the user specified column name using a delimited 
	** identifier, we need to invoke psl_reg_id_2_delim_id() to translate 
	** column name back into a delimited identifier; otherwise we 
	** just append it as is
	*/
	col_name = (u_char *) &psy_col->psy_colnm;
	col_nm_len = psf_trmwhite(sizeof(psy_col->psy_colnm),
	    (char *) col_name);

	if (~psy_col->psy_col_flags & PSY_REGID_COLSPEC)
	{
	    status = psl_norm_id_2_delim_id(&col_name, &col_nm_len, 
		delim_col_name, err_blk);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	status = psq_tadd(txt_chain, col_name, col_nm_len, &piece, err_blk);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }

    status = psq_tadd(txt_chain, (u_char *) ERx(")"),
	sizeof(ERx(")")) - 1, &piece, err_blk);

    return (status);
}

/*
** Name: psl_norm_id_2_delim_id - convert normalized identifier to a delimited 
**				  identifier
**
** Description:
**	Given address of a normalized identifier, this function will invoke
**	cui_idunorm() to unnormalize it and return pointer to and length of 
**	the resulting delimited identifier
**
** Input:
**	ident		address of a pointer to a normalized identifier
**	ident_len	length of normalized identifier
**	delim_id_buf	buffer to be used for the delimited identifier
**
** Output:
**	ident		address of a pointer to a delimited identifier
**			contained inside delim_id_buf
**	ident_len	length of delimited identifier contained inside 
**			delim_id_buf
**	err_blk		filled in if an error is encountered
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	17-aug-93 (andre)
**	    written
*/
DB_STATUS
psl_norm_id_2_delim_id(
		u_char		**ident,
		i4		*ident_len,
		u_char		*delim_id_buf,
		DB_ERROR	*err_blk)
{
    u_i4	delim_id_len = DB_MAX_DELIMID;
    u_i4       chars_read = (u_i4) *ident_len;
    DB_STATUS	status;

    status = cui_idunorm(*ident, &chars_read, delim_id_buf, &delim_id_len, 
	(u_i4) (CUI_ID_DLM | CUI_ID_STRIP), err_blk);
    if (DB_FAILURE_MACRO(status))
    {
	i4		err_code;

	(VOID) psf_error(err_blk->err_code, 0L, 
			 PSF_INTERR, &err_code, err_blk, 2,
			 (i4)(sizeof(ERx("Normalized identifier")) - 1),
			 (PTR) (ERx("Normalized identifier")),
			 (i4) chars_read, (PTR) *ident);
	return(status);
    }

    *ident = delim_id_buf;
    *ident_len = (i4) delim_id_len;
	
    return(E_DB_OK);
}  /* end psl_norm_id_2_delim_id */

/*
** Name: psl_remove_single_quotes - remove single-quoted identifiers from
** 				    a text chain (i.e. from query text);
**				    replace them with a delimited identifier
**
** Description:
**	Removes single-quotes from an identifier, replacing them with
**	double-quotes. 
**	
**	Given the address of a string constant returned from the scanner,
**	this function finds the piece of the text chain containing the string
**	constant (in this case it's actually a single-quoted identifier),
**	and replaces that piece with the delimited identifier version of the
**	string.
**
**	(At some point in the future, we may want to change this to strip the
**	single quotes and only replace them with delimiters if the identifier
**	NEEDS to be delimited.)
**	
**	The expected use of this function is for removing single-quotes from
**	identifiers in query text stored in the catalogs for statements like
**	CREATE PROCEDURE and CREATE VIEW.  In 6.5, we no longer want any
**	single-quoted identifiers stored in the query text catalog, because we
**	are deprecating single-quoted identifiers for most statements and will
**	remove support for them in 6.6 (if possible).
**
** Input:
**	text_chain	pointer to the head of the text chain
**	identifier	pointer to SCONST identifier returned from scanner
**
** Output:
**	text_chain	modified to contain a delimited identifier for
**			<identifier> instead of a single-quoted identifier
**	err_blk		filled in if an error is encountered
**
** Returns:
**	E_DB_{OK,ERROR}
**
** Side effects:
**	none
**
** History:
**	27-oct-93 (rblumer)
**	    written
*/
static DB_STATUS
psl_remove_single_quotes(
			  char	*text_chain,
			  char	*identifier,	/* normalized identifier from
						** scanner */
			  DB_ERROR *err_blk)
{
    DB_STATUS	status;
    u_char	delim_id[DB_MAX_DELIMID];
    i4		id_len;
    PTR		newpiece, *oldpieceptr;
    
#ifdef BYTE_ALIGN
    PTR             align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*oldpieceptr)
#endif

    /* The pointer to the piece of the text chain holding the single-quoted
    ** identifier is stored after the string constant by the scanner.
    ** 
    ** Since the quoted identifier is returned as an SCONST (string constant),
    ** it is stored in a DB_TEXT_STRING & we need to add DB_CNTSIZE to its
    ** length in order to find the piece ptr.
    ** (Note that <identifier> no longer points to a DB_TEXT_STRING, since
    **  sconvert() has been run on it; <identifier> points to the beginning
    **  of a null-terminated string that is in the same memory space as the
    **  original DB_TEXT_STRING.  Which is why STlength + DB_CNT_SIZE works!)
    */
    oldpieceptr = (PTR *) (identifier + STlength(identifier) + DB_CNTSIZE);

#ifdef BYTE_ALIGN
    MECOPY_CONST_MACRO((PTR)oldpieceptr, sizeof(PTR),
		       (PTR)&align_ptr);
#endif

    /* convert identifier to delimited identifier
    ** (identifier pointer gets overwritten, but not the identifier itself)
    */
    id_len = STlength(identifier);

    status = psl_norm_id_2_delim_id((u_char **) &identifier, &id_len, 
				    delim_id, err_blk);
    if (DB_FAILURE_MACRO(status))
	    return(status);

    /* Add a space first, to separate delimited id from previous keyword
    ** (since align_ptr may point to a name with preceding blanks, and
    **  <identifier> has no preceding blanks).
    */
    status = psq_tinsert(text_chain, (u_char *) ERx(" "), sizeof(ERx(" ")) - 1,
			 &newpiece, align_ptr, err_blk);
    if (DB_FAILURE_MACRO(status))
	return (status);

    /* replace single-quoted id with delimited id name
     */
    status = psq_tsubs(text_chain, align_ptr, (u_char *) identifier, id_len,
		       &newpiece, err_blk);
    return (status);

} /* end psl_replace_single_quotes */

/*
** Name: psl_prepend_schemaname - add the owner/schema name to query text 
** 				  in order to qualify an object reference
**
** Description:
**	Adds the qualifier 'schema.' to a tablename, in order to have a
**	fully-qualified table reference of form 'schema.tablename' in the query
**	text.  This is necessary in order to allow VIEWS and PROCEDURES to be
**	recreated with the same tables, even if tables with the same name are
**	added to the schema later.  (Note: the 'table' above could also be a
**	view or a synonym.)
**
**	The schema name is always converted to a delimited identifier before
**	being added to the text, since we don't know if the identifier really
**	needs to be delimited or not.  Since the username is already
**	case-translated when we get it, and DELIM_ID_CASE has to be either be
**	mixed (untranslated) or the same as REG_ID_CASE, this will never cause
**	case-translation problems when recreating the procedure.
**	
**	Given the address of a string constant returned from the scanner,
**	this function finds the piece of the text chain containing the string
**	constant and inserts 'schema.' before that piece of the chain.
**
**	(At some point in the future, we may want to change this to strip the
**	single quotes and only replace them with delimiters if the identifier
**	NEEDS to be delimited.)
**	
** Input:
**	text_chain	pointer to the head of the text chain
**	obj_name	pointer to orig_obj_name returned from scanner
**	schema_name	pointer to schema/owner name to be added
**
** Output:
**	text_chain	modified to contain a delimited identifier for
**			<identifier> instead of a single-quoted identifier
**	err_blk		filled in if an error is encountered
**
** Returns:
**	E_DB_{OK,ERROR}
**
** Side effects:
**	none
**
** History:
**	29-oct-93 (rblumer)
**	    written
*/
static DB_STATUS
psl_prepend_schemaname(
		     char	*text_chain,
		     char	*obj_name,
		     u_char	*schema_name,
		     DB_ERROR	*err_blk)
{
    DB_STATUS	status;
    u_char	delim_id[DB_MAX_DELIMID];
    i4		schema_len;
    PTR		newpiece, *oldpieceptr;
    
#ifdef BYTE_ALIGN
    PTR             align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*oldpieceptr)
#endif

    /* The pointer to the piece of the text chain holding the 
    ** identifier is stored after the string by the scanner.
    ** Note that we have to account for the null terminator.
    */
    oldpieceptr = (PTR *) (obj_name + STlength(obj_name) + 1);

#ifdef BYTE_ALIGN
    MECOPY_CONST_MACRO((PTR)oldpieceptr, sizeof(PTR),
		       (PTR)&align_ptr);
#endif

    /* convert schema name to a delimited identifier
    ** (schema_name pointer gets overwritten)
    */
    schema_len = psf_trmwhite(DB_MAXNAME, (char *) schema_name);

    status = psl_norm_id_2_delim_id((u_char **) &schema_name, &schema_len, 
				    delim_id, err_blk);
    if (DB_FAILURE_MACRO(status))
	    return(status);

    /* Add a space first,
    ** to separate delimited id from previous keyword
    */
    status = psq_tinsert(text_chain, (u_char *) ERx(" "), sizeof(ERx(" ")) - 1,
			 &newpiece, align_ptr, err_blk);
    if (DB_FAILURE_MACRO(status))
	return (status);

    /* Add delimited schema/owner name
     */
    status = psq_tinsert(text_chain, schema_name, schema_len,
			 &newpiece, align_ptr, err_blk);
    if (DB_FAILURE_MACRO(status))
	return (status);

    /* Add a PERIOD */
    status = psq_tinsert(text_chain, (u_char *) ERx("."), sizeof(ERx(".")) - 1,
			 &newpiece, align_ptr, err_blk);
    return (status);

} /* end psl_prepend_schemaname */

/*
** Name: psl_seqop_search: - check a parse tree fragment for presence of 
**				sequence operators.
**
** Description:
**	Descends a parse tree fragment searching for PST_SEQOP nodes. This
**	is done to disallow queries with sequence operators in invalid 
**	contexts (such as case expressions and aggregate functions).
**
** Input:
**	nodep		pointer to parse tree fragment being searched
**
** Output:
**
** Returns:
**	TRUE	- sequence operator was found
**	FALSE	- sequence operator was not found
**
** Side effects:
**	none
**
** History:
**	9-apr-02 (inkdo01) 
**	    Written for sequence support.
*/
static bool
psl_seqop_search(
	PST_QNODE	*nodep)

{
    /* This function trivially decends a parse tree fragment looking for 
    ** PST_SEQOP nodes. */

    if (nodep == (PST_QNODE *) NULL)
	return(FALSE);		/* check for no expression at all */

    switch (nodep->pst_sym.pst_type) {
      case PST_SEQOP:
	return(TRUE);		/* got one - return TRUE */

      default:
	/* For all the rest, just keep descending. */
	if (nodep->pst_left && psl_seqop_search(nodep->pst_left))
	    return(TRUE);	/* found one somewhere on left */
	if (nodep->pst_right && psl_seqop_search(nodep->pst_right))
	    return(TRUE);	/* found one somewhere on right */

	else return(FALSE);	/* nuttin' dere */
    }

}

/*
** Name: psl_validate_collation_name - verify a collation name specified 
**	in a column definition (or later, in a order by, group by).
**
** Description:
**	Loops over a list of known collation names searching for specified 
**	value. Later it will have to search iicollation catalog.
**
** Input:
**	collname	pointer to collation name token value
**	collID		pointer to collID value to return to caller
**
** Output:
**
** Returns:
**	TRUE	- collation name is valid
**	FALSE	- collation name is not valid
**
** Side effects:
**	none
**
** History:
**	13-dec-04 (inkdo01)
**	    Written for column level collation support.
*/
static bool
psl_validate_collation_name(
	char		*collname,
	i4		*collID)

{
    char	cname[DB_MAXNAME];
    char	*letter;
    i4		i;

    /* Copy collation name to local memory and turn it to lower case. */
    STcopy(collname, cname);
    for (letter = &cname[0]; *letter != EOS; CMnext(letter))
	CMtolower(letter, letter);

    /* Loop over valid collation name array looking for match. */
    *collID = -1;		/* init */
    for (i = 0; i < VALID_COLLATION_COUNT; i++)
	if (STcompare(&cname[0], collname_array[i]) == 0)
	    break;

    if (i < VALID_COLLATION_COUNT)
	*collID = i+1;

    return((*collID >= 0) ? TRUE : FALSE);
}

/*
** Name: psl_validate_collation_mix - verify that binary operation 
**	doesn't involve incompatible collations
**
** Description:
**	non-explicit collation and explicit collation are ok, as are
**	Explicitly declared unicode and unicode_case_insensitive. But 
**	the rest are verboten.
**
** Input:
**	collID1		operand1 collation ID
**	collID2		operand2 collation ID
**
** Output:
**
** Returns:
**	TRUE	- operation is valid
**	FALSE	- operation is NOT valid
**
** Side effects:
**	none
**
** History:
**	30-dec-04 (inkdo01)
**	    Written for column level collation support.
*/
static bool
psl_validate_collation_mix(
	i2	collID1,
	i2	collID2)

{

    /* Not much to it - just check for mixed non-default collations. */

    if (collID1 > 0 && collID2 > 0 && collID1 != collID2 && 
	!((collID1 == DB_UNICODE_COLL ||
	collID1 == DB_UNICODE_CASEINSENSITIVE_COLL) && 
	(collID2 == DB_UNICODE_COLL || collID2 == DB_UNICODE_CASEINSENSITIVE_COLL)))
	return(FALSE);

    return(TRUE);
}

/*
** Name: psl_collation_check - verify that collation ID is appropriate.
**
** Description:
**	Checks that data type is string and that collation ID is valid
**	for the type.
**
** Input:
**	cb
**	dv		ptr to DB_DATA_VALUE to validate
**	collID		collation ID to validate
**
** Output:
**
** Returns:
**
** Side effects:
**	none
**
** History:
**	1-feb-06 (dougi)
**	    Written to allow cast functions with collation ID.
*/
static DB_STATUS
psl_collation_check(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	DB_DATA_VALUE	*dv,
	i2		collID)
{
    i4		err_code;
    DB_DT_ID	dtype = dv->db_datatype;

    /* Do collation checks - first assure that collation is
    ** applicable for data type, then assure that column level
    ** collation is supported for defined collation. */
    if (!(((dtype == DB_NCHR_TYPE || dtype == DB_NVCHR_TYPE) &&
	    collID <= 2) || (collID > 2 &&
	    (dtype == DB_CHA_TYPE || dtype == DB_CHR_TYPE ||
	     dtype == DB_VCH_TYPE || dtype == DB_TXT_TYPE))))
    {
	i2	tcode;

	tcode = (collID <= 2) ? 0 : 1;
	(VOID) psf_error(6426L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		STlength(collname_array[collID-1]),
		collname_array[collID-1],
		STlength(type_array[tcode]), type_array[tcode]);
	return (E_DB_ERROR);
    }

    if (collID > 3)
    {
	(VOID) psf_error(6425L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength(collname_array[collID-1]),
		collname_array[collID-1]);
	return (E_DB_ERROR);
    }

    return(E_DB_OK);
}


/*
** Name: psl_push_yyvars - allocate fresh YYVARS and push previous.
**
** Description:
**	When subselect is encountered in FROM clause (and possibly in 
**	other non-WHERE clause contexts), allocate fresh YYVARS, push old
**	one and effectively recurse the YACC locals.
**
** Input:
**	psq_cb		ptr to parser control block
**	cb		ptr to PSF session control block
**	yyvpp		ptr to ptr to YACC locals
**
** Output:
**	yyvpp		ptr to ptr to fresh copy of YACC locals
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	24-jan-06 (dougi)
**	    Written for subselect in FROM clause support.
*/
static DB_STATUS
psl_push_yyvars(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	PSS_YYVARS	**yyvpp)

{
    DB_STATUS	status = E_DB_OK;

    /* Just include yyvarsinit.h to initialize local instance of 
    ** PSS_YYVARS, then allocate fresh copy and copy it over. */

#define YYVARS	PSS_YYVARS	/* stupid YACC! */
#include <yyvarsinit.h>

    /* Local yyvars has been initialized. Save parent into it, allocate
    ** fresh one, then copy local into allocated storage. */

    yyvars.prev_yyvarsp = *yyvpp;
    yyvars.join_id = yyvars.prev_yyvarsp->join_id; /* join_id persists */

    /* Open memory stream for allocating query tree, if not already
    ** open
    */
    if (!cb->pss_ostream.psf_mstream.qso_handle &&
	(status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	&psq_cb->psq_error)) != E_DB_OK)
    {
        return (status);    /* non-zero return means error */
    }

    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_YYVARS),
				yyvpp, &psq_cb->psq_error);
    if (DB_FAILURE_MACRO(status))
    {
	*yyvpp = yyvars.prev_yyvarsp;
	return(status);
    }

    /* Now copy it over. */
    MEcopy((char *)&yyvars, sizeof(PSS_YYVARS), (char *)*yyvpp);
    QUinit((QUEUE *)&(*yyvpp)->dcol_list);
    return(E_DB_OK);

}


/*
** Name: psl_groupingsets_fromcr - generate PST_GSET from cube/rollup
**
** Description:
**	There can only be one CUBE/ROLLUP optimally processed in a single
**	GROUPING SETS. If a GROUP BY has more than one, the subsequent ones
**	must be expanded into their corresponding GROUPING SETS.
**
** Input:
**	cb		ptr to PSF session control block
**	psq_cb		ptr to parser control block
**	crtype		indicator of whether this is CUBE or ROLLUP
**	listp		ptr to chain of entries in CUBE/ROLLUP
**	newnodep	ptr to ptr to PST_GSET structure to be returned
**
** Output:
**	newnodep	ptr to ptr to PST_GSET returned by expansion
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	5-apr-06 (dougi)
**	    Written for GROUP BY enhancements.
*/
static DB_STATUS
psl_groupingsets_fromcr(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	i4		crtype,
	PST_QNODE	*listp,
	PST_QNODE	**newnodep)

{
    PST_QNODE	*nodep, *prevgcl;
    PSS_DUPRB	dup_rb;
    i4		i, j, k;
    DB_STATUS	status;


    /* Create PST_GSET node and fill it in with expanded ROLLUP or 
    ** CUBE (different algorithm is used for each). */

    /* Init. the pst_treedup() parameter. */
    dup_rb.pss_op_mask	= 0;
    dup_rb.pss_num_joins = PST_NOJOIN;
    dup_rb.pss_tree_info = (i4 *) NULL;
    dup_rb.pss_mstream = &cb->pss_ostream;
    dup_rb.pss_1ptr	= NULL;
    dup_rb.pss_err_blk	= &psq_cb->psq_error;

    /* CUBE and ROLLUP both have empty grouping set. */
    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_GCL, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&prevgcl, &psq_cb->psq_error, 0);
    if (DB_FAILURE_MACRO(status))
	return(status);

    /* Allocate the PST_GSET and start by attaching the empty GCL. */
    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			prevgcl, PST_GSET, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			newnodep, &psq_cb->psq_error, 0);
    if (DB_FAILURE_MACRO(status))
	return(status);

    for (i = 0, nodep = listp; 
		nodep && nodep->pst_sym.pst_type != PST_TREE; 
		i++, nodep = nodep->pst_left);	/* count list entries */

    if (crtype == PST_GROUP_ROLLUP)
    {
	/* For ROLLUP, just take 1st 1, 2, 3, ... entries in listp and
	** make successive PST_GCLs from them. */
	for (j = 1; j <= i; j++)
	{
	    /* Allocate PST_GCL to contain next set of entries. */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_GCL, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&prevgcl->pst_left, &psq_cb->psq_error, 0);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    prevgcl = prevgcl->pst_left;
	    if (j == i)
	    {
		/* For last entry, stick in whole list of entries. */
		prevgcl->pst_right = listp;
		return(E_DB_OK);	/* and we're done */
	    }

	    /* Position nodep at nth entry in ROLLUP list in preparation
	    ** for copy. */
	    for (k = 0, nodep = listp; k < j; k++, nodep = nodep->pst_left);
	    dup_rb.pss_tree = nodep;
	    dup_rb.pss_dup = &prevgcl->pst_right;

	    status = pst_treedup(cb, &dup_rb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	return(E_DB_OK);
    }

    /* Now do CUBE expansion. This is trickier. We compute 2**i-1 (the
    ** number of grouping sets that a CUBE expands to). Then loop from 
    ** 1 to the value - each loop corresponds to a grouping and the grouping
    ** contains the list entries whose positions correspond to the set 
    ** bits in the loop control variable. E.g. the value of 5 corresponds
    ** to the grouping set with the 1st and 3rd entries of the cube list. */


}


/*
** Name: psl_groupingsets_normalize - check GROUP BY for grouping sets and
**	flatten them
**
** Description:
**	If a GROUP BY has multiple elements and at least one is a 
**	GROUPING SETS subclause, the gb must be transformed into a chain
**	of grouping sets that are the polynomial product of the 
**	original entries.
**	E.g. GROUP BY a, b, GROUPING SETS (c, d) becomes:
**	GROUP BY GROUPING SETS ((a, b, c), (a, b, d))
**
** Input:
**	cb		ptr to PSF session control block
**	psq_cb		ptr to parser control block
**	rootp		ptr to ptr to root node of GROUP BY list
**
** Output:
**	rootpp		ptr to ptr to updated GROUP BY list
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	31-mar-06 (dougi)
**	    Written for GROUP BY enhancements.
*/
static DB_STATUS
psl_groupingsets_normalize(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**rootp)

{
    DB_STATUS	status = E_DB_OK;
    PST_QNODE	*nodep, *prevp, *np1, *np2, *newgs;
    i4		i;

    bool	gotone, alldone = FALSE, notfirst = FALSE;


    /* Start by looking for PST_GSETs in the BY list. If none, there's
    ** nothing else to do but set the pst_rsno values. If there is
    ** one, and at least one other BY list entry, allocate an outer
    ** PST_GSET to anchor whole BY list and loop 'til the expansions
    ** are done. */

    for (nodep = *rootp, gotone = FALSE, i = 0; 
		nodep && nodep->pst_sym.pst_type != PST_TREE &&
				(!gotone || i <= 1);
		i++, nodep = nodep->pst_left)
     if (nodep->pst_sym.pst_type == PST_GSET)
	gotone = TRUE;

    if (i > 1 && gotone)
    {
	/* We need to expand. First allocate a PST_GSET to anchor 
	** the new list of PST_GSETs. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			*rootp, PST_GSET, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			rootp, &psq_cb->psq_error, 0);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* Next, loop over evolving BY list until there are no more
	** expansions to do. */
	do {
	    status = psl_groupingsets_expand(cb, psq_cb, rootp, &alldone);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	} while(!alldone);

	/* Then loop over all of them, looking for PST_GCLs to collapse. */
	for (nodep = *rootp; nodep; nodep = nodep->pst_left)
	 for (np1 = nodep->pst_right, prevp = NULL; np1;
			prevp = np1, np1 = np1->pst_left)
	  if (np1->pst_sym.pst_type == PST_GCL && np1->pst_right)
	  {
	    /* Got a PST_GCL. Drop the PST_GCL node and absorb the rest. */
	    if (prevp == (PST_QNODE *) NULL)
		nodep->pst_right = np1->pst_right;
	    else prevp->pst_left = np1->pst_right;

	    for (np2 = np1->pst_right; np2->pst_left; np2 = np2->pst_left);
					/* skip to end of GCL chain */
	    np2->pst_left = np1->pst_left;
	    np1 = np2;			/* reset for for-loop */
	  }

    }
    else if (gotone)
    {
	/* GROUP BY has one entry - a GROUPING SETS clause. Each 
	** entry in the list now requires a PST_GSET. */
	for (nodep = (*rootp)->pst_right, prevp = *rootp; 
		nodep && nodep->pst_sym.pst_type != PST_TREE;
		prevp = newgs, np1 = nodep, nodep = nodep->pst_left, 
				np1->pst_left = (PST_QNODE *) NULL)
	{
	    /* Allocate a PST_GSET for each entry and unstring them.
	    ** Notice that the first entry is left attached to the 
	    ** original PST_GSET. */
	    if (notfirst)
	    {
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			nodep, PST_GSET, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&newgs, &psq_cb->psq_error, 0);
		if (DB_FAILURE_MACRO(status))
		    return(status);

		prevp->pst_left = newgs;
	    }
	    else newgs = *rootp;

	    notfirst = TRUE;

	    if (nodep->pst_sym.pst_type == PST_GCL &&
		nodep->pst_right != (PST_QNODE *) NULL)
	    {
		/* flatten non-empty GCLs into containing GSET. */
		newgs->pst_right = nodep->pst_right;
	    }
	}
    }
	

    /* Now, pass over the <group by> to assign ascending resdom nos
    ** and attach PST_TREE nodes where necessary. */
    for (nodep = *rootp; nodep; nodep = nodep->pst_left)
    {
	i4		rsdmno = 0;

	/* If there's a bunch of PST_GSETs, each must be tidied separately.
	** Otherwise, just tidy the whole list at once. */
	status = psl_groupingsets_tidy(cb, psq_cb, 
	    (nodep->pst_sym.pst_type == PST_GSET) ? nodep->pst_right : nodep, 
	    &rsdmno);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	if (nodep->pst_sym.pst_type != PST_GSET)
	    break;
    }

    return(E_DB_OK);
}


/*
** Name: psl_groupingsets_expand - replicates chunks of the GROUP BY to
**	expand the contained GROUPING SETS.
**
** Description:
**	If a GROUP BY has multiple elements and at least one is a 
**	GROUPING SETS subclause, the gb must be transformed into a chain
**	of grouping sets that are the polynomial product of the 
**	original entries.
**	E.g. GROUP BY a, b, GROUPING SETS (c, d) becomes:
**	GROUP BY GROUPING SETS ((a, b, c), (a, b, d))
**
** Input:
**	cb		ptr to PSF session control block
**	psq_cb		ptr to parser control block
**	rootpp		ptr to ptr to root node of GROUP BY list
**	alldonep	ptr to bool returning indication of completion
**			of expansion process
**
** Output:
**	rootpp		ptr to ptr to updated GROUP BY list
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	31-mar-06 (dougi)
**	    Written for GROUP BY enhancements.
*/
static DB_STATUS
psl_groupingsets_expand(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**rootp,
	bool		*alldonep) 

{
    DB_STATUS	status = E_DB_OK;
    PST_QNODE	*np1, *np2, *np3, *newgs, *prevgs, *prev2, *xroot;
    PST_QNODE	*nodep, *outerp, *pouterp;
    PSS_DUPRB	dup_rb;
    i4		i, j;


    /* Init. the pst_treedup() parameter. */
    dup_rb.pss_op_mask	= 0;
    dup_rb.pss_num_joins = PST_NOJOIN;
    dup_rb.pss_tree_info = (i4 *) NULL;
    dup_rb.pss_mstream = &cb->pss_ostream;
    dup_rb.pss_1ptr	= NULL;
    dup_rb.pss_err_blk	= &psq_cb->psq_error;

    /* Look for the first BY list element with an embedded PST_GSET. */

    for (outerp = *rootp, pouterp = NULL; outerp; 
			pouterp = outerp, outerp = outerp->pst_left)
    {
	/* Search this BY list entry for an embedded PST_GSET. */
	for (nodep = outerp->pst_right, *alldonep = TRUE; nodep;
						nodep = nodep->pst_left)
	 if (nodep && nodep->pst_sym.pst_type == PST_GSET)
	 {
	    *alldonep = FALSE;		/* exit loop */
	    break;
	 }

	if (nodep == (PST_QNODE *) NULL ||
				nodep->pst_sym.pst_type != PST_GSET)
	    continue;			/* skip to next BY list entry */

	/* Found a PST_GSET to expand. Loop over embedded GSET, copying
	** whole BY list entry for each element. */
	for (np1 = nodep->pst_right, i = 0, xroot = NULL;
			np1 && np1->pst_sym.pst_type != PST_TREE;
			i++, np1 = np1->pst_left)
	{
	    /* Allocate new PST_GSET to spice into BY list. */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_GSET, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&newgs, &psq_cb->psq_error, 0);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    if (xroot == (PST_QNODE *) NULL)
		xroot = newgs;
	    else prevgs->pst_left = newgs;
	    prevgs = newgs;

	    dup_rb.pss_tree = outerp->pst_right;
	    dup_rb.pss_dup = &newgs->pst_right;
	    status = pst_treedup(cb, &dup_rb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	    
	    /* Now locate the GSET to expand in the copied tree. */
	    for (np2 = newgs->pst_right, prev2 = NULL; np2;
			prev2 = np2, np2 = np2->pst_left)
	     if (np2->pst_sym.pst_type == PST_GSET)
		break;		/* found the GSET to remove */

	    /* Now locate the ith entry in the embedded GSET. That's 
	    ** the one that will replace the whole GSET in the new 
	    ** expanded GSET. */
	    for (j = 0, np3 = np2->pst_right; j < i && np3; 
					j++, np3 = np3->pst_left);

	    if (np3 == (PST_QNODE *) NULL)
		return(E_DB_SEVERE);	/* this better not happen! */

	    /* Splice around the old GSET. */
	    if (prev2 == (PST_QNODE *) NULL)
		newgs->pst_right = np3;
	    else prev2->pst_left = np3;
	    np3->pst_left = np2->pst_left;
	}	/* end of GSET expansion */

	if (pouterp == NULL)
	    *rootp = xroot;
	else pouterp->pst_left = xroot;

	newgs->pst_left = outerp->pst_left;	/* hook in rest of 
						** GROUP BY elements */

	return(E_DB_OK);
    }

}


/*
** Name: psl_groupingsets_tidy - set pst_rsno values and terminate
**	any NULL-terminated chains
**
** Description:
**	Recursively descend the GROUP BY list and assign the resdom nos
**	on the way back out.
**
** Input:
**	cb		ptr to PSF session control block
**	psq_cb		ptr to parser control block
**	nodep		ptr to GROUP BY list to be tidied
**	rsdmnop		ptr to current value of pst_rsno
**
** Output:
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	4-apr-06 (dougi)
**	    Written for GROUP BY enhancements.
*/
static DB_STATUS
psl_groupingsets_tidy(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*nodep,
	i4		*rsdmnop)

{
    DB_STATUS	status;
    i4		crcount = 0;


    /* If this is a PST_GBCR, tidy its insides. */
    if (nodep->pst_sym.pst_type == PST_GBCR)
    {
	status = psl_groupingsets_tidy(cb, psq_cb, nodep->pst_right, &crcount);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }

    /* If this is the last node in a chain and isn't properly terminated,
    ** add a PST_TREE node. */
    if (nodep->pst_left == (PST_QNODE *) NULL)
    {
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&nodep->pst_left, &psq_cb->psq_error, 0);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }

    /* If the next node isn't a PST_TREE, recurse on it. */
    if (nodep->pst_left->pst_sym.pst_type != PST_TREE)
    {
	status = psl_groupingsets_tidy(cb, psq_cb, nodep->pst_left, rsdmnop);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }

    /* Finally - check for RESDOM and update its pst_rsno. */
    if (nodep->pst_sym.pst_type == PST_RESDOM)
	nodep->pst_sym.pst_value.pst_s_rsdm.pst_rsno = ++(*rsdmnop);

    return(E_DB_OK);

}

/*
** Name: psl_ansi_strtodt - semantic action for handling ANSI date/time
**			    literals.
**
** Description:
**	This functions implements the semantic action for constant functions
**	CURRENT_USER, USER, SESSION_USER, SYSTEM_USER, and INITIAL_USER.
**	First we call ADF to get the right function instance, then we build a
**	query tree node for the function
**	
**	NOTE: call will contain either a non-null newnode or a non-null dataval.
**	If the former, it will build a CONST node, otherwise it will just
**	fill in dataval.
**
** Input:
**	cb		ptr to PSF session control block
**	ansitype 	datatype of the literal 
**	intflds		range of fields in interval
**	instr		input character string
**	secfrac		fractions of seconds (in interval literal)
**			
** Output:
**	*newnode	will point at a newly allocated query tree node
**	dataval		will contain coerced date/time value
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	30-aug-06 (gupsh01)
**	    Created.
**	12-jan-2007 (dougi)
**	    Augmented support of intervals.
**	15-mar-2007 (dougi)
**	    Added support for fractions of secs in interval literals.
**	12-oct-2007 (dougi)
**	    Add logic to optionally only build and return the DB_DATA_VALUE.
**	13-Feb-2008 (kiria01) b119908
**	    Fix uninit'd variables plen, aoff & alen that can be accessed on an
**	    error path. (Klocwork IDis:4517,4520,4521)
**	    And while here address Klocwork ID: 4522 - bad NULL test
*/
DB_STATUS
psl_ansi_strtodt(
        PSS_SESBLK      *cb,
        PSQ_CB          *psq_cb,
	DB_DT_ID	ansitype,
	i4		intflds,
        DB_TEXT_STRING	*instr,
        PST_QNODE       **newnode,
	DB_DATA_VALUE	*dataval,
	i2		secfrac)
{
	DB_STATUS		status = E_DB_OK;
	PST_CNST_NODE		cconst;
	i4			constSize;
	i2			stringlen;
	i2			precision;
	DB_DATA_VALUE		indv;
	DB_DATA_VALUE		outdv;
	DB_DATA_VALUE		*outp;
	i4			composite;
	AD_ADATE		adate;
	AD_TIME			atime;
	AD_TIMESTAMP		atimestamp;
	AD_INTYM 		aintym;
	AD_INTDS		aintds;
	i4		        err_code;
	ADF_CB 			*adf_cb = cb->pss_adfcb;
	ADF_ERROR		adf_errcb = adf_cb->adf_errcb;
	PTR			savedp;
	i2			poff=0, plen=0, aoff=0, alen=0;
	bool			prepend = FALSE, append = FALSE;


	if (dataval)
	    outp = dataval;
	else outp = &outdv;

	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;

	composite = ((DB_TEXT_STRING *)instr)->db_t_count;
	precision = DB_P_DECODE_MACRO(composite);
	stringlen    = DB_S_DECODE_MACRO(composite);
	instr->db_t_count = stringlen;	/* just store string length */

        indv.db_data = (char *)instr;
        indv.db_length = stringlen + DB_CNTSIZE;
        indv.db_datatype = DB_VCH_TYPE;
        indv.db_prec = 0;
        indv.db_collID = 0;

	/* If this is an interval literal, check for incomplete value
	** that requires 0 valued fields to be prepended and/or
	** appended. */
	if (ansitype == DB_INYM_TYPE && (intflds/8 == INT_MONTH ||
			intflds%8 == INT_YEAR))
	{
	    if (intflds/8 == INT_MONTH)
	    {
		/* MONTH only - prepend "0-" for year. */
		prepend = TRUE;
		poff = 0;
		plen = 2;
	    }
	    else
	    {
		/* YEAR only - append "-0" for month. */
		append = TRUE;
		aoff = 1;
		alen = 2;
	    }
	}
	else if (ansitype == DB_INDS_TYPE && (intflds/8 != INT_DAY ||
			intflds%8 != INT_SECOND))
	{
	    /* Switch on 2nd and 1st field to determine prepend/append
	    ** parameters. */
	    prepend = TRUE;
	    poff = 3;			/* prepend always starts here */
	    switch (intflds/8) {
	      case INT_DAY:
		prepend = FALSE;	/* nothing to prepend */
		break;
	      case INT_HOUR:
		plen = 2;
		break;
	      case INT_MINUTE:
		plen = 4;
		break;
	      case INT_SECOND:
		plen = 6;
		break;
	    }

	    append = TRUE;
	    switch (intflds%8) {
	      case INT_DAY:
		aoff = 4;
		alen = 6;
		break;
	      case INT_HOUR:
		aoff = 6;
		alen = 4;
		break;
	      case INT_MINUTE:
		aoff = 8;
		alen = 2;
		break;
	      case INT_SECOND:
		append = FALSE;		/* nothing to append */
		break;
	    }
	}

	/* Perform prepend/append operations into work field & copy
	** updated string back. */
	if (prepend || append)
	{
	    char	intwork[50];
	    i2		ilen;

	    /* Copy prepend string. */
	    if (prepend)
	    {
		MEcopy(&interval_filler[poff], plen, &intwork[0]);
		ilen = plen;
	    }
	    else ilen = 0;

	    /* Copy actual literal value. */
	    MEcopy(&instr->db_t_text[0], stringlen, &intwork[ilen]);
	    ilen += stringlen;

	    /* Copy append string. */
	    if (append)
	    {
		MEcopy(&interval_filler[aoff], alen, &intwork[ilen]);
		ilen += alen;
	    }

	    /* Put resulting string back in symbol table. */
	    MEcopy(&intwork[0], ilen, &instr->db_t_text[0]);
	    instr->db_t_count = stringlen = ilen;
	    indv.db_length = ilen + DB_CNTSIZE;
	}

	if (dataval)
	    savedp = outp->db_data;

	switch (ansitype)
	{
	  case DB_ADTE_TYPE:
	    outp->db_data = (char *)&adate;
	    outp->db_length = ADF_ADATE_LEN;
	    break;

	  case DB_TMWO_TYPE:
	  case DB_TMW_TYPE:
	  case DB_TME_TYPE:
	    outp->db_data = (char *)&atime;
	    outp->db_length = ADF_TIME_LEN;
	    break;

	  case DB_TSWO_TYPE:
	  case DB_TSW_TYPE:
	  case DB_TSTMP_TYPE:
	    outp->db_data = (char *)&atimestamp;
	    outp->db_length = ADF_TSTMP_LEN;
	    break;

	  case DB_INYM_TYPE:
	    outp->db_data = (char *)&aintym;
	    outp->db_length = ADF_INTYM_LEN;
	    break;

	  case DB_INDS_TYPE:
	    outp->db_data = (char *)&aintds;
	    outp->db_length = ADF_INTDS_LEN;
	    /* Default second precision is 6. */
	    if (intflds/8 == INT_SECOND || intflds%8 == INT_SECOND)
		precision = secfrac;
	    break;

	  default:
	    /* ERROR */
	    break;
       }

	if (dataval)
	    outp->db_data = savedp;
        outp->db_prec = precision;
        outp->db_datatype = ansitype;
        outp->db_collID = 0;

        status = adu_21ansi_strtodt (cb->pss_adfcb,
                                        &indv, outp);
        if (DB_FAILURE_MACRO(status))
        {
	    (VOID) psf_error(2937L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof (cb->pss_lineno), &cb->pss_lineno,
                instr->db_t_count, instr->db_t_text);

	      if (!cb->pss_adfcb || 
		  cb->pss_adfcb->adf_errcb.ad_errclass == ADF_USER_ERROR)
                  psf_adf_error(&adf_errcb, &psq_cb->psq_error, cb);

	    return (E_DB_ERROR);
        }

	if (newnode)
	{
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
		ansitype, (i2) precision, outp->db_length, 
		(DB_ANYTYPE *)outp->db_data , newnode, &psq_cb->psq_error, 
		(i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}

	return (E_DB_OK);
}
extern WSCREADONLY yytabelem pslsexca[];
# define YYNPROD 1959
# define YYLAST 7397
extern WSCREADONLY yytabelem pslsact[];
extern WSCREADONLY yytabelem pslspact[];
extern WSCREADONLY yytabelem pslspgo[];
extern WSCREADONLY yytabelem pslsr1[];
extern WSCREADONLY yytabelem pslsr2[];
extern WSCREADONLY yytabelem pslschk[];
extern WSCREADONLY yytabelem pslsdef[];
typedef struct { char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif

#if YYDEBUG

GLOBALDEF READONLY	yytoktype pslstoks[] =
{
	"ABORT",	257,
	"ALL",	258,
	"ALTER",	259,
	"AND",	260,
	"ANY",	261,
	"APPEND",	262,
	"AS",	263,
	"ASC",	264,
	"AT",	265,
	"AUTHORIZATION",	266,
	"AVG",	267,
	"ADD",	268,
	"ALTGROUP",	269,
	"ALTROLE",	270,
	"ALTUSER",	271,
	"ALTLOC",	272,
	"ALTSEQ",	273,
	"ASYMMETRIC",	274,
	"BAOP",	275,
	"BAOPH",	276,
	"BASE_TABLE_STRUCTURE",	277,
	"BDIVP",	278,
	"BDOP",	279,
	"BGNXACT",	280,
	"BEGIN",	281,
	"BETWEEN",	282,
	"BY",	283,
	"BYREF",	284,
	"CALLPROC",	285,
	"CASCADE",	286,
	"CLOSE",	287,
	"CLUSTER",	288,
	"CASE",	289,
	"CACHE",	290,
	"CAST",	291,
	"COALESCE",	292,
	"CYCLE",	293,
	"COLON",	294,
	"COMMA",	295,
	"COPY",	296,
	"COPY_FROM",	297,
	"COPY_INTO",	298,
	"COMMENT_ON",	299,
	"CREATE",	300,
	"CHECK",	301,
	"COLUMN",	302,
	"COMMIT",	303,
	"COMMITTED",	304,
	"CONTINUE",	305,
	"COUNT",	306,
	"CROSSJOIN",	307,
	"CUBE",	308,
	"CURRENT",	309,
	"CURRVAL",	310,
	"CURSOR",	311,
	"CRTINTEG",	312,
	"CRTLINK",	313,
	"CRTPERM",	314,
	"CRTVIEW",	315,
	"CRTGROUP",	316,
	"CRTROLE",	317,
	"CRTRULE",	318,
	"CRTUSER",	319,
	"CREATEEVENT",	320,
	"CRTSYNONYM",	321,
	"CRTUSR",	322,
	"CRTSECALM",	323,
	"CRTLOC",	324,
	"CRTSEQ",	325,
	"COLLATE",	326,
	"DBA",	327,
	"DCONST",	328,
	"DECCONST",	329,
	"DEFERUPD",	330,
	"DEFQRY",	331,
	"DELIM_IDENT",	332,
	"DIRECTUPD",	333,
	"DISECAUDIT",	334,
	"DELETE",	335,
	"DECLARE",	336,
	"DESCRIBE",	337,
	"DESCINPUT",	338,
	"DISTINCT",	339,
	"DO",	340,
	"DROP",	341,
	"DROPINTEG",	342,
	"DROPLINK",	343,
	"DROPPERM",	344,
	"DROPSYNONYM",	345,
	"DROPVIEW",	346,
	"DROPGROUP",	347,
	"DROPROLE",	348,
	"DROPRULE",	349,
	"DROPUSER",	350,
	"DROPEVENT",	351,
	"DROPLOC",	352,
	"DROPSECALM",	353,
	"DROPSEQ",	354,
	"DOLLAR",	355,
	"ENDXACT",	356,
	"ENSECAUDIT",	357,
	"EOP",	358,
	"EQUAL",	359,
	"ELSE",	360,
	"ELSEIF",	361,
	"END",	362,
	"ENDFOR",	363,
	"ENDIF",	364,
	"ENDLOOP",	365,
	"ENDREPEAT",	366,
	"ENDWHILE",	367,
	"ESCAPE",	368,
	"EXCEPT",	369,
	"EXECUTE",	370,
	"EXISTS",	371,
	"EXCLUDING",	372,
	"FORREADONLY",	373,
	"F4CONST",	374,
	"F8CONST",	375,
	"FETCH",	376,
	"FIRST",	377,
	"FOR",	378,
	"FREELOCATOR",	379,
	"FROM",	380,
	"FULLANTI",	381,
	"FULLJOIN",	382,
	"FULLOUTER",	383,
	"GLOBAL",	384,
	"GRANT",	385,
	"GROUP",	386,
	"GROUPING",	387,
	"GROUPINGSETS",	388,
	"HAVING",	389,
	"HEXCONST",	390,
	"BITCONST",	391,
	"I2CONST",	392,
	"I4CONST",	393,
	"I8CONST",	394,
	"IF",	395,
	"IMMEDIATE",	396,
	"IMPORT",	397,
	"IN",	398,
	"INDEX",	399,
	"INGRES",	400,
	"INCREMENT",	401,
	"INNERJOIN",	402,
	"INOUT",	403,
	"INSERT",	404,
	"INTO",	405,
	"INTEGRITY",	406,
	"INTERSECT",	407,
	"INTERSECTJOIN",	408,
	"INTERVAL",	409,
	"IS",	410,
	"ISOLATION",	411,
	"JOIN",	412,
	"LEAVE",	413,
	"LEFTANTI",	414,
	"LEFTJOIN",	415,
	"LEFTOUTER",	416,
	"LEVEL",	417,
	"LIKE",	418,
	"LCURLY",	419,
	"LOCAL",	420,
	"LPAREN",	421,
	"MAX",	422,
	"MESSAGE",	423,
	"MIN",	424,
	"MODIFY",	425,
	"MODULE",	426,
	"MAXVALUE",	427,
	"MINVALUE",	428,
	"NAME",	429,
	"NATURAL",	430,
	"NEXT",	431,
	"NEXTVAL",	432,
	"NOCACHE",	433,
	"NOCYCLE",	434,
	"NOMAX",	435,
	"NOMIN",	436,
	"NOORDER",	437,
	"NOT",	438,
	"NULLIF",	439,
	"NULLWORD",	440,
	"NOTLIKE",	441,
	"OF",	442,
	"OFFSET",	443,
	"ON",	444,
	"OPEN",	445,
	"OPTION",	446,
	"OR",	447,
	"ORDER",	448,
	"OUT",	449,
	"OUTER",	450,
	"ONAPPLICATION",	451,
	"ONCOMMIT",	452,
	"ONCURRENT",	453,
	"ONDATABASE",	454,
	"ONEVENT",	455,
	"ONLOCATION",	456,
	"ONLY",	457,
	"ONPROCEDURE",	458,
	"ONSEQUENCE",	459,
	"PERIOD",	460,
	"PERMIT",	461,
	"PREPARE",	462,
	"PRESERVE",	463,
	"PRIVILEGES",	464,
	"PROCEDURE",	465,
	"PUBLIC",	466,
	"QDATA",	467,
	"QUESTIONMARK",	468,
	"QUERYID",	469,
	"RAISE",	470,
	"RAISEERROR",	471,
	"RAISEEVENT",	472,
	"RAWPCT",	473,
	"READ",	474,
	"REFERENCING",	475,
	"REGISTER",	476,
	"REGISTEREVENT",	477,
	"RELOCATE",	478,
	"REMOVE",	479,
	"REMOVEEVENT",	480,
	"REPEAT",	481,
	"REPEATABLE",	482,
	"REPLACE",	483,
	"RESTRICT",	484,
	"RESULTROW",	485,
	"RETURN",	486,
	"RESTART",	487,
	"REVOKE",	488,
	"RIGHTANTI",	489,
	"RIGHTJOIN",	490,
	"RIGHTOUTER",	491,
	"ROLLBACK",	492,
	"ROLLUP",	493,
	"ROW",	494,
	"ROWS",	495,
	"RCURLY",	496,
	"RPAREN",	497,
	"SAVE",	498,
	"SAVEPOINT",	499,
	"SCHEMA",	500,
	"SCONST",	501,
	"SCROLL",	502,
	"SELECT",	503,
	"SEMICOLON",	504,
	"SERIALIZABLE",	505,
	"SESSION",	506,
	"SET",	507,
	"SETAGGR",	508,
	"SETAUTOCOMMIT",	509,
	"SETCACHEDYN",	510,
	"SETCPUFACT",	511,
	"SETDATEFMT",	512,
	"SETDDLCONCUR",	513,
	"SETDECIMAL",	514,
	"SETFLATTEN",	515,
	"SETHASH",	516,
	"SETIOTRACE",	517,
	"SETJOINOP",	518,
	"SETJOURNAL",	519,
	"SETLOCKMODE",	520,
	"SETLOGGING",	521,
	"SETLOGTRACE",	522,
	"SETMXIO",	523,
	"SETMXROW",	524,
	"SETMXCPU",	525,
	"SETMXPAGE",	526,
	"SETMXCOST",	527,
	"SETLOCKTRACE",	528,
	"SETMNYFMT",	529,
	"SETMNYPREC",	530,
	"SETOPTIMIZEONLY",	531,
	"SETPRINTQRY",	532,
	"SETMXIDLE",	533,
	"SETMXCONNECT",	534,
	"SETPRTRULES",	535,
	"SETPRTEVENTS",	536,
	"SETLOGEVENTS",	537,
	"SETRULES",	538,
	"SETOJFLATTEN",	539,
	"SETPARALLEL",	540,
	"SETQEP",	541,
	"SETRANDOMSEED",	542,
	"SETRESSTRUCT",	543,
	"SETRETINTO",	544,
	"SETSESSION",	545,
	"SETSTATS",	546,
	"SETTRACE",	547,
	"SETTRANSACTION",	548,
	"SHORT_REMARK",	549,
	"SETUNICODESUB",	550,
	"SETUPDROWCNT",	551,
	"SETWORK",	552,
	"SOME",	553,
	"SQL",	554,
	"SUM",	555,
	"START",	556,
	"SYSTEM_MAINTAINED",	557,
	"SETROLE",	558,
	"SUBSTRING",	559,
	"SYMMETRIC",	560,
	"TABLE",	561,
	"TEMPORARY",	562,
	"THEN",	563,
	"TO",	564,
	"TRANSACTION",	565,
	"TOGROUP",	566,
	"TOROLE",	567,
	"TOUSER",	568,
	"TARGET",	569,
	"TMWOCONST",	570,
	"TMWCONST",	571,
	"TMECONST",	572,
	"TSWOCONST",	573,
	"TSWCONST",	574,
	"TSTMPCONST",	575,
	"UAOP",	576,
	"UCONST",	577,
	"UNCOMMITTED",	578,
	"UNION",	579,
	"UNIQUE",	580,
	"UNTIL",	581,
	"UPDATE",	582,
	"USER",	583,
	"USING",	584,
	"VALUES",	585,
	"VIEW",	586,
	"WHEN",	587,
	"WHERE",	588,
	"WHILE",	589,
	"WITH",	590,
	"WORK",	591,
	"WRITE",	592,
	"WLOCAL",	593,
	"WTIME",	594,
	"WITHOUT",	595,
	"WOTIME",	596,
	"DEFAULT",	597,
	"REFERENCES",	598,
	"PRIMARYKEY",	599,
	"FOREIGNKEY",	600,
	"CONSTRAINT",	601,
	"CURRENT_USER",	602,
	"CURDATE",	603,
	"CURTIME",	604,
	"CURTIMESTAMP",	605,
	"LOCTIME",	606,
	"LOCTIMESTAMP",	607,
	"INITIAL_USER",	608,
	"SESSION_USER",	609,
	"SYSTEM_USER",	610,
	"ALTSECAUDIT",	611,
	"CRTPROFILE",	612,
	"ALTPROFILE",	613,
	"DROPPROFILE",	614,
	"AUTOMATIC",	615,
	"HASH",	616,
	"LIST",	617,
	"RANGE",	618,
	"PARTITION",	619,
	"-unknown-",	-1	/* ends search */
};

GLOBALDEF READONLY	char * pslsreds[] =
{
	"-no such reduction-",
	"stmt : abort",
	"stmt : alter_role",
	"stmt : alter_group",
	"stmt : alter_user",
	"stmt : alter_location",
	"stmt : alter_table",
	"stmt : alter_profile",
	"stmt : alter_sequence",
	"stmt : btransact",
	"stmt : comment",
	"stmt : commit",
	"stmt : copy",
	"stmt : create_event",
	"stmt : create_role",
	"stmt : create_group",
	"stmt : create_index",
	"stmt : create_integrity",
	"stmt : create_link",
	"stmt : create_permit",
	"stmt : create_rule",
	"stmt : create_synonym",
	"stmt : create_schema",
	"stmt : create_table",
	"stmt : create_user",
	"stmt : create_location",
	"stmt : create_secalm",
	"stmt : create_view",
	"stmt : create_dbproc",
	"stmt : create_profile",
	"stmt : create_sequence",
	"stmt : cursor_close",
	"stmt : cursor_fetch",
	"stmt : cursor_open",
	"stmt : cursor_open_dsql",
	"stmt : define_query",
	"stmt : delete",
	"stmt : describe",
	"stmt : describe_input",
	"stmt : dgtt_stmt",
	"stmt : dircon",
	"stmt : dir_exec_immed",
	"stmt : drop_event",
	"stmt : drop_role",
	"stmt : drop_group",
	"stmt : drop_dbproc",
	"stmt : drop_tvis",
	"stmt : drop_schema",
	"stmt : dropinteg",
	"stmt : dropperm",
	"stmt : drop_rule",
	"stmt : drop_user",
	"stmt : drop_location",
	"stmt : drop_profile",
	"stmt : drop_secalm",
	"stmt : drop_sequence",
	"stmt : disable_secaud",
	"stmt : enable_secaud",
	"stmt : alter_secaud",
	"stmt : etransact",
	"stmt : execute_dbproc",
	"stmt : execute",
	"stmt : execute_imdte",
	"stmt : free_locator",
	"stmt : grant",
	"stmt : insert",
	"stmt : modify",
	"stmt : prepare",
	"stmt : query",
	"stmt : reg_gateway_idx",
	"stmt : reg_gateway_tab",
	"stmt : reg_distr_idx",
	"stmt : reg_distr_tv",
	"stmt : rollback",
	"stmt : relocate",
	"stmt : revoke",
	"stmt : register_event",
	"stmt : remove_event",
	"stmt : raise_event",
	"stmt : save",
	"stmt : savepoint",
	"stmt : setaggr",
	"stmt : setautocommit",
	"stmt : setcachedyn",
	"stmt : setcpufact",
	"stmt : setdatefmt",
	"stmt : setddl_concur",
	"stmt : setdecimal",
	"stmt : set_sess_auth_id",
	"stmt : setflatten",
	"stmt : sethash",
	"stmt : setiotrace",
	"stmt : setjoinop",
	"stmt : setjournal",
	"stmt : setjtimeout",
	"stmt : setlockmode",
	"stmt : setlocktrace",
	"stmt : setlogging",
	"stmt : setlogtrace",
	"stmt : setmnyfmt",
	"stmt : setmnyprec",
	"stmt : setmxio",
	"stmt : setmxrow",
	"stmt : setmxcpu",
	"stmt : setmxidle",
	"stmt : setmxconnect",
	"stmt : setmxpage",
	"stmt : setmxcost",
	"stmt : setojflatten",
	"stmt : setoptimizeonly",
	"stmt : setparallel",
	"stmt : setprintqry",
	"stmt : setprintrules",
	"stmt : setprintevents",
	"stmt : setlogevents",
	"stmt : setqep",
	"stmt : setrandomseed",
	"stmt : setresstruct",
	"stmt : setretinto",
	"stmt : setrules",
	"stmt : setsession",
	"stmt : setstats",
	"stmt : settrace",
	"stmt : settransaction",
	"stmt : setupdrowcnt",
	"stmt : setrole",
	"stmt : setwork",
	"stmt : setunicodesub",
	"stmt : update",
	"stmt : xaprepare",
	"stmt : error",
	"create_schema : create_schema_key create_schema_auth create_schema_list",
	"create_schema : create_schema_key create_schema_auth",
	"create_schema_key : CREATE SCHEMA",
	"create_schema_auth : AUTHORIZATION auth_ident",
	"create_schema_list : create_schema_list create_schema_element",
	"create_schema_list : create_schema_element",
	"create_schema_element : create_table",
	"create_schema_element : create_view",
	"create_schema_element : grant",
	"abort : abstmnt TO generic_ident",
	"abort : abstmnt TO intconst_p",
	"abort : abstmnt",
	"abstmnt : ABORT",
	"btransact : BGNXACT",
	"commit : commitstmt work",
	"commit : commitstmt work WITH xa_xid_parm",
	"commitstmt : COMMIT",
	"work : WORK",
	"work : /* empty */",
	"xaprepare : xa_prepare_stmt WITH xa_xid_parm",
	"xa_prepare_stmt : PREPARE TO COMMIT",
	"create_index : index_prefix index_defs",
	"index_defs : index_def",
	"index_defs : index_list",
	"index_list : LPAREN index_def RPAREN",
	"index_list : index_list COMMA LPAREN index_def RPAREN",
	"index_def : indexlocname ON indexrel LPAREN indexcols RPAREN index_unique tbl_with_clause",
	"index_prefix : CREATE index_unique INDEX",
	"index_unique : UNIQUE",
	"index_unique : /* empty */",
	"indexlocname : NAME COLON obj_spec",
	"indexlocname : obj_spec",
	"indexrel : obj_spec",
	"indexcols : indexcol",
	"indexcols : indexcols COMMA indexcol",
	"indexcol : col_spec asc_desc",
	"asc_desc : /* empty */",
	"asc_desc : ASC",
	"asc_desc : nonkeyword",
	"copy : copstmnt copytable coparam keywd copyfile copywith",
	"copstmnt : COPY copy_tbl_kwd",
	"copy_tbl_kwd : TABLE",
	"copy_tbl_kwd : /* empty */",
	"copytable : obj_spec",
	"coparam : LPAREN cospecs RPAREN",
	"coparam : LPAREN RPAREN",
	"cospecs : entname EQUAL fmtspec",
	"cospecs : cospecs COMMA entname EQUAL fmtspec",
	"entname : col_spec",
	"fmtspec : coent",
	"fmtspec : coent WITH NULLWORD",
	"fmtspec : coent WITH NULLWORD LPAREN covalue RPAREN",
	"cp_delim : /* empty */",
	"cp_delim : nonkey_or_sconst",
	"cp_delim : NULLWORD",
	"coent : nonkey_or_sconst",
	"coent : tname LPAREN intconst_p RPAREN cp_delim",
	"coent : tname LPAREN intconst_p COMMA intconst_p RPAREN cp_delim",
	"covalue : sign_op I2CONST",
	"covalue : sign_op I4CONST",
	"covalue : sign_op I8CONST",
	"covalue : sign_op DECCONST",
	"covalue : sign_op F4CONST",
	"covalue : sign_op F8CONST",
	"covalue : HEXCONST",
	"covalue : SCONST",
	"sign_op : UAOP",
	"sign_op : /* empty */",
	"keywd : INTO",
	"keywd : FROM",
	"copyfile : strconst",
	"copyfile : nonkeyword",
	"copywith : /* empty */",
	"copywith : WITH copyclause",
	"copyclause : copyoption",
	"copyclause : copyclause COMMA copyoption",
	"copyoption : nonkeyword EQUAL nonkeyword",
	"copyoption : nonkeyword EQUAL CONTINUE",
	"copyoption : ROLLBACK EQUAL nonkeyword",
	"copyoption : nonkeyword EQUAL SCONST",
	"copyoption : nonkeyword EQUAL int2_int4_p",
	"copyoption : nonkeyword EQUAL QDATA",
	"copyoption : nonkeyword",
	"create_integrity : integstmnt ON integtbl IS boolean_expr",
	"integstmnt : CRTINTEG",
	"integtbl : from_item",
	"create_permit : permit_prefix permtd where",
	"permit_prefix : permstmnt permspec",
	"permit_prefix : permstmnt permspec permword permtbl permtarg permwho permplace",
	"permstmnt : CRTPERM",
	"permspec : permlist",
	"permspec : ALL",
	"permlist : permission",
	"permlist : permlist COMMA permission",
	"permission : SELECT",
	"permission : DELETE",
	"permission : INSERT",
	"permission : UPDATE",
	"permword : ON",
	"permword : OF",
	"permword : TO",
	"permtbl : from_item",
	"permtarg : LPAREN permtlist RPAREN",
	"permtarg : EXCLUDING LPAREN permtlist RPAREN",
	"permtarg : /* empty */",
	"permtlist : permtelm",
	"permtlist : permtlist COMMA permtelm",
	"permtelm : generic_ident",
	"permwho : TO user_ident",
	"permwho : TO ALL",
	"permplace : AT NAME",
	"permplace : AT ALL",
	"permplace : /* empty */",
	"permtd : permtime permday",
	"permtd : permday",
	"permtd : permtime",
	"permtd : /* empty */",
	"permtime : FROM timeofday TO timeofday",
	"timeofday : intconst_e COLON intconst_e",
	"permday : ON NAME TO NAME",
	"create_event : crev_kwd obj_spec",
	"crev_kwd : CREATEEVENT",
	"drop_event : drev_kwd obj_spec",
	"drev_kwd : DROPEVENT",
	"drop_schema : DROP SCHEMA",
	"drop_schema : DROP SCHEMA generic_ident drop_behaviour",
	"create_rule : crl_kword crl_rule_name crl_rule_cond crl_exec_proc",
	"crl_kword : CRTRULE",
	"crl_rule_name : obj_spec",
	"crl_rule_cond : crl_tbl_rule",
	"crl_rule_cond : crl_time_rule",
	"crl_tbl_rule : crl_tbl_when crl_tbl_stmt_list crl_tbl_on crl_tbl_name crl_tbl_reference crl_tbl_where crl_tbl_with_clause",
	"crl_tbl_when : nonkeyword",
	"crl_tbl_stmt_list : crl_tbl_stmt",
	"crl_tbl_stmt_list : crl_tbl_stmt_list COMMA crl_tbl_stmt",
	"crl_tbl_stmt : DELETE",
	"crl_tbl_stmt : INSERT",
	"crl_tbl_stmt : UPDATE",
	"crl_tbl_stmt : UPDATE LPAREN crl_tbl_collist RPAREN",
	"crl_tbl_collist : crl_tbl_col",
	"crl_tbl_collist : crl_tbl_collist COMMA crl_tbl_col",
	"crl_tbl_col : col_spec",
	"crl_tbl_on : ON",
	"crl_tbl_on : FROM",
	"crl_tbl_on : INTO",
	"crl_tbl_on : OF",
	"crl_tbl_name : obj_spec",
	"crl_tbl_reference : REFERENCING crl_ref_clause crl_ref_clause",
	"crl_tbl_reference : REFERENCING crl_ref_clause",
	"crl_tbl_reference : /* empty */",
	"crl_ref_clause : nonkeyword noise_row noise_as tbl_spec",
	"noise_row : /* empty */",
	"noise_row : ROW",
	"noise_as : /* empty */",
	"noise_as : AS",
	"crl_tbl_where : crl_where_word boolean_expr",
	"crl_tbl_where : /* empty */",
	"crl_where_word : where_word",
	"crl_where_word : WHEN",
	"crl_time_rule : AT crl_time_date crl_time_repeat",
	"crl_time_date : strconst",
	"crl_time_repeat : REPEAT strconst",
	"crl_time_repeat : /* empty */",
	"crl_tbl_with_clause : /* empty */",
	"crl_tbl_with_clause : FOR nonkeyword crl_tbl_row_or_stmt",
	"crl_tbl_row_or_stmt : ROW",
	"crl_tbl_row_or_stmt : nonkeyword",
	"crl_exec_proc : EXECUTE PROCEDURE crl_proc_name LPAREN crl_proc_arg_list RPAREN",
	"crl_exec_proc : EXECUTE PROCEDURE crl_proc_name",
	"crl_proc_name : exdbp_name",
	"crl_proc_arg_list : exdbp_arg_list",
	"crt_syn : CRTSYNONYM",
	"create_synonym : crt_syn crname",
	"create_synonym : crt_syn crname FOR obj_spec",
	"dgtt_kwd : DECLARE GLOBAL TEMPORARY TABLE",
	"dgtton : ONCOMMIT PRESERVE ROWS",
	"dgtton : /* empty */",
	"dgtt_stmt : dgtt_kwd new_loc_name LPAREN tbl_elem_list RPAREN dgtton tbl_with_clause",
	"dgtt_stmt : dgtt_kwd new_loc_name newcolspec AS query_expr order_clause result_offset_clause fetch_first_clause",
	"dgtt_stmt : dgtt_kwd new_loc_name newcolspec AS query_expr order_clause result_offset_clause fetch_first_clause dgtton tbl_with_clause",
	"create_table : crt_tbl_kwd new_loc_name LPAREN tbl_elem_list RPAREN tbl_with_clause",
	"create_table : crt_tbl_kwd new_loc_name newcolspec crt_tbl_askwd query_expr order_clause result_offset_clause fetch_first_clause",
	"create_table : crt_tbl_kwd new_loc_name newcolspec crt_tbl_askwd query_expr order_clause result_offset_clause fetch_first_clause tbl_with_clause",
	"crt_tbl_askwd : AS",
	"crt_tbl_kwd : CREATE TABLE",
	"new_loc_name : NAME COLON crname",
	"new_loc_name : crname",
	"crname : obj_spec",
	"crname : error",
	"newcolspec : LPAREN newcollist RPAREN",
	"newcolspec : /* empty */",
	"newcollist : newcol",
	"newcollist : newcollist COMMA newcol",
	"newcol : col_spec",
	"newcol : error",
	"tbl_elem_list : tbl_elem",
	"tbl_elem_list : tbl_elem_list COMMA tbl_elem",
	"tbl_elem : newcolname typedesc",
	"tbl_elem : tbl_constraint",
	"type_qual_list : /* empty */",
	"type_qual_list : type_qual_list1",
	"type_qual_list1 : type_qual",
	"type_qual_list1 : type_qual_list1 type_qual",
	"type_qual : default",
	"type_qual : logical_key",
	"type_qual : null_constraint",
	"type_qual : col_constraint",
	"type_qual : con_with",
	"default : NOT DEFAULT",
	"default : user_default",
	"user_default : with_noise DEFAULT",
	"user_default : with_noise DEFAULT def_value",
	"def_value : /* empty */",
	"def_value : null_word",
	"def_value : constant",
	"def_value : UAOP constant",
	"def_value : seq_operator",
	"with_noise : WITH",
	"with_noise : /* empty */",
	"null_constraint : NOT NULLWORD",
	"null_constraint : WITH NULLWORD",
	"null_constraint : NULLWORD",
	"logical_key : WITH SYSTEM_MAINTAINED",
	"logical_key : NOT SYSTEM_MAINTAINED",
	"col_constraint : constraint_name col_constraint2",
	"col_constraint2 : unique_spec",
	"col_constraint2 : check_cons",
	"col_constraint2 : col_refcon ref_action_list",
	"col_refcon : REFERENCES obj_spec LPAREN cons_col RPAREN",
	"col_refcon : REFERENCES obj_spec",
	"ref_action_list : /* empty */",
	"ref_action_list : ON ref_action",
	"ref_action_list : ON ref_action ON ref_action",
	"ref_action : UPDATE ref_action_item",
	"ref_action : DELETE ref_action_item",
	"ref_action_item : RESTRICT",
	"ref_action_item : CASCADE",
	"ref_action_item : SET NULLWORD",
	"ref_action_item : nonkeyword nonkeyword",
	"constraint_name : /* empty */",
	"constraint_name : CONSTRAINT generic_ident",
	"unique_spec : UNIQUE",
	"unique_spec : PRIMARYKEY",
	"cons_colspec : LPAREN cons_collist RPAREN",
	"cons_collist : cons_col",
	"cons_collist : cons_collist COMMA cons_col",
	"cons_col : col_spec",
	"check_cons : CHECK",
	"check_cons : CHECK LPAREN boolean_expr RPAREN",
	"con_with : WITH",
	"con_with : WITH con_with_list",
	"con_with_list : nonkeyword INDEX",
	"con_with_list : tblwithopt",
	"con_with_list : LPAREN tblwithlist RPAREN",
	"tbl_constraint : constraint_name tbl_constraint2 con_with1",
	"con_with1 : con_with",
	"con_with1 : /* empty */",
	"tbl_constraint2 : unique_spec cons_colspec",
	"tbl_constraint2 : check_cons",
	"tbl_constraint2 : tbl_refcon ref_action_list",
	"tbl_refcon : FOREIGNKEY cons_colspec REFERENCES obj_spec cons_colspec",
	"tbl_refcon : FOREIGNKEY cons_colspec REFERENCES obj_spec",
	"newcolname : col_spec",
	"newcolname : error",
	"typedesc : tname type_qual_list collate",
	"typedesc : tname LPAREN intconst_e RPAREN type_qual_list collate",
	"typedesc : tname LPAREN intconst_e COMMA intconst_e RPAREN type_qual_list",
	"typedesc : tname dt_wquals tname type_qual_list",
	"typedesc : tname TO tname type_qual_list",
	"typedesc : tname TO tname LPAREN intconst_e RPAREN type_qual_list",
	"typedesc : tname LPAREN intconst_e RPAREN dt_wquals tname type_qual_list",
	"dt_wquals : WTIME",
	"dt_wquals : WLOCAL",
	"dt_wquals : WOTIME",
	"tname : NAME",
	"tname : NAME NAME",
	"tname : INTERVAL NAME",
	"tname : NAME NAME NAME",
	"tname : NAME NAME NAME NAME",
	"collate : /* empty */",
	"collate : COLLATE generic_ident",
	"tbl_with_clause : tbloptionalwith",
	"tbloptionalwith : WITH tblwithlist",
	"tbloptionalwith : /* empty */",
	"tblwithlist : tblwithopt",
	"tblwithlist : tblwithlist COMMA tblwithopt",
	"tblwithopt : twith_name",
	"tblwithopt : twith_ix_name",
	"tblwithopt : twith_nm_eq_str",
	"tblwithopt : twith_tb_eq_id",
	"tblwithopt : twith_num",
	"tblwithopt : twith_word",
	"tblwithopt : twith_list",
	"twith_name : nonkeyword EQUAL twith_nkw_kwd",
	"twith_nkw_kwd : nonkeyword",
	"twith_nkw_kwd : TABLE",
	"twith_nkw_kwd : ROW",
	"twith_nkw_bts : generic_ident",
	"twith_nkw_bts : BASE_TABLE_STRUCTURE",
	"twith_ix_name : INDEX EQUAL twith_nkw_bts",
	"twith_nm_eq_str : nonkeyword EQUAL SCONST",
	"twith_tb_eq_id : twith_tb_wd EQUAL internal_ident",
	"twith_tb_wd : TABLE",
	"twith_num : nonkeyword EQUAL intconst_e",
	"twith_word : nonkeyword",
	"twith_list : twith_list_prefix LPAREN twith_list_inside RPAREN",
	"twith_list_prefix : nonkeyword EQUAL",
	"twith_list_inside : twith_list_commalist",
	"twith_list_inside : twith_list_partition",
	"twith_list_commalist : twith_list_clist_elem",
	"twith_list_commalist : twith_list_commalist COMMA twith_list_clist_elem",
	"twith_list_clist_elem : generic_ident",
	"twith_list_clist_elem : index_rspec",
	"index_rspec : LPAREN index_rlst RPAREN",
	"index_rlst : index_relem",
	"index_rlst : index_rlst COMMA index_relem",
	"index_relem : sign_op I2CONST",
	"index_relem : sign_op I4CONST",
	"index_relem : sign_op DECCONST",
	"index_relem : sign_op F4CONST",
	"index_relem : sign_op F8CONST",
	"twith_list_partition : partition_dim partition_def_done",
	"twith_list_partition : partition_dim_list partition_def_done",
	"partition_def_done : /* empty */",
	"partition_dim_list : LPAREN partition_dim RPAREN",
	"partition_dim_list : partition_dim_list nonkeyword",
	"partition_dim_list : partition_dim_list nonkeyword LPAREN partition_dim RPAREN",
	"partition_dim : AUTOMATIC",
	"partition_dim : AUTOMATIC nonval_partlist",
	"partition_dim : HASH",
	"partition_dim : HASH partition_onlist nonval_partlist",
	"partition_dim : LIST",
	"partition_dim : LIST partition_onlist list_partlist",
	"partition_dim : RANGE",
	"partition_dim : RANGE partition_onlist range_partlist",
	"partition_onlist : ON partition_col_list",
	"partition_col_list : partition_column",
	"partition_col_list : partition_col_list COMMA partition_column",
	"partition_column : name_or_alt_kwd",
	"name_or_alt_kwd : generic_ident",
	"name_or_alt_kwd : ON",
	"name_or_alt_kwd : TO",
	"name_or_alt_kwd : AUTOMATIC",
	"name_or_alt_kwd : LIST",
	"name_or_alt_kwd : HASH",
	"name_or_alt_kwd : RANGE",
	"name_or_alt_kwd : VALUES",
	"name_or_alt_kwd : PARTITION",
	"nonval_partlist : nonval_partition",
	"nonval_partlist : nonval_partlist COMMA nonval_partition",
	"nonval_partition : PARTITION optional_namelist",
	"nonval_partition : PARTITION optional_namelist partition_with",
	"nonval_partition : intconst_p partition_s optional_namelist",
	"nonval_partition : intconst_p partition_s optional_namelist partition_with",
	"partition_s : PARTITION",
	"partition_s : nonkeyword",
	"optional_namelist : /* empty */",
	"optional_namelist : partition_name",
	"optional_namelist : LPAREN partition_namelist RPAREN",
	"partition_namelist : partition_name",
	"partition_namelist : partition_namelist COMMA partition_name",
	"partition_name : generic_ident",
	"list_partlist : list_partition",
	"list_partlist : list_partlist COMMA list_partition",
	"list_partition : /* empty */",
	"list_partition : PARTITION optional_name VALUES list_valuelist partition_with",
	"optional_name : /* empty */",
	"optional_name : partition_name",
	"list_valuelist : LPAREN part_valuelist RPAREN",
	"part_valuelist : part_value_or_default",
	"part_valuelist : part_valuelist COMMA part_value_or_default",
	"part_value_or_default : part_composite_value",
	"part_value_or_default : nonkeyword",
	"part_composite_value : part_value",
	"part_value : part_const",
	"part_value : LPAREN part_const_list RPAREN",
	"part_const_list : part_const",
	"part_const_list : part_const_list COMMA part_const",
	"part_const : sign_op number",
	"part_const : part_const_stringish",
	"part_const : NULLWORD",
	"part_const : DCONST",
	"part_const : TMWOCONST",
	"part_const : TMWCONST",
	"part_const : TMECONST",
	"part_const : TSWOCONST",
	"part_const : TSWCONST",
	"part_const : TSTMPCONST",
	"part_const_stringish : SCONST",
	"range_partlist : range_partition",
	"range_partlist : range_partlist COMMA range_partition",
	"range_partition : PARTITION optional_name VALUES BDOP",
	"range_partition : PARTITION optional_name VALUES BDOP part_composite_value partition_with",
	"partition_with : /* empty */",
	"partition_with : WITH",
	"partition_with : WITH partition_with_clause",
	"partition_with_clause : tblwithopt",
	"partition_with_clause : LPAREN tblwithlist RPAREN",
	"alter_table : alt_tbl ADD tbl_constraint",
	"alter_table : alt_tbl DROP CONSTRAINT generic_ident drop_behaviour",
	"alter_table : alt_tbl_add_col newcolname typedesc",
	"alter_table : alt_tbl_drop_col generic_ident drop_behaviour",
	"alter_table : alt_tbl_alter_col newcolname typedesc",
	"alt_tbl_add_col : alt_tbl add_col_kwd",
	"alt_tbl_drop_col : alt_tbl drop_col_kwd",
	"alt_tbl_alter_col : alt_tbl alter_col_kwd",
	"alt_tbl : alt_tbl_kwd obj_spec",
	"alt_tbl_kwd : ALTER TABLE",
	"add_col_kwd : ADD COLUMN",
	"add_col_kwd : ADD",
	"drop_col_kwd : DROP COLUMN",
	"drop_col_kwd : DROP",
	"alter_col_kwd : ALTER COLUMN",
	"alter_col_kwd : ALTER",
	"create_view : viewclause newcolspec",
	"create_view : viewclause newcolspec AS query_expr with_check",
	"viewclause : viewstmnt crname",
	"viewstmnt : CRTVIEW",
	"with_check : WITH CHECK OPTION",
	"with_check : /* empty */",
	"create_dbproc : cdbp_kwd cdbp_procname cdbp_parmspec cdbp_resrow_spec cdbp_asword cdbp_beblock",
	"cdbp_kwd : cdbp_noise PROCEDURE",
	"cdbp_noise : CREATE",
	"cdbp_noise : /* empty */",
	"cdbp_procname : obj_spec",
	"cdbp_parmspec : /* empty */",
	"cdbp_parmspec : LPAREN cdbp_parmlst RPAREN",
	"cdbp_parmspec : LPAREN cdbp_varname cdbp_equalnoise SET OF",
	"cdbp_parmspec : LPAREN cdbp_varname cdbp_equalnoise SET OF LPAREN cdbp_parmlst RPAREN RPAREN",
	"cdbp_parmlst : cdbp_parmitem",
	"cdbp_parmlst : cdbp_parmlst COMMA cdbp_parmitem",
	"cdbp_parmitem : cdbp_varname cdbp_equalnoise cdbp_typedesc",
	"cdbp_varname : cdbp_parmmode generic_ident",
	"cdbp_equalnoise : EQUAL",
	"cdbp_equalnoise : /* empty */",
	"cdbp_parmmode : /* empty */",
	"cdbp_parmmode : IN",
	"cdbp_parmmode : OUT",
	"cdbp_parmmode : INOUT",
	"cdbp_resrow_spec : /* empty */",
	"cdbp_resrow_spec : RESULTROW",
	"cdbp_resrow_spec : RESULTROW LPAREN cdbp_rowelem_list RPAREN",
	"cdbp_rowelem_list : cdbp_row_elem",
	"cdbp_rowelem_list : cdbp_rowelem_list COMMA cdbp_row_elem",
	"cdbp_row_elem : /* empty */",
	"cdbp_row_elem : cdbp_typedesc",
	"cdbp_asword : AS",
	"cdbp_asword : EQUAL",
	"cdbp_beblock : cdbp_declare cdbp_begin cdbp_stmtlist cdbp_end",
	"cdbp_begin : BEGIN",
	"cdbp_begin : LCURLY",
	"cdbp_end : END",
	"cdbp_end : RCURLY",
	"cdbp_declare : cdbp_declare1",
	"cdbp_declare1 : cdbp_deckwd cdbp_varspec",
	"cdbp_declare1 : /* empty */",
	"cdbp_deckwd : DECLARE",
	"cdbp_varspec : cdbp_varitem",
	"cdbp_varspec : cdbp_varspec cdbp_varitem",
	"cdbp_varitem : cdbp_varnamelst cdbp_equalnoise cdbp_typedesc SEMICOLON",
	"cdbp_varnamelst : cdbp_varname",
	"cdbp_varnamelst : cdbp_varnamelst COMMA cdbp_varname",
	"cdbp_typedesc : tname type_qual_list",
	"cdbp_typedesc : tname LPAREN intconst_e RPAREN type_qual_list",
	"cdbp_typedesc : tname LPAREN intconst_e COMMA intconst_e RPAREN type_qual_list",
	"cdbp_typedesc : tname dt_wquals tname type_qual_list",
	"cdbp_typedesc : tname TO tname type_qual_list",
	"cdbp_typedesc : tname LPAREN intconst_e RPAREN dt_wquals tname type_qual_list",
	"cdbp_seminoise : SEMICOLON",
	"cdbp_seminoise : /* empty */",
	"cdbp_opt_retrow : /* empty */",
	"cdbp_opt_retrow : cdbp_retrow_stmt",
	"cdbp_stmtlist : cdbp_stmtlst cdbp_seminoise",
	"cdbp_stmtlist : EXECUTE nonkeyword cdbp_opt_retrow cdbp_seminoise",
	"cdbp_stmtlist : cdbp_seminoise",
	"cdbp_stmtlst : cdbp_stmt",
	"cdbp_stmtlst : cdbp_stmtlst SEMICOLON cdbp_stmt",
	"cdbp_stmt : cdbp_ctrlstmt",
	"cdbp_stmt : cdbp_dmlstmt",
	"cdbp_stmt : cdbp_txstmt",
	"cdbp_stmt : cdbp_assignstmt",
	"cdbp_stmt : cdbp_exec_dbproc",
	"cdbp_stmt : cdbp_event_stmt",
	"cdbp_ctrlstmt : cdbp_ifstmt",
	"cdbp_ctrlstmt : cdbp_whilestmt",
	"cdbp_ctrlstmt : cdbp_forstmt",
	"cdbp_ctrlstmt : cdbp_return",
	"cdbp_ctrlstmt : cdbp_retrow_stmt",
	"cdbp_ctrlstmt : cdbp_repeatstmt",
	"cdbp_ctrlstmt : cdbp_message",
	"cdbp_ctrlstmt : cdbp_raise_error",
	"cdbp_ctrlstmt : cdbp_endloop",
	"cdbp_dmlstmt : cdbp_dml1stmt",
	"cdbp_dml1stmt : query",
	"cdbp_dml1stmt : insert",
	"cdbp_dml1stmt : delete",
	"cdbp_dml1stmt : update",
	"cdbp_txstmt : COMMIT work",
	"cdbp_txstmt : ROLLBACK work",
	"cdbp_ifstmt : cdbp_ifkwd boolean_expr cdbp_thenkwd cdbp_stmtlist cdbp_elsepart ENDIF",
	"cdbp_ifkwd : IF",
	"cdbp_thenkwd : THEN",
	"cdbp_elsekwd : ELSE",
	"cdbp_elsepart : cdbp_elsekwd cdbp_stmtlist",
	"cdbp_elsepart : cdbp_elseifpart cdbp_elsekwd cdbp_stmtlist",
	"cdbp_elsepart : cdbp_elseifpart",
	"cdbp_elsepart : /* empty */",
	"cdbp_elseifpart : cdbp_elseif",
	"cdbp_elseifpart : cdbp_elseifpart cdbp_elseif",
	"cdbp_elseif : cdbp_elseifkwd boolean_expr cdbp_thenkwd cdbp_stmtlist",
	"cdbp_elseifkwd : ELSEIF",
	"cdbp_forstmt : cdbp_forinit cdbp_dmlstmt cdbp_dokwd cdbp_stmtlist cdbp_endfor",
	"cdbp_forinit : cdbp_forlabel FOR",
	"cdbp_forlabel : generic_ident COLON",
	"cdbp_forlabel : /* empty */",
	"cdbp_endfor : ENDFOR",
	"cdbp_whilestmt : cdbp_whileinit boolean_expr cdbp_dokwd cdbp_stmtlist cdbp_endwhile",
	"cdbp_while_label : generic_ident COLON",
	"cdbp_while_label : /* empty */",
	"cdbp_whileinit : cdbp_while_label WHILE",
	"cdbp_dokwd : DO",
	"cdbp_endwhile : ENDWHILE",
	"cdbp_endloop : cdbp_endloopkwd",
	"cdbp_endloop : cdbp_endloopkwd cdbp_label",
	"cdbp_endloopkwd : ENDLOOP",
	"cdbp_endloopkwd : LEAVE",
	"cdbp_repeatstmt : cdbp_repinit cdbp_stmtlist cdbp_untkwd boolean_expr cdbp_endrep",
	"cdbp_repinit : cdbp_replabel REPEAT",
	"cdbp_replabel : generic_ident COLON",
	"cdbp_replabel : /* empty */",
	"cdbp_untkwd : UNTIL",
	"cdbp_endrep : ENDREPEAT",
	"cdbp_label : generic_ident",
	"cdbp_label : /* empty */",
	"cdbp_retval : int2_int4",
	"cdbp_retval : cdbp_parmlvar",
	"cdbp_retval : generic_ident",
	"cdbp_retval : /* empty */",
	"cdbp_return : RETURN",
	"cdbp_return : RETURN cdbp_retval",
	"cdbp_retrow_stmt : RETURN ROW cdbp_retrow_spec1 cdbp_retrow_spec2",
	"cdbp_retrow_spec1 : LPAREN",
	"cdbp_retrow_spec2 : invallist RPAREN",
	"cdbp_message : cdbp_msgkwd cdbp_mesparm cdbp_mesparm cdbp_meswith",
	"cdbp_message : cdbp_msgkwd cdbp_mesparm cdbp_meswith",
	"cdbp_msgkwd : MESSAGE",
	"cdbp_mesparm : int2_int4",
	"cdbp_mesparm : SCONST",
	"cdbp_mesparm : cdbp_parmlvar",
	"cdbp_mesparm : generic_ident",
	"cdbp_mesparm : LPAREN select_expr RPAREN",
	"cdbp_parmlvar : COLON generic_ident",
	"cdbp_meswith : WITH cdbp_destkey EQUAL LPAREN cdbp_destlist RPAREN",
	"cdbp_meswith : /* empty */",
	"cdbp_destlist : cdbp_dest",
	"cdbp_destlist : cdbp_destlist COMMA cdbp_dest",
	"cdbp_destkey : nonkeyword",
	"cdbp_dest : nonkeyword",
	"cdbp_dest : SESSION",
	"cdbp_raise_error : cdbp_rserr_kwd cdbp_mesparm cdbp_mesparm_2 cdbp_meswith",
	"cdbp_rserr_kwd : RAISEERROR",
	"cdbp_mesparm_2 : cdbp_mesparm",
	"cdbp_mesparm_2 : /* empty */",
	"cdbp_assignstmt : cdbp_lhs_asgn",
	"cdbp_assignstmt : cdbp_lhs_asgn cdbp_rhs_asgn",
	"cdbp_lhs_asgn : cdbp_lhs_var",
	"cdbp_lhs_var : generic_ident EQUAL",
	"cdbp_lhs_var : generic_ident COLON EQUAL",
	"cdbp_lhs_var : COLON generic_ident EQUAL",
	"cdbp_lhs_var : COLON generic_ident COLON EQUAL",
	"cdbp_rhs_asgn : select_expr",
	"cdbp_rhs_asgn : null_word",
	"cdbp_exec_dbproc : execute_dbproc",
	"cdbp_exec_dbproc : cdbp_lhs_asgn execute_dbproc",
	"cdbp_exec_dbproc : execute_dbproc cdbp_into",
	"cdbp_into : cdbp_into_var",
	"cdbp_into_var : INTO generic_ident",
	"cdbp_into_var : INTO COLON generic_ident",
	"cdbp_event_stmt : cdbp_ev_stmt",
	"cdbp_ev_stmt : raise_event",
	"cdbp_ev_stmt : register_event",
	"cdbp_ev_stmt : remove_event",
	"cursor_close : CLOSE QUERYID",
	"cursor_fetch : FETCH QUERYID",
	"cursor_open : curop_ini query for_rdonly",
	"curop_ini : curop_ini_1",
	"curop_ini : curop_ini_2",
	"curop_ini_1 : OPEN QUERYID scrollopt CURSOR FOR",
	"curop_ini_2 : DEFQRY OPEN CURSOR QUERYID scrollopt FOR",
	"scrollopt : /* empty */",
	"scrollopt : keyset_opt SCROLL",
	"keyset_opt : /* empty */",
	"keyset_opt : nonkeyword",
	"for_rdonly : FORREADONLY",
	"for_rdonly : /* empty */",
	"cursor_open_dsql : curop_ini_dsql for_rdonly using_list",
	"curop_ini_dsql : curop_ini_1 generic_ident",
	"using_list : USING const_list",
	"using_list : /* empty */",
	"const_list : dsql_data",
	"const_list : const_list COMMA dsql_data",
	"dsql_data : QDATA",
	"define_query : defqry_ini repeat_query",
	"defqry_ini : DEFQRY QUERYID IS",
	"repeat_query : delete",
	"repeat_query : insert",
	"repeat_query : /* empty */",
	"repeat_query : query",
	"repeat_query : update",
	"delete : delstmnt from_item where_cur",
	"delstmnt : DELETE FROM",
	"drop_tvis : drop",
	"drop : drop_stmnt drop_obj_list",
	"drop : drop_syn drop_syn_list",
	"drop_stmnt : drop_prefix",
	"drop_prefix : DROP",
	"drop_prefix : DROP TABLE",
	"drop_prefix : DROPVIEW",
	"drop_prefix : DROP INDEX",
	"drop_prefix : DROPLINK",
	"drop_prefix : REMOVE",
	"drop_prefix : REMOVE TABLE",
	"drop_prefix : REMOVE VIEW",
	"drop_prefix : REMOVE INDEX",
	"drop_prefix : REMOVE PROCEDURE",
	"drop_syn : DROPSYNONYM",
	"drop_obj_list : drop_obj",
	"drop_obj_list : drop_obj_list COMMA drop_obj",
	"drop_syn_list : drop_syn_item",
	"drop_syn_list : drop_syn_list COMMA drop_syn_item",
	"drop_syn_item : obj_spec",
	"drop_obj : obj_spec",
	"dropinteg : dropintegstmnt obj_spec dropipspec",
	"dropintegstmnt : DROPINTEG ON",
	"dropperm : droppermstmnt ON obj_spec dropipspec",
	"dropperm : droppermstmnt ON PROCEDURE",
	"dropperm : droppermstmnt ON PROCEDURE obj_spec dropipspec",
	"dropperm : droppermstmnt ON nonkeyword",
	"dropperm : droppermstmnt ON nonkeyword obj_spec dropipspec",
	"droppermstmnt : DROPPERM",
	"dropipspec : dropiplist",
	"dropipspec : ALL",
	"dropiplist : dropipint",
	"dropiplist : dropiplist COMMA dropipint",
	"dropipint : intconst_p",
	"drop_dbproc : ddbp_drpkwd obj_spec",
	"ddbp_drpkwd : DROP PROCEDURE",
	"drop_rule : drl_kwd obj_spec",
	"drl_kwd : DROPRULE",
	"etransact : ENDXACT",
	"execute_dbproc : exdbp_kword exdbp_name exdbp_arguments",
	"exdbp_kword : exdbp_xkword",
	"exdbp_xkword : EXECUTE PROCEDURE",
	"exdbp_xkword : CALLPROC",
	"exdbp_name : obj_spec",
	"exdbp_arguments : /* empty */",
	"exdbp_arguments : LPAREN exdbp_arg_list RPAREN",
	"exdbp_arg_list : exdbp_arg",
	"exdbp_arg_list : exdbp_arg_list COMMA exdbp_arg",
	"exdbp_arg : generic_ident EQUAL SESSION PERIOD generic_ident",
	"exdbp_arg : generic_ident EQUAL exdbp_arg_val",
	"exdbp_arg : generic_ident EQUAL BYREF LPAREN cdbp_parmlvar RPAREN",
	"exdbp_arg : generic_ident EQUAL BYREF LPAREN cname RPAREN",
	"exdbp_arg_val : cdbp_rhs_asgn",
	"execute_imdte : EXECUTE IMMEDIATE ex_imdte_stmts",
	"execute_imdte : EXECUTE IMMEDIATE",
	"execute_imdte : EXECUTE IMMEDIATE query",
	"ex_imdte_stmts : abort",
	"ex_imdte_stmts : alter_role",
	"ex_imdte_stmts : alter_group",
	"ex_imdte_stmts : alter_user",
	"ex_imdte_stmts : alter_location",
	"ex_imdte_stmts : alter_table",
	"ex_imdte_stmts : alter_profile",
	"ex_imdte_stmts : alter_sequence",
	"ex_imdte_stmts : btransact",
	"ex_imdte_stmts : comment",
	"ex_imdte_stmts : commit",
	"ex_imdte_stmts : copy",
	"ex_imdte_stmts : create_dbproc",
	"ex_imdte_stmts : create_event",
	"ex_imdte_stmts : create_role",
	"ex_imdte_stmts : create_group",
	"ex_imdte_stmts : create_index",
	"ex_imdte_stmts : create_integrity",
	"ex_imdte_stmts : create_link",
	"ex_imdte_stmts : create_permit",
	"ex_imdte_stmts : create_rule",
	"ex_imdte_stmts : create_table",
	"ex_imdte_stmts : create_user",
	"ex_imdte_stmts : create_profile",
	"ex_imdte_stmts : create_location",
	"ex_imdte_stmts : create_schema",
	"ex_imdte_stmts : create_secalm",
	"ex_imdte_stmts : create_sequence",
	"ex_imdte_stmts : create_synonym",
	"ex_imdte_stmts : create_view",
	"ex_imdte_stmts : delete",
	"ex_imdte_stmts : dgtt_stmt",
	"ex_imdte_stmts : drop_dbproc",
	"ex_imdte_stmts : drop_event",
	"ex_imdte_stmts : drop_role",
	"ex_imdte_stmts : drop_group",
	"ex_imdte_stmts : drop_tvis",
	"ex_imdte_stmts : drop_schema",
	"ex_imdte_stmts : dropinteg",
	"ex_imdte_stmts : dropperm",
	"ex_imdte_stmts : drop_rule",
	"ex_imdte_stmts : drop_user",
	"ex_imdte_stmts : drop_location",
	"ex_imdte_stmts : drop_profile",
	"ex_imdte_stmts : drop_secalm",
	"ex_imdte_stmts : drop_sequence",
	"ex_imdte_stmts : disable_secaud",
	"ex_imdte_stmts : enable_secaud",
	"ex_imdte_stmts : alter_secaud",
	"ex_imdte_stmts : execute_dbproc",
	"ex_imdte_stmts : etransact",
	"ex_imdte_stmts : grant",
	"ex_imdte_stmts : insert",
	"ex_imdte_stmts : modify",
	"ex_imdte_stmts : reg_distr_idx",
	"ex_imdte_stmts : reg_distr_tv",
	"ex_imdte_stmts : revoke",
	"ex_imdte_stmts : rollback",
	"ex_imdte_stmts : relocate",
	"ex_imdte_stmts : reg_gateway_tab",
	"ex_imdte_stmts : register_event",
	"ex_imdte_stmts : remove_event",
	"ex_imdte_stmts : raise_event",
	"ex_imdte_stmts : save",
	"ex_imdte_stmts : savepoint",
	"ex_imdte_stmts : setaggr",
	"ex_imdte_stmts : setautocommit",
	"ex_imdte_stmts : setcachedyn",
	"ex_imdte_stmts : setcpufact",
	"ex_imdte_stmts : setdatefmt",
	"ex_imdte_stmts : setddl_concur",
	"ex_imdte_stmts : setdecimal",
	"ex_imdte_stmts : setflatten",
	"ex_imdte_stmts : sethash",
	"ex_imdte_stmts : setiotrace",
	"ex_imdte_stmts : setjoinop",
	"ex_imdte_stmts : setjournal",
	"ex_imdte_stmts : setjtimeout",
	"ex_imdte_stmts : setlockmode",
	"ex_imdte_stmts : setlocktrace",
	"ex_imdte_stmts : setlogging",
	"ex_imdte_stmts : setlogtrace",
	"ex_imdte_stmts : setmnyfmt",
	"ex_imdte_stmts : setmnyprec",
	"ex_imdte_stmts : setmxio",
	"ex_imdte_stmts : setmxrow",
	"ex_imdte_stmts : setmxcpu",
	"ex_imdte_stmts : setmxidle",
	"ex_imdte_stmts : setmxconnect",
	"ex_imdte_stmts : setmxpage",
	"ex_imdte_stmts : setmxcost",
	"ex_imdte_stmts : setojflatten",
	"ex_imdte_stmts : setoptimizeonly",
	"ex_imdte_stmts : setparallel",
	"ex_imdte_stmts : setprintqry",
	"ex_imdte_stmts : setprintrules",
	"ex_imdte_stmts : setprintevents",
	"ex_imdte_stmts : setlogevents",
	"ex_imdte_stmts : setqep",
	"ex_imdte_stmts : setrandomseed",
	"ex_imdte_stmts : setresstruct",
	"ex_imdte_stmts : setretinto",
	"ex_imdte_stmts : setrules",
	"ex_imdte_stmts : setsession",
	"ex_imdte_stmts : setstats",
	"ex_imdte_stmts : settrace",
	"ex_imdte_stmts : settransaction",
	"ex_imdte_stmts : set_sess_auth_id",
	"ex_imdte_stmts : setunicodesub",
	"ex_imdte_stmts : setupdrowcnt",
	"ex_imdte_stmts : setwork",
	"ex_imdte_stmts : setrole",
	"ex_imdte_stmts : update",
	"grant : grant_kwd tbl_priv_spec tbl_priv_obj_spec grant_auth_spec grant_option",
	"grant : grant_kwd dbproc_priv_spec dbproc_priv_obj_spec grant_auth_spec grant_option",
	"grant : grant_kwd seq_priv_spec seq_priv_obj_spec grant_auth_spec grant_option",
	"grant : grant_kwd event_priv_spec event_priv_obj_spec grant_auth_spec grant_option",
	"grant : grant_kwd db_priv_spec db_priv_obj_spec grant_auth_spec",
	"grant_option : WITH GRANT OPTION",
	"grant_option : /* empty */",
	"grant_kwd : GRANT",
	"priv_noise : PRIVILEGES",
	"priv_noise : /* empty */",
	"tbl_priv_spec : tbl_priv_list",
	"tbl_priv_spec : ALL priv_noise",
	"tbl_priv_list : tbl_priv",
	"tbl_priv_list : tbl_priv_list COMMA tbl_priv",
	"tbl_priv : SELECT",
	"tbl_priv : DELETE",
	"tbl_priv : INSERT",
	"tbl_priv : UPDATE",
	"tbl_priv : UPDATE grant_col_spec",
	"tbl_priv : REFERENCES",
	"tbl_priv : REFERENCES grant_col_spec",
	"tbl_priv : COPY_FROM",
	"tbl_priv : COPY_INTO",
	"dbproc_priv_spec : dbproc_priv_list",
	"dbproc_priv_spec : ALL priv_noise",
	"dbproc_priv_list : dbproc_priv",
	"dbproc_priv_list : dbproc_priv_list COMMA dbproc_priv",
	"dbproc_priv : EXECUTE",
	"seq_priv_spec : seq_priv_list",
	"seq_priv_spec : ALL priv_noise",
	"seq_priv_list : seq_priv",
	"seq_priv_list : seq_priv_list COMMA seq_priv",
	"seq_priv : NEXT",
	"event_priv_spec : event_priv_list",
	"event_priv_spec : ALL priv_noise",
	"event_priv_list : event_priv",
	"event_priv_list : event_priv_list COMMA event_priv",
	"event_priv : REGISTER",
	"event_priv : RAISE",
	"db_priv_spec : db_priv_list",
	"db_priv_spec : ALL priv_noise",
	"db_priv_list : db_priv",
	"db_priv_list : db_priv_list COMMA db_priv",
	"db_priv : user_ident",
	"db_priv : user_ident intconst_p",
	"db_priv_obj_spec : ONCURRENT nonkeyword",
	"db_priv_obj_spec : ONDATABASE db_loc_obj_list",
	"db_priv_obj_spec : /* empty */",
	"db_loc_obj_list : db_loc_obj",
	"db_loc_obj_list : db_loc_obj_list COMMA db_loc_obj",
	"db_loc_obj : generic_ident",
	"tbl_priv_obj_spec : ON tbl_priv_obj_list",
	"tbl_priv_obj_spec : ON TABLE tbl_priv_obj_list",
	"tbl_priv_obj_list : tbl_priv_obj",
	"tbl_priv_obj_list : tbl_priv_obj_list COMMA tbl_priv_obj",
	"tbl_priv_obj : obj_spec",
	"dbproc_priv_obj_spec : ONPROCEDURE dbproc_priv_obj_list",
	"dbproc_priv_obj_list : dbproc_priv_obj",
	"dbproc_priv_obj_list : dbproc_priv_obj_list COMMA dbproc_priv_obj",
	"dbproc_priv_obj : obj_spec",
	"seq_priv_obj_spec : ONSEQUENCE seq_priv_obj_list",
	"seq_priv_obj_list : seq_priv_obj",
	"seq_priv_obj_list : seq_priv_obj_list COMMA seq_priv_obj",
	"seq_priv_obj : obj_spec",
	"event_priv_obj_spec : ONEVENT event_priv_obj_list",
	"event_priv_obj_list : event_priv_obj",
	"event_priv_obj_list : event_priv_obj_list COMMA event_priv_obj",
	"event_priv_obj : obj_spec",
	"grant_col_spec : LPAREN grant_col_list RPAREN",
	"grant_col_spec : EXCLUDING",
	"grant_col_spec : EXCLUDING LPAREN grant_col_list RPAREN",
	"grant_col_spec : /* empty */",
	"grant_col_list : /* empty */",
	"grant_col_list : grant_col",
	"grant_col_list : grant_col_list COMMA grant_col",
	"grant_col : col_spec",
	"grant_auth_spec : TO user_auth_list",
	"grant_auth_spec : TOUSER user_auth_list",
	"grant_auth_spec : TOGROUP group_role_auth_list",
	"grant_auth_spec : TOROLE group_role_auth_list",
	"user_auth_list : user_auth",
	"user_auth_list : user_auth_list COMMA user_auth",
	"user_auth : user_ident",
	"user_auth : PUBLIC",
	"group_role_auth_list : group_role_auth",
	"group_role_auth_list : group_role_auth_list COMMA group_role_auth",
	"group_role_auth : auth_ident",
	"revoke : rev_kwd grant_option_for db_priv_spec db_priv_obj_spec rev_auth_spec",
	"revoke : rev_kwd grant_option_for tbl_priv_spec tbl_priv_obj_spec rev_auth_spec drop_behaviour",
	"revoke : rev_kwd grant_option_for dbproc_priv_spec dbproc_priv_obj_spec rev_auth_spec drop_behaviour",
	"revoke : rev_kwd grant_option_for seq_priv_spec seq_priv_obj_spec rev_auth_spec drop_behaviour",
	"revoke : rev_kwd grant_option_for event_priv_spec event_priv_obj_spec rev_auth_spec drop_behaviour",
	"grant_option_for : GRANT OPTION FOR",
	"grant_option_for : /* empty */",
	"rev_kwd : REVOKE",
	"rev_auth_spec : FROM user_role_auth_list",
	"rev_auth_spec : FROM USER user_auth_list",
	"rev_auth_spec : FROM GROUP group_role_auth_list",
	"user_role_auth_list : generic_ident group_role_auth_list",
	"user_role_auth_list : user_auth_list",
	"drop_behaviour : CASCADE",
	"drop_behaviour : RESTRICT",
	"create_secalm : crt_alm_kwd crt_alm_name alm_obj_spec alm_cond_spec alm_priv_spec alm_auth_spec alm_event_spec",
	"crt_alm_kwd : CRTSECALM",
	"crt_alm_name : generic_ident",
	"crt_alm_name : /* empty */",
	"alm_obj_spec : ONCURRENT nonkeyword",
	"alm_obj_spec : ONDATABASE generic_ident",
	"alm_obj_spec : ON obj_spec",
	"alm_obj_spec : ON TABLE obj_spec",
	"alm_cond_spec : IF alm_cond_list",
	"alm_cond_spec : /* empty */",
	"alm_cond_list : alm_cond COMMA alm_cond_list",
	"alm_cond_list : alm_cond",
	"alm_cond : nonkeyword",
	"alm_priv_list : alm_priv",
	"alm_priv_list : alm_priv_list COMMA alm_priv",
	"alm_priv : SELECT",
	"alm_priv : DELETE",
	"alm_priv : INSERT",
	"alm_priv : UPDATE",
	"alm_priv : nonkeyword",
	"alm_priv_spec : WHEN alm_priv_list",
	"alm_priv_spec : /* empty */",
	"alm_auth_spec : BY user_role_auth_list",
	"alm_auth_spec : BY GROUP group_role_auth_list",
	"alm_auth_spec : BY USER user_auth_list",
	"alm_auth_spec : /* empty */",
	"alm_event_spec : RAISEEVENT obj_spec alm_ev_text",
	"alm_event_spec : /* empty */",
	"alm_ev_text : SCONST",
	"alm_ev_text : /* empty */",
	"drop_secalm : drop_secalkw alm_obj_spec drop_secalspeclist",
	"drop_secalkw : DROPSECALM",
	"drop_secalspeclist : drop_secallist",
	"drop_secalspeclist : ALL",
	"drop_secallist : drop_secallist COMMA drop_secalspec",
	"drop_secallist : drop_secalspec",
	"drop_secalspec : generic_ident",
	"drop_secalspec : dropipint",
	"alter_secaud : alt_secaud_kwd alt_secaud_word alt_secaud_with",
	"alt_secaud_kwd : ALTSECAUDIT",
	"alt_secaud_word : RESTART",
	"alt_secaud_word : nonkeyword",
	"alt_secaud_word : /* empty */",
	"alt_secaud_with : WITH alt_secaud_withlist",
	"alt_secaud_with : /* empty */",
	"alt_secaud_withlist : alt_secaud_withentry",
	"alt_secaud_withlist : alt_secaud_withentry COMMA alt_secaud_withlist",
	"alt_secaud_withentry : nonkeyword EQUAL strconst",
	"enable_secaud : en_secaud_kwd sec_aud_spec",
	"en_secaud_kwd : ENSECAUDIT",
	"disable_secaud : dis_secaud_kwd sec_aud_spec",
	"dis_secaud_kwd : DISECAUDIT",
	"sec_aud_spec : sec_aud_ltok LPAREN sec_aud_lvl RPAREN",
	"sec_aud_spec : sec_aud_type",
	"sec_aud_type : ALL",
	"sec_aud_type : TABLE",
	"sec_aud_type : USER",
	"sec_aud_type : VIEW",
	"sec_aud_type : PROCEDURE",
	"sec_aud_type : ROW",
	"sec_aud_type : nonkeyword",
	"sec_aud_ltok : nonkeyword",
	"sec_aud_lvl : name_or_sconst",
	"create_profile : crt_pro_kwd auth_user usr_with_spec",
	"crt_pro_kwd : CRTPROFILE",
	"alter_profile : alt_pro_start usr_adp_spec usr_with_spec",
	"alt_pro_start : ALTPROFILE",
	"alt_pro_start : ALTPROFILE auth_user",
	"alt_pro_start : ALTER DEFAULT nonkeyword",
	"drop_profile : drp_pro_kwd auth_user drp_pro_term",
	"drp_pro_kwd : DROPPROFILE",
	"drp_pro_term : /* empty */",
	"drp_pro_term : RESTRICT",
	"drp_pro_term : CASCADE",
	"create_user : crt_usr_kwd auth_user usr_with_spec",
	"crt_usr_kwd : CRTUSER",
	"alter_user : alt_usr_kwd auth_user usr_adp_spec usr_with_spec",
	"alt_usr_kwd : ALTUSER",
	"usr_adp_spec : ADD PRIVILEGES LPAREN usr_priv_list RPAREN",
	"usr_adp_spec : DROP PRIVILEGES LPAREN usr_priv_list RPAREN",
	"usr_adp_spec : /* empty */",
	"usr_with_spec : WITH usr_with_list",
	"usr_with_spec : /* empty */",
	"usr_with_list : usr_with COMMA usr_with_list",
	"usr_with_list : usr_with",
	"usr_with : GROUP EQUAL auth_ident",
	"usr_with : PRIVILEGES EQUAL LPAREN usr_priv_list RPAREN",
	"usr_with : nonkeyword EQUAL LPAREN usr_priv_list RPAREN",
	"usr_with : nonkeyword EQUAL sconst_ident",
	"usr_with : nonkeyword EQUAL HEXCONST",
	"usr_with : nonkeyword EQUAL ALL",
	"usr_with : nonkeyword",
	"usr_priv_list : usr_priv COMMA usr_priv_list",
	"usr_priv_list : usr_priv",
	"usr_priv : nonkeyword",
	"usr_priv : ALL",
	"drop_user : drp_usr_kwd auth_user",
	"drp_usr_kwd : DROPUSER",
	"create_location : crt_loc_kwd db_loc_obj loc_with_spec",
	"crt_loc_kwd : CRTLOC",
	"alter_location : alt_loc_kwd db_loc_obj loc_with_spec",
	"alt_loc_kwd : ALTLOC",
	"loc_with_spec : WITH loc_with_list",
	"loc_with_list : loc_with COMMA loc_with_list",
	"loc_with_list : loc_with",
	"loc_with : loc_use_tok LPAREN loc_use_list RPAREN",
	"loc_with : loc_rawpct_tok loc_rawpct",
	"loc_with : loc_area_tok loc_area",
	"loc_with : loc_nouse_tok",
	"loc_area_tok : nonkeyword EQUAL",
	"loc_use_tok : nonkeyword EQUAL",
	"loc_nouse_tok : nonkeyword",
	"loc_area : name_or_sconst",
	"loc_use_list : loc_use COMMA loc_use_list",
	"loc_use_list : loc_use",
	"loc_use : loc_use_type",
	"loc_use_type : ALL",
	"loc_use_type : WORK",
	"loc_use_type : nonkeyword",
	"loc_rawpct_tok : RAWPCT EQUAL",
	"loc_rawpct : loc_rawpct_type",
	"loc_rawpct_type : intconst_p",
	"drop_location : drp_loc_kwd db_loc_obj",
	"drp_loc_kwd : DROPLOC",
	"create_group : crt_grp_kwd auth_obj_list crt_grp_spec",
	"crt_grp_kwd : CRTGROUP",
	"crt_grp_spec : WITH crt_grp_ukwd EQUAL LPAREN auth_user_list RPAREN",
	"crt_grp_spec : /* empty */",
	"crt_grp_ukwd : nonkeyword",
	"alter_group : alt_grp_kwd auth_obj_list alt_grp_spec",
	"alt_grp_kwd : ALTGROUP",
	"alt_grp_spec : ADD alt_grp_ukwd LPAREN auth_user_list RPAREN",
	"alt_grp_spec : DROP alt_grp_ukwd LPAREN auth_user_list RPAREN",
	"alt_grp_spec : DROP ALL",
	"alt_grp_ukwd : nonkeyword",
	"drop_group : drp_grp_kwd auth_obj_list",
	"drp_grp_kwd : DROPGROUP",
	"create_role : crt_role_kwd auth_obj_list usr_with_spec",
	"crt_role_kwd : CRTROLE",
	"alter_role : alt_role_kwd auth_obj_list usr_adp_spec usr_with_spec",
	"alt_role_kwd : ALTROLE",
	"drop_role : drp_role_kwd auth_obj_list",
	"drp_role_kwd : DROPROLE",
	"auth_user_list : auth_user",
	"auth_user_list : auth_user_list COMMA auth_user",
	"auth_user : user_ident",
	"auth_obj_list : auth_obj",
	"auth_obj_list : auth_obj_list COMMA auth_obj",
	"auth_obj : auth_ident",
	"create_sequence : crt_seq_kwd obj_spec seq_opt_list",
	"crt_seq_kwd : CRTSEQ",
	"seq_opt_list : seq_opt_list1",
	"seq_opt_list : /* empty */",
	"seq_opt_list1 : seq_opt",
	"seq_opt_list1 : seq_opt_list1 seq_opt",
	"seq_opt : AS seq_type",
	"seq_opt : START WITH sign_op number",
	"seq_opt : RESTART WITH sign_op number",
	"seq_opt : INCREMENT BY sign_op number",
	"seq_opt : MAXVALUE sign_op number",
	"seq_opt : MINVALUE sign_op number",
	"seq_opt : CACHE number",
	"seq_opt : CYCLE",
	"seq_opt : ORDER",
	"seq_opt : NOMAX",
	"seq_opt : NOMIN",
	"seq_opt : NOCACHE",
	"seq_opt : NOCYCLE",
	"seq_opt : NOORDER",
	"seq_type : tname",
	"seq_type : tname LPAREN intconst_e seq_type_scale RPAREN",
	"seq_type_scale : /* empty */",
	"seq_type_scale : COMMA intconst_e",
	"alter_sequence : alt_seq_kwd obj_spec seq_opt_list",
	"alt_seq_kwd : ALTSEQ",
	"drop_sequence : drp_seq_kwd obj_spec drp_seq_behaviour",
	"drp_seq_kwd : DROPSEQ",
	"drp_seq_behaviour : /* empty */",
	"drp_seq_behaviour : drop_behaviour",
	"free_locator : FREELOCATOR locator_list",
	"locator_list : locator_elem",
	"locator_list : locator_list COMMA locator_elem",
	"locator_elem : QDATA",
	"insert : insertkwd intname incolspec invalspec",
	"insert : insertkwd intname incolspec query_expr order_clause result_offset_clause fetch_first_clause",
	"insertkwd : INSERT INTO",
	"intname : obj_spec",
	"incolspec : LPAREN incollist RPAREN",
	"incolspec : /* empty */",
	"incollist : incol",
	"incollist : incollist COMMA incol",
	"incol : col_spec",
	"invalspec : DEFAULT VALUES",
	"invalspec : values LPAREN invallist RPAREN",
	"values : VALUES",
	"invallist : invallst",
	"invallst : inexpr",
	"invallst : invallst COMMA inexpr",
	"inexpr : select_expr",
	"inexpr : NULLWORD",
	"inexpr : DEFAULT",
	"modify : modstmnt modtable modnoise modstorage modkeys mod_with_or_where",
	"modstmnt : MODIFY",
	"modtable : obj_spec",
	"modtable : obj_spec modpartition",
	"modpartition : /* empty */",
	"modpartition : PARTITION logpartlist",
	"logpartlist : logpartname",
	"logpartlist : logpartlist PERIOD logpartname",
	"logpartname : generic_ident",
	"modnoise : TO",
	"modnoise : /* empty */",
	"modstorage : modstorname",
	"modstorage : modstorname UNIQUE modscope",
	"modscope : /* empty */",
	"modscope : nonkeyword EQUAL twith_nkw_kwd",
	"modstorname : nonkeyword",
	"modstorname : RELOCATE",
	"modstorname : nonkeyword EQUAL twith_nkw_kwd",
	"modstorname : twith_num",
	"modkeys : ON modrptkey",
	"modkeys : /* empty */",
	"modrptkey : modbasekey",
	"modrptkey : modrptkey COMMA modbasekey",
	"modbasekey : modkeyname",
	"modbasekey : modkeyname m_asc_desc",
	"m_asc_desc : ASC",
	"m_asc_desc : nonkeyword",
	"modkeyname : col_spec",
	"mod_with_or_where : WITH tblwithlist",
	"mod_with_or_where : WHERE tblwithlist",
	"mod_with_or_where : /* empty */",
	"prepare : prepare_kwrd generic_ident prep_from opt_repeat prepare_stmt_list",
	"prepare : prepare_kwrd generic_ident INTO NAME using_names prep_from opt_repeat prepare_stmt_list",
	"prepare_kwrd : PREPARE",
	"opt_repeat : /* empty */",
	"opt_repeat : REPEAT",
	"prep_from : FROM",
	"prepare_stmt_list : alter_role",
	"prepare_stmt_list : alter_group",
	"prepare_stmt_list : alter_user",
	"prepare_stmt_list : alter_location",
	"prepare_stmt_list : alter_table",
	"prepare_stmt_list : alter_profile",
	"prepare_stmt_list : comment",
	"prepare_stmt_list : commit",
	"prepare_stmt_list : copy",
	"prepare_stmt_list : create_event",
	"prepare_stmt_list : create_role",
	"prepare_stmt_list : create_group",
	"prepare_stmt_list : create_integrity",
	"prepare_stmt_list : create_permit",
	"prepare_stmt_list : create_rule",
	"prepare_stmt_list : create_table",
	"prepare_stmt_list : create_location",
	"prepare_stmt_list : create_view",
	"prepare_stmt_list : create_index",
	"prepare_stmt_list : create_secalm",
	"prepare_stmt_list : create_profile",
	"prepare_stmt_list : create_synonym",
	"prepare_stmt_list : delete",
	"prepare_stmt_list : dgtt_stmt",
	"prepare_stmt_list : drop_event",
	"prepare_stmt_list : drop_role",
	"prepare_stmt_list : drop_group",
	"prepare_stmt_list : drop_tvis",
	"prepare_stmt_list : drop_schema",
	"prepare_stmt_list : dropinteg",
	"prepare_stmt_list : dropperm",
	"prepare_stmt_list : drop_rule",
	"prepare_stmt_list : drop_user",
	"prepare_stmt_list : drop_location",
	"prepare_stmt_list : drop_profile",
	"prepare_stmt_list : drop_secalm",
	"prepare_stmt_list : disable_secaud",
	"prepare_stmt_list : enable_secaud",
	"prepare_stmt_list : alter_secaud",
	"prepare_stmt_list : grant",
	"prepare_stmt_list : insert",
	"prepare_stmt_list : modify",
	"prepare_stmt_list : query",
	"prepare_stmt_list : reg_gateway_idx",
	"prepare_stmt_list : reg_gateway_tab",
	"prepare_stmt_list : relocate",
	"prepare_stmt_list : revoke",
	"prepare_stmt_list : rollback",
	"prepare_stmt_list : register_event",
	"prepare_stmt_list : remove_event",
	"prepare_stmt_list : raise_event",
	"prepare_stmt_list : save",
	"prepare_stmt_list : savepoint",
	"prepare_stmt_list : set_sess_auth_id",
	"prepare_stmt_list : update",
	"execute : exe_stmnt using_list",
	"exe_stmnt : EXECUTE generic_ident",
	"describe : DESCRIBE generic_ident using_names",
	"using_names : USING nonkeyword",
	"using_names : /* empty */",
	"describe_input : DESCINPUT generic_ident",
	"query : query_with query_expr query_clause query_hint_with",
	"query_with : /* empty */",
	"query_with : WITH query_with_list",
	"query_with_list : with_list_element",
	"query_with_list : query_with_list COMMA with_list_element",
	"with_list_element : tbl_spec dcollist AS LPAREN",
	"with_list_element : tbl_spec dcollist AS LPAREN query_expr RPAREN",
	"query_clause : order_clause result_offset_clause fetch_first_clause",
	"query_clause : cur_updmode UPDATE OF newcollist",
	"query_clause : cur_updmode UPDATE",
	"cur_updmode : DEFERUPD",
	"cur_updmode : DIRECTUPD",
	"cur_updmode : FOR",
	"order_clause : ORDER BY",
	"order_clause : ORDER BY order_item_list",
	"order_clause : /* empty */",
	"result_offset_clause : OFFSET const_or_dbparm",
	"result_offset_clause : /* empty */",
	"fetch_first_clause : FETCH first_or_next const_or_dbparm row_or_rows ONLY",
	"fetch_first_clause : /* empty */",
	"first_or_next : nonkeyword",
	"first_or_next : NEXT",
	"row_or_rows : ROW",
	"row_or_rows : ROWS",
	"const_or_dbparm : cdbp_parmlvar",
	"const_or_dbparm : constant",
	"query_hint_with : /* empty */",
	"query_hint_with : WITH query_hint_list",
	"query_hint_list : query_hint_element",
	"query_hint_list : query_hint_list COMMA query_hint_element",
	"query_hint_element : nonkeyword",
	"hintdummy : ORDER",
	"hintdummy : /* empty */",
	"hintdummy : INDEX LPAREN generic_ident COMMA generic_ident RPAREN",
	"hintdummy : nonkeyword LPAREN generic_ident COMMA generic_ident RPAREN",
	"query_expr : query_expr_1",
	"query_expr_1 : query_term",
	"query_expr_1 : query_expr_1 union query_term",
	"query_term : subselect",
	"query_term : LPAREN query_expr_1 RPAREN",
	"union : UNION union_opt",
	"union_opt : /* empty */",
	"union_opt : DISTINCT",
	"union_opt : ALL",
	"subselect : select first_n distinct target_spec into_clause from",
	"subselect : select first_n distinct target_spec into_clause from where groupby having",
	"first_n : /* empty */",
	"first_n : FIRST int2_int4_p",
	"into_clause : into cdbp_lvar_list",
	"into_clause : /* empty */",
	"cdbp_lvar_list : cdbp_lvar",
	"cdbp_lvar_list : cdbp_lvar_list COMMA cdbp_lvar",
	"cdbp_lvar : colon generic_ident",
	"colon : COLON",
	"colon : /* empty */",
	"select : SELECT",
	"distinct : DISTINCT",
	"distinct : ALL",
	"distinct : /* empty */",
	"into : INTO",
	"target_spec : target_list",
	"target_list : target_item",
	"target_list : target_list COMMA target_item",
	"target_item : BAOP",
	"target_item : sel_expr_or_null",
	"target_item : col_spec EQUAL sel_expr_or_null",
	"target_item : COLON col_spec EQUAL sel_expr_or_null",
	"target_item : sel_expr_or_null optional_as col_spec",
	"target_item : all_col_ref",
	"optional_as : AS",
	"optional_as : /* empty */",
	"from_u : FROM from_list",
	"from_u : /* empty */",
	"from : from_word from_list",
	"from : /* empty */",
	"from_word : FROM",
	"from_list : from_list_item",
	"from_list : from_list COMMA from_list_item",
	"corr_name : tbl_spec",
	"corr_name : AS tbl_spec",
	"corr_name : /* empty */",
	"corr_name1 : tbl_spec",
	"corr_name1 : AS tbl_spec",
	"from_list_item : obj_spec corr_name",
	"from_list_item : LPAREN",
	"from_list_item : LPAREN query_expr RPAREN corr_name1 dcollist",
	"from_list_item : joined_table",
	"dcollist : /* empty */",
	"dcollist : LPAREN dcollist1 RPAREN",
	"dcollist1 : col_spec",
	"dcollist1 : dcollist1 COMMA col_spec",
	"from_item : obj_spec corr_name",
	"joined_table : cross_join",
	"joined_table : qualified_join",
	"joined_table : natural_join",
	"joined_table : LPAREN joined_table RPAREN",
	"qualified_join : from_list_item join_type from_list_item",
	"qualified_join : from_list_item join_type from_list_item join_specification",
	"cross_join : from_list_item CROSSJOIN from_list_item",
	"natural_join : from_list_item NATURAL join_type from_list_item",
	"join_type : JOIN",
	"join_type : INNERJOIN",
	"join_type : INTERSECTJOIN",
	"join_type : LEFTANTI",
	"join_type : LEFTANTI JOIN",
	"join_type : LEFTJOIN",
	"join_type : LEFTOUTER JOIN",
	"join_type : RIGHTANTI",
	"join_type : RIGHTANTI JOIN",
	"join_type : RIGHTJOIN",
	"join_type : RIGHTOUTER JOIN",
	"join_type : FULLANTI",
	"join_type : FULLANTI JOIN",
	"join_type : FULLJOIN",
	"join_type : FULLOUTER JOIN",
	"join_specification : join_condition",
	"join_specification : named_columns_join",
	"join_condition : ON boolean_expr",
	"named_columns_join : USING LPAREN named_collist RPAREN",
	"named_collist : named_column",
	"named_collist : named_collist COMMA named_column",
	"named_column : generic_ident",
	"where : where_word",
	"where : where_word boolean_expr",
	"where : /* empty */",
	"where_word : WHERE",
	"groupby : group_by group_list",
	"groupby : /* empty */",
	"group_by : GROUP BY",
	"having : having_word",
	"having : having_word boolean_expr",
	"having : /* empty */",
	"having_word : HAVING",
	"group_list : select_expr",
	"group_list : group_list COMMA select_expr",
	"cname : col_ref",
	"order_item_list : order_item",
	"order_item_list : order_item_list COMMA order_item",
	"order_item : order_column",
	"order_item : order_column ASC",
	"order_item : order_column nonkeyword",
	"order_column : select_expr",
	"boolean_expr : boolean_term",
	"boolean_expr : boolean_expr OR boolean_term",
	"boolean_term : boolean_factor",
	"boolean_term : boolean_term AND boolean_factor",
	"boolean_factor : boolean_primary",
	"boolean_factor : NOT boolean_primary",
	"boolean_primary : predicate",
	"boolean_primary : LPAREN boolean_expr RPAREN",
	"between : BETWEEN",
	"between : NOT BETWEEN",
	"symmetric : /* empty */",
	"symmetric : ASYMMETRIC",
	"symmetric : SYMMETRIC",
	"in : IN",
	"in : NOT IN",
	"is_postfix_op : IS is_name",
	"is_postfix_op : IS OF LPAREN is_name RPAREN",
	"is_postfix_op : IS NOT is_not_name",
	"is_postfix_op : IS NOT OF LPAREN is_not_name RPAREN",
	"is_name : NAME",
	"is_not_name : NAME",
	"like : LIKE",
	"like : NOTLIKE",
	"subsel_pred_qualifier : ALL",
	"subsel_pred_qualifier : SOME",
	"predicate : select_expr comparison select_expr",
	"predicate : select_expr comparison ANY LPAREN subselect RPAREN",
	"predicate : select_expr comparison subsel_pred_qualifier",
	"predicate : select_expr comparison subsel_pred_qualifier LPAREN subselect RPAREN",
	"predicate : select_expr between symmetric select_expr AND select_expr",
	"predicate : select_expr in select_expr",
	"predicate : select_expr in LPAREN sel_expr_list RPAREN",
	"predicate : EXISTS",
	"predicate : EXISTS LPAREN subselect RPAREN",
	"predicate : select_expr is_postfix_op",
	"predicate : element like select_expr",
	"predicate : element like select_expr ESCAPE strconst_e",
	"select_expr : arith_term",
	"select_expr : select_expr UAOP arith_term",
	"arith_term : arith_factor",
	"arith_term : arith_term bin_op arith_factor",
	"arith_factor : primary BAOPH arith_factor",
	"arith_factor : primary",
	"bin_op : BAOP",
	"bin_op : BDIVP",
	"primary : element",
	"primary : UAOP primary",
	"element : cname",
	"element : set_or_scalar_function",
	"element : case_function",
	"element : cast_expr",
	"element : seq_operator",
	"element : constant",
	"element : LPAREN select_expr_or_subselect RPAREN",
	"element : cdbp_parmlvar",
	"select_expr_or_subselect : select_expr",
	"select_expr_or_subselect : subselect",
	"comparison : BDOP",
	"comparison : EOP",
	"comparison : EQUAL",
	"comparison : NAME",
	"sel_expr_list : select_expr",
	"sel_expr_list : sel_expr_list COMMA select_expr",
	"constant : number",
	"constant : SCONST",
	"constant : bit_or_hex_const",
	"constant : UCONST",
	"constant : DCONST",
	"constant : TMWOCONST",
	"constant : TMWCONST",
	"constant : TMECONST",
	"constant : TSWOCONST",
	"constant : TSWCONST",
	"constant : TSTMPCONST",
	"constant : interval_const",
	"constant : QDATA",
	"constant : DOLLAR I2CONST EQUAL QDATA",
	"constant : QUESTIONMARK",
	"constant : USER",
	"constant : CURDATE",
	"constant : CURTIME",
	"constant : CURTIME LPAREN number RPAREN",
	"constant : CURTIMESTAMP",
	"constant : CURTIMESTAMP LPAREN number RPAREN",
	"constant : LOCTIME",
	"constant : LOCTIME LPAREN number RPAREN",
	"constant : LOCTIMESTAMP",
	"constant : LOCTIMESTAMP LPAREN number RPAREN",
	"constant : CURRENT_USER",
	"constant : SESSION_USER",
	"constant : SYSTEM_USER",
	"constant : INITIAL_USER",
	"constant : DBA",
	"constant : INGRES",
	"interval_const : INTERVAL SCONST interval_type",
	"interval_type : nonkeyword interval_junk1 interval_junk2",
	"interval_junk1 : /* empty */",
	"interval_junk1 : LPAREN I2CONST RPAREN",
	"interval_junk1 : LPAREN I2CONST COMMA I2CONST RPAREN",
	"interval_junk2 : /* empty */",
	"interval_junk2 : TO nonkeyword LPAREN I2CONST RPAREN",
	"interval_junk2 : TO nonkeyword",
	"number : I2CONST",
	"number : I4CONST",
	"number : I8CONST",
	"number : DECCONST",
	"number : F4CONST",
	"number : F8CONST",
	"avg_min_max_sum : AVG",
	"avg_min_max_sum : MIN",
	"avg_min_max_sum : MAX",
	"avg_min_max_sum : SUM",
	"set_or_scalar_function : count LPAREN BAOP RPAREN",
	"set_or_scalar_function : count LPAREN set_fun_dist select_expr RPAREN",
	"set_or_scalar_function : ANY LPAREN",
	"set_or_scalar_function : ANY LPAREN set_fun_dist select_expr RPAREN",
	"set_or_scalar_function : avg_min_max_sum",
	"set_or_scalar_function : avg_min_max_sum LPAREN set_fun_dist select_expr RPAREN",
	"set_or_scalar_function : nonreswd_function",
	"count : COUNT",
	"set_fun_dist : /* empty */",
	"set_fun_dist : ALL",
	"set_fun_dist : DISTINCT",
	"set_fun_all_dist : DISTINCT",
	"set_fun_all_dist : ALL",
	"nonreswd_function : func LPAREN RPAREN",
	"nonreswd_function : func LPAREN set_fun_all_dist select_expr RPAREN",
	"nonreswd_function : SUBSTRING LPAREN sel_expr_or_null from_or_comma sel_expr_or_null RPAREN",
	"nonreswd_function : func LPAREN sel_expr_or_null IN sel_expr_or_null RPAREN",
	"nonreswd_function : func LPAREN trim_or_extract_spec FROM sel_expr_or_null RPAREN",
	"nonreswd_function : SUBSTRING LPAREN sel_expr_or_null from_or_comma sel_expr_or_null for_or_comma sel_expr_or_null RPAREN",
	"nonreswd_function : func LPAREN func_argcommalist RPAREN",
	"from_or_comma : FROM",
	"from_or_comma : COMMA",
	"for_or_comma : FOR",
	"for_or_comma : COMMA",
	"func_argcommalist : func_arg",
	"func_argcommalist : func_argcommalist COMMA func_arg",
	"func_arg : sel_expr_or_null",
	"func : name_or_interval",
	"name_or_interval : NAME",
	"name_or_interval : INTERVAL",
	"trim_or_extract_spec : nonkeyword strconst_e",
	"trim_or_extract_spec : nonkeyword",
	"trim_or_extract_spec : strconst_e",
	"case_function : case_word case_body END",
	"case_function : NULLIF LPAREN select_expr COMMA select_expr RPAREN",
	"case_function : COALESCE LPAREN coalesce_list RPAREN",
	"case_word : CASE",
	"case_body : searched_case",
	"case_body : select_expr simple_case",
	"searched_case : searched_when_list case_else",
	"searched_when_list : searched_when_list_item",
	"searched_when_list : searched_when_list searched_when_list_item",
	"searched_when_list_item : WHEN boolean_expr THEN sel_expr_or_null",
	"simple_case : simple_when_list case_else",
	"simple_when_list : simple_when_list_item",
	"simple_when_list : simple_when_list simple_when_list_item",
	"simple_when_list_item : WHEN select_expr THEN sel_expr_or_null",
	"case_else : /* empty */",
	"case_else : ELSE sel_expr_or_null",
	"coalesce_list : coalesce_list_item",
	"coalesce_list : coalesce_list COMMA coalesce_list_item",
	"coalesce_list_item : sel_expr_or_null",
	"cast_expr : CAST LPAREN sel_expr_or_null AS cast_type RPAREN",
	"cast_type : tname collate",
	"cast_type : tname LPAREN intconst_e RPAREN collate",
	"cast_type : tname LPAREN intconst_e COMMA intconst_e RPAREN",
	"cast_type : tname TO tname",
	"cast_type : tname TO tname LPAREN intconst_e RPAREN",
	"seq_operator : ansi_seqop",
	"seq_operator : oracle_seqop",
	"ansi_seqop : aseqopwd obj_spec",
	"aseqopwd : NEXTVAL FOR",
	"aseqopwd : CURRVAL FOR",
	"oracle_seqop : generic_ident PERIOD generic_ident PERIOD oseqopwd",
	"oracle_seqop : generic_ident PERIOD oseqopwd",
	"oseqopwd : NEXTVAL",
	"oseqopwd : CURRVAL",
	"sel_expr_or_null : select_expr",
	"sel_expr_or_null : null_word",
	"null_word : NULLWORD",
	"relocate : RELOCATE obj_spec TO NAME",
	"rollback : rollbkstmnt TO generic_ident",
	"rollback : rollbkstmnt TO intconst_p",
	"rollback : rollbkstmnt WITH xa_xid_parm",
	"rollback : rollbkstmnt",
	"rollbkstmnt : ROLLBACK work",
	"xa_xid_parm : nonkeyword EQUAL strconst",
	"register_event : reg_ev_kword event_name event_tail",
	"reg_ev_kword : REGISTEREVENT",
	"event_name : obj_spec",
	"event_tail : /* empty */",
	"remove_event : rem_ev_kword event_name event_tail",
	"rem_ev_kword : REMOVEEVENT",
	"raise_event : ras_ev_kword event_name ras_ev_options event_tail",
	"ras_ev_kword : RAISEEVENT",
	"ras_ev_options : ras_ev_value ras_ev_with",
	"ras_ev_value : /* empty */",
	"ras_ev_value : colon NAME",
	"ras_ev_value : SCONST",
	"ras_ev_with : /* empty */",
	"ras_ev_with : WITH nonkeyword",
	"save_tbl : obj_spec",
	"save : savstmnt save_tbl UNTIL date",
	"save : savstmnt save_tbl",
	"savstmnt : SAVE",
	"date : month intconst_e intconst_e",
	"month : NAME",
	"month : intconst_p",
	"savepoint : spoint sp_name",
	"spoint : SAVEPOINT",
	"sp_name : generic_ident",
	"sp_name : intconst_p",
	"setaggr : SETAGGR strsetparam",
	"setautocommit : setauto_kwd on_or_off",
	"setauto_kwd : SETAUTOCOMMIT",
	"setcachedyn : SETCACHEDYN",
	"setcpufact : SETCPUFACT intsetparam",
	"setdatefmt : SETDATEFMT strconst_e",
	"setddl_concur : setddlconcur_kwd on_or_off",
	"setddlconcur_kwd : SETDDLCONCUR",
	"on_or_off : ON",
	"on_or_off : nonkeyword",
	"setdecimal : SETDECIMAL strconst_e",
	"setiotrace : SETIOTRACE",
	"setjoinop : SETJOINOP",
	"setjournal : SETJOURNAL",
	"setjournal : SETJOURNAL ON",
	"setjournal : SETJOURNAL ON obj_spec",
	"setjtimeout : SETJOINOP nonkeyword setjint",
	"setjint : int2_int4_p",
	"setjint : /* empty */",
	"setlockmode : setlockstmnt setlockscope WHERE setlockparms",
	"setlockstmnt : SETLOCKMODE",
	"setlockscope : SESSION",
	"setlockscope : ON obj_spec",
	"setlockparms : setlockparm",
	"setlockparms : setlockparms COMMA setlockparm",
	"setlockparm : setlockkey EQUAL nonkeyword",
	"setlockparm : setlockkey EQUAL ROW",
	"setlockparm : setlockkey EQUAL TABLE",
	"setlockparm : setlockkey EQUAL SESSION",
	"setlockparm : setlockkey EQUAL intsetparam",
	"setlockkey : nonkeyword",
	"setlockkey : LEVEL",
	"settransaction : settranstmnt settranmodes",
	"settranstmnt : SETTRANSACTION",
	"settranmodes : settranmode",
	"settranmodes : settranmode COMMA settranmode",
	"settranmode : settranisolation_level",
	"settranmode : settranaccess_mode",
	"settranisolation_level : ISOLATION LEVEL isolation_level",
	"isolation_level : READ COMMITTED",
	"isolation_level : READ UNCOMMITTED",
	"isolation_level : REPEATABLE READ",
	"isolation_level : SERIALIZABLE",
	"settranaccess_mode : access_mode",
	"access_mode : READ ONLY",
	"access_mode : READ WRITE",
	"setlocktrace : SETLOCKTRACE",
	"setlogging : SETLOGGING",
	"setlogtrace : SETLOGTRACE",
	"setmnyfmt : SETMNYFMT strconst_e",
	"setmnyprec : SETMNYPREC intsetparam",
	"setmxio : setmxio_kwd intsetparam",
	"setmxio : setmxio_kwd",
	"setmxio_kwd : SETMXIO",
	"setmxrow : setmxrow_kwd intsetparam",
	"setmxrow : setmxrow_kwd",
	"setmxrow_kwd : SETMXROW",
	"setmxcpu : setmxcpu_kwd intsetparam",
	"setmxcpu : setmxcpu_kwd",
	"setmxcpu_kwd : SETMXCPU",
	"setmxidle : setmxidle_kwd intsetparam",
	"setmxidle : setmxidle_kwd",
	"setmxidle_kwd : SETMXIDLE",
	"setmxconnect : setmxconnect_kwd intsetparam",
	"setmxconnect : setmxconnect_kwd",
	"setmxconnect_kwd : SETMXCONNECT",
	"setmxpage : setmxpage_kwd intsetparam",
	"setmxpage : setmxpage_kwd",
	"setmxpage_kwd : SETMXPAGE",
	"setmxcost : setmxcost_kwd intsetparam",
	"setmxcost : setmxcost_kwd",
	"setmxcost_kwd : SETMXCOST",
	"setprintqry : SETPRINTQRY",
	"setprintrules : SETPRTRULES",
	"setrules : SETRULES",
	"setprintevents : SETPRTEVENTS",
	"setlogevents : SETLOGEVENTS",
	"setoptimizeonly : SETOPTIMIZEONLY",
	"setflatten : SETFLATTEN",
	"sethash : SETHASH",
	"setojflatten : SETOJFLATTEN",
	"setparallel : SETPARALLEL parconst",
	"parconst : int2_int4_p",
	"parconst : /* empty */",
	"setqep : SETQEP",
	"setrandomseed : SETRANDOMSEED intsetparam",
	"setrandomseed : SETRANDOMSEED",
	"setretinto : SETRETINTO strsetparam",
	"set_stat_tbl : QDATA",
	"set_stat_tbl : obj_spec",
	"setsession : setsessstmt setsessopts setsesswith",
	"setsessstmt : SETSESSION",
	"setsessopts : setsessopt",
	"setsessopts : setsessopt COMMA setsessopt",
	"setsessopts : /* empty */",
	"setsessopt : ADD PRIVILEGES LPAREN usr_priv_list RPAREN",
	"setsessopt : DROP PRIVILEGES LPAREN usr_priv_list RPAREN",
	"setsessopt : ISOLATION LEVEL isolation_level",
	"setsessopt : ISOLATION LEVEL nonkeyword",
	"setsessopt : access_mode",
	"setsessopt : nonkeyword",
	"setsesswith : WITH setsessparms",
	"setsesswith : /* empty */",
	"setsessparms : setsessparm",
	"setsessparms : setsessparm COMMA setsessparms",
	"setsessparm : nonkeyword EQUAL nonkeyword",
	"setsessparm : nonkeyword EQUAL strconst",
	"setsessparm : nonkeyword EQUAL int2_int4",
	"setsessparm : nonkeyword EQUAL ROLLBACK SAVEPOINT generic_ident",
	"setsessparm : nonkeyword EQUAL ROLLBACK nonkeyword",
	"setsessparm : PRIVILEGES EQUAL LPAREN usr_priv_list RPAREN",
	"setsessparm : PRIVILEGES EQUAL DEFAULT",
	"setsessparm : PRIVILEGES EQUAL ALL",
	"setsessparm : nonkeyword",
	"setstats : SETSTATS set_stat_tbl",
	"settrace : settracestmnt strsetparam",
	"settrace : settracestmnt strsetparam strsetparam",
	"settrace : settracestmnt strsetparam strsetparam intconst_p",
	"settrace : settracestmnt strsetparam strsetparam intconst_p intconst_p",
	"settracestmnt : SETTRACE",
	"setresstruct : SETRESSTRUCT strsetparam",
	"setwork : sw_stmnt sw_locations sw_actionword LPAREN sw_loclist RPAREN",
	"sw_stmnt : SETWORK",
	"sw_locations : NAME",
	"sw_actionword : ADD",
	"sw_actionword : DROP",
	"sw_actionword : NAME",
	"sw_loclist : sw_locname",
	"sw_loclist : sw_locname COMMA sw_loclist",
	"sw_locname : NAME",
	"setrole : SETROLE",
	"setrole : SETROLE generic_ident setrole_passwd",
	"setrole_passwd : /* empty */",
	"setrole_passwd : WITH nonkeyword EQUAL name_or_sconst",
	"setunicodesub : SETUNICODESUB",
	"setunicodesub : SETUNICODESUB strconst_e",
	"setupdrowcnt : SETUPDROWCNT strsetparam",
	"intsetparam : intconst_p",
	"intsetparam : SCONST",
	"strsetparam : strconst",
	"strsetparam : nonkeyword",
	"intconst_e : intconst_p",
	"intconst_e : error",
	"intconst_p : int2_int4_p",
	"intconst_p : QDATA",
	"int2_int4_p : I4CONST",
	"int2_int4_p : I2CONST",
	"int2_int4 : UAOP int2_int4_p",
	"int2_int4 : int2_int4_p",
	"strconst : SCONST",
	"strconst : QDATA",
	"strconst_e : SCONST",
	"strconst_e : QDATA",
	"strconst_e : error",
	"bit_or_hex_const : HEXCONST",
	"bit_or_hex_const : BITCONST",
	"update : updatekwd from_item from_u",
	"update : updatekwd from_item from_u SET updatelist",
	"update : updatekwd from_item from_u SET updatelist where_cur",
	"updatekwd : UPDATE",
	"updatelist : update_item",
	"updatelist : updatelist COMMA update_item",
	"update_item : col_spec EQUAL select_expr",
	"update_item : col_spec EQUAL DEFAULT",
	"update_item : col_spec EQUAL NULLWORD",
	"where_cur : where",
	"where_cur : WHERE CURRENT OF cursor_id",
	"cursor_id : QUERYID",
	"cursor_id : generic_ident",
	"comment : comment_stmt comment_obj long_remark short_remark",
	"comment_stmt : COMMENT_ON",
	"comment_obj : TABLE obj_spec",
	"comment_obj : COLUMN comment_col",
	"col_ref : generic_ident",
	"col_ref : generic_ident PERIOD generic_ident",
	"col_ref : generic_ident PERIOD generic_ident PERIOD generic_ident",
	"col_ref : DBA PERIOD generic_ident PERIOD generic_ident",
	"col_ref : INGRES PERIOD generic_ident PERIOD generic_ident",
	"col_ref : SESSION PERIOD generic_ident PERIOD generic_ident",
	"all_col_ref : generic_ident PERIOD BAOP",
	"all_col_ref : generic_ident PERIOD generic_ident PERIOD BAOP",
	"all_col_ref : DBA PERIOD generic_ident PERIOD BAOP",
	"all_col_ref : INGRES PERIOD generic_ident PERIOD BAOP",
	"all_col_ref : SESSION PERIOD generic_ident PERIOD BAOP",
	"comment_col : col_ref",
	"long_remark : IS SCONST",
	"long_remark : /* empty */",
	"short_remark : SHORT_REMARK EQUAL SCONST",
	"short_remark : /* empty */",
	"set_sess_auth_id : SETSESSION AUTHORIZATION",
	"set_sess_auth_id : SETSESSION AUTHORIZATION eff_user_id_spec",
	"eff_user_id_spec : generic_ident",
	"eff_user_id_spec : DBA",
	"eff_user_id_spec : INGRES",
	"eff_user_id_spec : USER",
	"eff_user_id_spec : CURRENT_USER",
	"eff_user_id_spec : SESSION_USER",
	"eff_user_id_spec : SYSTEM_USER",
	"eff_user_id_spec : INITIAL_USER",
	"eff_user_id_spec : SCONST",
	"eff_user_id_spec : QDATA",
	"eff_user_id_spec : QUESTIONMARK",
	"reg_distr_tv : reg_keywd reg_name link_cols as_link_or_native from_ldb_obj ldb_spec",
	"from_ldb_obj : from_ldb_wd internal_ident",
	"from_ldb_obj : from_ldb_wd owner_name PERIOD internal_ident",
	"from_ldb_obj : /* empty */",
	"from_ldb_wd : FROM",
	"owner_name : internal_ident",
	"as_link_or_native : AS nonkeyword",
	"reg_keywd : reg_tvp",
	"reg_name : obj_spec",
	"reg_tvp : REGISTER",
	"reg_tvp : REGISTER TABLE",
	"reg_tvp : REGISTER VIEW",
	"reg_tvp : REGISTER PROCEDURE",
	"create_link : crt_lnk_kwd reg_name link_cols",
	"create_link : crt_lnk_kwd reg_name link_cols ldb_spec",
	"crt_lnk_kwd : CRTLINK",
	"link_cols : LPAREN link_col_list RPAREN",
	"link_cols : /* empty */",
	"link_col_list : col_spec",
	"link_col_list : link_col_list COMMA col_spec",
	"ldb_spec : /* empty */",
	"ldb_spec : WITH NULLWORD",
	"ldb_spec : WITH nonkeyword",
	"ldb_spec : WITH ldb_spec_list",
	"ldb_spec_list : ldb_spec_item",
	"ldb_spec_list : ldb_spec_list COMMA ldb_spec_item",
	"ldb_spec_item : twith_name",
	"ldb_spec_item : twith_nm_eq_str",
	"ldb_spec_item : twith_tb_eq_id",
	"reg_gateway_tab : reg_keywd reg_name LPAREN reg_attr_list RPAREN AS IMPORT FROM reg_file_name reg_with_list reg_exit_rtn",
	"reg_attr_list : reg_attr_elem",
	"reg_attr_list : reg_attr_list COMMA reg_attr_elem",
	"reg_attr_elem : newcolname typedesc",
	"reg_attr_elem : newcolname typedesc IS reg_extfmt",
	"reg_extfmt : SCONST",
	"reg_file_name : SCONST",
	"reg_with_list : WITH reg_parm_list",
	"reg_with_list : /* empty */",
	"reg_parm_list : reg_parm_elem",
	"reg_parm_list : reg_parm_list COMMA reg_parm_elem",
	"reg_parm_elem : reg_dbms_or_struct_parm",
	"reg_parm_elem : reg_key_parm",
	"reg_parm_elem : reg_rows_parm",
	"reg_parm_elem : reg_keywd_only_parm",
	"reg_dbms_or_struct_parm : nonkeyword EQUAL nonkey_or_sconst",
	"reg_dbms_or_struct_parm : nonkeyword EQUAL UNIQUE name_or_sconst",
	"reg_key_parm : nonkeyword EQUAL LPAREN reg_key RPAREN",
	"reg_key : reg_icols",
	"reg_key : reg_key COMMA reg_icols",
	"reg_icols : col_spec asc_desc",
	"reg_rows_parm : ROWS EQUAL intconst_p",
	"reg_keywd_only_parm : nonkeyword",
	"reg_keywd_only_parm : UPDATE",
	"reg_exit_rtn : /* empty */",
	"reg_distr_idx : reg_idx reg_idx_name ON indexrel as_link from_ldb_obj",
	"reg_gateway_idx : reg_idx reg_idx_name ON indexrel LPAREN indexcols RPAREN AS IMPORT FROM reg_file_name WITH reg_idx_withopts",
	"reg_idx : reg_idx_key",
	"reg_idx_key : REGISTER INDEX",
	"reg_idx_key : REGISTER UNIQUE INDEX",
	"reg_idx_name : obj_spec",
	"as_link : AS nonkeyword",
	"reg_idx_withopts : reg_idx_withopt",
	"reg_idx_withopts : reg_idx_withopts COMMA reg_idx_withopt",
	"reg_idx_withopt : nonkeyword EQUAL nonkeyword",
	"dircon : dircon_prefix ldb_spec",
	"dircon_prefix : nonkeyword nonkeyword",
	"dir_exec_immed : dir_exec_immed_prefix ldb_spec",
	"dir_exec_immed_prefix : nonkeyword EXECUTE IMMEDIATE SCONST",
	"nonkeyword : NAME",
	"nonkey_or_sconst : NAME",
	"nonkey_or_sconst : SCONST",
	"name_or_sconst : NAME",
	"name_or_sconst : SCONST",
	"generic_ident : NAME",
	"generic_ident : DELIM_IDENT",
	"sconst_ident : generic_ident",
	"sconst_ident : SCONST",
	"internal_ident : generic_ident",
	"internal_ident : SCONST",
	"auth_ident : internal_ident",
	"user_ident : internal_ident",
	"user_ident : DBA",
	"user_ident : INGRES",
	"schema_spec : user_ident",
	"tbl_spec : generic_ident",
	"col_spec : generic_ident",
	"obj_spec : generic_ident",
	"obj_spec : schema_spec PERIOD generic_ident",
	"obj_spec : SESSION PERIOD generic_ident",
};
#endif /* YYDEBUG */
FUNC_EXTERN	i4	psls1iftn();
FUNC_EXTERN	i4	psls2iftn();
FUNC_EXTERN	i4	psls3iftn();
FUNC_EXTERN	i4	psls4iftn();
FUNC_EXTERN	i4	psls5iftn();
FUNC_EXTERN	i4	psls6iftn();
FUNC_EXTERN	i4	psls7iftn();
FUNC_EXTERN	i4	psls8iftn();
FUNC_EXTERN	i4	psls9iftn();
FUNC_EXTERN	i4	psls10iftn();
FUNC_EXTERN	i4	psls11iftn();
FUNC_EXTERN	i4	psls12iftn();
FUNC_EXTERN	i4	psls13iftn();
FUNC_EXTERN	i4	psls14iftn();
FUNC_EXTERN	i4	psls15iftn();
FUNC_EXTERN	i4	psls16iftn();
FUNC_EXTERN	i4	psls17iftn();
FUNC_EXTERN	i4	psls18iftn();
FUNC_EXTERN	i4	psls19iftn();
FUNC_EXTERN	i4	psls20iftn();
FUNC_EXTERN	i4	psls21iftn();
FUNC_EXTERN	i4	psls22iftn();
FUNC_EXTERN	i4	psls23iftn();
FUNC_EXTERN	i4	psls24iftn();
FUNC_EXTERN	i4	psls25iftn();
FUNC_EXTERN	i4	psls26iftn();
FUNC_EXTERN	i4	psls27iftn();
FUNC_EXTERN	i4	psls28iftn();
FUNC_EXTERN	i4	psls29iftn();
FUNC_EXTERN	i4	psls30iftn();
FUNC_EXTERN	i4	psls31iftn();
FUNC_EXTERN	i4	psls32iftn();
FUNC_EXTERN	i4	psls33iftn();
FUNC_EXTERN	i4	psls34iftn();
FUNC_EXTERN	i4	psls35iftn();
FUNC_EXTERN	i4	psls36iftn();
FUNC_EXTERN	i4	psls37iftn();
FUNC_EXTERN	i4	psls38iftn();
FUNC_EXTERN	i4	psls39iftn();
FUNC_EXTERN	i4	psls40iftn();
FUNC_EXTERN	i4	psls41iftn();
FUNC_EXTERN	i4	psls42iftn();
FUNC_EXTERN	i4	psls43iftn();
FUNC_EXTERN	i4	psls44iftn();


extern	i4	(*pslsfunc[])();
/*
**Copyright (c) 2004 Ingres Corporation
*/
/*
** Skeleton parser driver for yacc output
**
**
** History
**
** 07-apr-93 (smc)
**	Commented out YYREENTER text after endif.
** 10-jan-1996 (toumi01; from 1.1 axp_osf port)
**	Cast (long) 3rd... EXsignal args to avoid truncation.
** 17-nov-99 (inkdo01)
**	Changed YYACCEPT symbol to NOT EXsignal (because of kernel 
**	overhead).
** 17-dec-1999 (somsa01)
**	Removed extra EXdelete() from YYACCEPT that was added.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	19-sep-01 (inkdo01)
**	    Added code to error handling to retry reserved words as 
**	    equivalent identifiers.
**	25-jan-06 (dougi)
**	    Changed action calls to pass YYVARS** instead of YYVARS* to
**	    allow recursion on derived tables (subselects in FROM clauses).
*/

/*
** yacc user known macros and defines
*/
#ifdef		YYFUNCTIONS
#	ifdef    VMS
#		define  YYACCVAL	MAXI4
#		define  YYABORTVAL	E_DB_ERROR
#	endif
#	ifdef    UNIX
#		define  YYACCVAL	MAXI4
#		define  YYABORTVAL	E_DB_ERROR
#	endif
#	ifdef    DESKTOP
#		define  YYACCVAL	MAXI4
#		define  YYABORTVAL	E_DB_ERROR
#	endif
/*
** ysstatusp is a pointer, and EXsignal expects i4, so this solution
** is not very clean; there is no other option, however, so we will go
** ahead and use it, should be OK for now.
** This WAS OK until we ported to axp_osf, where i4 and i4 are 32 bits
** and pointers are 64 bits.  EXsignal was (of course) modified as well.
*/
#	define YYERROR	(VOID)EXsignal(EX_PSF_LJMP, 2, (long)1,yystatusp)
#	define YYACCEPT	\
    {\
	EXdelete();\
	return(E_DB_OK);\
    }
#	define YYABORT	(VOID)EXsignal(EX_PSF_LJMP, 2, (long)YYABORTVAL,yystatusp)
#else
#	define YYERROR	goto yyerrlab
#	define YYACCVAL	E_DB_OK
#	define YYACCEPT	return(YYACCVAL)
#	define YYABORT	return(E_DB_ERROR)
#endif

#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yacc_cb->yychar >= 0 || ( pslsr2[ yacc_cb->yytmp ] >> 1 ) != 1 )\
	{\
		(*yacc_cb->yyerror)(1, cb, psq_cb);\
		goto yyerrlab;\
	}\
	yacc_cb->yychar = newtoken;\
	yacc_cb->yystate = *yacc_cb->yyps;\
	yacc_cb->yylval = newvalue;\
	goto yynewstate;\
}
#define YYRECOVERING()	(!!yacc_cb->yyerrflag)

/*
** user known globals
*/
#ifndef	YYREENTER
i4  pslsdebug;			/* set to 1 to get debugging */
#endif

/*
** driver internal defines
*/
#define YYFLAG		(-1000)

/* 
** If not defined we need to define YYVARS, even though it won't be used,
** because -S option requires it.
*/
#ifdef YACC_VARS
#define	    YYVARS	PSS_YYVARS
#else
typedef	i4	YYVARS;
#endif

#ifdef		YYFUNCTIONS
/*{
** Name: YY_1HANDLER, YY_2HANDLER	- Exception handlers for the YACC generated
** parser.
**
** Description:
**      This function is the exception handler for quel and SQL parsers.
**	Exceptions are caught here only if -S flag is specified to YACC.
**	YY_2HANDLER handles exceptions that occur within YY_1HANDLER.
**
** Inputs:
**      exargs                          The exception handler args, as defined
**					by the CL spec.
**
** Outputs:
**      None
**	Returns:
**	    EXDECLARE
**	Exceptions:
**	    none
**
** Side Effects:
**	    Can send error message to terminal and/or log file
**
** History:
**	11-nov-87 (stec)
**          written
*/

i4
YY_2HANDLER(exargs)
EX_ARGS            *exargs;
{
	return(EXDECLARE);
}

i4
YY_1HANDLER(exargs)
EX_ARGS            *exargs;
{
    EX_CONTEXT	context;
    i4		status;

    /*
    ** Handle exception handler exceptions here.
    */
    if (EXdeclare(YY_2HANDLER, &context) != OK)
    {
	EXdelete();
	return(EXRESIGNAL);
    }

    if (EXmatch(EX_PSF_LJMP, 1, exargs->exarg_num))
    {
	if (exargs->exarg_count == 2)
	{
	    DB_STATUS *statp;

	    statp =  (DB_STATUS *) exargs->exarg_array[1];
	    *statp = (DB_STATUS) exargs->exarg_array[0];
	    status = EXDECLARE;
	}
	else
	{
	    /* unexpected exceptions handled by psf_handle */
	    status = EXRESIGNAL;
	}
    }
    else
    {
	/* unexpected exceptions handled by psf_handle */
	status = EXRESIGNAL;
    }
    EXdelete();
    return(status);
}
#endif

/*
** yyparse - return E_DB_OK if worked, E_DB_ERROR if syntax error not recovered
**	     from
*/
DB_STATUS
pslsparse(cb,psq_cb)
PSS_SESBLK	*cb;
PSQ_CB *	psq_cb;
{
#ifndef	YYREENTER
	register YYSTYPE *yypvt;	/* top of value stack for $vars */
	i4		 yyerr_decl;
	YYSTYPE yyv[ YYMAXDEPTH ];	/* value stack */
	i4 yys[ YYMAXDEPTH ];		/* state stack */

	YYSTYPE *yypv;			/* top of value stack */
	i4 *yyps;			/* top of state stack */

	i4 yystate;			/* current state */
	i4 yytmp;			/* extra var (lasts between blocks) */

	i4 yynerrs;			/* number of errors */
	i4 yyerrflag;			/* error recovery flag */
	i4 yychar;			/* current input token number */
#else
	YACC_CB *yacc_cb = (YACC_CB *) (cb->pss_yacc);
#endif

#ifndef YACC_VARS
	YYVARS	yyvars, *yyvarsp = &yyvars, **yyvarspp = &yyvarsp;
#endif
#ifdef	YYFUNCTIONS
	EX_CONTEXT	context;
	DB_STATUS	yystatus, *yystatusp = &yystatus;

#ifdef YACC_VARS
#include "yyvarsinit.h"	
#endif
	/*
	** Handle all exceptions here, They will be primarily generated
	** by execution of YYERROR, YYABORT, YYACCEPT.
	*/
	if (EXdeclare(YY_1HANDLER, &context) != OK)
	{
		if (yystatus == YYACCVAL)
		{
			EXdelete();
			/* E_DB_OK should be returned */
			yystatus = E_DB_OK;
			return (yystatus);
		}
		else if (yystatus == YYABORTVAL)
		{
			EXdelete();
			/* E_DB_ERROR should be returned */
			yystatus = E_DB_ERROR;
			return (yystatus);
		}
		else if (yystatus == 1)		/* YYERROR */
		{
			goto yyerrlab;
		}
		else	/* Should never be reached */
		{
			EXdelete();
			/* E_DB_SEVERE should be returned */
			yystatus = E_DB_SEVERE;
			return (yystatus);
		}
	}
#else
#ifdef YACC_VARS
#include "yyvarsinit.h"	
#endif
#endif

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yacc_cb->yypv = &yacc_cb->yyv[-1];
	yacc_cb->yyps = &yacc_cb->yys[-1];
	yacc_cb->yystate = 0;
	yacc_cb->yytmp = 0;
	yacc_cb->yynerrs = 0;
	yacc_cb->yyerrflag = 0;
	yacc_cb->yychar = -2;

	goto yystack;
	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register i4  *yy_ps;		/* top of state stack */
		register i4  yy_state;		/* current state */
		register i4   yy_n;		/* internal state number info */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yacc_cb->yypv;
		yy_ps = yacc_cb->yyps;
		yy_state = yacc_cb->yystate;
		goto yy_newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yacc_cb->yypv;
		yy_ps = yacc_cb->yyps;
		yy_state = yacc_cb->yystate;

		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
#ifdef	xDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yacc_cb->yydebug )
		{
			register i4  yy_i;

			YYPRINTF( "State %d, token ", yy_state );
			if ( yacc_cb->yychar == 0 )
				YYPRINTF( "end-of-file\n" );
			else if ( yacc_cb->yychar < 0 )
				YYPRINTF( "-none-\n" );
			else
			{
				for ( yy_i = 0; pslstoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( pslstoks[yy_i].t_val == yacc_cb->yychar )
						break;
				}
				YYPRINTF( "%s\n", pslstoks[yy_i].t_name );
			}
		}
#endif /* xDEBUG */
		if ( ++yy_ps >= &yacc_cb->yys[ YYMAXDEPTH ] )	/* room on stack? */
		{
			(*yacc_cb->yyerror)(2, cb, psq_cb);
			YYABORT;
		}
		*yy_ps = yy_state;
		yy_pv++;
		STRUCT_ASSIGN_MACRO(yacc_cb->yyval, *yy_pv);

		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = pslspact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
#ifdef	xDEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yacc_cb->yytmp = yacc_cb->yychar == -2;
#endif
		if (yacc_cb->yychar == -2)
			yacc_cb->yychar = (*yacc_cb->yylex)(cb,psq_cb);
		if (yacc_cb->yychar == -1)
			goto yyerrlab;
/*		REPLACED WITH ABOVE 4 LINES
/*		if ( ( yacc_cb->yychar == -2 ) && ( ( yacc_cb->yychar = (*yacc_cb->yylex)(cb,psq_cb) ) < 0 ) )
/*			yacc_cb->yychar = 0;		/* reached EOF */
/**/
#ifdef	xDEBUG
		if ( yacc_cb->yydebug && yacc_cb->yytmp )
		{
			register i4  yy_i;

			YYPRINTF( "Received token " );
			if ( yacc_cb->yychar == 0 )
				YYPRINTF( "end-of-file\n" );
			else if ( yacc_cb->yychar < 0 )
				YYPRINTF( "-none-\n" );
			else
			{
				for ( yy_i = 0; pslstoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( pslstoks[yy_i].t_val == yacc_cb->yychar )
						break;
				}
				YYPRINTF( "%s\n", pslstoks[yy_i].t_name );
			}
		}
#endif /* xDEBUG */
		if ( ( ( yy_n += yacc_cb->yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( pslschk[ yy_n = pslsact[ yy_n ] ] == yacc_cb->yychar ) /*valid shift*/
		{
			yacc_cb->yychar = -2;
			STRUCT_ASSIGN_MACRO(yacc_cb->yylval, yacc_cb->yyval);
			yy_state = yy_n;
			if ( yacc_cb->yyerrflag > 0 )
				yacc_cb->yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = pslsdef[ yy_state ] ) == -2 )
		{
#ifdef	xDEBUG
			yacc_cb->yytmp = yacc_cb->yychar < 0;
#endif
			if (yacc_cb->yychar == -2)
				yacc_cb->yychar = (*yacc_cb->yylex)(cb,psq_cb);
			if (yacc_cb->yychar == -1)
				goto yyerrlab;
/*			REPLACED WITH ABOVE 4 LINES
/*			if ( ( yacc_cb->yychar < 0 ) &&
/*			    ( ( yacc_cb->yychar = (*yacc_cb->yylex)(cb,psq_cb) ) < 0 ) )
/*			{
/*				yacc_cb->yychar = 0;		/* reached EOF */
/*			}
/**/
#ifdef	xDEBUG
			if ( yacc_cb->yydebug && yacc_cb->yytmp )
			{
				register i4  yy_i;

				YYPRINTF( "Received token " );
				if ( yacc_cb->yychar == 0 )
					YYPRINTF( "end-of-file\n" );
				else if ( yacc_cb->yychar < 0 )
					YYPRINTF( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						pslstoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( pslstoks[yy_i].t_val
							== yacc_cb->yychar )
						{
							break;
						}
					}
					YYPRINTF( "%s\n", pslstoks[yy_i].t_name );
				}
			}
#endif /* xDEBUG */
			/*
			** look through exception table
			*/
			{
				register i4  *yyxi = (i4*)pslsexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yacc_cb->yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yacc_cb->yyerrflag )
			{
			case 0:		/* new error */
				/* First try the new keyword-as-ident trick. */
				if (yacc_cb->yyreswd)
				{
				    yacc_cb->yyrestok = yacc_cb->yychar;  /* save reswd token */
				    yacc_cb->yyreswd = FALSE;	/* reset flag */
				    yacc_cb->yylval.psl_strtype =
					yacc_cb->yy_rwdstr;	/* retry as IDENT */
				    yacc_cb->yychar = NAME;		/* new token type */
				    goto yy_newstate;	/* try again */
				}
				/* Then, if we just tried it and still got error
				** resend original reserved word. */
				if (yacc_cb->yyrestok > 0)
				{
				    yacc_cb->yylval.psl_tytype = PSL_GOVAL;
				    yacc_cb->yychar = yacc_cb->yyrestok;
				    yacc_cb->yyrestok = 0;
				    goto yy_newstate;
				}
				(*yacc_cb->yyerror)(3, cb, psq_cb);
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yacc_cb->yypv;
				yy_ps = yacc_cb->yyps;
				yy_state = yacc_cb->yystate;
				yacc_cb->yynerrs++;
			skip_init:
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yacc_cb->yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
/*
** This comment supercedes the comment above.
** VERY IMPORTANT! Based on the assumption that there will be never more than
one statement to be parsed at a time, we have taken a different approach to
error reporting/recovery; we have concluded that:
- recovery is not needed
- for certain most common errors `error' productions have been defined in the
SQL grammar. This means that when a valid action cannot be taken, parser will
conceptually recognize seeing a special `error' token and will perform an action
specified. Reduction will follow, as if the rule was recognized. The `while'
loop below searches that state stack backwards for the first state which allows
handling of error token, this resulted in executing the `error' action for
unrelated errors and display of messages that were meaningless. We have,
therefore, decided to commnet out the `while' loop and let the code determine
whether error handling is allowed for current state only. This caused some extra
work with forming productions in such a way that `error' actions get executed
when needed, but that was not tough to do, and we have achieved the desired
result.
*/
/*
** Fix for 2 bugs:  09-jun-89 (neil)
** Both the following bugs occur if the scanner returns -1.  There are many
** cases to force this (ie, a names too long, invalid operators).
**	Bug 1: AV: If nothing has been reduced yet and yylex returned -1 then
**	       yy_ps was not yet correctly set to point at any "saved
**	       reduction stack".  The original "while" loop would never
**	       have let us into this code.  Therefore I modified the commented
**	       out "while" loop to a real "if" statement with the same
**	       condition to check.  AV's occurring to statements such as
**		    rollback aaaaaaaaaaaaaaaaaaaaaaa (> db_maxname chars)
**	       which returned -1 and had no saved "reduction" stack yet no
**	       longer occur as yy_ps is not yet pointing at a valid stack entry.
**	Bug 2: Hangs: Some error rules would loop forever when trying to recover
**	       to a YACC "error" rule in a list construct that occurred not
**	       because of a real syntax error (which had pushed a syntax
**	       state), such as:
**		    create table tx (i varchar(abcde))
**	       but because of a lex error in a list construct (-1 returned,
**	       and pushed nothing):
**		    create table tx (i integer, j varchar(^))
**	       These latter types of errors all cause -1 to be returned.
**	       The fix to this is to not even try the error recovery if the
**	       yychar is -1 as the scanner has already reported an error.
** Note both the above could be fixed by just checking yychar != -1, but
** the extra check to confirm a valid value for yy_ps is done just a safety
** check and will usually apply whenever yychar == -1.
*/
/*				while ( yy_ps >= yacc_cb->yys ) */
				if (   yacc_cb->yychar != -1
				    && yy_ps >= yacc_cb->yys )
				{
					yy_n = pslspact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
					    pslschk[pslsact[yy_n]] == YYERRCODE)
					{
						/*
						** simulate shift of "error"
						*/
						yy_state = pslsact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#ifdef	xDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
				/*	if ( yacc_cb->yydebug )
						YYPRINTF( _POP_, *yy_ps,
							yy_ps[-1] ); */
#	undef _POP_
#endif
				/*	yy_ps--;
					yy_pv--; */
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
#ifdef	xDEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yacc_cb->yydebug )
				{
					register i4  yy_i;

					YYPRINTF( "Error recovery discards " );
					if ( yacc_cb->yychar == 0 )
						YYPRINTF("token end-of-file\n");
					else if ( yacc_cb->yychar < 0 )
						YYPRINTF( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							pslstoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( pslstoks[yy_i].t_val
								== yacc_cb->yychar )
							{
								break;
							}
						}
						YYPRINTF( "token %s\n",
							pslstoks[yy_i].t_name );
					}
				}
#endif /* xDEBUG */
				if ( yacc_cb->yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yacc_cb->yychar = -2;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
#ifdef	xDEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yacc_cb->yydebug )
			YYPRINTF( "Reduce by (%d) \"%s\"\n",
				yy_n, pslsreds[ yy_n ] );
#endif
		yacc_cb->yytmp = yy_n;			/* value to switch over */
		yacc_cb->yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If pslsr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register i4  yy_len = pslsr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				/* $$ = $1 */
				yy_pv -= yy_len;
				STRUCT_ASSIGN_MACRO(yacc_cb->yypv[1], yacc_cb->yyval);
				yy_state = pslspgo[ yy_n = pslsr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					pslschk[ yy_state =
					pslsact[ yy_state ] ] != -yy_n )
				{
					yy_state = pslsact[ pslspgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			/* $$ = $1 */
			yy_pv -= yy_len;
			STRUCT_ASSIGN_MACRO(yy_pv[1], yacc_cb->yyval);
			yy_state = pslspgo[ yy_n = pslsr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				pslschk[ yy_state = pslsact[ yy_state ] ] != -yy_n )
			{
				yy_state = pslsact[ pslspgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yacc_cb->yystate = yy_state;
		yacc_cb->yyps = yy_ps;
		yacc_cb->yypv = yy_pv;
	}
#ifdef		YYFUNCTIONS
	if (pslsfunc[yacc_cb->yytmp] != (i4 (*)()) NULL)
#ifdef		YYREENTER
	    yacc_cb->yyerr_decl = (*pslsfunc[yacc_cb->yytmp])(yacc_cb, yacc_cb->yytmp,
		yystatusp, yyvarspp, cb,psq_cb);
#else
# ifdef rtp_us5
	{
	    /* AIX cc needs temp to avoid "compiler loop" fatal (daveb) */
	    i4  (*f)() = pslsfunc[yacc_cb->yytmp];
	    yacc_cb->yyerr_decl = (*f)(yacc.cb, yacc_cb->yytmp, yystatusp, yyvarspp, cb,psq_cb);
	}
# else	
	    yacc_cb->yyerr_decl = (*pslsfunc[yacc_cb->yytmp])(yacc_cb->yypvt, &yacc_cb->yyval,
		yacc_cb->yytmp, yystatusp, cb,psq_cb);
# endif
#endif		/* YYREENTER */
	else
	    yacc_cb->yyerr_decl = 0;

	if (yacc_cb->yyerr_decl == YYACCVAL)	/* TRUE iff YYACCEPT action was taken */
	    YYACCEPT;

	/* In case of RTI any other non-zero value indicates an error 
	** returned from a semantic routine, so no error recovery (in YACC
	** sense of the word) is needed, just report the error to caller.
	*/
	if (yacc_cb->yyerr_decl)		/* Production asked for */
	{
	     EXdelete();
	     return (yacc_cb->yyerr_decl);
	}
	/*    goto yyerrlab;		 * Error recovery */
#else
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yacc_cb->yytmp )
	{
		
	}
#endif
	goto yystack;		/* reset registers in driver code */
}


i4
psls1iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 130:
if (!((*yyvarspp)->bypass_actions))
/* # line 4346 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	YYABORT;
    } break;

case 131:
if (TRUE)	/* NOBYPASS */
/* # line 4352 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

#ifdef	xDEBUG
	psl_debug();
#endif

	status = psl_cs01s_create_schema(cb, psq_cb, yacc_cb->yypvt[-1].psl_strtype);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 132:
if (TRUE)	/* NOBYPASS */
/* # line 4364 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

#ifdef	xDEBUG
	psl_debug();
#endif

	status = psl_cs01s_create_schema(cb, psq_cb, yacc_cb->yypvt[-0].psl_strtype);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 133:
if (TRUE)	/* NOBYPASS */
/* # line 4378 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	i4		err_code;

#ifdef	xDEBUG
	psl_debug();
#endif

	psq_cb->psq_mode = PSQ_CREATE_SCHEMA;

	/* "create schema" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}

	status = psl_cs02s_create_schema_key(cb, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** Bypass remaining semantic actions, except those identified
	** by the %nobypass directive above.
	*/
	yyvarsp->bypass_actions = TRUE;
    } break;

case 134:
if (TRUE)	/* NOBYPASS */
/* # line 4411 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* test username for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 140:
if (!((*yyvarspp)->bypass_actions))
/* # line 4431 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;

	psq_cb->psq_mode = PSQ_ABSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Give QEF pointer to name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 141:
if (!((*yyvarspp)->bypass_actions))
/* # line 4456 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;
	char		       numbuf[25];

	psq_cb->psq_mode = PSQ_ABSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Give QEF pointer to name */
	CVla((i4) yacc_cb->yypvt[-0].psl_inttype, (PTR) numbuf);
	STmove(numbuf, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 142:
if (!((*yyvarspp)->bypass_actions))
/* # line 4483 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_ABORT;
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = (DB_SP_NAME *) NULL;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 143:
if (!((*yyvarspp)->bypass_actions))
/* # line 4499 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	/* Set mode for error recovery purpose only */
	psq_cb->psq_mode = PSQ_ABSAVE;

	/* Create the QEF control block for abort */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    } break;

case 144:
if (!((*yyvarspp)->bypass_actions))
/* # line 4530 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_BGNTRANS;

	/* Allocate QEF control block for begin transaction */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_modifier = QEF_MSTRAN;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_db_id = cb->pss_dbid;
	qef_rcb->qef_flag = 0;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 145:
if (!((*yyvarspp)->bypass_actions))
/* # line 4568 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status; 

	psq_cb->psq_mode = PSQ_COMMIT;
	/* Destroy all prepare statements, if any */
	if (cb->pss_defqry != PSQ_PREPARE)
	{
	    status = pst_commit_dsql(psq_cb, cb);
	    if (status != E_DB_OK)
		return (status);
	}
    } break;

case 146:
if (!((*yyvarspp)->bypass_actions))
/* # line 4581 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_XA_COMMIT;
	/*
	** Above we destroy all prepare statements. 
	** This can't be done for the XA commit until we find the
	** correct scb in scsqncr.c.
	** In any case the above call to pst_commit_dsql() seems to be
	** redundant. The same thing gets done again from the sequencer:
	**
	**  scs_sequencer(...) -> psq_call(PSQ_COMMIT...) -> pst_commit_dsql(..)
	*/
    } break;

case 147:
if (!((*yyvarspp)->bypass_actions))
/* # line 4596 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	/* Allocate the QEF control block for commit */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
							    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream,cb->pss_object,&psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    } break;

case 150:
if (!((*yyvarspp)->bypass_actions))
/* # line 4627 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
							    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream,cb->pss_object,&psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;

	psq_cb->psq_mode = PSQ_XA_PREPARE;
    } break;

case 151:
if (!((*yyvarspp)->bypass_actions))
/* # line 4652 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;

	/* Allocate the QEF control block for xaprepare */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
} break;

case 152:
if (!((*yyvarspp)->bypass_actions))
/* # line 4663 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DMU_CB *dmu_cb;
	QEU_CB *qeu_cb, *temp_cb, *end;
	DMU_CHAR_ENTRY  *char_entry;
	i4         char_count, ix, ixcount;
	DB_TAB_ID 	save_tab;
	i4		err_code;
	bool		c_idx, concurrent_idx = FALSE;

	qeu_cb = (QEU_CB *) cb->pss_save_qeucb;	/* get the first one */
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	save_tab = dmu_cb->dmu_tbl_id;

	char_entry = 
	      (DMU_CHAR_ENTRY *) ((char *) dmu_cb->dmu_char_array.data_address);
	char_count = dmu_cb->dmu_char_array.data_in_size/sizeof(DMU_CHAR_ENTRY);
	for (ix = 0; ix < char_count; ix++)
	{
	    switch (char_entry[ix].char_id)
	    {
		case DMU_CONCURRENT_ACCESS:
		    if (char_entry[ix].char_value == DMU_C_ON)
	  		concurrent_idx = TRUE;
		    break;
		default :
		    continue;
	    }
	}

	for (end = qeu_cb->qeu_prev, temp_cb = qeu_cb, ixcount = 1; ;
	     temp_cb = temp_cb->qef_next, ixcount++)
	{
	    dmu_cb = (DMU_CB *) temp_cb->qeu_d_cb;
	    if (save_tab.db_tab_base != dmu_cb->dmu_tbl_id.db_tab_base)
	    {
	        (VOID) psf_error(9349, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			(i4) sizeof("CREATE INDEX")-1, "CREATE INDEX");
		return(E_DB_ERROR);
	    }
	    char_entry = 
	      (DMU_CHAR_ENTRY *) ((char *) dmu_cb->dmu_char_array.data_address);
	    char_count = 
	      dmu_cb->dmu_char_array.data_in_size/sizeof(DMU_CHAR_ENTRY);
	    
	    c_idx = FALSE;
	    for (ix = 0; ix < char_count; ix++)
	    {
		switch (char_entry[ix].char_id)
		{
		    case DMU_CONCURRENT_ACCESS:
			if ((char_entry[ix].char_value == DMU_C_ON) &&
				 (!concurrent_idx))
			{
	        	    (VOID) psf_error(9351, 0L, PSF_USERERR,
					&err_code, &psq_cb->psq_error, 1,
					(i4) sizeof("CREATE INDEX")-1, 
					"CREATE INDEX");
			    return(E_DB_ERROR);
			}
			else if ((char_entry[ix].char_value == DMU_C_OFF) &&
				 (concurrent_idx))
			{
	        	    (VOID) psf_error(9351, 0L, PSF_USERERR,
					&err_code, &psq_cb->psq_error, 1,
					(i4) sizeof("CREATE INDEX")-1, 
					"CREATE INDEX");
			    return(E_DB_ERROR);
			}
	    		c_idx = TRUE;
		        break;
		    default:
			continue;
		}
	    } 
	    if ((concurrent_idx) && (!c_idx)) 
	    {
	        (VOID) psf_error(9351, 0L, PSF_USERERR, &err_code, 
				 &psq_cb->psq_error, 1,
				 (i4) sizeof("CREATE INDEX")-1, 
				 "CREATE INDEX");
		return(E_DB_ERROR);
	    }

	    if (temp_cb->qef_next == end)
		break;
	}
	if (ixcount > PSS_MAX_CONCURRENT_IDX)
	{
	    (VOID) psf_error(9352, 0L, PSF_USERERR, &err_code, 
				 &psq_cb->psq_error, 1,
				 (i4) sizeof("CREATE INDEX")-1, 
				 "CREATE INDEX");
	    return(E_DB_ERROR);
	}
    } break;

case 153:
if (!((*yyvarspp)->bypass_actions))
/* # line 4762 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{

    } break;

case 154:
if (!((*yyvarspp)->bypass_actions))
/* # line 4766 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{

    } break;

case 155:
if (!((*yyvarspp)->bypass_actions))
/* # line 4772 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{

    } break;

case 156:
if (!((*yyvarspp)->bypass_actions))
/* # line 4776 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{

    } break;

case 157:
if (!((*yyvarspp)->bypass_actions))
/* # line 4783 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		unique = FALSE;
	i4		err_code;

	/* cannot specify 2 unique options */
        if ((yyvarsp->unique) && (yacc_cb->yypvt[-1].psl_tytype == TRUE))
	{
	    (VOID) psf_error(9350, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			(i4) sizeof("CREATE INDEX")-1, "CREATE INDEX");
	    return(E_DB_ERROR);
	}

	/* 
	** if parallel style index is specified and old style unique is 
	** specified, consider all the indexes unique as long as the
	** syntax does not have in unique in individual create indexes.
	*/
	if (yyvarsp->unique)
	    unique = TRUE;
	else
	    unique = yacc_cb->yypvt[-1].psl_tytype;

	/* Now dmu_cb char_id must be fixed up for unique indexes */
	status = psl_ci1_create_index(cb, &yyvarsp->with_clauses, unique,
					&psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 158:
if (!((*yyvarspp)->bypass_actions))
/* # line 4816 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/*
	** set query mode here since psl_ci2_index_prefix() also gets called for
	** RMSGW's REGISTER INDEX
	*/
	psq_cb->psq_mode = PSQ_INDEX;
	cb->pss_object = (PTR) 0;
	cb->pss_save_qeucb = (PTR) 0;
	yyvarsp->unique = yacc_cb->yypvt[-1].psl_tytype;
        
	/*
	** next we will be parsing the name of the new index; we are trying to
	** produce a meaningful mesdsage if the user issues CREATE INDEX
	** SESSION.<name>
	*/
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    } break;

case 159:
if (!((*yyvarspp)->bypass_actions))
/* # line 4838 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = TRUE;
	/* Set unique-with here in case this is inside an index-def
	** (new style) rather than the old style unique prefix.
	*/
	PSS_WC_SET_MACRO(PSS_WC_UNIQUE, &yyvarsp->with_clauses);
    } break;

case 160:
if (!((*yyvarspp)->bypass_actions))
/* # line 4846 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = FALSE;
    } break;

case 161:
if (!((*yyvarspp)->bypass_actions))
/* # line 4852 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_ci2_index_prefix(cb, psq_cb, &yyvarsp->with_clauses, yyvarsp->unique);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ci5_indexlocname(cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_objspec, &yyvarsp->with_clauses, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* 
	** test indexname for reserved name
	*/
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* finished parsing the name of the new object */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    } break;

case 162:
if (!((*yyvarspp)->bypass_actions))
/* # line 4873 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_ci2_index_prefix(cb, psq_cb, &yyvarsp->with_clauses, yyvarsp->unique);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ci5_indexlocname(cb, (char *) NULL, yacc_cb->yypvt[-0].psl_objspec, &yyvarsp->with_clauses,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* test indexname for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* finished parsing the name of the new object */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    } break;

case 163:
if (!((*yyvarspp)->bypass_actions))
/* # line 4896 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_ci3_indexrel(cb, yacc_cb->yypvt[-0].psl_objspec, &psq_cb->psq_error, psq_cb->psq_mode);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 166:
if (!((*yyvarspp)->bypass_actions))
/* # line 4910 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_ci4_indexcol(cb, yacc_cb->yypvt[-1].psl_strtype, &psq_cb->psq_error, FALSE);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 167:
if (!((*yyvarspp)->bypass_actions))
/* # line 4920 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PSS_ASCENDING;
    } break;

case 168:
if (!((*yyvarspp)->bypass_actions))
/* # line 4924 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PSS_ASCENDING;
    } break;
	}
	return(0);
}

i4
psls2iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 169:
if (!((*yyvarspp)->bypass_actions))
/* # line 4928 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "desc"))
	{
	    psl_yerror(3, cb, psq_cb);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_tytype = PSS_DESCENDING;
    } break;

case 170:
if (!((*yyvarspp)->bypass_actions))
/* # line 4942 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_cp1_copy(cb, psq_cb, &yyvarsp->xlated_qry,
			yyvarsp->scanbuf_ptr, &yyvarsp->with_clauses, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 171:
if (!((*yyvarspp)->bypass_actions))
/* # line 4953 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	
	status = psl_cp2_copstmnt( cb, &psq_cb->psq_mode, &yyvarsp->with_clauses,
				   &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 174:
if (!((*yyvarspp)->bypass_actions))
/* # line 4968 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           	status;
	i4			rngvar_info;
	PSS_RNGTAB		*resrange;

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
			 &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
			 psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb,
		FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psl_cp3_copytable(cb, resrange, &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
		&yyvarsp->xlated_qry, psq_cb->psq_ldbdesc, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 175:
if (!((*yyvarspp)->bypass_actions))
/* # line 5007 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;

case 176:
if (!((*yyvarspp)->bypass_actions))
/* # line 5010 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           	status;

	status = psl_cp4_coparam(cb, &yyvarsp->xlated_qry, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 177:
if (!((*yyvarspp)->bypass_actions))
/* # line 5020 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           	status;

	status = psl_cp5_cospecs(cb, &yyvarsp->xlated_qry, yacc_cb->yypvt[-2].psl_strtype,
		yyvarsp->scanbuf_ptr, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 178:
if (!((*yyvarspp)->bypass_actions))
/* # line 5030 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           	status;

	status = psl_cp5_cospecs(cb, &yyvarsp->xlated_qry, yacc_cb->yypvt[-2].psl_strtype,
		yyvarsp->scanbuf_ptr, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 179:
if (!((*yyvarspp)->bypass_actions))
/* # line 5042 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_cp6_entname(cb, yacc_cb->yypvt[-0].psl_strtype, &psq_cb->psq_error, &yyvarsp->scanbuf_ptr);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_stmt_flags &= ~PSS_CP_DUMMY_COL;
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 181:
if (!((*yyvarspp)->bypass_actions))
/* # line 5057 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_cp7_fmtspec(cb, &psq_cb->psq_error, FALSE);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 182:
if (!((*yyvarspp)->bypass_actions))
/* # line 5066 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_cp7_fmtspec(cb, &psq_cb->psq_error, TRUE);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 183:
if (!((*yyvarspp)->bypass_actions))
/* # line 5077 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* no delimiter */
	yacc_cb->yyval.psl_strtype = (char *) NULL;
    } break;

case 184:
if (!((*yyvarspp)->bypass_actions))
/* # line 5082 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 185:
if (!((*yyvarspp)->bypass_actions))
/* # line 5086 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = "null";
    } break;

case 186:
if (!((*yyvarspp)->bypass_actions))
/* # line 5092 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/*
	** This is a column type, possibly with a delimiter, possibly quoted.
	**     - i4
	**     - c0tab
	**     - date
	**     - 'd0null'
	*/

	status = psl_cp8_coent(cb, psq_cb, (bool) TRUE, yacc_cb->yypvt[-0].psl_strtype, 0, (i4 *) NULL,
	    (char *) NULL);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 187:
if (!((*yyvarspp)->bypass_actions))
/* # line 5110 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	i4			len = (i4) yacc_cb->yypvt[-2].psl_inttype;

	/*
	** This is a column type, length and, possibly, a delimiter (which
	** may be quoted).
	**     - text(40)[[']nl[']]
	*/

	status = psl_cp8_coent(cb, psq_cb, (bool) FALSE, yacc_cb->yypvt[-4].psl_strtype, 1, &len, yacc_cb->yypvt[-0].psl_strtype);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 188:
if (!((*yyvarspp)->bypass_actions))
/* # line 5126 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	i4			len[2];

	/*
	** This is a column type, length and, possibly, a delimiter (which
	** may be quoted).
	**     - decimal(15,2)[[']nl[']]
	*/

	len[0] = yacc_cb->yypvt[-4].psl_inttype;
	len[1] = yacc_cb->yypvt[-2].psl_inttype;
	status = psl_cp8_coent(cb, psq_cb, (bool) FALSE, yacc_cb->yypvt[-6].psl_strtype, 2, len, yacc_cb->yypvt[-0].psl_strtype);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 189:
if (!((*yyvarspp)->bypass_actions))
/* # line 5146 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
		*yacc_cb->yypvt[-0].psl_i2type = -(*yacc_cb->yypvt[-0].psl_i2type);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_INT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(i2);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) yacc_cb->yypvt[-0].psl_i2type;
	}
    } break;

case 190:
if (!((*yyvarspp)->bypass_actions))
/* # line 5164 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
		*yacc_cb->yypvt[-0].psl_i4type = -(*yacc_cb->yypvt[-0].psl_i4type);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_INT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(i4);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) yacc_cb->yypvt[-0].psl_i4type;
	}
    } break;

case 191:
if (!((*yyvarspp)->bypass_actions))
/* # line 5182 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
		*yacc_cb->yypvt[-0].psl_i8type = -(*yacc_cb->yypvt[-0].psl_i8type);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_INT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(i8);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) yacc_cb->yypvt[-0].psl_i8type;
	}
    } break;

case 192:
if (!((*yyvarspp)->bypass_actions))
/* # line 5200 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;
	i2		prec_scale;
	i4		prec;
	i4		scale;
	u_char		tmp[DB_MAX_DECLEN];
	PTR		d;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    I2ASSIGN_MACRO(*yacc_cb->yypvt[-0].psl_dectype, prec_scale);
	    prec  = DB_P_DECODE_MACRO(prec_scale);
	    scale = DB_S_DECODE_MACRO(prec_scale);
	    d     = (PTR)(yacc_cb->yypvt[-0].psl_dectype + sizeof(i2));

	    if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
	    {
		MEcopy(d, DB_PREC_TO_LEN_MACRO(prec), (PTR)tmp);
		MHpkneg((PTR)tmp, prec, scale, d);
	    }
	
	    cpdom_desc->cp_nulldbv.db_datatype = DB_DEC_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = prec_scale;
	    cpdom_desc->cp_nulldbv.db_length = DB_PREC_TO_LEN_MACRO(prec);
	    cpdom_desc->cp_nulldbv.db_data = d;
	}
    } break;

case 193:
if (!((*yyvarspp)->bypass_actions))
/* # line 5232 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
		*yacc_cb->yypvt[-0].psl_f4type = -(*yacc_cb->yypvt[-0].psl_f4type);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_FLT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(f4);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) yacc_cb->yypvt[-0].psl_f4type;
	}
    } break;

case 194:
if (!((*yyvarspp)->bypass_actions))
/* # line 5250 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
		*yacc_cb->yypvt[-0].psl_f8type = -(*yacc_cb->yypvt[-0].psl_f8type);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_FLT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(f8);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) yacc_cb->yypvt[-0].psl_f8type;
	}
    } break;

case 195:
if (!((*yyvarspp)->bypass_actions))
/* # line 5268 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    cpdom_desc->cp_nulldbv.db_datatype = DB_VCH_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = 
				(i4)yacc_cb->yypvt[-0].psl_textype->db_t_count + DB_CNTSIZE;
	    cpdom_desc->cp_nulldbv.db_data = (PTR) yacc_cb->yypvt[-0].psl_textype;
	}
    } break;

case 196:
if (!((*yyvarspp)->bypass_actions))
/* # line 5285 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    cpdom_desc->cp_nulldbv.db_datatype = DB_VCH_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = 
				(i4)yacc_cb->yypvt[-0].psl_textype->db_t_count + DB_CNTSIZE;
	    cpdom_desc->cp_nulldbv.db_data = (PTR) yacc_cb->yypvt[-0].psl_textype;
	}
    } break;

case 197:
if (!((*yyvarspp)->bypass_actions))
/* # line 5304 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yacc_cb->yypvt[-0].psl_tytype == ADI_SUB_OP)
	    yacc_cb->yyval.psl_tytype = ADI_MINUS_OP;
	else
	    yacc_cb->yyval.psl_tytype = ADI_PLUS_OP;
    } break;

case 198:
if (!((*yyvarspp)->bypass_actions))
/* # line 5311 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = ADI_PLUS_OP;
    } break;

case 199:
if (!((*yyvarspp)->bypass_actions))
/* # line 5317 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB			*qef_rcb;
	DB_STATUS	status;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qef_rcb->qeu_copy->qeu_direction = CPY_INTO;
	}
	else
	{
	    status = psq_x_add(cb, "", &cb->pss_ostream,
				yyvarsp->xlated_qry.pss_buf_size,
				&yyvarsp->xlated_qry.pss_q_list,
				(i4) -1,	
				(char *)NULL, (char *)NULL, "into ", 
				&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    } break;

case 200:
if (!((*yyvarspp)->bypass_actions))
/* # line 5340 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB			*qef_rcb;
	DB_STATUS	status;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qef_rcb->qeu_copy->qeu_direction = CPY_FROM;
	}
	else
	{
	    status = psq_x_add(cb, "", &cb->pss_ostream,
				yyvarsp->xlated_qry.pss_buf_size,
				&yyvarsp->xlated_qry.pss_q_list,
				(i4) -1,	
				(char *)NULL, (char *)NULL, "from ", 
				&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    } break;

case 201:
if (!((*yyvarspp)->bypass_actions))
/* # line 5364 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	QEU_COPY	*qe_copy;
	DB_STATUS	status;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psq_x_add(cb, yacc_cb->yypvt[-0].psl_strtype, &cb->pss_ostream,
				yyvarsp->xlated_qry.pss_buf_size,
				&yyvarsp->xlated_qry.pss_q_list,
				(i4)STlength((char *)yacc_cb->yypvt[-0].psl_strtype),	
				"\'", "\'", (char *) NULL, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	    yyvarsp->scanbuf_ptr = (PTR) cb->pss_nxtchar;
	}
	else
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qe_copy = qef_rcb->qeu_copy;

	    /*
	    ** Copy the filename to the control block.
	    */
	    status = psf_malloc(cb, &cb->pss_ostream, STlength((char *) yacc_cb->yypvt[-0].psl_strtype) + 1,
		(PTR *) &qe_copy->qeu_fdesc->cp_filename, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    STcopy((char *) yacc_cb->yypvt[-0].psl_strtype, qe_copy->qeu_fdesc->cp_filename);
	}
    } break;
	}
	return(0);
}

i4
psls3iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 202:
if (!((*yyvarspp)->bypass_actions))
/* # line 5397 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		*qef_rcb;
	i4		err_code;


	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "program") != 0)
	{
	    (VOID) psf_error(5851L, 0L, PSF_USERERR, &err_code, 
		    &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qef_rcb->qeu_copy->qeu_stat |= CPY_PROGRAM;
	}
    } break;

case 204:
if (!((*yyvarspp)->bypass_actions))
/* # line 5419 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;

case 205:
if (!((*yyvarspp)->bypass_actions))
/* # line 5424 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;

case 206:
if (!((*yyvarspp)->bypass_actions))
/* # line 5428 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;

case 207:
if (!((*yyvarspp)->bypass_actions))
/* # line 5433 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

    	status = psl_cp9_nm_eq_nm(cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_strtype, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 208:
if (!((*yyvarspp)->bypass_actions))
/* # line 5442 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

    	status = psl_cp9_nm_eq_nm(cb, yacc_cb->yypvt[-2].psl_strtype, "continue", &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 209:
if (!((*yyvarspp)->bypass_actions))
/* # line 5451 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

    	status = psl_cp9_nm_eq_nm(cb, "rollback", yacc_cb->yypvt[-0].psl_strtype, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 210:
if (!((*yyvarspp)->bypass_actions))
/* # line 5460 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

    	status = psl_cp10_nm_eq_str(cb, yacc_cb->yypvt[-2].psl_strtype, sconvert(yacc_cb->yypvt[-0].psl_textype), &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 211:
if (!((*yyvarspp)->bypass_actions))
/* # line 5469 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

    	status = psl_cp11_nm_eq_no( cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_inttype, &yyvarsp->with_clauses, 
				    &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 212:
if (!((*yyvarspp)->bypass_actions))
/* # line 5479 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

    	status = psl_cp12_nm_eq_qdata(cb, psq_cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_dbval, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 213:
if (!((*yyvarspp)->bypass_actions))
/* # line 5488 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

    	status = psl_cp13_nm_single(cb, yacc_cb->yypvt[-0].psl_strtype, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 214:
if (!((*yyvarspp)->bypass_actions))
/* # line 5499 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_RT_NODE	root;
	PST_QNODE	*rootnode;
	PST_QTREE	*tree;
	PSY_CB		*psy_cb;
	i4		err_code;
	PST_PROCEDURE   *pnode;

	/* Make the ROOT node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&yyvarsp->from_list);
	root.pst_tvrc   = BTcount((char *) &yyvarsp->from_list, BITS_IN(yyvarsp->from_list));
	MEcopy((char *)&yyvarsp->from_list, sizeof(PST_J_MASK), 
					(char *)&root.pst_tvrm);
	/* the range var map is actually filled again in psydint.c */

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);

	/* make sure no tids in the integrity */
	if (psy_qscan(rootnode, cb->pss_resrng->pss_rgno, DB_IMTID))
	{
	    (VOID) psf_error(3496L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Make the query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, (yyvarsp->isdbp) ? 0 : PST_0FULL_HEADER,
	    &yyvarsp->xlated_qry);
	if (status != E_DB_OK)
	    return (status);

	/* Make sure there are no aggregates in qualification */
	if (tree->pst_agintree)
	{
	    (VOID) psf_error(3490L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}
	/* make sure there are no subselects in qualification */
	if (tree->pst_subintree)
	{
	    (VOID) psf_error(3497L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}
	
	/* Make sure the integrity has only one range variable */
	if (cb->pss_auxrng.pss_maxrng > 0)
	{
	    (VOID) psf_error(3491L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	/*
	** By definition, integrity can not possibly involve a join.  Since
	** pst_numjoins was set to PST_NOJOIN in pst_header(), we do not need to
	** do it here.
	*/

	/* Set the root in QSF */
	if (pnode != (PST_PROCEDURE *) NULL)
	{
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	/* Put the query text in a contiguous block in QSF */
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** We want to give the control block back to the caller.  However,
	** the control block has been allocated using the control block
	** stream, and it's the output stream that gets handed back to the
	** caller.  Therefore, we must swap the control block and output
	** streams.
	*/
	/* Copy the query tree stream so we can re-use it */
	STRUCT_ASSIGN_MACRO(cb->pss_ostream, cb->pss_cbstream);

	/* Create the PSY_CB for the integrity definition */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return(status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Fill in QSF object ids for query tree and modified query text */
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	STRUCT_ASSIGN_MACRO(cb->pss_cbstream.psf_mstream, psy_cb->psy_intree);

	/* Fill in table id and table name */
	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-2].psl_rngtype->pss_tabid, psy_cb->psy_tables[0]);
	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-2].psl_rngtype->pss_tabname, psy_cb->psy_tabname[0]);
    } break;

case 215:
if (!((*yyvarspp)->bypass_actions))
/* # line 5620 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PTR		       piece;

	psq_cb->psq_mode = PSQ_INTEG;

	/* "create integrity" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(3495L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Open the memory stream for allocating the query tree */
	if (yyvarsp->isdbp == FALSE)
	{
	    status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	/*
	** The "create integrity" statement requires query text to be stored in
	** the iiqrytext relation.  Open a text chain and put the initial
	** words "create integrity " in it.  The text chain will be coalesced
	** into a contiguous block later.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	status = psq_tadd(cb->pss_tchain, (u_char *) "create integrity ",
	    sizeof("create integrity ") - 1, &piece, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* The FROM clause is not present, therefore
	** the bitmap needs to be initialized.
	*/
	MEfill(sizeof(PST_J_MASK), 0, (char *)&yyvarsp->flists[cb->pss_qualdepth]);

	/*
	** If the name of the object on which the integrity is being created is
	** that of a synonym, we will replace it with the name of the actual
	** table.
	*/
	yyvarsp->qry_mask |= PSS_REPL_SYN_WITH_ACTUAL;
    } break;

case 216:
if (!((*yyvarspp)->bypass_actions))
/* # line 5675 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4     err_code;
	i4	    mask;
	i4     mask2;
	i4	    err_no = 0L;

	/*
	** On an integrity definition, remember what the result range variable
	** is.  This can't be stored in the result range variable slot in
	** the user range table, because that is not for "real" range variables,
	** only for result tables (as in an append).
	*/
	cb->pss_resrng = yacc_cb->yypvt[-0].psl_rngtype;

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/*
	** Check for integrities on views.
	*/
	if (mask & DMT_VIEW)
	{
	    err_no = 3493L;
	}
	else if (mask & DMT_IDX)
	{
	    err_no = 9348;
	}
	else if ((mask & DMT_CATALOG) || (mask2 & DMT_TEXTENSION))
	{
	    /* If not an extended catalog and no catalog update
	    ** permission - error.
	    */
	    if (~mask & DMT_EXTENDED_CAT
		&& !(cb->pss_ses_flag & PSS_CATUPD) )
	    {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS	local_status;
		    DB_ERROR	e_error;
		    /*
		    ** Audit failure to create integrity
		    */
		    local_status = psy_secaudit( FALSE, cb, 
			    cb->pss_resrng->pss_tabname.db_tab_name, 
			    &cb->pss_resrng->pss_ownname,
			    sizeof(cb->pss_resrng->pss_tabname),
			    SXF_E_TABLE, I_SX203D_INTEGRITY_CREATE,
			    SXF_A_FAIL | SXF_A_CONTROL, 
			    &e_error);
		}
		/*
		** let user know if name supplied by the him was resolved to a
		** synonym
		*/
		if (yyvarsp->rngvar_info & PSS_BY_SYNONYM)
		{
		    psl_syn_info_msg(cb, cb->pss_resrng, &yyvarsp->obj_spec,
			yyvarsp->rngvar_info, sizeof("CREATE INTEGRITY")-1,
			"CREATE INTEGRITY", &psq_cb->psq_error);
		}				      

		(VOID) psf_error(3498L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2, 
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return (E_DB_ERROR);
	    }
	}
	/* Check for integrity on table owned by someone else. */
	else if (MEcmp((PTR) &cb->pss_user, 
	               (PTR) &cb->pss_resrng->pss_tabdesc->tbl_owner,
		       sizeof(DB_OWN_NAME)))
	{
	    err_no = 3494L;
	}

	if (err_no != 0L)
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;
		/*
		** Audit failure to create integrity
		*/
		local_status = psy_secaudit( FALSE, cb, 
		    cb->pss_resrng->pss_tabname.db_tab_name, 
		    &cb->pss_resrng->pss_ownname,
		    sizeof(cb->pss_resrng->pss_tabname),
		    SXF_E_TABLE, I_SX203D_INTEGRITY_CREATE,
		    SXF_A_FAIL | SXF_A_CONTROL, 
		    &e_error);
	    }
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (yyvarsp->rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, cb->pss_resrng, &yyvarsp->obj_spec, yyvarsp->rngvar_info,
		    sizeof("CREATE INTEGRITY")-1, "CREATE INTEGRITY",
		    &psq_cb->psq_error);
	    }				      

	    (VOID) psf_error(err_no, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_rngtype = yacc_cb->yypvt[-0].psl_rngtype;
    } break;

case 217:
if (!((*yyvarspp)->bypass_actions))
/* # line 5795 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PSF_MSTREAM	tempstream;
	PST_QNODE	*rootnode;
	PST_RT_NODE	root;
	PSY_CB		*psy_cb;
	PST_QTREE	*tree;
	i4		err_code;

	/* Restore mode in case subselect in where clause changed it */
	psq_cb->psq_mode = PSQ_PROT;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* mark if we have a qualification */
	if ((yacc_cb->yypvt[-0].psl_trtype)->pst_sym.pst_type != PST_QLEND)
	{
	    PST_PROCEDURE   *pnode;

	    psy_cb->psy_istree = TRUE;

	    /* Make the ROOT node */
	    root.pst_rtuser = TRUE;
	    root.pst_union.pst_next  = 0;
	    root.pst_dups   = PST_ALLDUPS;
	    MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&yyvarsp->from_list);
	    root.pst_tvrc   = BTcount((char *) &yyvarsp->from_list,
		BITS_IN(yyvarsp->from_list));
	    MEcopy((char *)&yyvarsp->from_list, sizeof(PST_J_MASK), 
					(char *)&root.pst_tvrm);
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, yacc_cb->yypvt[-0].psl_trtype, 
		PST_ROOT, (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error,
		(i4) 0);
	    if (status != E_DB_OK)
		return (status);

	    /* Make the query tree header */
	    status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
		rootnode, &tree, &pnode, (yyvarsp->isdbp) ? 0 : PST_0FULL_HEADER,
		&yyvarsp->xlated_qry);
	    if (status != E_DB_OK)
		return (status);

	    /* set pst_numjoins.  $Yjoin_id contains the highest join id */
	    tree->pst_numjoins = yyvarsp->join_id;


	    /* Set the root in QSF */
	    if (pnode != (PST_PROCEDURE *) NULL)
	    {
		status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode,
		    &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);
	    }

	    /*
	    ** Copy the object ids for the query tree and query text to the
	    ** control block.
	    */
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream.psf_mstream,
				psy_cb->psy_intree);

	    /*
	    ** Issue a warning  here; this permit is not GRANT compatible
	    ** it contains a qualification.
	    */
	    (VOID) psf_error(2331L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME),
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	}
	else
	{
	    /* There is no QTREE, so close QTREE stream */
	    status = psf_mclose(cb, &cb->pss_ostream, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    cb->pss_ostream.psf_mstream.qso_handle = (PTR) NULL;
	}


	/*
	** We want to give the control block back to the caller.  However,
	** the control block has been allocated using the control block
	** stream, and it's the output stream that gets handed back to the
	** caller.  Therefore, we must swap the control block and output
	** streams.
	*/
	if (psy_cb->psy_istree)
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream, tempstream);
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    STRUCT_ASSIGN_MACRO(tempstream, cb->pss_cbstream);
	}
	else
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    cb->pss_cbstream.psf_mstream.qso_handle = (PTR) NULL;
	}
	/* Put the query text in a contiguous block in QSF */
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
    } break;

case 218:
if (!((*yyvarspp)->bypass_actions))
/* # line 5909 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PTR		piece;
	DB_STATUS	status;
	char		*str;

	/*
	** The "create permit" statement requires query text to be stored in
	** the iiqrytext relation.  Open a text chain and store the initial
	** string.  Note the initial string includes a placeholder for a
	** privilege name (one of SELECT, INSERT, DELETE, UPDATE) if more than
	** one privilege has been specified; otherwise that actual privilege
	** name will be inserted.
	** The text chain will be coalesced into a contiguous block later.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** initial string has to be different depending on how the privileges
	** were specified;  if ALL was specified, ON has not been seen by the
	** scanner yet, on the other hand, if a privilege list was specified,
	** scanner has already seen ON, so we must include ON in the initial
	** string
	*/
	if (yacc_cb->yypvt[-0].psl_tytype == 1)	    /* CREATE PERMIT ALL */
	{
	    str = "create permit ??????";
	}
	else		    /* CREATE PERMIT <privileges> */
	{
	    PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	    /*
	    ** if only one privilege was specified, we will insert it into the
	    ** template now; otherwise, we will store the placeholder
	    */

	    if (BTcount((char *) &psy_cb->psy_opmap, BITS_IN(psy_cb->psy_opmap))
		    > 1)
	    {
		str = "create permit ?????? on";
	    }
	    else if (psy_cb->psy_opmap == DB_RETRIEVE)
	    {
		str = "create permit select on";
	    }
	    else if (psy_cb->psy_opmap == DB_REPLACE)
	    {
		str = "create permit update on";
	    }
	    else if (psy_cb->psy_opmap == DB_DELETE)
	    {
		str = "create permit delete on";
	    }
	    else
	    {
		str = "create permit insert on";
	    }
	}

	status = psq_tadd(cb->pss_tchain, (u_char *) str, STlength(str), &piece,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

    } break;

case 219:
if (!((*yyvarspp)->bypass_actions))
/* # line 5980 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	*psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** If a list of columns to which privilege(s) will or will not (using
	** EXCLUDING clause) apply and priivleges other than UPDATE have been
	** specified, this permit is not GRANT-compatible (only column-specific
	** UPDATE is currently allowed with GRANT statement), so issue a warning
	** 
	** pretty soon it will allow column-specific INSERT as well, so we will
	** have to remember to change this test
	*/
	if (psy_cb->psy_numcols && psy_cb->psy_opmap & ~DB_REPLACE)
	{
	    i4	err_code;

	    (VOID) psf_error(2331L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	}

	/*
	** We want to replace all references to synonyms in the where-clause of
	** the permit definition with the actual table names + all table names
	** in the from list(s) must be prefixed with their owner name.
	*/
	yyvarsp->qry_mask |= (PSS_REPL_SYN_WITH_ACTUAL | PSS_PREFIX_WITH_OWNER);
    } break;

case 220:
if (!((*yyvarspp)->bypass_actions))
/* # line 6014 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_PROT;

	/* "create permit" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(3596L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Open the memory stream for allocating the query tree */
	if (yyvarsp->isdbp == FALSE)
	{
	    status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	/* Allocate the PSY_CB for the create permit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_cbstream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_grant = PSY_CPERM;	    /* indicate not GRANT stmnt */

	/* Default terminal name is "" */
	MEfill(sizeof(psy_cb->psy_terminal), ' ', (PTR) &psy_cb->psy_terminal);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/*
	** Default time is all day, starting at 00:00 and ending at 24:00,
	** given as minutes after 00:00.
	*/
	psy_cb->psy_timbgn = 0;
	psy_cb->psy_timend = 1440;

	/*
	** Default days are all week, starting with Sunday and ending with
	** Saturday.  Sunday = 0, Saturday = 6.
	*/
	psy_cb->psy_daybgn = 0;
	psy_cb->psy_dayend = 6;

	/* The FROM clause is not present, therefore
	** the bitmap needs to be initialized.
	*/
	MEfill(sizeof(PST_J_MASK), 0, (char *)&yyvarsp->flists[cb->pss_qualdepth]);

	/*
	** If the name of the object for which the permit is being created is
	** that of a synonym, we will replace it with the name of the actual
	** table.
	*/
	yyvarsp->qry_mask |= PSS_REPL_SYN_WITH_ACTUAL;
    } break;

case 221:
if (!((*yyvarspp)->bypass_actions))
/* # line 6082 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 222:
if (!((*yyvarspp)->bypass_actions))
/* # line 6086 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB                 *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_opmap = psy_cb->psy_opctl =
	    DB_RETRIEVE | DB_APPEND | DB_REPLACE | DB_DELETE;

	yacc_cb->yyval.psl_tytype = 1;
    } break;

case 223:
if (!((*yyvarspp)->bypass_actions))
/* # line 6098 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= yacc_cb->yypvt[-0].psl_u_inttype;
	psy_cb->psy_opctl |= yacc_cb->yypvt[-0].psl_u_inttype;
    } break;

case 224:
if (!((*yyvarspp)->bypass_actions))
/* # line 6105 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= yacc_cb->yypvt[-0].psl_u_inttype;
	psy_cb->psy_opctl |= yacc_cb->yypvt[-0].psl_u_inttype;
    } break;

case 225:
if (!((*yyvarspp)->bypass_actions))
/* # line 6114 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_u_inttype = DB_RETRIEVE;
    } break;

case 226:
if (!((*yyvarspp)->bypass_actions))
/* # line 6118 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_u_inttype = DB_DELETE;
    } break;

case 227:
if (!((*yyvarspp)->bypass_actions))
/* # line 6122 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_u_inttype = DB_APPEND;
    } break;

case 228:
if (!((*yyvarspp)->bypass_actions))
/* # line 6126 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_u_inttype = DB_REPLACE;
    } break;

case 232:
if (!((*yyvarspp)->bypass_actions))
/* # line 6137 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb;
	i4		mask = yacc_cb->yypvt[-0].psl_rngtype->pss_tabdesc->tbl_status_mask;
	DB_STATUS	status;
	PSY_TBL		*psy_tbl;

	cb->pss_resrng = yacc_cb->yypvt[-0].psl_rngtype;

	/*
	** For the time being CREATE PERMIT can be used to create permits on
	** 1) objects owned by the current user,
	** 2) catalogs if the current user has CATUPD and
	** 3) extended catalogs if the current user is DBA;
	** the last two conditions will be eventually phased out, until then we
	** will not try to call psy_tbl_grant_check() (in psy_dperm()) to check
	** if the user can actually CREATE a permit on an object not owned by
	** him
	*/

	/*
	** One no longer has to be a DBA or $INGRES in order to
	** CREATE permission on tables other than catalogues.
	** psy_permit_ok() will be used to determine if permit may
	** be CREATEd
	*/

	if (!psy_permit_ok(mask, cb, &yacc_cb->yypvt[-0].psl_rngtype->pss_ownname))
	{
	    i4	err_code;

	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;

		/* Must audit CREATE PERMIT failure. */
		
		local_status = psy_secaudit(FALSE, cb,
			    (char *)&yacc_cb->yypvt[-0].psl_rngtype->pss_tabdesc->tbl_name,
			    &yacc_cb->yypvt[-0].psl_rngtype->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX2016_PROT_TAB_CREATE, SXF_A_FAIL | SXF_A_MOD_DAC,
			    &e_error);
	    }

	    /*
	    ** let user know if name supplied by the him was resolved to a
	    ** synonym
	    */
	    if (yyvarsp->rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, cb->pss_resrng, &yyvarsp->obj_spec,
		    yyvarsp->rngvar_info, sizeof("CREATE PERMIT")-1,
		    "CREATE PERMIT", &psq_cb->psq_error);
	    }				      

	    (VOID) psf_error(3592L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &yacc_cb->yypvt[-0].psl_rngtype->pss_tabname),
		&yacc_cb->yypvt[-0].psl_rngtype->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Copy table id and table name to control block */
	psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** Allocate memory for a table entry - use the same stream from which
	** PSY_CB was allocated - pss_cbstream
	*/
	status = psf_malloc(cb, &cb->pss_cbstream, (i4) sizeof(PSY_TBL),
	    (PTR *) &psy_tbl, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy table id, table name, and owner name in table entry.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid, psy_tbl->psy_tabid);
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabname, psy_tbl->psy_tabnm);
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_ownname, psy_tbl->psy_owner);
	
	/* remember the object type */
	if (mask & DMT_VIEW)
	{
	    psy_tbl->psy_mask = PSY_OBJ_IS_VIEW;
	}
	else if (mask & DMT_IDX)
	{
	    psy_tbl->psy_mask = PSY_OBJ_IS_INDEX;
	}
	else
	{
	    psy_tbl->psy_mask = PSY_OBJ_IS_TABLE;
	}

	/*
	** Attach element to the list.
	*/
	(VOID) QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);

	yacc_cb->yyval.psl_rngtype = yacc_cb->yypvt[-0].psl_rngtype;
    } break;

case 234:
if (!((*yyvarspp)->bypass_actions))
/* # line 6246 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB  *psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_flags |= PSY_EXCLUDE_COLUMNS;
    } break;

case 238:
if (!((*yyvarspp)->bypass_actions))
/* # line 6259 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DMT_ATT_ENTRY	       *attribute;
	DB_ATT_NAME	       attname;
	i4		       err_code;
	PSY_CB		       *psy_cb;

	/* Look up the attribute number */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_ATT_NAME), (char *) &attname);
	attribute = pst_coldesc(cb->pss_resrng, &attname);

	/* Check for attribute not found */
	if (attribute == (DMT_ATT_ENTRY *) NULL)
	{
	    psf_error(2100L, 0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 4,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &cb->pss_resrng->pss_ownname),
		&cb->pss_resrng->pss_ownname,
		STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Copy the attribute number to the control block */
	psy_cb = (PSY_CB *) cb->pss_object;
	if (psy_cb->psy_numcols >= DB_MAX_COLS)
	{
	    (VOID) psf_error(2113L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof (cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_cols[psy_cb->psy_numcols++].db_att_id =
	    (i2) attribute->att_number;
    } break;

case 239:
if (!((*yyvarspp)->bypass_actions))
/* # line 6299 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/* {@fix_me@} */	/* Check validity of user name? */

	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_OWN_NAME), (char *) &psy_cb->psy_user);

	/* granted to a user */
	psy_cb->psy_gtype = DBGR_USER;
    } break;
	}
	return(0);
}

i4
psls4iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 240:
if (!((*yyvarspp)->bypass_actions))
/* # line 6310 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/* granted to public */
	psy_cb->psy_gtype = DBGR_PUBLIC;

	/* psy_cb->psy_user has already been blank-filled */
    } break;

case 241:
if (!((*yyvarspp)->bypass_actions))
/* # line 6321 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB                 *psy_cb = (PSY_CB *) cb->pss_object;

#ifdef NOT_NEEDED
	/* Check validity of terminal name */
	if (!TEvalid(yacc_cb->yypvt[-0].psl_strtype))
	{
	    i4		err_code;

	    (VOID) psf_error(3590L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
#endif
	/* Copy terminal name to control block */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_TERM_NAME), (char *) &psy_cb->psy_terminal);
    } break;

case 248:
if (!((*yyvarspp)->bypass_actions))
/* # line 6352 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB                 *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_timbgn = yacc_cb->yypvt[-2].psl_inttype;
	psy_cb->psy_timend = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 249:
if (!((*yyvarspp)->bypass_actions))
/* # line 6362 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	/* Check validity of hours */
	if (yacc_cb->yypvt[-2].psl_inttype > 24 || yacc_cb->yypvt[-2].psl_inttype < 0)
	{
	    (VOID) psf_error(2136L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof(yacc_cb->yypvt[-2].psl_inttype), &(yacc_cb->yypvt[-2].psl_inttype));
	    return (E_DB_ERROR);
	}

	/* Check validity of minutes */
	if (yacc_cb->yypvt[-0].psl_inttype > 59 || yacc_cb->yypvt[-0].psl_inttype < 0)
	{
	    (VOID) psf_error(2137L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof(yacc_cb->yypvt[-0].psl_inttype), &(yacc_cb->yypvt[-0].psl_inttype));
	    return (E_DB_ERROR);
	}

	/* If hours are 24, make sure minutes are 0 (e.g. 24:10 illegal) */
	if (yacc_cb->yypvt[-2].psl_inttype == 24 && yacc_cb->yypvt[-0].psl_inttype != 0)
	{
	    (VOID) psf_error(2138L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof(yacc_cb->yypvt[-0].psl_inttype), &(yacc_cb->yypvt[-0].psl_inttype));
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_inttype = (yacc_cb->yypvt[-2].psl_inttype * 60) + yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 250:
if (!((*yyvarspp)->bypass_actions))
/* # line 6397 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB                 *psy_cb;
	i4		       err_code;
	i4		       daynum;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Convert beginning day of week string to number */
	daynum = psq_cvtdow(yacc_cb->yypvt[-2].psl_strtype);
	if (daynum < 0)
	{
	    (VOID) psf_error(3594L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname,
		STtrmwhite(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
	    return (E_DB_ERROR);
	}
	psy_cb->psy_daybgn = daynum;

	/* Convert ending day of week string to number */
	daynum = psq_cvtdow(yacc_cb->yypvt[-0].psl_strtype);
	if (daynum < 0)
	{
	    (VOID) psf_error(3594L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname,
		STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
	psy_cb->psy_dayend = daynum;
    } break;

case 251:
if (!((*yyvarspp)->bypass_actions))
/* # line 6445 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4         err_code;
	DB_STATUS	status;
	PSY_CB		*psy_cb;
	PTR		piece;
	i4		name_len;
	u_char		*name;
	u_char		delim_id[DB_MAX_DELIMID];

        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(6350L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1,
                (i4) sizeof("CREATE DBEVENT")-1, "CREATE DBEVENT");
            return (E_DB_ERROR);    /* non-zero return means error */
        }

	/* test event name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (VOID) psf_error(E_PS0421_CRTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("CREATE DBEVENT") - 1, "CREATE DBEVENT",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Allocate the PSY_CB for the CREATE DBEVENT statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* The "create dbevent" statement requires query text to be saved */
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
			   &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	name = (u_char *) ERx("create dbevent ");
	status = psq_tadd(cb->pss_tchain,  name, STlength((char *) name), 
			  &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* add the event name to the text
	 */
	name     = (u_char *) yacc_cb->yypvt[-0].psl_objspec->pss_obj_name.db_tab_name;
	name_len = psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-0].psl_objspec->pss_obj_name.db_tab_name);

	if (yyvarsp->id_type != PSS_ID_REG)
	{
	    /* delimit the name
	     */
	    status = psl_norm_id_2_delim_id(&name, &name_len, 
					    delim_id, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}	    
	status = psq_tadd(cb->pss_tchain,  (u_char *) name, name_len, 
			  &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psq_tout(cb, (PSS_USRRANGE *)NULL, cb->pss_tchain, 
			  &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Copy query text object into control block */
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);

	/* Set control block and tuple fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   		
	MEfill(sizeof(psy_cb->psy_tuple.psy_event), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_event);
	STmove(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_event.dbe_name);
	psy_cb->psy_tuple.psy_event.dbe_type = DBE_T_ALERT;
    } break;

case 252:
if (!((*yyvarspp)->bypass_actions))
/* # line 6534 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_EVENT;
    } break;

case 253:
if (!((*yyvarspp)->bypass_actions))
/* # line 6549 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(6350L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1,
                (i4) sizeof("DROP DBEVENT")-1, "DROP DBEVENT");
            return (E_DB_ERROR);    /* non-zero return means error */
        }

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		/*
		** Audit failure to drop dbevent
		*/
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
		    (DB_OWN_NAME *)&yacc_cb->yypvt[-0].psl_objspec->pss_owner, sizeof(yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
		    SXF_E_EVENT, I_SX203C_EVENT_DROP,
		    SXF_A_FAIL | SXF_A_DROP, 
		    &e_error);
	    }

	    (VOID) psf_error(E_PS0420_DROPOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("DROP DBEVENT") - 1, "DROP DBEVENT",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Allocate the PSY_CB for the DROP DBEVENT statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Initialize dbevent tuple */
	MEfill(sizeof(psy_cb->psy_tuple.psy_event), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_event);
	STmove(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_event.dbe_name);
	psy_cb->psy_tuple.psy_event.dbe_type = DBE_T_ALERT;
    } break;

case 254:
if (!((*yyvarspp)->bypass_actions))
/* # line 6605 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_EVDROP;
    } break;

case 255:
if (!((*yyvarspp)->bypass_actions))
/* # line 6611 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	{
	    i4	val1, val2;
	    /*
	    ** in 6.5 we are not officially supporting DROP SCHEMA; in order to
	    ** execute this statement, one must have set trace point ps150
	    */

	    if (!ult_check_macro(&cb->pss_trace, PSS_ENABLE_DROP_SCHEMA,
		    &val1, &val2))
	    {
		psl_yerror(3, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	}
	
	psq_cb->psq_mode = PSQ_DROP_SCHEMA;

	/* "DROP SCHEMA" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;
	    
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP SCHEMA")-1, (PTR) "DROP SCHEMA");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 256:
if (!((*yyvarspp)->bypass_actions))
/* # line 6641 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_SCHEMA_NAME	    schema_name;
	DB_STATUS	    status;
	i4		    err_code;
	i4		    name_len = STlength(yacc_cb->yypvt[-1].psl_strtype);
	PSY_CB		    *psy_cb;
	DB_IISCHEMA	    *schema_tuple;
	
	/*
	** in 6.5 a user can have at most one schema; its name must be the same
	** as the user name; just for the sake of argument, let's say that no
	** one may drop $ingres
	*/

	MEmove(name_len, (PTR) yacc_cb->yypvt[-1].psl_strtype, ' ', sizeof(schema_name),
	    (PTR) schema_name.db_schema_name);

	if (!MEcmp((PTR) &schema_name, (PTR) cb->pss_cat_owner,
		sizeof(schema_name)))
	{
	    /* can't drop schema "$ingres" owned by $ingres */
	    (void) psf_error(E_PS0572_CANT_DROP_SYSCAT_SCHEMA, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	if (MEcmp((PTR) &schema_name, (PTR) &cb->pss_user, DB_MAXNAME))
	{
	    /* can't drop a schema owned by a different user */
	    (void) psf_error(E_PS0573_CANT_DROP_OTHERS_SCHEMA, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		name_len, (PTR) yacc_cb->yypvt[-1].psl_strtype, name_len, (PTR) yacc_cb->yypvt[-1].psl_strtype);
	    return(E_DB_ERROR);
	}

	/* Allocate the PSY_CB for the DROP SCHEMA statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;
	schema_tuple = &psy_cb->psy_tuple.psy_schema;
	
	/* store schema name and schema owner name into PSY_CB */
	STRUCT_ASSIGN_MACRO(cb->pss_user, schema_tuple->db_schowner);
	STRUCT_ASSIGN_MACRO(schema_name, schema_tuple->db_schname);

	if (yacc_cb->yypvt[-0].psl_tytype == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    } break;

case 257:
if (!((*yyvarspp)->bypass_actions))
/* # line 6722 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PSF_MSTREAM	tempstream;
	PST_QNODE	*rootnode;
	PST_RT_NODE	root;
	PST_PROCEDURE   *pnode;
	PSY_CB		*psy_cb;
	PST_QTREE	*tree;
	i4                err_code;

	psq_cb->psq_mode = PSQ_RULE;		/* Restore mode - safety */
	yyvarsp->in_rule = 0;

	psy_cb = (PSY_CB *)cb->pss_object;

	if ((psy_cb->psy_tuple.psy_rule.dbr_flags & DBR_F_BEFORE) && 
		cb->pss_dbp_flags & PSS_DATA_CHANGE)
	{
	    /* Can't have a BEFORE rule triggering a procedure with 
	    ** a data change statement (INSERT, UPDATE, DELETE). */
	    _VOID_ psf_error(E_US18B5_6325_NODCBEFORE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Check if we need a tree - parameter list and/or qualification */
	if (yacc_cb->yypvt[-1].psl_trtype != NULL || yacc_cb->yypvt[-0].psl_trtype != NULL)
	{
	    psy_cb->psy_istree = TRUE;

	    /* Make the ROOT node */
	    root.pst_rtuser          = TRUE;
	    root.pst_union.pst_next  = NULL;
	    root.pst_dups  	     = PST_ALLDUPS;
	    root.pst_tvrc   	     = 0;
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);
	    /*	Left = params, right = qualification */
	    status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_trtype, yacc_cb->yypvt[-1].psl_trtype,
		PST_ROOT, (PTR)&root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0,
		(i4)0, (DB_ANYTYPE *)NULL, &rootnode, &psq_cb->psq_error,
		(i4) 0);
	    if (status != E_DB_OK)
		return (status);

	    /*
	    ** if a rule is being created on a view, we will replace references
	    ** to the view's attributes in the qualification and/or parameter
	    ** tree with references to the attributes of the view's underlying
	    ** base table.  To do this we will use a copy of a view tree which
	    ** was pumped through qrymod in crl_tbl_name production.
	    */
	    if (cb->pss_resrng->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	    {
		status = psl_vrule_tree_convert(rootnode, yyvarsp->rule_view_tree,
		    cb, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	    
	    /* Make the query tree header */
	    status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
		rootnode, &tree, &pnode, (yyvarsp->isdbp) ? 0 : PST_0FULL_HEADER,
		&yyvarsp->xlated_qry);
	    if (status != E_DB_OK)
		return (status);

	    /* set pst_numjoins.  $Yjoin_id contains the highest join id */
	    tree->pst_numjoins = yyvarsp->join_id;

	    /* Set the root in QSF */
	    if (pnode != NULL)
	    {
		status = psf_mroot(cb, &cb->pss_ostream, (PTR)pnode,
				   &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);
	    }

	    /* Save QSF object id for the query tree */
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream.psf_mstream,psy_cb->psy_intree);
	}
	else
	{
	    /* There is no tree, so close tree stream */
	    status = psf_mclose(cb, &cb->pss_ostream, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    cb->pss_ostream.psf_mstream.qso_handle = NULL;
	} /* If tree or not */


	/*
	** We want to give the control block back to the caller.  However,
	** the control block has been allocated using the control block
	** stream, and it's the output stream that gets handed back to the
	** caller.  Therefore, we must swap the control block and output
	** streams.
	*/
	if (psy_cb->psy_istree)
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream, tempstream);
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    STRUCT_ASSIGN_MACRO(tempstream, cb->pss_cbstream);
	}
	else
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    cb->pss_cbstream.psf_mstream.qso_handle = NULL;
	}

	/* Put the query text in a contiguous block in QSF and save id */
	status = psq_tout(cb, (PSS_USRRANGE *)NULL, cb->pss_tchain,
			  &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
    } break;

case 258:
if (!((*yyvarspp)->bypass_actions))
/* # line 6841 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	PTR		       piece;

	psq_cb->psq_mode = PSQ_RULE;

	/* "create rule" is not allowed in Star */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    _VOID_ psf_error(E_US18A0_6304_RULE_STAR, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Open object stream for allocating the tree (may be needed) */
	status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** The "create rule" statement requires query text to be saved.
	** Open a text chain and put the initial words "create rule " in it.
	** The text chain will be built later.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
			   &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psq_tadd(cb->pss_tchain, (u_char *)"create rule ",
	    		  sizeof("create rule ")-1, &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Allocate the PSY_CB for the CREATE RULE statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_cbstream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   			/* Assume no tree yet */
	psy_cb->psy_tabname[0].db_tab_name[0] = EOS;	/* Table name */
	(VOID) QUinit((QUEUE *) &psy_cb->psy_colq);	/* Column name list */
	MEfill(sizeof(psy_cb->psy_tuple.psy_rule), EOS,
	       (PTR)&psy_cb->psy_tuple.psy_rule);

	/* No FROM clause so initialize bitmap - not really needed */
	MEfill(sizeof(PST_J_MASK), 0, (char *)&yyvarsp->flists[cb->pss_qualdepth]);

	yyvarsp->in_rule = 1;		/* For condition checking */

	/*
	** group and role permits will be disregarded when parsing definitions
	** of views, rules, and database procedures
	*/
	cb->pss_stmt_flags |= PSS_DISREGARD_GROUP_ROLE_PERMS;
    } break;

case 259:
if (!((*yyvarspp)->bypass_actions))
/* # line 6906 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	char		*ch1 = (char *) yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name;
# ifndef DOUBLEBYTE
	char		*ch2 = ch1 + CMbytecnt(ch1);
# else
	char		*ch2 ;
	
	ch2 = ch1 + CMbytecnt(ch1);
# endif /* #ifndef DOUBLEBYTE */

	/* If name was qualified, it'd better be the same as the user
	** (unless this is a system-generated rule [used for constraints])
	*/
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME))
	    && ((psq_cb->psq_info == (PST_INFO *) NULL)
		|| (~psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED)))
	{
	    (VOID) psf_error(E_PS0421_CRTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("CREATE RULE") - 1, "CREATE RULE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

	/* If "ii" then must be "ingres" */
	if (!CMcmpnocase(ch1, &SystemCatPrefix[0]) &&
	    !CMcmpnocase(ch2, &SystemCatPrefix[1]))
	{
	    if (MEcmp((PTR)&cb->pss_user, (PTR)cb->pss_cat_owner,
		      sizeof(DB_OWN_NAME)) != 0)
	    {
		_VOID_ psf_error(E_US18A1_6305_RULE_II, 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 2,
				 STlength(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name),
				 yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name,
				 STlength(SystemCatPrefix),
				 SystemCatPrefix);
		return (E_DB_ERROR);
	    }
	}

	/* test rule name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	STmove(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	      (char *)&((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_name);
    } break;

case 260:
if (!((*yyvarspp)->bypass_actions))
/* # line 6961 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 261:
if (!((*yyvarspp)->bypass_actions))
/* # line 6965 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;		/* Never any tree */
    } break;

case 262:
if (!((*yyvarspp)->bypass_actions))
/* # line 6971 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DMT_ATT_ENTRY   *att;
	PSY_CB		*psy_cb;
	PSY_COL		*col;
	DB_IIRULE	*rule_tup;
	i4		err_code;

	psy_cb = (PSY_CB *)cb->pss_object;
	rule_tup = &(psy_cb->psy_tuple.psy_rule);

	if ((yacc_cb->yypvt[-6].psl_tytype & DBR_F_BEFORE) && yacc_cb->yypvt[-0].psl_tytype == DBR_T_STMT)
	{
	    /* No support yet for statement level before rules. */
	    _VOID_ psf_error(E_US18B4_6324_NOSTMTBEFORE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
 
	rule_tup->dbr_type      = yacc_cb->yypvt[-0].psl_tytype;
	rule_tup->dbr_statement = yacc_cb->yypvt[-5].psl_inttype;
	rule_tup->dbr_flags     = yacc_cb->yypvt[-6].psl_tytype;

	/* if have list of column names, convert it to a bitmap;
	** also check for duplicates and non-existent columns
	*/
	if (psy_cb->psy_colq.q_next != &(psy_cb->psy_colq))
	{
	    /* for each column in the list, find its postion in the table
	    ** and add it to the bitmap.
	    ** Return an error if duplicate name or column not in table.
	    */ 
	    for (col = (PSY_COL *) psy_cb->psy_colq.q_next; 
		 col !=(PSY_COL *) &(psy_cb->psy_colq);
		 col = (PSY_COL *) col->queue.q_next)
	    {
		att = pst_coldesc(cb->pss_resrng, &col->psy_colnm);
		
		if (att == (DMT_ATT_ENTRY *) NULL)
		{
		    _VOID_ psf_error(E_US18A2_6306_RULE_COLTAB, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 2,
				     psf_trmwhite(sizeof(DB_TAB_NAME),
						  (char *) &col->psy_colnm),
				     &col->psy_colnm,
				     psf_trmwhite(sizeof(DB_TAB_NAME),
					 (char *) &cb->pss_resrng->pss_tabname),
				     &cb->pss_resrng->pss_tabname);
		    return (E_DB_ERROR);
		}

		if (BTtest(att->att_number,
			   (char *) rule_tup->dbr_columns.db_domset))
		{
		    /* duplicate, so return error 
		     */
		    _VOID_ psf_error(E_PS0460_DUP_UPD_COL, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 1,
				     psf_trmwhite(sizeof(DB_TAB_NAME),
						  (char *) &col->psy_colnm),
				     &col->psy_colnm);
		    return (E_DB_ERROR);
		}

		/* otherwise, set bit in column bitmap
		 */
	
		BTset(att->att_number, 
		      (char *) rule_tup->dbr_columns.db_domset);

	    } /* end for */
	} /* end if have list of columns */
	else
	{
	    /* table-level rule, so set ALL bits in column bitmap 
	     */
	    MEfill(sizeof(rule_tup->dbr_columns.db_domset), 
		   (unsigned char) 0xff, (PTR) rule_tup->dbr_columns.db_domset);
	}

	/* if PST_INFO flags are set, set special bits in rule tuple
	**
	** (For CONSTRAINTS, QEF will build an Execute Immediate CREATE RULE
	**  statement, and set bits in the PST_INFO structure.)
	*/
       	if (psq_cb->psq_info != (PST_INFO *) NULL)
	{
	    if (psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED)
	    {
		rule_tup->dbr_flags |= DBR_F_SYSTEM_GENERATED;
	    }
	
	    if (psq_cb->psq_info->pst_execflags & PST_NOT_DROPPABLE)
	    {
		rule_tup->dbr_flags |= DBR_F_NOT_DROPPABLE;
	    }

	    if (psq_cb->psq_info->pst_execflags &
		    PST_CASCADED_CHECK_OPTION_RULE)
	    {
		rule_tup->dbr_flags |= DBR_F_CASCADED_CHECK_OPTION_RULE;
	    }
	}

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;	/* May be NULL */
    } break;

case 263:
if (!((*yyvarspp)->bypass_actions))
/* # line 7079 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "after") == 0)
	    yacc_cb->yyval.psl_tytype = DBR_F_AFTER;
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "before") == 0)
	    yacc_cb->yyval.psl_tytype = DBR_F_BEFORE;
	else
	{
	    _VOID_ psf_error(E_US18A7_6311_RULE_WHEN, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
    } break;

case 264:
if (!((*yyvarspp)->bypass_actions))
/* # line 7096 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 265:
if (!((*yyvarspp)->bypass_actions))
/* # line 7100 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;

	/* check if same stmt specified more than once
	 */
	if (yacc_cb->yypvt[-2].psl_inttype & yacc_cb->yypvt[-0].psl_inttype)
	{
	    _VOID_ psf_error(E_US18A3_6307_RULE_STMT, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	yacc_cb->yyval.psl_inttype |= yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 266:
if (!((*yyvarspp)->bypass_actions))
/* # line 7115 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = DBR_S_DELETE;
    } break;

case 267:
if (!((*yyvarspp)->bypass_actions))
/* # line 7119 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = DBR_S_INSERT;
    } break;

case 268:
if (!((*yyvarspp)->bypass_actions))
/* # line 7123 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = DBR_S_UPDATE;
    } break;

case 269:
if (!((*yyvarspp)->bypass_actions))
/* # line 7127 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = DBR_S_UPDATE;

	/* columns are now in a queue pointed to by psy_cb->psy_colq
	 */
    } break;

case 272:
if (!((*yyvarspp)->bypass_actions))
/* # line 7138 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;
	PSY_COL     *psy_col;
	PSY_CB      *psy_cb;

	/* Allocate memory for a column entry
	 */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_COL),
			    (PTR *) &psy_col, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy update column name to column entry.
	*/
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_ATT_NAME),
		psy_col->psy_colnm.db_att_name);

	/*
	** Attach element to the list.
	*/
	psy_cb = (PSY_CB *) cb->pss_object;
	QUinsert((QUEUE *) psy_col, (QUEUE *) &psy_cb->psy_colq);
    } break;

case 277:
if (!((*yyvarspp)->bypass_actions))
/* # line 7173 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	i4		err_code, err_num;
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	/* Enter into range table as implicit NEW */
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name,
			&yacc_cb->yypvt[-0].psl_objspec->pss_owner, &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, cb->pss_qualdepth,
			 yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, FALSE,
			 &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
			 &rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}
	
	if (status != E_DB_OK)
	    return (status);
	
	/* Save name (for errors in psy_tabname) and table id in rule tuple */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabname, psy_cb->psy_tabname[0]);
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
		      psy_cb->psy_tuple.psy_rule.dbr_tabid);

	/*
	** Check for rules on catalogs and ownership of table
	**
	** NOTE:
	**	now rules may be created on updatable views.
	**	Also, referential constraints may need to create rules
	**	on other users' tables, so don't return 'not owner' error
	**	for system-generated rules.
	*/
	if ((resrange->pss_tabdesc->tbl_status_mask & DMT_CATALOG) ||
	    (resrange->pss_tabdesc->tbl_2_status_mask & DMT_TEXTENSION))
	{
	    /* Check if user has CATALOG UPDATE privilege */
	    if (! (cb->pss_ses_flag & PSS_CATUPD) )
	    {
		err_num = E_US18A9_6313_RULE_CAT;
		status = E_DB_ERROR;
	    }
	}
	else if (MEcmp((PTR) &cb->pss_user,
		       (PTR) &resrange->pss_tabdesc->tbl_owner,
		       sizeof(DB_OWN_NAME))
		 && ((psq_cb->psq_info == (PST_INFO *) NULL)
		     || (~psq_cb->psq_info->pst_execflags 
			 		& PST_SYSTEM_GENERATED)))
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;

		/*
		** Write Security Audit Record, indicating that the attempt
		** to create a rule on a table failed.
		*/
		local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrange->pss_tabname,
			    &resrange->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_RULE,
			    I_SX202F_RULE_ACCESS, SXF_A_FAIL | SXF_A_CREATE,
			    &e_error);
	    }

	    err_num = E_US18A5_6309_RULE_OWN;
	    status = E_DB_ERROR;
	}

	if (DB_FAILURE_MACRO(status))
	{
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
		    sizeof("CREATE RULE")-1, "CREATE RULE",
		    &psq_cb->psq_error);
	    }

	    _VOID_ psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname);
	    return(status);
	}
	
	/*
	** if user has referred to the object using name of a synonym, we need 
	** to replace synonym name with the real object name in the text which 
	** will be stored in IIQRYTEXT
	*/
        if (rngvar_info & PSS_BY_SYNONYM)
        {
	    PTR		*obj_name_ptr;
	    PTR		newpiece;
	    i4  	name_len;
	    u_char  	*actual_obj_owner = (u_char *) &resrange->pss_ownname;
	    u_char	delim_id[DB_MAX_DELIMID];
#ifdef BYTE_ALIGN
	    PTR	align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*obj_name_ptr)
#endif

	    /* The piece ptr is stored after the null terminated string */
	    obj_name_ptr = (PTR *) ((char *) yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name +
				    STlength(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name) + 1);
#ifdef BYTE_ALIGN
	    MECOPY_CONST_MACRO((PTR)obj_name_ptr, sizeof(PTR), (PTR)&align_ptr);
#endif
	    /*
	    ** if synonym name was qualified with owner name, and the owner
	    ** of the synonym is different from the owner of the actual
	    ** object, we will replace name of the owner of the synonym with
	    ** that of the actual object
	    */
	    if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	        MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (PTR) actual_obj_owner,
		    sizeof(DB_OWN_NAME)))
	    {
	        PTR	syn_owner = psq_tbacktrack(align_ptr, 2);
    
	        /*
	        ** psq_tsubs() may replace a name with preceding blank(s)
	        ** with one without them.  This is undesirable, e.g.
	        ** 
	        **	    create synonym andre.x for eric.t;
	        **	    create rule r after update of andre.x...;
	        **
	        ** would result in text
	        **
	        **	    create rule r after update oferic.t 
	        **
	        ** Therefore, we must add a space before the actual object
	        ** owner name.
	        */

	        status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
		    sizeof(" ") - 1, &newpiece, syn_owner,
		    &psq_cb->psq_error);
	        if (DB_FAILURE_MACRO(status))
		    return (status);

		/* 
		** convert owner name to a delimited identifier
		** (obj_owner pointer gets overwritten)
		*/
		name_len = psf_trmwhite(DB_MAXNAME, (char *) actual_obj_owner);

	        status = psl_norm_id_2_delim_id(&actual_obj_owner,
		    &name_len, delim_id, &psq_cb->psq_error);
	        if (DB_FAILURE_MACRO(status))
		    return(status);

		status = psq_tsubs(cb->pss_tchain, syn_owner,
		    actual_obj_owner, name_len,
		    &newpiece, &psq_cb->psq_error);
	        if (DB_FAILURE_MACRO(status))
	        {
		    return(status);
	        }
	    }

	    /*
	    ** if (synonym name was different from the actual object name)
	    ** {
	    **     replace synonym name with actual object name;
	    ** }
	    */
	    if (MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, (PTR) &resrange->pss_tabname,
		      sizeof(DB_TAB_NAME)))
	    {
		u_char	*actual_tbl = (u_char *) &resrange->pss_tabname;

		/* 
		** convert table name to a delimited identifier
		** (actual_tbl pointer gets overwritten)
		*/
		name_len = psf_trmwhite(DB_MAXNAME, (char *) actual_tbl);

	        status = psl_norm_id_2_delim_id(&actual_tbl, &name_len, 
		    delim_id, &psq_cb->psq_error);
	        if (DB_FAILURE_MACRO(status))
		    return(status);

		/*
		** if the schema name was not explicitly specified, psq_tsubs()
		** may strike again; it may substitute a string for a string 
		** preceeded by at least one blank and screw things up; to make
		** sure that it does not, insert a blank before the object name
		** unless the schema name was explicitly specified
		*/

		if (~yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
		{
		    /* Add a blank */
		    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
		        sizeof(" ") - 1, &newpiece, align_ptr,
		        &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
		        return (status);
		}

		status = psq_tsubs(cb->pss_tchain, align_ptr, actual_tbl, 
		    name_len, &newpiece, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	}

	/*
	** if creating a rule on a view, verify that it is, indeed, updatable;
	** because we allow updates on views someof whose columns are not
	** updatable, it would be unreasonable to require that only updatable
	** columns of such view are referenced in the rule definition (inside
	** <column list> in UPDATE(<column list), WHERE-clause, or parameter
	** list) - but we will verify that the view is updatable
	**
	** to accomplish this, we will obtain a view tree from RDF and pump its
	** copy through qrymod; after qrymod, we will know whether a view is
	** updatable + we will know underlying columns of each of the view's
	** columns - this info will be used when we translate a rule tree (if
	** any) to reference attributes of the view's underlying base table
	** instead of referencing attributes of the view itself
	** 
	*/
	if (resrange->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	{
	    RDF_CB	    rdfcb, *rdf_cb = &rdfcb;
	    RDR_RB	    *rdf_rb = &rdf_cb->rdf_rb;
	    PST_PROCEDURE   *pnode;
	    PST_QTREE	    *header;
	    PST_QNODE	    *root;
	    PST_VRMAP	    viewmap;
	    i4		    i;
	    PST_QNODE	    *tree_copy;
	    PSS_USRRANGE    *rngtab = &cb->pss_auxrng;
	    DB_ERROR	    *err_blk = &psq_cb->psq_error;
	    i4		    nonupdt_info;
	    PSS_RNGTAB      *rngvar;
	    i4		    rgno;
	    PST_J_ID	    dummy;
	    i4         qrymod_resp_mask;

	    /* initialize static fields in rdf_cb used to retrieve view trees */
	    pst_rdfcb_init(rdf_cb, cb);
	    
	    rdf_rb->rdr_types_mask = RDR_VIEW | RDR_QTREE;
	    STRUCT_ASSIGN_MACRO(resrange->pss_tabid, rdf_rb->rdr_tabid);
	    rdf_rb->rdr_rec_access_id = NULL;
	    rdf_cb->rdf_info_blk = resrange->pss_rdrinfo;
	    rdf_rb->rdr_qtuple_count = 1;

	    /* call RDF to get the view tree */
	    status = rdf_call(RDF_GETINFO, (PTR) rdf_cb);

	    /*
	    ** RDF may choose to allocate a new info block and return its
	    ** address in rdf_info_blk - we need to copy it over to pss_rdrinfo
	    ** to avoid memory leak and other assorted unpleasantries
	    */
	    resrange->pss_rdrinfo = rdf_cb->rdf_info_blk;

	    if (DB_FAILURE_MACRO(status))
	    {
		if (rdf_cb->rdf_error.err_code == E_RD0002_UNKNOWN_TBL)
		{
		    (VOID) psf_error(E_PS0903_TAB_NOTFOUND, 
			rdf_cb->rdf_error.err_code, PSF_INTERR,
			&err_code, err_blk, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME), 
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);
		}
		else
		{
		    (VOID)psf_rdf_error(RDF_GETINFO, &rdf_cb->rdf_error,
			err_blk);
		}

		return(status);
	    }

	    pnode =
		(PST_PROCEDURE *) rdf_cb->rdf_info_blk->rdr_view->qry_root_node;
		
	    header = pnode->pst_stmts->pst_specific.pst_tree;

	    /*
	    ** determine whether the view is updatable - rules cannot be
	    ** created on non-updatable views
	    */
	    if (!psy_view_is_updatable(header, (i4) PSQ_RULE, &nonupdt_info))
	    {
		err_num = 0;
		
		if (nonupdt_info & PSY_UNION_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0590_UNION_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_DISTINCT_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0591_DISTINCT_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_AGGR_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0594_AGGR_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_GROUP_BY_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0593_GROUP_BY_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_MULT_VAR_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0592_MULT_VARS_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_NO_UPDT_COLS)
		    err_num = E_PS0595_CANNOT_UPDT_RULE_VIEW;

		if (err_num)
		{
		    if (rngvar_info & PSS_BY_SYNONYM)
		    {
			psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
			    sizeof("CREATE RULE")-1, "CREATE RULE",
			    err_blk);
		    }

		    _VOID_ psf_error(err_num, 0L, PSF_USERERR, &err_code,
			err_blk, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME), 
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);
		    return(E_DB_ERROR);
		}
	    }
	    
	    root = header->pst_qtree;
	    
	    yyvarsp->dup_rb.pss_tree = root;
	    yyvarsp->dup_rb.pss_dup  = &tree_copy;
	    status = pst_treedup(cb, &yyvarsp->dup_rb);

	    if (status != E_DB_OK)
		return (status);

	    /* create a bitmap of vars used in the view */
	    psy_varset(tree_copy, &viewmap);

	    /*
	    ** reinitialize the range table since we are about to pump the view
	    ** tree through qrymod and we want the range table to contain only
	    ** the view's underlying tables.  Once we are done with this
	    ** exercise, we will reinitialize the range table and reenter the
	    ** var corresponding to the view on which a rule is being created
	    */
	    status = pst_clrrng(cb, rngtab, err_blk);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /* remember range number of the view's underlying table/view */
	    rgno = BTnext(-1,
		(char *) &root->pst_sym.pst_value.pst_s_root.pst_tvrm,
		PST_NUMVARS);
	    
	    /* merge the view's range variables into the range table */
	    for (i = -1; (i = BTnext(i, (char *) &viewmap, PST_NUMVARS)) != -1;)
	    {
		status = pst_rgent(cb, rngtab, -1, "!", PST_SHWID,
		    (DB_TAB_NAME *) NULL, (DB_TAB_OWN *) NULL,
		    &header->pst_rangetab[i]->pst_rngvar, FALSE, 
		    &rngvar, (i4) 0, err_blk);
		    
		if (DB_FAILURE_MACRO(status))
		{
		    /* If table could not be found return a user error
		    ** so that things can be retried.
		    */
		    if (err_blk->err_code == E_PS0903_TAB_NOTFOUND)
		    {
			(VOID) psf_error(2120L, 0L, PSF_USERERR,
			    &err_code, err_blk, 0);
		    }
		    return(status);
		}

		/*
		** copy inner and outer join maps into the new range table
		** entry
		*/
		STRUCT_ASSIGN_MACRO(header->pst_rangetab[i]->pst_inner_rel,
		    rngvar->pss_inner_rel);
		STRUCT_ASSIGN_MACRO(header->pst_rangetab[i]->pst_outer_rel,
		    rngvar->pss_outer_rel);

		/*
		** if this is the view's underlying table/view, mark
		** pss_var_mask of the range variable corresponding to that
		** table/view accordingly
		*/
		if (i == rgno)
		{
		    rngvar->pss_var_mask |= PSS_RULE_RNG_VAR;
		}
	    }

	    dummy = header->pst_numjoins;

	    /*
	    ** pump the view tree through qrymod; this will enable us to
	    ** determine whether the view is, indeed, updatable + we will have a
	    ** tree representing attributes of the view which can be used when
	    ** we need to replace references to attributes of the view with
	    ** references to the attributes of its underlying base table
	    */
	    status = psy_qrymod(tree_copy, cb, psq_cb, &dummy,
		&qrymod_resp_mask);
	    if (DB_FAILURE_MACRO(status))
	    {
		err_num = 0;
		
		if (qrymod_resp_mask & PSY_UNION_IN_UNDERLYING_VIEW)
		    err_num = E_PS0596_CRT_RULE_UNION_IN_UV;
		else if (qrymod_resp_mask & PSY_DISTINCT_IN_UNDERLYING_VIEW)
		    err_num = E_PS0597_CRT_RULE_DISTINCT_IN_UV;
		else if (qrymod_resp_mask & PSY_MULT_VAR_IN_UNDERLYING_VIEW)
		    err_num = E_PS0598_CRT_RULE_MULT_VARS_IN_UV;
		else if (qrymod_resp_mask & PSY_GROUP_BY_IN_UNDERLYING_VIEW)
		    err_num = E_PS0599_CRT_RULE_GROUP_BY_IN_UV;
		else if (qrymod_resp_mask & PSY_SET_FUNC_IN_UNDERLYING_VIEW)
		    err_num = E_PS059A_CRT_RULE_AGGR_IN_UV;
		else if (qrymod_resp_mask &PSY_NO_UPDT_COLS_IN_UNDRLNG_VIEW)
		    err_num = E_PS059B_CRT_RULE_CANNOT_UPDT_UV;

		if (err_num)
		{
		    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
			err_blk, 1,
			STlength(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name),
			yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name);
		}

		return(status);
	    }

	    /*
	    ** OK, the view seems to be updatable; store address of the tree
	    ** returned from psy_qrymod(), clear the range table, and reenter
	    ** the view on which a rule is being created
	    */
	    yyvarsp->rule_view_tree = tree_copy;

	    status = pst_clrrng(cb, rngtab, err_blk);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    status = pst_rgent(cb, rngtab, -1, "!", PST_SHWID,
		(DB_TAB_NAME *) NULL, (DB_TAB_OWN *) NULL,
		&psy_cb->psy_tuple.psy_rule.dbr_tabid, FALSE, 
		&resrange, (i4) 0, err_blk);
		
	    if (DB_FAILURE_MACRO(status))
	    {
		/* If table could not be found return a user error
		** so that things can be retried.
		*/
		if (err_blk->err_code == E_PS0903_TAB_NOTFOUND)
		{
		    (VOID) psf_error(2120L, 0L, PSF_USERERR,
			&err_code, err_blk, 0);
		}
		
		return(status);
	    }

	}

	resrange->pss_image = PST_AFTER;	/* Default as "new */

	cb->pss_resrng = resrange;
    } break;

case 279:
if (!((*yyvarspp)->bypass_actions))
/* # line 7670 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	char		*corr_name;

	/*
	** default correlation name must match the default case of regular
	** identifiers
	*/
	if (*cb->pss_dbxlate & CUI_ID_REG_U)
	{
	    corr_name = (yacc_cb->yypvt[-0].psl_tytype == PST_BEFORE) ? "NEW" : "OLD";
	}
	else
	{
	    corr_name = (yacc_cb->yypvt[-0].psl_tytype == PST_BEFORE) ? "new" : "old";
	}
	
	/* Enter old/new - whichever one wasn't entered */
	status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth, corr_name,
		     &cb->pss_resrng->pss_ownname, &cb->pss_resrng->pss_tabname,
		     cb, FALSE, &resrange, psq_cb->psq_mode,
		     &psq_cb->psq_error, &rngvar_info);
	if (status != E_DB_OK)
	    return (status);
	resrange->pss_image = yacc_cb->yypvt[-0].psl_tytype == PST_BEFORE ? PST_AFTER : PST_BEFORE;

	/* copy the mask field */
	resrange->pss_var_mask = cb->pss_resrng->pss_var_mask;
    } break;

case 280:
if (!((*yyvarspp)->bypass_actions))
/* # line 7702 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;

	/* Enter "old" and "new" as default correlation variables */
	status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth,
	    (*cb->pss_dbxlate & CUI_ID_REG_U) ? "OLD" : "old",
	    &cb->pss_resrng->pss_ownname, &cb->pss_resrng->pss_tabname,
	    cb, FALSE, &resrange, psq_cb->psq_mode,
	    &psq_cb->psq_error, &rngvar_info);
	if (status != E_DB_OK)
	    return (status);

	/* copy the mask field */
	resrange->pss_var_mask = cb->pss_resrng->pss_var_mask;
	
	resrange->pss_image = PST_BEFORE;
	
	status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth,
	    (*cb->pss_dbxlate & CUI_ID_REG_U) ? "NEW" : "new",
	    &cb->pss_resrng->pss_ownname, &cb->pss_resrng->pss_tabname,
	    cb, FALSE, &resrange, psq_cb->psq_mode,
	    &psq_cb->psq_error, &rngvar_info);
	if (status != E_DB_OK)
	    return (status);

	/* copy the mask field */
	resrange->pss_var_mask = cb->pss_resrng->pss_var_mask;
	
	resrange->pss_image = PST_AFTER;
    } break;

case 281:
if (!((*yyvarspp)->bypass_actions))
/* # line 7737 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	i4		old_new_image;
	i4		err_code;

	if (STcompare(yacc_cb->yypvt[-3].psl_strtype, "old") == 0)
	{
	    old_new_image = PST_BEFORE;
	}
	else if (STcompare(yacc_cb->yypvt[-3].psl_strtype, "new") == 0)
	{
	    old_new_image = PST_AFTER;
	}
	else
	{
	    _VOID_ psf_error(E_US18A6_6310_RULE_OLDNEW, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     STlength(yacc_cb->yypvt[-3].psl_strtype), yacc_cb->yypvt[-3].psl_strtype);
	    return (E_DB_ERROR);
	}
	status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth, yacc_cb->yypvt[-0].psl_strtype,
		     &cb->pss_resrng->pss_ownname, &cb->pss_resrng->pss_tabname,
		     cb, FALSE, &resrange, psq_cb->psq_mode,
		     &psq_cb->psq_error, &rngvar_info);
	if (status != E_DB_OK)
	    return (status);

	/* copy the mask field */
	resrange->pss_var_mask = cb->pss_resrng->pss_var_mask;

	yacc_cb->yyval.psl_tytype = resrange->pss_image = old_new_image;
    } break;

case 286:
if (!((*yyvarspp)->bypass_actions))
/* # line 7782 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree;
    } break;
	}
	return(0);
}

i4
psls5iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 287:
if (!((*yyvarspp)->bypass_actions))
/* # line 7786 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;
    } break;

case 290:
if (!((*yyvarspp)->bypass_actions))
/* # line 7796 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	/* Not implemented yet */
	_VOID_ psf_error(2411L, 0L, PSF_USERERR,
			 &err_code, &psq_cb->psq_error, 0);
	return (E_DB_ERROR);
    } break;

case 291:
if (!((*yyvarspp)->bypass_actions))
/* # line 7806 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** FIXME: Convert string $1 into date pointed at by dbr_tm_date.
	** dbstr -> $1;
	** dbdte -> &((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_tm_date;
	** adc_cvinto(dbstr, dbdte);
	** check errors
	*/
    } break;

case 292:
if (!((*yyvarspp)->bypass_actions))
/* # line 7818 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** FIXME: Convert string $1 into date pointed at by dbr_tm_date.
	** dbstr -> $1;
	** dbdte -> &((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_tm_int;
	** adc_cvinto(dbstr, dbdte);
	** check errors
	*/
    } break;

case 293:
if (!((*yyvarspp)->bypass_actions))
/* # line 7828 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** FIXME: MEfill with 0, sizeof(DB_DATE)
	*/
    } break;

case 294:
if (!((*yyvarspp)->bypass_actions))
/* # line 7836 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBR_T_ROW;
    } break;

case 295:
if (!((*yyvarspp)->bypass_actions))
/* # line 7840 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;
	i4 lineno = 1;
	i4	val1=0, val2=0;  /* for trace point checking */
	
	/* this is for internal statement-level rules,
	** for which the syntax is RULE_SCOPE = STATEMENT.
	** Users are not allowed to use this syntax (yet)
	** (and this syntax has not passed the LRC, either).    22-dec-92
	*/
	/* This syntax has been altered to the ANSI "for each {row | statement}"
	** option. A corresponding change has been made to qef!qeq!qeaddl.c,
	** where statement level rule syntax is currently built under the 
	** covers. The syntax has also been externalized to permit users
	** to code their own statement level rules (they used to be 
	** restricted to internally generated rules built to implement
	** referential and check constraints). The error check which used
	** to be here has now been removed. */


	if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "each") != 0)
	{
	    psf_error(2076L, 0L, PSF_USERERR,
		      &err_code, &psq_cb->psq_error, 1,
		      STlength(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
	    return(E_DB_ERROR);
	}
 
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;	/* return ROW or STATEMENT */

    } break;

case 296:
if (!((*yyvarspp)->bypass_actions))
/* # line 7874 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBR_T_ROW;
    } break;

case 297:
if (!((*yyvarspp)->bypass_actions))
/* # line 7878 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	/* valid value is STATEMENT 
	 */
	if (STbcompare(yacc_cb->yypvt[-0].psl_strtype, 0, "statement", 0, TRUE) == 0)
	{
	    yacc_cb->yyval.psl_tytype = DBR_T_STMT;
	}	    
	else
	{
	    psf_error(2076L, 0L, PSF_USERERR,
		      &err_code, &psq_cb->psq_error, 1,
		      STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return(E_DB_ERROR);
	}

    } break;

case 298:
if (!((*yyvarspp)->bypass_actions))
/* # line 7900 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 299:
if (!((*yyvarspp)->bypass_actions))
/* # line 7904 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;
    } break;

case 300:
if (!((*yyvarspp)->bypass_actions))
/* # line 7910 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* A dbpinfo has been filled when validating the procedure name */
	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_dbpinfo->pss_ptuple.db_dbpname,
		   ((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_dbpname);
	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_dbpinfo->pss_ptuple.db_owner,
		   ((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_dbpowner);
	((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_dbpparam = 0;
	if (yacc_cb->yypvt[-0].psl_dbpinfo->pss_ptuple.db_mask[0] & DBP_DATA_CHANGE)
	    cb->pss_dbp_flags |= PSS_DATA_CHANGE;
	else cb->pss_dbp_flags &= ~PSS_DATA_CHANGE;
    } break;

case 301:
if (!((*yyvarspp)->bypass_actions))
/* # line 7924 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* How many parameters were there - highest resdom number? */
	((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_dbpparam = 
				yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_rsno;
    } break;

case 302:
if (!((*yyvarspp)->bypass_actions))
/* # line 7932 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_CSYNONYM;

	/* "CREATE SYNONYM" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE SYNONYM")-1, "CREATE SYNONYM");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the CREATE SYNONYM statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	/* we are about to process the new synonym name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    } break;

case 303:
if (!((*yyvarspp)->bypass_actions))
/* # line 7958 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* we are done processing the new object name */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    } break;

case 304:
if (!((*yyvarspp)->bypass_actions))
/* # line 7963 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	i4		    rngvar_info;
	PSS_RNGTAB	    *resrange;
	DB_IISYNONYM	    *syn_tuple;

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
		&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb,
		TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (rngvar_info & PSS_BY_SYNONYM)
	{
	    i4	    err_code;

	    /* can't create synonyms on other synonyms */
	    (VOID) psf_error(E_PS0455_CRT_SYN_ON_SYN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name), yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name);
	    return (E_DB_ERROR);
	}
	
	/* Allocate DB_IISYNONYM structure */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_IISYNONYM),
			    (PTR *) &syn_tuple, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* initialize DB_IISYNONYM tuple */
	STmove(yacc_cb->yypvt[-3].psl_strtype, ' ', sizeof(DB_SYNNAME), syn_tuple->db_synname.db_synonym);
	MEmove(sizeof(cb->pss_user), cb->pss_user.db_own_name, ' ',
	       sizeof(DB_SYNOWN), syn_tuple->db_synowner.db_syn_own);
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid, syn_tuple->db_syntab_id);

	((PSY_CB *) cb->pss_object)->psy_tupptr = (PTR) syn_tuple;

    } break;

case 305:
if (!((*yyvarspp)->bypass_actions))
/* # line 8023 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4			    err_code;
	DB_STATUS 		    status;

	/* "DECLARE GLOBAL TEMPORARY TABLE" is not allowed in distributed */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		sizeof("DECLARE GLOBAL TEMPORARY TABLE") - 1,
		"DECLARE GLOBAL TEMPORARY TABLE");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DGTT;
	cb->pss_stmt_flags |= PSS_CREATE_DGTT; /* bug 76902 */
	status = psl_ct10_crt_tbl_kwd(cb, psq_cb, &yyvarsp->with_clauses, 1L);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* we are about to process a new object name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    } break;

case 307:
if (!((*yyvarspp)->bypass_actions))
/* # line 8050 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		    err_code;

	(VOID) psf_error(E_PS0BD6_MUST_USE_ON_COMMIT,
			0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, 
			sizeof("DECLARE GLOBAL TEMPORARY TABLE")-1,
			"DECLARE GLOBAL TEMPORARY TABLE");
	return (E_DB_ERROR);		
    } break;

case 308:
if (!((*yyvarspp)->bypass_actions))
/* # line 8062 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_ct1_create_table(cb, psq_cb, (PSS_CONS *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 309:
if (!((*yyvarspp)->bypass_actions))
/* # line 8071 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/*
	** we are (almost) done processing DGTT AS SELECT; reset the query
	** mode; resetting it before query_expr was processed would require
	** additional changes in the qrymod functions and would not buy us
	** anything
	*/
	psq_cb->psq_mode = PSQ_DGTT_AS_SELECT;

	/* Even though DGTT doesn't allow partitioning, do the column
	** name fixup here to stay in sync with "real" create table.
	*/
	status = psl_crtas_fixup_columns(cb, yacc_cb->yypvt[-5].psl_trtype, yacc_cb->yypvt[-3].psl_trtype, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 310:
if (!((*yyvarspp)->bypass_actions))
/* # line 8090 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	i4			err_code;

	if (yacc_cb->yypvt[-5].psl_tytype != 0)
	    yyvarsp->sort_list = (PST_QNODE *) NULL;

	/* ORDER BY is only allowed if there is at least an offset or first
	** "n" clause. */
	if (yyvarsp->sort_list != NULL && yyvarsp->first_n == NULL && yyvarsp->offset_n == NULL)
	{
	    (VOID) psf_error(2160L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}

	status = psl_ct2s_crt_tbl_as_select(cb, yacc_cb->yypvt[-8].psl_trtype, yacc_cb->yypvt[-6].psl_trtype, psq_cb, &yyvarsp->join_id,
			&yyvarsp->xlated_qry, yyvarsp->sort_list, yyvarsp->first_n, yyvarsp->offset_n);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 311:
if (TRUE)	/* NOBYPASS */
/* # line 8115 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special processing for CREATE SCHEMA
	    */
	    status = psl_cs03s_create_table(cb, psq_cb,
			 yyvarsp->stmtstart, yyvarsp->deplist, yyvarsp->cons_list);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	    return(E_DB_OK);
	}

	status = psl_ct1_create_table(cb, psq_cb, yyvarsp->cons_list);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct16_distr_create(cb, &yyvarsp->xlated_qry, TRUE, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    } break;

case 312:
if (TRUE)	/* NOBYPASS */
/* # line 8147 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	i4 err_code;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** ERROR - No DML allowed in CREATE TABLE within CREATE SCHEMA
	    */
	    (VOID) psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("CREATE TABLE ... AS SELECT")-1,
				 "CREATE TABLE ... AS SELECT");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/*
	** we are (almost) done processing CREATE AS SELECT; reset the query
	** mode; resetting it before query_expr was processed would require
	** additional changes in the qrymod functions and would not buy us
	** anything
	*/
	psq_cb->psq_mode = PSQ_RETINTO;

	/* Do column name and other fixes before the with clause, so that
	** partition definition sees a reasonably good set of columns.
	*/
	status = psl_crtas_fixup_columns(cb, yacc_cb->yypvt[-5].psl_trtype, yacc_cb->yypvt[-3].psl_trtype, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* The query tree isn't hooked up until after the with clause, yet
	** the with clause (partition) needs to get at the column names!
	** Drop a copy of the tree pointer into the yyvars for partition
	** definition, so that it can check out column names..
	*/
	yyvarsp->part_crtas_qtree = yacc_cb->yypvt[-3].psl_trtype;
	
    } break;

case 313:
if (TRUE)	/* NOBYPASS */
/* # line 8192 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	i4			err_code;

	if (yacc_cb->yypvt[-4].psl_tytype != 0)
	    yyvarsp->sort_list = (PST_QNODE *) NULL;

	/* ORDER BY is only allowed if there is at least an offset or first
	** "n" clause. */
	if (yyvarsp->sort_list != NULL && yyvarsp->first_n == NULL && yyvarsp->offset_n == NULL)
	{
	    (VOID) psf_error(2160L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}

	status = psl_ct2s_crt_tbl_as_select(cb, yacc_cb->yypvt[-7].psl_trtype, yacc_cb->yypvt[-5].psl_trtype, psq_cb, &yyvarsp->join_id,
			&yyvarsp->xlated_qry, yyvarsp->sort_list, yyvarsp->first_n, yyvarsp->offset_n);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct16_distr_create(cb, &yyvarsp->xlated_qry, FALSE, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    } break;

case 314:
if (!((*yyvarspp)->bypass_actions))
/* # line 8224 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* This simply forces execution of the flag set prior to parsing 
	** the accompanying SELECT, which in turn allows the detection of
	** valid parameter markers in the WHERE clause of PREPAREd RETINTOs.
	*/

	yyvarsp->qry_mask |= PSS_CRTAB_AS_SELECT;
    } break;

case 315:
if (TRUE)	/* NOBYPASS */
/* # line 8235 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS 		    status;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    yyvarsp->submode = PSQ_CREATE;
	    yyvarsp->deplist = (PST_OBJDEP *) NULL;
	    yyvarsp->stmtstart = (char *) cb->pss_prvgoval;
	    yyvarsp->cons_list = (PSS_CONS *) NULL;
	    return(E_DB_OK);
	}
	    
	psq_cb->psq_mode = PSQ_CREATE;
	status = psl_ct10_crt_tbl_kwd(cb, psq_cb, &yyvarsp->with_clauses, 0L);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* we are about to process a new object name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    } break;

case 316:
if (!((*yyvarspp)->bypass_actions))
/* # line 8265 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_ct9_new_loc_name(cb, psq_cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_strtype, &yyvarsp->with_clauses,
					&yyvarsp->xlated_qry);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* 
	** distributed thread must convert location: to a
	** WITH-clause item
	*/
	cb->pss_distr_sflags |= PSS_LOCATION;
    } break;

case 317:
if (!((*yyvarspp)->bypass_actions))
/* # line 8280 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_ct9_new_loc_name(cb, psq_cb, (char *) NULL,
				      yacc_cb->yypvt[-0].psl_strtype, &yyvarsp->with_clauses, &yyvarsp->xlated_qry);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 318:
if (TRUE)	/* NOBYPASS */
/* # line 8292 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS               status;

	/* test object name for reserved name;
	** (this production is used for synonym, table, view creation)
	*/
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    return(psl_cs06s_obj_spec(cb, psq_cb, &(yyvarsp->deplist), yacc_cb->yypvt[-0].psl_objspec,
				        (u_i4)PST_DEP_NOORDER));
	}

	status = psl_ct12_crname(cb, psq_cb, yacc_cb->yypvt[-0].psl_objspec);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name;
    } break;

case 319:
if (TRUE)	/* NOBYPASS */
/* # line 8317 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	(VOID) psl_sx_error(2721L, cb, psq_cb);
	YYABORT;
    } break;
	}
	return(0);
}

i4
psls6iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 320:
if (!((*yyvarspp)->bypass_actions))
/* # line 8324 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	char		    *name;
	i4		    err_code;
	register PST_QNODE  *node, *node1;
	i4		    num_attrs;

	/* we are done processing the new object/column names */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

	/*
	** See if there are duplicate column names.
	*/
	for (node = yacc_cb->yypvt[-1].psl_trtype; node != (PST_QNODE *) NULL; node = node->pst_left)
	{
	    /* to save on dereferencing */
	    name = node->pst_sym.pst_value.pst_s_rsdm.pst_rsname;
	    
	    for (node1 = node->pst_left; node1 != (PST_QNODE *) NULL;
					 node1 = node1->pst_left )
	    {	    
		if ((MEcmp((PTR) name,
			   (PTR) node1->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
			   DB_MAXNAME) == 0)
		   )
		{
		    (VOID) psf_error(2013L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, 
			psf_trmwhite(DB_MAXNAME, (char*) name), (char*) name);
		     return (E_DB_ERROR); 
		}
	    }
	}

	/*
	** Find the leftmost node in the tree.
	*/
	for (node = yacc_cb->yypvt[-1].psl_trtype, num_attrs = 0; 
	     node->pst_left != (PST_QNODE *) NULL;
	     node = node->pst_left, num_attrs++)
	;

	if (num_attrs > DB_MAX_COLS)
	{
	    char	command[PSL_MAX_COMM_STRING];
	    i4 	len;
	    i4		max_cols = DB_MAX_COLS;

	    psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, &len);

	    (VOID) psf_error(E_PS0BE0_TOO_MANY_COLS, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 3,
		len, (PTR) command,
		(i4) sizeof(num_attrs), (PTR) &num_attrs,
		(i4) sizeof(max_cols), (PTR) &max_cols);
	    return(E_DB_ERROR);
	}

	/* Allocate the PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &node->pst_left,
		&psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = yyvarsp->resdmhd = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 321:
if (!((*yyvarspp)->bypass_actions))
/* # line 8395 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yyvarsp->resdmhd = (PST_QNODE *) NULL;
    } break;

case 322:
if (!((*yyvarspp)->bypass_actions))
/* # line 8401 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 323:
if (!((*yyvarspp)->bypass_actions))
/* # line 8405 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = pst_tlprpnd(yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype);
    } break;

case 324:
if (!((*yyvarspp)->bypass_actions))
/* # line 8411 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PST_QNODE	    *resdomnode;
	PST_RSDM_NODE	    resdom;

	/* Normalize the attribute name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(resdom.pst_rsname),
	    (char *) resdom.pst_rsname);

	resdom.pst_rsno = (i4) 1;
	resdom.pst_ntargno = (i4) 0;
	resdom.pst_ttargtype = (i4) PST_USER;
	resdom.pst_rsupdt = (i4) FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;
	resdom.pst_dmuflags = 0;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_RESDOM, (char *) &resdom,
	    sizeof(PST_RSDM_NODE), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &resdomnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 325:
if (!((*yyvarspp)->bypass_actions))
/* # line 8438 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	(VOID) psl_sx_error(2720L, cb, psq_cb);
	YYABORT;
    } break;

case 328:
if (!((*yyvarspp)->bypass_actions))
/* # line 8449 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS               status;

	/* test column name for reserved name;
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-1].psl_strtype, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct17_distr_specs(cb, yyvarsp->scanbuf_ptr, &yyvarsp->xlated_qry,
				    &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    } break;

case 329:
if (!((*yyvarspp)->bypass_actions))
/* # line 8467 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	
	/* check that constraints are allowed for this statement 
	 */
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 330:
if (!((*yyvarspp)->bypass_actions))
/* # line 8480 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* nothing specified implies ->
	** 	with null <no default> not system_maintained
	** schang : RMS gateway dictates that nothing implies
	**	    not null with default
	**	PROBLEM : for other gateways that want to comply
	**	    with INGRES rules, we have to defer the this flag
	**	    setting actuntil we know what kind of gateway we
	**	    are using.
        ** schang :  the fips constraint project makes it possible to
        **      use the following flag for RMS GW
	*/
	if (psq_cb->psq_mode == PSQ_REG_IMPORT)
	    yacc_cb->yyval.psl_inttype = (PSS_TYPE_DEFAULT | PSS_TYPE_NOT_NULL);
	else
	    yacc_cb->yyval.psl_inttype = PSS_TYPE_NULL;   /* don't want PSS_TYPE_DEFAULT here
                                  ** because WITH NULL implies a default of NULL
                                  ** and the new PSS_TYPE_DEFAULT implies a
                                  ** default of 0 or blank depending on
                                  ** the datatype   (rjb  10/11/92)
                                  */
    } break;

case 333:
if (!((*yyvarspp)->bypass_actions))
/* # line 8507 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS               status;

	/* check for duplicate and conflicting qualifications
	 */
	status = psl_ct18s_type_qual(psq_cb->psq_mode, yacc_cb->yypvt[-1].psl_inttype, yacc_cb->yypvt[-0].psl_inttype, cb, yyvarsp->dbpinfo,
				     &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	/* build up bitmap of qualifications specified
	 */
	yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-1].psl_inttype | yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 334:
if (!((*yyvarspp)->bypass_actions))
/* # line 8524 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->inconstraint = FALSE;
	cb->pss_stmt_flags &= ~PSS_DEFAULT_VALUE;
    } break;

case 335:
if (!((*yyvarspp)->bypass_actions))
/* # line 8529 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->inconstraint = FALSE;
    } break;

case 336:
if (!((*yyvarspp)->bypass_actions))
/* # line 8533 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->inconstraint = FALSE;
    } break;

case 337:
if (!((*yyvarspp)->bypass_actions))
/* # line 8537 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->inconstraint = TRUE;
	if (yacc_cb->yypvt[-0].psl_inttype & PSS_TYPE_NOT_NULL)
	    yacc_cb->yyval.psl_inttype = PSS_TYPE_NOT_NULL;
	else yacc_cb->yyval.psl_inttype = 0;		/* column constraints return zippo */
    } break;

case 338:
if (!((*yyvarspp)->bypass_actions))
/* # line 8544 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->inconstraint = FALSE;
	yacc_cb->yyval.psl_inttype = 0;		/* column constraint with's too */
    } break;

case 339:
if (!((*yyvarspp)->bypass_actions))
/* # line 8552 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PSS_TYPE_NDEFAULT;
    } break;

case 340:
if (!((*yyvarspp)->bypass_actions))
/* # line 8556 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 341:
if (!((*yyvarspp)->bypass_actions))
/* # line 8564 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	
	/* get the string version of the default value by opening
	** a text chain and having the scanner put text into it;
	** use TXTEMIT2 and tchain2 because the first chain (pss_tchain) will
	** be used for procedure text if this is inside a CREATE PROCEDURE.
	*/
	status = psq_topen(&cb->pss_tchain2, 
			   &cb->pss_memleft, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_stmt_flags |= PSS_TXTEMIT2;	    /* Indicate to emit text */
	cb->pss_stmt_flags |= PSS_DEFAULT_VALUE;
    } break;

case 342:
if (!((*yyvarspp)->bypass_actions))
/* # line 8581 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_TEXT_STRING	*def_txt;
	i4 	err_code, err;
	char		command[PSL_MAX_COMM_STRING];
	i4 	length;
	
	/* turn off text-emit flag; 
	 */
	cb->pss_stmt_flags &= ~PSS_TXTEMIT2;
    
	if (yacc_cb->yypvt[-0].psl_trtype != (PST_QNODE *) NULL)  /* <=== */
	{
	    /*** have user-defined default 
	     ***/
	    yacc_cb->yyval.psl_inttype = PSS_TYPE_DEFAULT | PSS_TYPE_USER_DEFAULT;

	    /* store away the default value string;
	    ** will be passed to psl_ct14s_typedesc for processing
	    */
	    status = psq_tmulti_out(cb, (PSS_USRRANGE *) NULL,
				    cb->pss_tchain2, &cb->pss_ostream,
				    &def_txt, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    yyvarsp->default_text = def_txt;

	    /* store away the node representing the default value;
	    ** will be passed to ADF to check that it matches column's datatype
	    */
	    yyvarsp->default_node = yacc_cb->yypvt[-0].psl_trtype;  /* <=== */

	    /* in 6.5, user-defined defaults are only allowed 
	    ** in CREATE TABLE statements;
	    ** if TEMP table, CREATE PROCEDURE, or gateway, return error;
	    ** also, if distributed (STAR), return error
	    ** Added support for alter table alter column.
	    */
	    if ((cb->pss_distrib & DB_3_DDB_SESS)
		|| ( (psq_cb->psq_mode != PSQ_CREATE) &&
		     (psq_cb->psq_mode != PSQ_ATBL_ADD_COLUMN) && 
		     (psq_cb->psq_mode != PSQ_ATBL_ALTER_COLUMN) ) )
	    {
		psl_command_string(psq_cb->psq_mode, 
				   cb->pss_lang, command, &length);
		
		if (cb->pss_distrib & DB_3_DDB_SESS)
		    err = E_PS0489_DDB_USER_DEFAULT_NOT_ALLOWED;
		else 
		    err = E_PS0476_USER_DEFAULT_NOTALLOWED;
		
		_VOID_ psf_error(err, 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 1,
				 length, command);
		return (E_DB_ERROR);
	    }
	} /* end if ($4 != NULL) */
	else
	{
	    /* have INGRES default 
	     */
	    yacc_cb->yyval.psl_inttype = PSS_TYPE_DEFAULT;

	    /* clear the default value pointers
	     */
	    yyvarsp->default_text = (DB_TEXT_STRING *) NULL;
	    yyvarsp->default_node = (PST_QNODE *) NULL;

	    /* make sure WITH keyword was present
	     */
	    if (yacc_cb->yypvt[-3].psl_inttype == FALSE)
	    {
		/* return error
		 */
		psl_command_string(psq_cb->psq_mode, 
				   cb->pss_lang, command, &length);

		if ( (psq_cb->psq_mode == PSQ_CREATE) ||
		     (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) || 
		     (psq_cb->psq_mode == PSQ_ATBL_ALTER_COLUMN) )
		{
		    /* give error noting DEFAULT <value> as an option
		     */
		    err = E_PS0477_BAD_DEFAULTSYNTAX_SQL92;
		}
		else
		{   /* give error noting WITH DEFAULT option only 
		     */
		    err = E_PS0478_BAD_DEFAULT_SYNTAX;
		}
		_VOID_ psf_error(err, 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 1,
				 length, command);
		return (E_DB_ERROR);

	    } /* end if error */

	} /* end else have INGRES default */
	
	/* close text chain and clear its pointer
	** so we don't try to close/free it again 
	*/
	status = psq_tclose(cb->pss_tchain2, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
	cb->pss_tchain2 = (PTR) NULL;
	
    } break;

case 343:
if (!((*yyvarspp)->bypass_actions))
/* # line 8693 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = (PST_QNODE *) NULL;
    } break;

case 346:
if (!((*yyvarspp)->bypass_actions))
/* # line 8700 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	/*
	** The scanner is unable to distinguish between unary and binary +,
	** and unary and binary -.  Therefore, translate the binary operator
	** ids to unary ones here.
	*/
	if (yacc_cb->yypvt[-1].psl_tytype == ADI_ADD_OP)
	    opnode.pst_opno = ADI_PLUS_OP;
	else if (yacc_cb->yypvt[-1].psl_tytype == ADI_SUB_OP)
	    opnode.pst_opno = ADI_MINUS_OP;

	opnode.pst_opmeta   = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_trtype, (PST_QNODE *) NULL,
	    PST_UOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, 0);

	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 348:
if (!((*yyvarspp)->bypass_actions))
/* # line 8733 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = TRUE;    /* set flag that WITH was seen; check in WITH DEFAULT */
    } break;

case 349:
if (!((*yyvarspp)->bypass_actions))
/* # line 8737 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = FALSE;
    } break;

case 350:
if (!((*yyvarspp)->bypass_actions))
/* # line 8743 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PSS_CONS	*cons;
	i4		val1=0, val2=0;  /* for trace point checking */
	
	/* don't create a NOT NULL constraint for temp tables or dbprocs;
	** only create the constraint for create table, 
	** and then only if the correct trace point is set (see below).
	**
	** Due to performance problems caused by generating the dummy NOT NULL
	** constraints, we are not generating these constraints in 6.5.
	** These constraints are only needed for Intermediate SQL92
	** catalogs, and we don't need to be compliant with that yet.
	**
	** But a trace point has been added to turn on the dummy-constraint
	** generation so that it can continue to be tested (so that future
	** changes will not break this feature).      B58442
	** 				-roger blumer   01/04/94
	*/
	if (   ( (psq_cb->psq_mode == PSQ_CREATE) ||
	         (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) || 
	         (psq_cb->psq_mode == PSQ_ATBL_ALTER_COLUMN) )
	    && (ult_check_macro(&cb->pss_trace,	
				PSS_GENERATE_NOT_NULL_CONS, &val1, &val2)))
	{
	    /* build a constraint info block
	     */
	    status = psl_ct19s_constraint(cb, 
		       (i4) PSS_CONS_CHECK|PSS_CONS_COL|PSS_CONS_NOT_NULL,
				  (PSY_COL *) &(yyvarsp->lastcol),
				  (PSS_OBJ_NAME *) NULL,
				  (PSY_COL *) NULL, (PSS_TREEINFO *) NULL,
				  &cons, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);
		  
	    /* attach new constraint to the list
	     */
	    status = psl_ct21s_cons_name((char *) NULL, cons, &(yyvarsp->cons_list));
	    /*
	     ** NOTE: when decide to implement Intermediate Level SQL92,
	     ** will have to allow a constraint name to be specified 
	     ** for NOT NULL; 
	     ** to do so, just add the constraint_name production as
	     ** the first part of this production and
	     ** replace the NULL ptr in psl_ct21s_cons_name with $1
	     */
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	yacc_cb->yyval.psl_inttype = PSS_TYPE_NOT_NULL;
    } break;

case 351:
if (!((*yyvarspp)->bypass_actions))
/* # line 8797 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PSS_TYPE_NULL;
    } break;

case 352:
if (!((*yyvarspp)->bypass_actions))
/* # line 8805 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PSS_TYPE_NULL;
    } break;

case 353:
if (!((*yyvarspp)->bypass_actions))
/* # line 8811 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{  
	i4	    err_code;

	/* schang: GW error : not allowed for RMSGW */
	if (psq_cb->psq_mode == PSQ_REG_IMPORT)
	{
	    (VOID) psf_error(8004L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) STtrmwhite("system_maintained"),
			     "system_maintained");
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_inttype = PSS_TYPE_SYS_MAINTAINED;
    } break;

case 354:
if (!((*yyvarspp)->bypass_actions))
/* # line 8827 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{  
	i4	    err_code;

	/* schang: GW error : not allowed for RMSGW */
	if (psq_cb->psq_mode == PSQ_REG_IMPORT)
	{
	    (VOID) psf_error(8004L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) STtrmwhite("system_maintained"),
			     "system_maintained");
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_inttype = PSS_TYPE_NOT_SYS_MAINTAINED;
    } break;

case 355:
if (TRUE)	/* NOBYPASS */
/* # line 8845 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	/* we have processed the constraint;
	** turn new_object bit back on, as we could still see more column names
	*/
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    if (yacc_cb->yypvt[-0].psl_constype == (PSS_CONS *) NULL)	/* Ignore if not REFERENTIAL */
		return(E_DB_OK);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** REFERENCES clauses if being done on behalf of CREATE SCHEMA
	    */
	    if (yacc_cb->yypvt[-0].psl_constype == (PSS_CONS *) NULL)	/* Ignore if REFERENTIAL */
	        return(E_DB_OK);
	}

	status = psl_ct21s_cons_name(yacc_cb->yypvt[-1].psl_strtype, yacc_cb->yypvt[-0].psl_constype, &(yyvarsp->cons_list));

	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* If PRIMARY KEY or UNIQUE, NOT NULL is implied. */
	if (yacc_cb->yypvt[-0].psl_constype && (yacc_cb->yypvt[-0].psl_constype->pss_cons_type & PSS_CONS_UNIQUE))
	    yacc_cb->yyval.psl_inttype = PSS_TYPE_NOT_NULL;
	else
	    yacc_cb->yyval.psl_inttype = 0;
    } break;

case 356:
if (TRUE)	/* NOBYPASS */
/* # line 8896 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Don't drive this semantic action for CREATE SCHEMA
	    */
	    yacc_cb->yyval.psl_constype = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}

	/* check that constraints are allowed for this statement 
	 */
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ct19s_constraint(cb, yacc_cb->yypvt[-0].psl_inttype | PSS_CONS_COL, 
				      (PSY_COL *) &(yyvarsp->lastcol),
				      (PSS_OBJ_NAME *) NULL,
				      (PSY_COL *) NULL, (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	yacc_cb->yyval.psl_constype = cons;
    } break;
	}
	return(0);
}

i4
psls7iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 357:
if (TRUE)	/* NOBYPASS */
/* # line 8932 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Don't drive this semantic action for CREATE SCHEMA
	    */
	    yacc_cb->yyval.psl_constype = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	status = psl_ct19s_constraint(cb, 
				      (i4) PSS_CONS_CHECK | PSS_CONS_COL,
				      (PSY_COL *) &(yyvarsp->lastcol),
				      (PSS_OBJ_NAME *) NULL,
				      (PSY_COL *) NULL, yacc_cb->yypvt[-0].psl_treeinfo_type,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	yacc_cb->yyval.psl_constype = cons;
    } break;

case 358:
if (TRUE)	/* NOBYPASS */
/* # line 8961 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_constype = yacc_cb->yypvt[-1].psl_constype;
    } break;

case 359:
if (!((*yyvarspp)->bypass_actions))
/* # line 8967 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    status = psl_cs06s_obj_spec(cb, psq_cb, &(yyvarsp->deplist), yacc_cb->yypvt[-3].psl_objspec,
				        (u_i4)PST_DEP_NOORDER);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** if being done on behalf of CREATE SCHEMA
	    */
	    yacc_cb->yyval.psl_constype = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	/* check that constraints are allowed for this statement 
	 */
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_REF | PSS_CONS_COL,
				      (PSY_COL *) &(yyvarsp->lastcol), yacc_cb->yypvt[-3].psl_objspec, yacc_cb->yypvt[-1].psl_coltype,
				      (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	yacc_cb->yyval.psl_constype = cons;
    } break;

case 360:
if (!((*yyvarspp)->bypass_actions))
/* # line 9020 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    status = psl_cs06s_obj_spec(cb, psq_cb, &(yyvarsp->deplist), yacc_cb->yypvt[-0].psl_objspec,
				        (u_i4)PST_DEP_NOORDER);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** if being done on behalf of CREATE SCHEMA
	    */
	    yacc_cb->yyval.psl_constype = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	/* check that constraints are allowed for this statement 
	 */
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_REF | PSS_CONS_COL,
				      (PSY_COL *) &(yyvarsp->lastcol), yacc_cb->yypvt[-0].psl_objspec,
				      (PSY_COL *) NULL,
				      (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	yacc_cb->yyval.psl_constype = cons;
    } break;

case 364:
if (!((*yyvarspp)->bypass_actions))
/* # line 9081 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_CONS	*cons = cb->pss_curcons;

	if (cons->pss_cons_flags & (PSS_CONS_UPD_CASCADE |
	  PSS_CONS_UPD_SETNULL | PSS_CONS_UPD_RESTRICT | PSS_CONS_UPD_NOACT))
	{	/* already specified an update referential action */
	    i4	err_code;

	    (VOID) psf_error(E_PS04B2_CONS_REFOPTS, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if (yacc_cb->yypvt[-0].psl_inttype == CASCADE) cons->pss_cons_flags |= PSS_CONS_UPD_CASCADE;
	else if (yacc_cb->yypvt[-0].psl_inttype == NULLWORD) cons->pss_cons_flags |= PSS_CONS_UPD_SETNULL;
	else if (yacc_cb->yypvt[-0].psl_inttype == RESTRICT) cons->pss_cons_flags |= PSS_CONS_UPD_RESTRICT;
	else if (yacc_cb->yypvt[-0].psl_inttype == 0) cons->pss_cons_flags |= PSS_CONS_UPD_NOACT;
    } break;

case 365:
if (!((*yyvarspp)->bypass_actions))
/* # line 9100 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_CONS	*cons = cb->pss_curcons;

	if (cons->pss_cons_flags & (PSS_CONS_DEL_CASCADE |
	  PSS_CONS_DEL_SETNULL | PSS_CONS_DEL_RESTRICT | PSS_CONS_DEL_NOACT))
	{	/* already specified a delete referential action */
	    i4	err_code;

	    (VOID) psf_error(E_PS04B2_CONS_REFOPTS, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if (yacc_cb->yypvt[-0].psl_inttype == CASCADE) cons->pss_cons_flags |= PSS_CONS_DEL_CASCADE;
	else if (yacc_cb->yypvt[-0].psl_inttype == NULLWORD) cons->pss_cons_flags |= PSS_CONS_DEL_SETNULL;
	else if (yacc_cb->yypvt[-0].psl_inttype == RESTRICT) cons->pss_cons_flags |= PSS_CONS_DEL_RESTRICT;
	else if (yacc_cb->yypvt[-0].psl_inttype == 0) cons->pss_cons_flags |= PSS_CONS_DEL_NOACT;
    } break;

case 366:
if (!((*yyvarspp)->bypass_actions))
/* # line 9121 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = RESTRICT;
    } break;

case 367:
if (!((*yyvarspp)->bypass_actions))
/* # line 9125 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = CASCADE;
    } break;

case 368:
if (!((*yyvarspp)->bypass_actions))
/* # line 9129 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = NULLWORD;
    } break;

case 369:
if (!((*yyvarspp)->bypass_actions))
/* # line 9133 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (!STcompare(yacc_cb->yypvt[-1].psl_strtype, "no") && !STcompare(yacc_cb->yypvt[-0].psl_strtype, "action"))
		yacc_cb->yyval.psl_inttype = 0;
	else {
	    if (psq_cb->psq_mode == PSQ_CONS) psq_cb->psq_mode = yyvarsp->savemode;
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    } break;

case 370:
if (TRUE)	/* NOBYPASS */
/* # line 9145 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	yacc_cb->yyval.psl_strtype = (char *) NULL;   

	/* there was no new object/constraint name;
	** turn off bit until are done parsing rest of constraint
	*/
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

    } break;

case 371:
if (TRUE)	/* NOBYPASS */
/* # line 9164 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	/* test constraint name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);
	    
	/* we have processed the new object/constraint name;
	** turn off bit until are done parsing rest of constraint
	*/
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 372:
if (!((*yyvarspp)->bypass_actions))
/* # line 9188 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PSS_CONS_UNIQUE;
    } break;

case 373:
if (!((*yyvarspp)->bypass_actions))
/* # line 9192 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PSS_CONS_UNIQUE | PSS_CONS_PRIMARY;
    } break;

case 374:
if (TRUE)	/* NOBYPASS */
/* # line 9199 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	yacc_cb->yyval.psl_coltype = yacc_cb->yypvt[-1].psl_coltype; 
    } break;

case 375:
if (TRUE)	/* NOBYPASS */
/* # line 9214 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	yacc_cb->yyval.psl_coltype = yacc_cb->yypvt[-0].psl_coltype;
    } break;

case 376:
if (TRUE)	/* NOBYPASS */
/* # line 9227 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	/* attach newcol to end of column list 
	** (so they stay in the order the user specified; order is important!)
	*/
	QUinsert((QUEUE *) yacc_cb->yypvt[-0].psl_coltype, yacc_cb->yypvt[-2].psl_coltype->queue.q_prev);
		  
	yacc_cb->yyval.psl_coltype = yacc_cb->yypvt[-2].psl_coltype;
    } break;

case 377:
if (TRUE)	/* NOBYPASS */
/* # line 9247 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PSY_COL		*newcol;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	newcol = (PSY_COL *) NULL;
	
	status = psl_ct20s_cons_col(cb, &newcol, yacc_cb->yypvt[-0].psl_strtype, &psq_cb->psq_error);
	
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	/*
	** remember whether the column name was specified 
	** using a regular or a delimited identifier
	*/
	if (yyvarsp->id_type == PSS_ID_REG)
	{
	    newcol->psy_col_flags |= PSY_REGID_COLSPEC;
	}

	yacc_cb->yyval.psl_coltype = newcol;
    } break;

case 378:
if (!((*yyvarspp)->bypass_actions))
/* # line 9280 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PTR    	    piece;
	DB_STATUS   status;
	
	/* check that constraints are allowed for this statement 
	** (do this check a little earlier than for other constraints,
	**  as the txtemit code and boolean_expr code below will break
	**  for illegal statements [like CREATE PROC])
	*/
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* 
	** set flag that we are processing a check constraint;
        **
	** This is used in the boolean_expr productions to delay type
	** resolution because, for CREATE TABLE, we may not know the type
	** of the column yet (i.e. the CHECK constraint could come before
	** the column definition)
	*/
	cb->pss_stmt_flags |= PSS_PARSING_CHECK_CONS;	    


	/* emit text for CHECK constraints, 
	** so can store it in the constraint info block as the
	** user typed it in, instead of as the parser breaks it up
	** (e.g. as IN or BETWEEN instead of converted into several ORs).
	** This (first) text chain is stored in IIQRYTEXT for the user to see.
	** 
	** We also need to keep a 2nd text chain so that we can add the "NEW"
	** correlation name to its text; this text chain will be used in
	** creating a rule to enforce the constraint.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT | PSS_TXTEMIT2;

	/* initialize text chain, and stick just-parsed CHECK word into it
	 */
	status = psq_topen(&cb->pss_tchain, 
			   &cb->pss_memleft, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	status = psq_tadd(cb->pss_tchain, (u_char *) ERx("CHECK"),
			  sizeof("CHECK") - 1, &piece, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* initialize 2nd chain, and stick NOT into it (for rule)
	 */
	status = psq_topen(&cb->pss_tchain2, 
			   &cb->pss_memleft, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	status = psq_tadd(cb->pss_tchain2, (u_char *) ERx("NOT "),
			  sizeof("NOT ") - 1, &piece, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if processing ALTER TABLE, zero out $Ycheck_cons_cols which will
	** contain a map of attributes referenced inside the constraint
	*/
	if ( (psq_cb->psq_mode == PSQ_ALTERTABLE) ||
	     (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) )
	{
	    i4	    i;

	    DB_COLUMN_BITMAP_INIT((yyvarsp->check_cons_cols.db_domset), i, 0);
	}
	
    } break;

case 379:
if (!((*yyvarspp)->bypass_actions))
/* # line 9353 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	if (psl_seqop_search(yacc_cb->yypvt[-1].psl_treeinfo_type->pss_tree))
	{
	    /* No sequence operators in check constraints. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* turn off CHECK_CONS flag
	 */
	cb->pss_stmt_flags &= ~PSS_PARSING_CHECK_CONS;	    

	/* turn off TXTEMIT flag; the text is actually copied 
	** and the text chain is freed in psl_ct19s_constraint
	*/
	cb->pss_stmt_flags &= ~PSS_TXTEMIT;
	cb->pss_stmt_flags &= ~PSS_TXTEMIT2;

	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-1].psl_treeinfo_type;
    } break;

case 380:
if (!((*yyvarspp)->bypass_actions))
/* # line 9379 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (!yyvarsp->inconstraint)	/* better be following constraint def */
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	yyvarsp->savemode = psq_cb->psq_mode;		/* save query mode */
	psq_cb->psq_mode = PSQ_CONS;		/* & reset for checks */
	/* reset options */
	MEfill(sizeof (yyvarsp->with_clauses), 0, &yyvarsp->with_clauses); 
    } break;

case 381:
if (!((*yyvarspp)->bypass_actions))
/* # line 9391 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4 flags = cb->pss_curcons->pss_cons_flags;
	/* (kibro01) b119050 - Disallow NOINDEX or BASETAB with anything else */
	if ( (flags & PSS_CONS_OTHER_OPTS) &&
	     (flags & (PSS_CONS_NOINDEX | PSS_CONS_BASETAB)) )
	{
	    psl_yerror(3, cb, psq_cb);
	}
	psq_cb->psq_mode = yyvarsp->savemode;		/* reset query mode */
	yacc_cb->yyval.psl_inttype = 0;
	/* reset options */
	MEfill(sizeof (yyvarsp->with_clauses), 0, &yyvarsp->with_clauses);
    } break;

case 382:
if (!((*yyvarspp)->bypass_actions))
/* # line 9407 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{	/* with no index */
	if (!STcompare(yacc_cb->yypvt[-1].psl_strtype, "no"))
	    cb->pss_curcons->pss_cons_flags |= PSS_CONS_NOINDEX;
	else {
	    if (psq_cb->psq_mode == PSQ_CONS) psq_cb->psq_mode = yyvarsp->savemode;
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    } break;

case 383:
if (!((*yyvarspp)->bypass_actions))
/* # line 9417 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Show the presence of index with-opts (one or many) */
	cb->pss_curcons->pss_cons_flags |= PSS_CONS_INDEX_OPTS;
    } break;

case 384:
if (!((*yyvarspp)->bypass_actions))
/* # line 9422 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_curcons->pss_cons_flags |= PSS_CONS_INDEX_OPTS;
    } break;

case 385:
if (TRUE)	/* NOBYPASS */
/* # line 9428 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	/* we have processed the constraint;
	** turn new_object bit back on, as we could still see more column names
	*/
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    if (yacc_cb->yypvt[-1].psl_constype == (PSS_CONS *) NULL)	/* Ignore if not REFERENTIAL */
		return(E_DB_OK);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** REFERENCES clauses if being done on behalf of CREATE SCHEMA
	    */
	    if (yacc_cb->yypvt[-1].psl_constype == (PSS_CONS *) NULL)	/* Ignore if REFERENTIAL */
	        return(E_DB_OK);
	}

	status = psl_ct21s_cons_name(yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-1].psl_constype, &(yyvarsp->cons_list));

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 388:
if (TRUE)	/* NOBYPASS */
/* # line 9477 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** This semantic action is not driven by CREATE SCHEMA
	    */
	    yacc_cb->yyval.psl_constype = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	status = psl_ct19s_constraint(cb, yacc_cb->yypvt[-1].psl_inttype, yacc_cb->yypvt[-0].psl_coltype,
				      (PSS_OBJ_NAME *) NULL,
				      (PSY_COL *) NULL, (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	yyvarsp->inconstraint = TRUE;		/* to allow "with" parsing */
	yacc_cb->yyval.psl_constype = cons;
    } break;

case 389:
if (TRUE)	/* NOBYPASS */
/* # line 9506 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** This semantic action is not driven by CREATE SCHEMA
	    */
	    yacc_cb->yyval.psl_constype = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_CHECK,
				      (PSY_COL *) NULL, (PSS_OBJ_NAME *) NULL,
				      (PSY_COL *) NULL, yacc_cb->yypvt[-0].psl_treeinfo_type,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if this CHECK constraint was specified using ALTER TABLE statement,
	** we need to copy the map of attributes referenced in the <search
	** condition> from $Ycheck_cons_cols into *cons->pss_check_cons_cols
	*/
	if (psq_cb->psq_mode == PSQ_ALTERTABLE) 
	{
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_COLUMN_BITMAP),
		(PTR *) &cons->pss_check_cons_cols, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    STRUCT_ASSIGN_MACRO(yyvarsp->check_cons_cols,
				(*cons->pss_check_cons_cols));
	}
	
	cb->pss_curcons = cons;		/* save for with analysis */
	yyvarsp->inconstraint = TRUE;		/* to allow "with" parsing */
	yacc_cb->yyval.psl_constype = cons;
	cb->pss_curcons = cons;		/* save for with analysis (even if
					** it doesn't make sense for check) */
    } break;

case 390:
if (TRUE)	/* NOBYPASS */
/* # line 9553 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->inconstraint = TRUE;		/* to allow "with" parsing */
	yacc_cb->yyval.psl_constype = yacc_cb->yypvt[-1].psl_constype;
    } break;

case 391:
if (!((*yyvarspp)->bypass_actions))
/* # line 9560 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    status = psl_cs06s_obj_spec(cb, psq_cb, &(yyvarsp->deplist), yacc_cb->yypvt[-1].psl_objspec,
				        (u_i4)PST_DEP_NOORDER);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** if being done on behalf of CREATE SCHEMA
	    */
	    yacc_cb->yyval.psl_constype = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}

	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_REF,
				      yacc_cb->yypvt[-3].psl_coltype, yacc_cb->yypvt[-1].psl_objspec, yacc_cb->yypvt[-0].psl_coltype, (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	yacc_cb->yyval.psl_constype = cons;
    } break;
	}
	return(0);
}

i4
psls8iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 392:
if (!((*yyvarspp)->bypass_actions))
/* # line 9605 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    status = psl_cs06s_obj_spec(cb, psq_cb, &(yyvarsp->deplist), yacc_cb->yypvt[-0].psl_objspec,
				        (u_i4)PST_DEP_NOORDER);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** if being done on behalf of CREATE SCHEMA
	    */
	    yacc_cb->yyval.psl_constype = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}

	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_REF,
				      yacc_cb->yypvt[-2].psl_coltype, yacc_cb->yypvt[-0].psl_objspec, (PSY_COL *) NULL, 
				      (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	yacc_cb->yyval.psl_constype = cons;
    } break;

case 393:
if (TRUE)	/* NOBYPASS */
/* # line 9653 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS               status;

	/*
	** Capture column name for reconstruction of
	** column-level constraints
	*/
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_ATT_NAME),
		(char *) &(yyvarsp->lastcol.psy_colnm.db_att_name));
	yyvarsp->inconstraint = FALSE;

	/*
	** If we are doing CREATE SCHEMA, we are done.
	*/
	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	    return(E_DB_OK);

	/*
	** This rule is part of production used by CREATE TABLE and (gateway)
	** REGISTER TABLE.  For Star's REGISTER, error will be issued in
	** 'typedesc' rule.
	*/
	if (psq_cb->psq_mode != PSQ_REG_LINK)
	{
	    if (   cb->pss_distrib & DB_3_DDB_SESS
		&& yyvarsp->id_type == PSS_ID_DELIM)
	    {
		cb->pss_distr_sflags |= PSS_DELIM_COLNAME;
	    }
	    status = psl_ct13_newcolname(cb, yacc_cb->yypvt[-0].psl_strtype, psq_cb, &yyvarsp->xlated_qry,
					&yyvarsp->scanbuf_ptr);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 394:
if (TRUE)	/* NOBYPASS */
/* # line 9691 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	(VOID) psl_sx_error(2720L, cb, psq_cb);
	YYABORT;
    } break;

case 395:
if (!((*yyvarspp)->bypass_actions))
/* # line 9698 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
		return (E_DB_ERROR);
	}

	status = psl_ct14_typedesc(cb, yacc_cb->yypvt[-2].psl_strtype, 0, (i4 *) NULL, 
			   yacc_cb->yypvt[-1].psl_inttype, yyvarsp->default_node, yyvarsp->default_text, psq_cb, yacc_cb->yypvt[-0].psl_inttype);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-2].psl_strtype;
    } break;

case 396:
if (!((*yyvarspp)->bypass_actions))
/* # line 9722 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS               status;
	i4			len = yacc_cb->yypvt[-3].psl_inttype;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
			&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-5].psl_strtype), yacc_cb->yypvt[-5].psl_strtype);
		return (E_DB_ERROR);
	}
	status = psl_ct14_typedesc(cb, yacc_cb->yypvt[-5].psl_strtype, 1, &len, 
			   yacc_cb->yypvt[-1].psl_inttype, yyvarsp->default_node, yyvarsp->default_text, psq_cb, yacc_cb->yypvt[-0].psl_inttype);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-5].psl_strtype;
    } break;

case 397:
if (!((*yyvarspp)->bypass_actions))
/* # line 9744 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4			parms[2];
	DB_STATUS               status;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
			&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-6].psl_strtype), yacc_cb->yypvt[-6].psl_strtype);
		return (E_DB_ERROR);
	}
	parms[0] = yacc_cb->yypvt[-4].psl_inttype;
	parms[1] = yacc_cb->yypvt[-2].psl_inttype;
	status = psl_ct14_typedesc(cb, yacc_cb->yypvt[-6].psl_strtype, 2, parms, 
			   yacc_cb->yypvt[-0].psl_inttype, yyvarsp->default_node, yyvarsp->default_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-6].psl_strtype;
    } break;

case 398:
if (!((*yyvarspp)->bypass_actions))
/* # line 9768 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*value;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-3].psl_strtype), yacc_cb->yypvt[-3].psl_strtype);
		return (E_DB_ERROR);
	}

	/* One of the TIME/TIMESTAMP's. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-3].psl_strtype, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-1].psl_strtype, &value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = psl_ct14_typedesc(cb, value, 0, (i4 *) NULL, 
			   yacc_cb->yypvt[-0].psl_inttype, yyvarsp->default_node, yyvarsp->default_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-3].psl_strtype;
    } break;

case 399:
if (!((*yyvarspp)->bypass_actions))
/* # line 9800 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*value;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-3].psl_strtype), yacc_cb->yypvt[-3].psl_strtype);
		return (E_DB_ERROR);
	}

	/* One of the INTERVAL xxx TO xxx type's. Glue the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-3].psl_strtype, "to", yacc_cb->yypvt[-1].psl_strtype, 
						&value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = psl_ct14_typedesc(cb, value, 0, (i4 *) NULL, 
			   yacc_cb->yypvt[-0].psl_inttype, yyvarsp->default_node, yyvarsp->default_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-3].psl_strtype;
    } break;

case 400:
if (!((*yyvarspp)->bypass_actions))
/* # line 9833 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*value;
	i4			len = yacc_cb->yypvt[-2].psl_inttype;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-6].psl_strtype), yacc_cb->yypvt[-6].psl_strtype);
		return (E_DB_ERROR);
	}

	/* One of the INTERVAL xxx TO xxx type's. Glue the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-6].psl_strtype, "to", yacc_cb->yypvt[-4].psl_strtype, 
						&value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = psl_ct14_typedesc(cb, value, 1, &len,
			   yacc_cb->yypvt[-0].psl_inttype, yyvarsp->default_node, yyvarsp->default_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-6].psl_strtype;
    } break;

case 401:
if (!((*yyvarspp)->bypass_actions))
/* # line 9867 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*value;
	i4			len = yacc_cb->yypvt[-4].psl_inttype;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-6].psl_strtype), yacc_cb->yypvt[-6].psl_strtype);
		return (E_DB_ERROR);
	}

	/* One of the multi-name date/time's. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-6].psl_strtype, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-1].psl_strtype, &value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = psl_ct14_typedesc(cb, value, 1, &len,
			   yacc_cb->yypvt[-0].psl_inttype, yyvarsp->default_node, yyvarsp->default_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-6].psl_strtype;
    } break;

case 402:
if (!((*yyvarspp)->bypass_actions))
/* # line 9902 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = "with time";
} break;

case 403:
if (!((*yyvarspp)->bypass_actions))
/* # line 9906 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = "with local";
} break;

case 404:
if (!((*yyvarspp)->bypass_actions))
/* # line 9910 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = "without time";
} break;

case 405:
if (!((*yyvarspp)->bypass_actions))
/* # line 9916 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 406:
if (!((*yyvarspp)->bypass_actions))
/* # line 9920 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-1].psl_strtype, yacc_cb->yypvt[-0].psl_strtype, 
						(char *)NULL, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	yacc_cb->yyval.psl_strtype = value;
    } break;

case 407:
if (!((*yyvarspp)->bypass_actions))
/* # line 9932 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, "interval", yacc_cb->yypvt[-0].psl_strtype, 
						(char *)NULL, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	yacc_cb->yyval.psl_strtype = value;
    } break;

case 408:
if (!((*yyvarspp)->bypass_actions))
/* # line 9944 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-1].psl_strtype, yacc_cb->yypvt[-0].psl_strtype, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	yacc_cb->yyval.psl_strtype = value;
    } break;

case 409:
if (!((*yyvarspp)->bypass_actions))
/* # line 9955 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-3].psl_strtype, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-1].psl_strtype, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ct11_tname_name_name(cb, psq_cb, value, yacc_cb->yypvt[-0].psl_strtype,
						(char *) NULL, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	yacc_cb->yyval.psl_strtype = value;
    } break;

case 410:
if (!((*yyvarspp)->bypass_actions))
/* # line 9973 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = -1;
    } break;

case 411:
if (!((*yyvarspp)->bypass_actions))
/* # line 9977 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4			collID;

	if (!psl_validate_collation_name(yacc_cb->yypvt[-0].psl_strtype, &collID))
	{
	    /* report error in collation name. */
	    i4	    err_code;

	    (VOID) psf_error(6424L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
	yacc_cb->yyval.psl_inttype = collID;
    } break;

case 412:
if (!((*yyvarspp)->bypass_actions))
/* # line 9995 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_ct3_crwith(cb, psq_cb->psq_mode, &yyvarsp->with_clauses,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 419:
if (!((*yyvarspp)->bypass_actions))
/* # line 10017 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		if (psq_cb->psq_mode == PSQ_CONS)
		    cb->pss_curcons->pss_cons_flags |= PSS_CONS_OTHER_OPTS;
		} break;

case 421:
if (!((*yyvarspp)->bypass_actions))
/* # line 10023 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		if (psq_cb->psq_mode == PSQ_CONS)
		    cb->pss_curcons->pss_cons_flags |= PSS_CONS_OTHER_OPTS;
		} break;

case 422:
if (!((*yyvarspp)->bypass_actions))
/* # line 10028 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		if (psq_cb->psq_mode == PSQ_CONS)
		    cb->pss_curcons->pss_cons_flags |= PSS_CONS_OTHER_OPTS;
		} break;

case 423:
if (!((*yyvarspp)->bypass_actions))
/* # line 10033 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		if (psq_cb->psq_mode == PSQ_CONS)
		    cb->pss_curcons->pss_cons_flags |= PSS_CONS_OTHER_OPTS;
		} break;

case 424:
if (!((*yyvarspp)->bypass_actions))
/* # line 10045 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct15_distr_with(cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_strtype,
			&yyvarsp->xlated_qry, FALSE, psq_cb);
	}
	else
	{
	    status = psl_nm_eq_nm(cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_strtype, &yyvarsp->with_clauses, psq_cb->psq_mode,
		&psq_cb->psq_error);
	}
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 426:
if (!((*yyvarspp)->bypass_actions))
/* # line 10065 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ yacc_cb->yyval.psl_strtype="table";} break;

case 427:
if (!((*yyvarspp)->bypass_actions))
/* # line 10066 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ yacc_cb->yyval.psl_strtype="row";} break;

case 429:
if (!((*yyvarspp)->bypass_actions))
/* # line 10074 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ yacc_cb->yyval.psl_strtype="base table structure";} break;

case 430:
if (!((*yyvarspp)->bypass_actions))
/* # line 10083 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/* Need special by-hand check for INDEX = BASE TABLE STRUCTURE,
	** because it's only allowed from ALTER TABLE which is in $Ysavemode.
	*/
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"base table structure") == 0)
	{
	    if (psq_cb->psq_mode == PSQ_CONS && yyvarsp->savemode == PSQ_ALTERTABLE)
	    {
		cb->pss_curcons->pss_cons_flags |= PSS_CONS_BASETAB;
	    }
	    else
	    {
		if (psq_cb->psq_mode == PSQ_CONS) psq_cb->psq_mode = yyvarsp->savemode;
		psl_yerror(3, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	}
	else
	{
	    status = psl_nm_eq_nm(cb, ERx("index"), yacc_cb->yypvt[-0].psl_strtype, &yyvarsp->with_clauses, 
		psq_cb->psq_mode, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    } break;
	}
	return(0);
}

i4
psls9iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 431:
if (!((*yyvarspp)->bypass_actions))
/* # line 10114 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/* No quotes allowed in non-distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(E_PS03A7_QUOTED_WITH_CLAUSE, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	status = psl_ct15_distr_with(cb, yacc_cb->yypvt[-2].psl_strtype, sconvert(yacc_cb->yypvt[-0].psl_textype),
		    		&yyvarsp->xlated_qry, TRUE, psq_cb);

        if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 432:
if (!((*yyvarspp)->bypass_actions))
/* # line 10137 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	bool			quote_value = FALSE;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* This is essentially "error", there is no table= option
	    ** outside of STAR.
	    */
	    status = psl_nm_eq_nm(cb, "table", yacc_cb->yypvt[-0].psl_strtype, &yyvarsp->with_clauses,
		psq_cb->psq_mode, &psq_cb->psq_error);
	}
	else
	{
	    if (yyvarsp->id_type == PSS_ID_SCONST)
	    {
		cb->pss_distr_sflags |= PSS_QUOTED_TBLNAME;
		quote_value	= TRUE;
	    }
	    else if (yyvarsp->id_type == PSS_ID_DELIM)
	    {
		cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;
	    }
	    status = psl_ct15_distr_with(cb, "table", yacc_cb->yypvt[-0].psl_strtype,
				&yyvarsp->xlated_qry, quote_value, psq_cb);
	}

        if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 433:
if (!((*yyvarspp)->bypass_actions))
/* # line 10170 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** For Star, keep track of whether local object was delimited
	** so that we can disallow incompatible case translation scenarios
	** when we look up local object.  Turn off flags set in 'crname'
	** production if user has provided WITH TABLE clause.
	*/
	cb->pss_distr_sflags &= ~(PSS_DELIM_TBLNAME|PSS_DELIM_OWNNAME);
    } break;

case 434:
if (!((*yyvarspp)->bypass_actions))
/* # line 10183 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_nm_eq_no(cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_inttype, &yyvarsp->with_clauses, psq_cb->psq_mode,
	    &psq_cb->psq_error, &yyvarsp->xlated_qry);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 435:
if (!((*yyvarspp)->bypass_actions))
/* # line 10203 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		qmode;
	i4		toss_err;

	qmode = psq_cb->psq_mode;
	/* There aren't any single-word options allowed on a partition's
	** with clause.  Rather than add the test to all the various
	** places below, check it right away here.
	*/
	if (cb->pss_stmt_flags & PSS_PARTITION_DEF)
	{
	    (void) psf_error(E_US1931_6449_PARTITION_BADOPT, 0, PSF_USERERR,
			&toss_err, &psq_cb->psq_error, 2,
			0, uld_psq_modestr(qmode),
			STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
	if (qmode == PSQ_CONS && yyvarsp->savemode == PSQ_ALTERTABLE)
	{
	    /* Relocated check for only alter table add constraint option */
	    /* (schka24) This disallows "compression" as a constraint
	    ** index with-option, but I guess one can always use the
	    ** "compression=(key)" flavor.
	    */
	    if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "nojournal_check"))
	    {
		psq_cb->psq_mode = yyvarsp->savemode;
		psl_yerror(3, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	    if (cb->pss_curcons)
		cb->pss_curcons->pss_cons_flags |= PSS_NO_JOURNAL_CHECK;
	    status = E_DB_OK;
	}
	else if (qmode == PSQ_INDEX)
	    status = psl_ci7_index_woword(cb, yacc_cb->yypvt[-0].psl_strtype, &yyvarsp->with_clauses,
		&psq_cb->psq_error);
	else if (qmode == PSQ_CREATE || qmode == PSQ_RETINTO
		 || qmode == PSQ_DGTT || qmode == PSQ_DGTT_AS_SELECT)
	    status = psl_ct6_cr_single_kwd(cb, yacc_cb->yypvt[-0].psl_strtype, &yyvarsp->with_clauses,
		psq_cb->psq_mode, &psq_cb->psq_error, &yyvarsp->xlated_qry);
	else if (qmode == PSQ_MODIFY)
	    status = psl_md9_modopt_word(cb, yacc_cb->yypvt[-0].psl_strtype, &yyvarsp->with_clauses,
		&psq_cb->psq_error);
	else
	{
	    psl_yerror(3, cb, psq_cb);
	    return (E_DB_ERROR);
	}
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 436:
if (TRUE)	/* NOBYPASS */
/* # line 10265 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Turn off the funky special keyword stuff */
	cb->pss_yacc->yy_partalt_kwds = FALSE;

	/* FIXME get rid of this later along with pss_restab goop. */
	if (yyvarsp->create_with_key)
	    cb->pss_restab.pst_reskey = yacc_cb->yypvt[-1].psl_reskey;
	yyvarsp->list_clause = 0;		/* done with this clause */
	yyvarsp->create_with_key = FALSE;
    } break;

case 437:
if (TRUE)	/* NOBYPASS */
/* # line 10282 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	yyvarsp->create_with_key = FALSE;
	status = psl_lst_prefix(cb, psq_cb, yacc_cb->yypvt[-1].psl_strtype, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
	/* **** TEMP until I get everything handled as dmu char */
	/* KEY= option on a create-table-ish thing is handled as a
	** linked list of reskey's
	*/
	if (yyvarsp->list_clause == PSS_KEY_CLAUSE &&
	  (psq_cb->psq_mode == PSQ_CREATE || psq_cb->psq_mode == PSQ_RETINTO
	   || psq_cb->psq_mode == PSQ_DGTT
	   || psq_cb->psq_mode == PSQ_DGTT_AS_SELECT))
	    yyvarsp->create_with_key = TRUE;
	/* If we have a PARTITION= list, turn on the alternate keyword
	** list (replacing the normal keyword list).
	*/
	if (STcompare(yacc_cb->yypvt[-1].psl_strtype,"partition") == 0)
	    cb->pss_yacc->yy_partalt_kwds = TRUE;
    } break;

case 440:
if (!((*yyvarspp)->bypass_actions))
/* # line 10311 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yyvarsp->create_with_key)
	    yacc_cb->yyval.psl_reskey = yacc_cb->yypvt[-0].psl_reskey;
    } break;

case 441:
if (!((*yyvarspp)->bypass_actions))
/* # line 10316 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yyvarsp->create_with_key)
	{
	    PST_RESKEY	*reskey;

	    /*
	    ** Find the last key in the list.
	    */
	    for (reskey = yacc_cb->yypvt[-2].psl_reskey; reskey->pst_nxtkey; reskey = reskey->pst_nxtkey)
	    ;
     
	    reskey->pst_nxtkey = yacc_cb->yypvt[-0].psl_reskey;

	    yacc_cb->yyval.psl_reskey = yacc_cb->yypvt[-2].psl_reskey;
	}
    } break;

case 442:
if (!((*yyvarspp)->bypass_actions))
/* # line 10342 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	char			*letter;
	i4			err_code;
	i4			id_len;
	i4			qmode;
	PST_RESKEY		*reskey;
	u_char			*id_name;
	u_char			delim_buf[DB_MAX_DELIMID+1];

	qmode = psq_cb->psq_mode;
	if (yyvarsp->list_clause != PSS_KEY_CLAUSE)
	{
	    if (yyvarsp->id_type == PSS_ID_DELIM)
	    {
		/* delimited identifiers are not allowed here,
		** so return a syntax error.
		*/
		/* first un-normalize identifier (put double quotes back)
		 */
		id_len  = STlength(yacc_cb->yypvt[-0].psl_strtype);
		id_name = (u_char *) yacc_cb->yypvt[-0].psl_strtype;
		(void) psl_norm_id_2_delim_id(&id_name, &id_len, 
					      delim_buf, &psq_cb->psq_error);
		psf_error(5343L, 0L, PSF_USERERR,
			  &err_code, &psq_cb->psq_error, 2,
			  0, uld_psq_modestr(qmode),
			  id_len, id_name);
		return (E_DB_ERROR);
	    }
	    /*
	    ** Translate nonkeywords to lower case
	    */
	    for (letter =  yacc_cb->yypvt[-0].psl_strtype; *letter != EOS; CMnext(letter))
	        CMtolower(letter, letter);
	}

	if (qmode == PSQ_CREATE || qmode == PSQ_RETINTO
		|| qmode == PSQ_DGTT || qmode == PSQ_DGTT_AS_SELECT
		|| qmode == PSQ_CREATE_SCHEMA)
	{
	    /* Create-table-ish statements */
	    status = psl_ct8_cr_lst_elem(cb, yyvarsp->list_clause, &yyvarsp->part_locs, yacc_cb->yypvt[-0].psl_strtype,
	    	yyvarsp->create_with_key ? &reskey : (PST_RESKEY **) NULL,
		&psq_cb->psq_error, &yyvarsp->xlated_qry);
	}
	else
	{
	    /* Index, modify, constraint-with */
	    status = psl_lst_elem(cb, yyvarsp->list_clause, &yyvarsp->part_locs, yacc_cb->yypvt[-0].psl_strtype, qmode,
		&psq_cb->psq_error);
	}
	if (DB_FAILURE_MACRO(status))
	    return (status);
		    
	if (yyvarsp->create_with_key)
	    yacc_cb->yyval.psl_reskey = reskey;
    } break;

case 443:
if (!((*yyvarspp)->bypass_actions))
/* # line 10401 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Keep yacc type-checking happy */
	yacc_cb->yyval.psl_reskey = NULL;
    } break;

case 447:
if (!((*yyvarspp)->bypass_actions))
/* # line 10415 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	f8		tmp;

	if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
	  *yacc_cb->yypvt[-0].psl_i2type = -(*yacc_cb->yypvt[-0].psl_i2type);
	tmp = *yacc_cb->yypvt[-0].psl_i2type;
	status = psl_lst_relem(cb, yyvarsp->list_clause, &tmp, PSQ_INDEX,
			    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 448:
if (!((*yyvarspp)->bypass_actions))
/* # line 10428 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	f8		tmp;

	if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
	  *yacc_cb->yypvt[-0].psl_i4type = -(*yacc_cb->yypvt[-0].psl_i4type);
	tmp = *yacc_cb->yypvt[-0].psl_i4type;
	status = psl_lst_relem(cb, yyvarsp->list_clause, &tmp, PSQ_INDEX,
			    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 449:
if (!((*yyvarspp)->bypass_actions))
/* # line 10442 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i2		prec_scale;
	i4		prec;
	i4		scale;
	PTR		d;
	u_char	tmpdec[DB_MAX_DECLEN];
	f8		tmp;

	I2ASSIGN_MACRO(*yacc_cb->yypvt[-0].psl_dectype, prec_scale);
	prec = DB_P_DECODE_MACRO(prec_scale);
	scale = DB_S_DECODE_MACRO(prec_scale);
	d = (PTR)(yacc_cb->yypvt[-0].psl_dectype + sizeof(i2));

	if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
	{
	    MEcopy(d, DB_PREC_TO_LEN_MACRO(prec), (PTR)tmpdec);
	    MHpkneg((PTR)tmpdec, prec, scale, d);
	}
	CVpkf(d, prec, scale, &tmp);
	status = psl_lst_relem(cb, yyvarsp->list_clause, &tmp, PSQ_INDEX,
				    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 450:
if (!((*yyvarspp)->bypass_actions))
/* # line 10468 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	f8		tmp;

	if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
	    *yacc_cb->yypvt[-0].psl_f4type = -(*yacc_cb->yypvt[-0].psl_f4type);
	tmp = *yacc_cb->yypvt[-0].psl_f4type;
	status = psl_lst_relem(cb, yyvarsp->list_clause, &tmp, PSQ_INDEX,
				    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 451:
if (!((*yyvarspp)->bypass_actions))
/* # line 10481 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	f8		tmp;

	if (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP)
	    *yacc_cb->yypvt[-0].psl_f8type = -(*yacc_cb->yypvt[-0].psl_f8type);
	tmp = *yacc_cb->yypvt[-0].psl_f8type;

	status = psl_lst_relem(cb, yyvarsp->list_clause, &tmp, PSQ_INDEX,
				    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 452:
if (!((*yyvarspp)->bypass_actions))
/* # line 10509 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_reskey = NULL;
    } break;

case 453:
if (!((*yyvarspp)->bypass_actions))
/* # line 10513 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_reskey = NULL;
    } break;

case 454:
if (!((*yyvarspp)->bypass_actions))
/* # line 10522 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Finish and validate the definition, copy to our QSF object */
	if (psl_partdef_end(cb, psq_cb, yyvarsp) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 456:
if (!((*yyvarspp)->bypass_actions))
/* # line 10533 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	char command[PSL_MAX_COMM_STRING];
	i4 toss_err;
	i4 len;

	if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"subpartition") != 0)
	{
	    psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, &len);
	    (void) psf_error(E_US1930_6448_PARTITION_EXPECTS,
		    0, PSF_USERERR, &toss_err, &psq_cb->psq_error,
		    3, len, command, sizeof("subpartition")-1, "subpartition",
		    STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
	/* continue to parse more dimensions */
    } break;

case 458:
if (!((*yyvarspp)->bypass_actions))
/* # line 10561 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psl_partdef_new_dim(cb, psq_cb, yyvarsp, DBDS_RULE_AUTOMATIC) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 460:
if (!((*yyvarspp)->bypass_actions))
/* # line 10567 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psl_partdef_new_dim(cb, psq_cb, yyvarsp, DBDS_RULE_HASH) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 462:
if (!((*yyvarspp)->bypass_actions))
/* # line 10573 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psl_partdef_new_dim(cb, psq_cb, yyvarsp, DBDS_RULE_LIST) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 464:
if (!((*yyvarspp)->bypass_actions))
/* # line 10579 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psl_partdef_new_dim(cb, psq_cb, yyvarsp, DBDS_RULE_RANGE) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 466:
if (!((*yyvarspp)->bypass_actions))
/* # line 10588 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Done with the list, build DB_PART_LIST for dimension */
	if (psl_partdef_partlist(cb, psq_cb, yyvarsp) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 469:
if (!((*yyvarspp)->bypass_actions))
/* # line 10601 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psl_partdef_oncol(cb,psq_cb,yyvarsp,yacc_cb->yypvt[-0].psl_strtype) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 471:
if (!((*yyvarspp)->bypass_actions))
/* # line 10617 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{yacc_cb->yyval.psl_strtype = REG_ID_CASE_STRING(cb,"on","ON");} break;

case 472:
if (!((*yyvarspp)->bypass_actions))
/* # line 10618 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{yacc_cb->yyval.psl_strtype = REG_ID_CASE_STRING(cb,"to","TO");} break;

case 473:
if (!((*yyvarspp)->bypass_actions))
/* # line 10619 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{yacc_cb->yyval.psl_strtype = REG_ID_CASE_STRING(cb,"automatic","AUTOMATIC");} break;

case 474:
if (!((*yyvarspp)->bypass_actions))
/* # line 10620 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{yacc_cb->yyval.psl_strtype = REG_ID_CASE_STRING(cb,"list","LIST");} break;
	}
	return(0);
}

i4
psls10iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 475:
if (!((*yyvarspp)->bypass_actions))
/* # line 10621 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{yacc_cb->yyval.psl_strtype = REG_ID_CASE_STRING(cb,"hash","HASH");} break;

case 476:
if (!((*yyvarspp)->bypass_actions))
/* # line 10622 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{yacc_cb->yyval.psl_strtype = REG_ID_CASE_STRING(cb,"range","RANGE");} break;

case 477:
if (!((*yyvarspp)->bypass_actions))
/* # line 10623 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{yacc_cb->yyval.psl_strtype = REG_ID_CASE_STRING(cb,"values","VALUES");} break;

case 478:
if (!((*yyvarspp)->bypass_actions))
/* # line 10624 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{yacc_cb->yyval.psl_strtype = REG_ID_CASE_STRING(cb,"partition","PARTITION");} break;

case 481:
if (!((*yyvarspp)->bypass_actions))
/* # line 10640 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Not a typo, define 1 partition */
	if (psl_partdef_nonval(cb, psq_cb, yyvarsp, 1) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 483:
if (!((*yyvarspp)->bypass_actions))
/* # line 10647 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Pass the number of partitions to make */
	if (psl_partdef_nonval(cb, psq_cb, yyvarsp, yacc_cb->yypvt[-2].psl_inttype) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 486:
if (!((*yyvarspp)->bypass_actions))
/* # line 10661 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4 toss_err;

	if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"partitions") != 0)
	{
	    (void) psf_error(E_US1930_6448_PARTITION_EXPECTS,
		    0, PSF_USERERR, &toss_err, &psq_cb->psq_error,
		    3, yyvarsp->qry_len, yyvarsp->qry_name, sizeof("partitions")-1, "partitions",
		    STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 492:
if (!((*yyvarspp)->bypass_actions))
/* # line 10694 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb, TRUE) != E_DB_OK)
	    return(E_DB_ERROR);
	/* Also need to check for iixxx but pname will do that */
	if (psl_partdef_pname(cb, psq_cb, yyvarsp, yacc_cb->yypvt[-0].psl_strtype, FALSE) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 495:
if (!((*yyvarspp)->bypass_actions))
/* # line 10714 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Get a list PARTITION clause started off:
	** All value-opers for LIST are "equal" unless we get a DEFAULT.
	*/
	yyvarsp->first_break = TRUE;
	yyvarsp->value_oper = DBDS_OP_EQ;
	/* continue production... */
    } break;

case 503:
if (!((*yyvarspp)->bypass_actions))
/* # line 10747 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	char buf[2];
	DB_DATA_VALUE emptyval;
	i4 toss_err;
	i4 len;

	if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"default") != 0)
	{
	    (void) psf_error(E_US1930_6448_PARTITION_EXPECTS,
			0, PSF_USERERR, &toss_err, &psq_cb->psq_error,
			3, yyvarsp->qry_len, yyvarsp->qry_name, 0, "default",
			STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
	yyvarsp->value_oper = DBDS_OP_DFLT;
	emptyval.db_datatype = DB_LTXT_TYPE;
	emptyval.db_length = 0;
	emptyval.db_data = &buf[0];
	buf[0] = '\0';
	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&emptyval) != E_DB_OK)
	    return (E_DB_ERROR);
	yyvarsp->value_oper = DBDS_OP_EQ;
    } break;

case 504:
if (!((*yyvarspp)->bypass_actions))
/* # line 10776 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Just make sure we got one const per dimension ON-column */
	if (psl_partdef_value_check(cb, psq_cb, yyvarsp) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 509:
if (!((*yyvarspp)->bypass_actions))
/* # line 10796 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psl_partdef_value(cb,psq_cb,yyvarsp,yacc_cb->yypvt[-1].psl_tytype,yacc_cb->yypvt[-0].psl_dbval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 510:
if (!((*yyvarspp)->bypass_actions))
/* # line 10801 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,yacc_cb->yypvt[-0].psl_dbval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 511:
if (!((*yyvarspp)->bypass_actions))
/* # line 10806 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,NULL) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 512:
if (!((*yyvarspp)->bypass_actions))
/* # line 10811 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DATA_VALUE	dval;
	AD_ADATE	value;

	dval.db_data = (PTR)&value;

	if (status = psl_ansi_strtodt(cb, psq_cb, DB_ADTE_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, (PST_QNODE **)NULL, &dval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&dval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 513:
if (!((*yyvarspp)->bypass_actions))
/* # line 10826 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DATA_VALUE	tval;
	AD_TIME		value;

	tval.db_data = (PTR)&value;

	if (status = psl_ansi_strtodt(cb, psq_cb, DB_TMWO_TYPE, 0,
		       (DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, (PST_QNODE **)NULL, &tval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 514:
if (!((*yyvarspp)->bypass_actions))
/* # line 10841 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DATA_VALUE	tval;
	AD_TIME		value;

	tval.db_data = (PTR)&value;

	if (status = psl_ansi_strtodt(cb, psq_cb, DB_TMW_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, (PST_QNODE **)NULL, &tval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 515:
if (!((*yyvarspp)->bypass_actions))
/* # line 10856 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DATA_VALUE	tval;
	AD_TIME		value;

	tval.db_data = (PTR)&value;

	if (status = psl_ansi_strtodt(cb, psq_cb, DB_TME_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, (PST_QNODE **)NULL, &tval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 516:
if (!((*yyvarspp)->bypass_actions))
/* # line 10871 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DATA_VALUE	tsval;
	AD_TIMESTAMP	value;

	tsval.db_data = (PTR)&value;

	if (status = psl_ansi_strtodt(cb, psq_cb, DB_TSWO_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, (PST_QNODE **)NULL, &tsval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tsval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 517:
if (!((*yyvarspp)->bypass_actions))
/* # line 10886 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DATA_VALUE	tsval;
	AD_TIMESTAMP	value;

	tsval.db_data = (PTR)&value;

	if (status = psl_ansi_strtodt(cb, psq_cb, DB_TSW_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, (PST_QNODE **)NULL, &tsval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tsval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 518:
if (!((*yyvarspp)->bypass_actions))
/* # line 10901 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DATA_VALUE	tsval;
	AD_TIMESTAMP	value;

	tsval.db_data = (PTR)&value;

	if (status = psl_ansi_strtodt(cb, psq_cb, DB_TSTMP_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, (PST_QNODE **)NULL, &tsval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tsval) != E_DB_OK)
	    return (E_DB_ERROR);
    } break;

case 519:
if (!((*yyvarspp)->bypass_actions))
/* # line 10923 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->db_pdata.db_datatype	= DB_LTXT_TYPE;
	yyvarsp->db_pdata.db_prec  	= 0;
	yyvarsp->db_pdata.db_length	= yacc_cb->yypvt[-0].psl_textype->db_t_count + sizeof(u_i2);
	yyvarsp->db_pdata.db_data	= (PTR) yacc_cb->yypvt[-0].psl_textype;
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 522:
if (!((*yyvarspp)->bypass_actions))
/* # line 10944 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i2	op;

	/* Translate/save the BDOP, then keep going */
	op = DBDS_OP_LT;
	if (yacc_cb->yypvt[-0].psl_tytype == ADI_LE_OP) op = DBDS_OP_LTEQ;
	else if (yacc_cb->yypvt[-0].psl_tytype == ADI_GE_OP) op = DBDS_OP_GTEQ;
	else if (yacc_cb->yypvt[-0].psl_tytype == ADI_GT_OP) op = DBDS_OP_GT;
	yyvarsp->value_oper = op;
	/* There's only one break per clause with RANGE, but set the
	** first-time flag anyway so that the value action Does The
	** Right Things.
	*/
	yyvarsp->first_break = TRUE;
	/* continue with production... */
    } break;

case 525:
if (!((*yyvarspp)->bypass_actions))
/* # line 10965 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* This is a recursive WITH clause, save what's going on in the
	** outside world.  Fortunately we only have one level of recursion.
	*/
	yyvarsp->save_list_clause = yyvarsp->list_clause;
	yyvarsp->list_clause = 0;
	MEcopy(&yyvarsp->with_clauses, sizeof(PSS_WITH_CLAUSE), &yyvarsp->save_with_clauses);
	MEfill(sizeof (yyvarsp->with_clauses), 0, &yyvarsp->with_clauses);
    } break;

case 526:
if (!((*yyvarspp)->bypass_actions))
/* # line 10975 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Copy any options seen to a physical-partition data block,
	** and restore the outer WITH context.  Also return to parsing
	** PARTITION keywords, as WITH-parsing uses normal keywords.
	*/
	if (psl_partdef_with(cb, psq_cb, yyvarsp) != E_DB_OK)
	    return (E_DB_ERROR);
	cb->pss_yacc->yy_partalt_kwds = TRUE;
    } break;

case 529:
if (!((*yyvarspp)->bypass_actions))
/* # line 10996 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	
	/* be sure to turn off new-object bit, as it gets reset during
	** tbl_constraint processing (but is only needed for CREATE TABLE
	** because it allows multiple constraints in one statement)
	*/
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

	status = psl_alter_table(cb, psq_cb, yacc_cb->yypvt[-2].psl_rngtype, yyvarsp->cons_list);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 530:
if (!((*yyvarspp)->bypass_actions))
/* # line 11011 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_d_cons(cb, psq_cb, yacc_cb->yypvt[-4].psl_rngtype, yacc_cb->yypvt[-1].psl_strtype,
	    (bool) (yacc_cb->yypvt[-0].psl_tytype == CASCADING_DESTRUCTION));
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 531:
if (!((*yyvarspp)->bypass_actions))
/* # line 11020 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_ATT_NAME	       attname;
	DB_STATUS	       status;

	STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', sizeof(DB_ATT_NAME), (char *) &attname);

	status = psl_alt_tbl_col_add(cb, psq_cb, attname, yyvarsp->cons_list);
	 
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 532:
if (!((*yyvarspp)->bypass_actions))
/* # line 11032 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_ATT_NAME	       attname;
	DB_STATUS	       status;

	STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', sizeof(DB_ATT_NAME), (char *) &attname);

	/* allocate and populate the DMU_CB control block */
	 
	status = psl_alt_tbl_col(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	   return(status);

	status = psl_alt_tbl_col_drop(cb, psq_cb, attname,
	    			      (bool) (yacc_cb->yypvt[-0].psl_tytype == CASCADING_DESTRUCTION));
	 
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 533:
if (!((*yyvarspp)->bypass_actions))
/* # line 11052 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_ATT_NAME            attname;
        DB_STATUS              status;

        STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', sizeof(DB_ATT_NAME), (char *) &attname);

        status = psl_alt_tbl_col_add(cb, psq_cb, attname, yyvarsp->cons_list);

        if (DB_FAILURE_MACRO(status))
            return(status);
    } break;
	}
	return(0);
}

i4
psls11iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 534:
if (!((*yyvarspp)->bypass_actions))
/* # line 11066 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_ATBL_ADD_COLUMN;

	/* allocate and populate the DMU_CB control block */
	 
	status = psl_alt_tbl_col(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	   return(status);
    } break;

case 535:
if (!((*yyvarspp)->bypass_actions))
/* # line 11081 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_ATBL_DROP_COLUMN;
    } break;

case 536:
if (!((*yyvarspp)->bypass_actions))
/* # line 11087 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS              status;

        psq_cb->psq_mode = PSQ_ATBL_ALTER_COLUMN;

        /* allocate and populate the DMU_CB control block */

        status = psl_alt_tbl_col(cb, psq_cb);

        if (DB_FAILURE_MACRO(status))
           return(status);
    } break;

case 537:
if (!((*yyvarspp)->bypass_actions))
/* # line 11102 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS  status;
	PSS_RNGTAB *rngvar;

	/* verify that table exists, and put its info into cb->pss_usrrng
	 */
	status = psl_alt_tbl(cb, psq_cb, yacc_cb->yypvt[-0].psl_objspec, &rngvar);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	yacc_cb->yyval.psl_rngtype = rngvar;
    } break;

case 538:
if (!((*yyvarspp)->bypass_actions))
/* # line 11118 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* set query mode here, because it needs to be set before 
	** the obj_spec production (SESSION checks are done there)
	*/
	psq_cb->psq_mode = PSQ_ALTERTABLE;
    } break;

case 545:
if (TRUE)	/* NOBYPASS */
/* # line 11143 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* we are done processing the new object names */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    } break;

case 546:
if (TRUE)	/* NOBYPASS */
/* # line 11148 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	i4		    err_code;

#ifdef	xDEBUG
	psl_debug();
#endif
	if (yyvarsp->seq_ops)
	{
	    /* No use of sequences in view definitions. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special processing for CREATE SCHEMA
	    */
	    status = psl_cs04s_create_view(cb, psq_cb, yyvarsp->stmtstart,
			yyvarsp->deplist);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	    return(E_DB_OK);
	}

	/*
	** CAUTION: here I am using the knowledge that the $Y vars can be
	** accessed by dereferencing through yyvarsp
	*/
	status = psl_cv1_create_view(cb, psq_cb, yacc_cb->yypvt[-4].psl_trtype, yacc_cb->yypvt[-1].psl_trtype, yacc_cb->yypvt[-0].psl_bool, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 547:
if (!((*yyvarspp)->bypass_actions))
/* # line 11186 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	    *snode = (PST_STATEMENT *) cb->pss_object;
	PST_CREATE_VIEW     *crt_view = &snode->pst_specific.pst_create_view;
	QEUQ_CB		    *qeuq_cb = (QEUQ_CB *) crt_view->pst_qeuqcb;
	DMU_CB		    *dmu_cb = (DMU_CB *) qeuq_cb->qeuq_dmf_cb;

	/* Copy the table name into PST_CREATE_VIEW and DMU_CB */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_TAB_NAME), (char *) &crt_view->pst_view_name);
	STRUCT_ASSIGN_MACRO(crt_view->pst_view_name, dmu_cb->dmu_table_name);
    } break;

case 548:
if (TRUE)	/* NOBYPASS */
/* # line 11199 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    yyvarsp->submode = PSQ_VIEW;
	    yyvarsp->deplist = (PST_OBJDEP *) NULL;
	    yyvarsp->stmtstart = (char *) cb->pss_prvtok;
	    yyvarsp->cons_list = (PSS_CONS *) NULL;
	    return(E_DB_OK);
	}

	status = psl_cv2_viewstmnt(cb, psq_cb, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* we are about to process the new object name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    } break;

case 549:
if (!((*yyvarspp)->bypass_actions))
/* # line 11228 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_bool = TRUE;
    } break;

case 550:
if (!((*yyvarspp)->bypass_actions))
/* # line 11232 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_bool = FALSE;
    } break;

case 551:
if (!((*yyvarspp)->bypass_actions))
/* # line 11239 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_PROCEDURE	*pnode;
	DB_STATUS	status;
	i4		count = 0;
	i4		firstno=0;
	QSF_RCB		qsf_rb;
	i4		err_code;
	PSS_DBPALIAS	dbpid;
	DB_CURSOR_ID	*dbpidp = (DB_CURSOR_ID *) dbpid;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	PST_DECVAR	*decvar;
	i4		qsf_op;
	register PSS_DECVAR	*parm;
	register DB_DATA_VALUE	*db_data;
	register DB_PARM_NAME	*parm_name;
	register i4		*parm_mode;

	/* Set the query mode, as it was probably altered. */
   	psq_cb->psq_mode = PSQ_CREDBP;
	yyvarsp->isdbp = FALSE;

	/*
	** If we were parsing the dbproc to determine if it is grantable/active
	** and got this far, is is definitely grantable/active.  We don't need
	** to perform the rest of the actions (or, rather, performing some of
	** the actions in the body of this production (e.g. creating a new QP
	** object) is highly unadvisable)
	*/
	if (!(cb->pss_dbp_flags & (PSS_0DBPGRANT_CHECK | PSS_CHECK_IF_ACTIVE)))
	{
	    /* Count parms. */
	    for (parm = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
		 parm != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
		 parm = (PSS_DECVAR *) parm->pss_queue.q_next
		)
	    {
		if (parm->pss_out)
		    continue;

		/* We're moving in the next direction, the last
		** one is really the first parm specified.
		*/
		firstno = parm->pss_no;

		count++;
	    }

	    /* Allocate memory for PST_DECVAR */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) (sizeof(PST_DECVAR)), 
		(PTR *) &decvar, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    decvar->pst_nvars = count;
	    decvar->pst_first_varno = firstno;

	    if (count)
	    {
		/* Allocate memory for parm db_data array */
		status = psf_malloc(cb, &cb->pss_ostream,
		    (i4) (count * sizeof(DB_DATA_VALUE)), 
		    (PTR *) &decvar->pst_vardef, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		/* Allocate memory for parm name array */
		status = psf_malloc(cb, &cb->pss_ostream,
		    (i4) (count * sizeof(DB_PARM_NAME)), 
		    (PTR *) &decvar->pst_varname, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		/* Allocate memory for parm mode array */
		status = psf_malloc(cb, &cb->pss_ostream,
		    (i4) (count * sizeof(i4)), 
		    (PTR *) &decvar->pst_parmmode, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		/* Copy db data values, oldest one first */
		for (parm = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_prev,
		     db_data = decvar->pst_vardef,
		     parm_name = decvar->pst_varname,
		     parm_mode = decvar->pst_parmmode;
		     parm != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
		     parm = (PSS_DECVAR *) parm->pss_queue.q_prev
		    )
		{
		    if (parm->pss_out)
			continue;

		    STRUCT_ASSIGN_MACRO(parm->pss_dbdata, *db_data);
		    STRUCT_ASSIGN_MACRO(parm->pss_varname, *parm_name);
		    if (parm->pss_flags & PSS_PPOUT)
			*parm_mode = PST_PMOUT;
		    else if (parm->pss_flags & PSS_PPINOUT)
			*parm_mode = PST_PMINOUT;
		    else *parm_mode = PST_PMIN;

		    /* Allocate memory for default values as necessary. */
		    if (parm->pss_default)
		    {
			status = psf_malloc(cb, &cb->pss_ostream,
			    db_data->db_length, (PTR *) &db_data->db_data,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);
			status = adc_getempty (adf_scb, db_data);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }

		    /* Increment array ptrs */
		    db_data++;
		    parm_name++;
		    parm_mode++;
		}
	    }
	    else
	    {
		decvar->pst_vardef = (DB_DATA_VALUE *) NULL;
		decvar->pst_varname = (DB_PARM_NAME *) NULL;
	    }

	    /* Allocate a procedure node */
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_PROCEDURE),
		(PTR *) &pnode, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /* Fill in the procedure node */
	    pnode->pst_mode = (i2) psq_cb->psq_mode;
	    pnode->pst_vsn = (i2) PST_CUR_VSN;
	    pnode->pst_isdbp = TRUE;
	    pnode->pst_flags = 0;
	    pnode->pst_stmts = yacc_cb->yypvt[-0].psl_stmt;
	    pnode->pst_parms = decvar;

	    if (cb->pss_dbp_flags & PSS_SET_INPUT_PARAM)
		pnode->pst_flags |= PST_SET_INPUT_PARAM;

	    /* Fix the root in QSF */
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode,
	        &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
	        return (status);

	    if (cb->pss_dbp_flags & PSS_RECREATE)
	    {
		/* 
		** psq_recreate() has already done QSO_TRANS_OR_DEFINE and 
		** the QP object's BE id was placed into psq_cb->psq_cursid 
		** from which we will now copy it into pnode->pst_dbpid
		*/
		STRUCT_ASSIGN_MACRO(psq_cb->psq_cursid, pnode->pst_dbpid);
	    }
	    else
	    {
	        /* 
		** do special things if we are creating the procedure for the
	        ** first time (instead of parsing it to recreate the query plan)
	        */

	        /* build FE and BE object ids for the QP object */
	        psq_dbp_qp_ids(cb, dbpid, &pnode->pst_dbpid, 
		    &yyvarsp->dbpinfo->pss_ptuple.db_dbpname, 
		    &yyvarsp->dbpinfo->pss_ptuple.db_owner);

		/*
		** Finish emitting text properly. Put the query text
		** in a contiguous block in QSF.
		**
		** NOTE: this text stream is also used by psl_fill_proc_params
		**       to allocate memory for tuples passed to PSY.
		**       Thus, this must come BEFORE calling that procedure.
		*/
		status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
		    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream,
		    psq_cb->psq_txtout);

		/* check for a set-input parameter */
		if (cb->pss_dbp_flags & PSS_SET_INPUT_PARAM)
		{
		    /*
		    ** If we have a set-input parameter, we don't optimize the
		    ** query tree until the procedure is executed (because then
		    ** it will be re-created with an _instantiated_ set).  So
		    ** we change the query mode to show we are creating a
		    ** set-input dbproc, and SCF knows not to optimize it.
		    ** 		
		    ** But we don't free the query tree object because other
		    ** things besides the query tree are stored in that memory
		    ** stream.  That stream will get freed up by SCF after it
		    ** calls PSY.
		    */
		    psq_cb->psq_mode = PSQ_CRESETDBP;

		    /* set up procedure parameters for passing to RDF/QEF
		    ** (this is done by PSY)
		    */
		    status = psl_fill_proc_params(cb, 
						  yyvarsp->dbpinfo->pss_setparmno,
						  &yyvarsp->dbpinfo->pss_setparmq, 
						  TRUE, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return(status);

		}  /* end if PSS_SET_INPUT_PARAM */
		else
		{
		    /* set up procedure parameters for passing to RDF/QEF
		    ** (this is done by PSY).
		    */
		    status = psl_fill_proc_params(cb,
						  yyvarsp->dbpinfo->pss_procparmno,
						  &(yyvarsp->dbpinfo->pss_varq), 
						  FALSE, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return(status);
		}		    

	        /*
	        ** For procedure we need to define or translate
	        ** the procedure id because QEPs are shareable.
	        */
		qsf_rb.qsf_type = QSFRB_CB;
		qsf_rb.qsf_ascii_id = QSFRB_ASCII_ID;
		qsf_rb.qsf_length = sizeof(qsf_rb);
		qsf_rb.qsf_owner = (PTR)DB_PSF_ID;
		qsf_rb.qsf_sid = cb->pss_sessid;
	        qsf_rb.qsf_feobj_id.qso_type = QSO_ALIAS_OBJ;
	        qsf_rb.qsf_feobj_id.qso_lname = sizeof(dbpid);
	        (VOID)MEcopy((PTR) dbpid, sizeof(dbpid),
		    (PTR) qsf_rb.qsf_feobj_id.qso_name);
	        qsf_rb.qsf_obj_id.qso_type = QSO_QP_OBJ;
	        qsf_rb.qsf_obj_id.qso_lname = sizeof(DB_CURSOR_ID);
	        (VOID)MEcopy((PTR) &pnode->pst_dbpid,
		    sizeof(DB_CURSOR_ID),
		    (PTR) qsf_rb.qsf_obj_id.qso_name);
    
	        /* 
		** if creating a set-input procedure for the first time,
	        ** we do not want to create (DEFINE) a query plan.
	        ** Yet we still want to destroy any existing query plans for a
	        ** procedure with the same name in the same schema,
	        ** so we still try to TRANSLATE the procedure name into a QP id.
	        */ 
		qsf_op = 
		    (psq_cb->psq_mode == PSQ_CRESETDBP) ? QSO_JUST_TRANS 
							: QSO_TRANS_OR_DEFINE;
    
	        qsf_rb.qsf_lk_state = QSO_FREE;
	        status = qsf_call(qsf_op, &qsf_rb);
    
	        if (DB_FAILURE_MACRO(status))
	        {
		    if ((qsf_rb.qsf_error.err_code == E_QS0019_UNKNOWN_OBJ)	
		        && (qsf_op == QSO_JUST_TRANS))
		    {
		        /* didn't find object, which is OK in this case */
		        status = E_DB_OK;
		    }
		    else
		    {
		        (VOID) psf_error(E_PS0379_QSF_T_OR_D_ERR,
				         qsf_rb.qsf_error.err_code, PSF_INTERR,
				         &err_code, &psq_cb->psq_error, 0);
		        return (status);
		    }
	        }	

	        if (qsf_rb.qsf_t_or_d == QSO_WASTRANSLATED)
	        {
		    /*
		    ** If not recreating procedure, may find an existing QEP
		    ** if same user/role is creating a procedure with the same
		    ** name in 2 different sessions OR if a user issues CREATE
		    ** PROCEDURE, does a rollback (destroying catalog entries),
		    ** and then runs CREATE PROCEDURE again.
		    ** 
		    ** At any rate, if an alias exists, we delete it
		    ** and create a new one.
		    */
 
		    /* Get ready to destroy the ALIAS. */
		    qsf_rb.qsf_lk_state = QSO_SHLOCK;
 
		    status = qsf_call(QSO_GETHANDLE, &qsf_rb);
 
		    if (DB_FAILURE_MACRO(status))
		    {
			_VOID_ psf_error(E_PS0A0B_CANTGETHNDLE,
			    qsf_rb.qsf_error.err_code, PSF_INTERR, &err_code,
			    &psq_cb->psq_error, 0);
			return(status);
		    }
 
		    /* Now destroy the ALIAS and the QP objects in QSF */
		    status = qsf_call(QSO_DESTROY, &qsf_rb);
 
		    if (DB_FAILURE_MACRO(status))
		    {
			_VOID_ psf_error(E_PS0A09_CANTDESTROY,
			    qsf_rb.qsf_error.err_code, PSF_INTERR, &err_code,
			    &psq_cb->psq_error, 0);
			return(status);
		    }
 
		    /* Reinitialize part of the QSF ctrl block,
		    ** because QSO_WASTRANSLATED code means that
		    ** the translated value was placed in 'qsf_obj_id'
		    */
		    qsf_rb.qsf_obj_id.qso_type = QSO_QP_OBJ;
		    qsf_rb.qsf_obj_id.qso_lname = sizeof(DB_CURSOR_ID);
		    MEcopy((PTR) &pnode->pst_dbpid, sizeof(DB_CURSOR_ID),
			(PTR) qsf_rb.qsf_obj_id.qso_name);
 
		    qsf_rb.qsf_lk_state = QSO_FREE;
		    status = qsf_call(qsf_op, &qsf_rb);
 
		    if (DB_FAILURE_MACRO(status))
		    {
			if ((qsf_rb.qsf_error.err_code == E_QS0019_UNKNOWN_OBJ)	
			    && (qsf_op == QSO_JUST_TRANS))
			{
			    /* didn't find object, which is OK in this case */
			    status = E_DB_OK;
			}
			else
			{
			    _VOID_ psf_error(E_PS0379_QSF_T_OR_D_ERR,
					qsf_rb.qsf_error.err_code, PSF_INTERR,
					&err_code, &psq_cb->psq_error, 0);
			    return (status);
			}
		    }
    
		    if (qsf_rb.qsf_t_or_d == QSO_WASTRANSLATED)
		    {
			/* We need to retry; looks like there is some
			** concurrent activity going on.
			*/
			psq_cb->psq_error.err_code = E_PS0008_RETRY;
			/* parser will free the stream, but this handle is never
		     cleared. The sequencer tries to free it on the retry.*/
			psq_cb->psq_txtout.qso_handle = (PTR) NULL;
			return (E_DB_ERROR);
		    }
	        }	/* end if QSO_TRANSLATED */
    
		/*
		** Following assignment is done so that SCF can extract
		** proc name and pass it in PSY_CB to psy_call when
		** creating a procedure.
		*/
		STRUCT_ASSIGN_MACRO(pnode->pst_dbpid, psq_cb->psq_cursid);
	    }

#ifdef	xDEBUG
	    {
		i4 val1;
		i4 val2;

		if (ult_check_macro(&cb->pss_trace, 15, &val1, &val2))
		{   
		    _VOID_ pst_dbpdump(pnode, 0);	    /* pst_next */
		}
	    }
#endif

	    /* As the very last action fix the pst_next ptrs where necessary,
	    ** also change pst_type in WHILE statements to PST_IF_TYPE.
	    */
	    _VOID_ psl_backpatch(yacc_cb->yypvt[-0].psl_stmt, (PST_STATEMENT *) NULL);

#ifdef	xDEBUG
	    {
		i4 val1;
		i4 val2;

		if (ult_check_macro(&cb->pss_trace, 14, &val1, &val2))
		{   
		    _VOID_ pst_dbpdump(pnode, 1);	    /* pst_link */
		}
	    }
#endif
	}
    } break;

case 552:
if (!((*yyvarspp)->bypass_actions))
/* # line 11634 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PTR		       piece;

	/* "[CREATE] PROCEDURE" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		sizeof("CREATE PROCEDURE") - 1, "CREATE PROCEDURE");
	    return (E_DB_ERROR);
	}

	/* Set the query mode for proper recovery from syntax errors.
	** the mode will be changed by any DML statement, but it shall
	** be later restored to the proper value.
	*/
	psq_cb->psq_mode = PSQ_CREDBP;

	yyvarsp->isdbp = TRUE;

	/* 
        ** Indicate to other routines that where are parsing a database
	** procedure
	*/
	cb->pss_dbp_flags |= PSS_DBPROC;

	/* Open the memory stream for allocating the query tree */
	status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if processing a "true" [re]create (i.e. not reparsing a dbproc to
	** determine whether it is grantable or active), open a memory stream
	** for allocating lists of objects and privileges on which this dbproc
	** depends
	*/
	if (!(cb->pss_dbp_flags & (PSS_0DBPGRANT_CHECK | PSS_CHECK_IF_ACTIVE)))
	{
	    PSF_MSTREAM                 mem_stream;

	    status = psf_mopen(cb, QSO_QTEXT_OBJ, &mem_stream, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    /*
	    ** far out: we will allocate a stream descriptor using the stream
	    ** itself; sess_cb->pss_dependencies_stream will point at this new 
	    ** descriptor so that if an exception occurs, the exception handler
	    ** will be able to release the memory associated with the stream.
	    */
	    status = psf_malloc(cb, &mem_stream, sizeof(PSF_MSTREAM),
		(PTR *) &cb->pss_dependencies_stream, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    STRUCT_ASSIGN_MACRO(mem_stream, (*cb->pss_dependencies_stream));
	}
	    
	/*
	** We may need to determine if the dbproc is "grantable".
	** If we find that the dbproc is grantable, its QP will be
	** accessible to everyone; otherwise, we will create a QP
	** accessible only by the owner of the dbproc.
	** 
	** In general, until proven otherwise, we'll assume that dbproc is
	** grantable.
	**
	** 3/26/92 (andre)
	**	when trying to establish whether a dbproc P is "at least active"
	**	(as would happen when we are parsing a new dbproc or recreating
	**	a dormant dbproc for execution by its owner), we may end up
	**	reparsing dormant dbprocs invoked by P (this can be detected by
	**	checking whether PSS_CHECK_IF_ACTIVE is set).
	**	The alternative which I originally considered involved checking
	**	invoked dbproc on the subject of them being grantable and, based
	**	on this information, determining whether P is grantable.
	**	Unfortunately, maintaining and using a privilege list where some
	**	privileges are grantable and others are not makes the algorithm
	**	more complicated. Eventually, I may choose to do it that way,
	**	but for the time being I will not attempt to determine whether
	**	the invoked dbproc is grantable (i.e. we will not set
	**	PSS_DBPGRANT_OK bit.)
	*/
	if (~cb->pss_dbp_flags & PSS_CHECK_IF_ACTIVE)
	{
	    cb->pss_dbp_flags |= PSS_DBPGRANT_OK;
	}

	if (~cb->pss_dbp_flags & PSS_RECREATE)
	{
	    /*
	    ** The "create procedure" statement requires query text to be stored
	    ** in the iiqrytext relation.  Open a text chain and put the initial
	    ** words just parsed in it.  The text chain will be coalesced into
	    ** a contiguous block later.
	    */
	    cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */

	    status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
		&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    if (yacc_cb->yypvt[-1].psl_tytype)
	    {
		status = psq_tadd(cb->pss_tchain,
		    (u_char *) "create procedure ",
		    sizeof("create procedure ") - 1, &piece,
		    &psq_cb->psq_error);
	    }
	    else
	    {
		status = psq_tadd(cb->pss_tchain, (u_char *) "procedure ",
		    sizeof("procedure ") - 1, &piece, &psq_cb->psq_error);
	    }
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /*
	    ** during parsing of dbproc definition we will insist on up-to-date
	    ** RDF cache info and report errors
	    */
	    cb->pss_retry = PSS_REPORT_MSGS | PSS_REFRESH_CACHE;
	}

	/*
	** group and role permits will be disregarded when parsing definitions
	** of views, rules, and database procedures
	*/
	cb->pss_stmt_flags |= PSS_DISREGARD_GROUP_ROLE_PERMS;
    } break;

case 553:
if (!((*yyvarspp)->bypass_actions))
/* # line 11772 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = 1;
    } break;

case 554:
if (!((*yyvarspp)->bypass_actions))
/* # line 11776 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 555:
if (!((*yyvarspp)->bypass_actions))
/* # line 11782 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DBP_NAME	dbpname;
	i4		dbpshow_flags;
	i4		err_code;
        DB_STATUS	local_status;
        i4              access = 0;
   
	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (VOID) psf_error(E_PS0421_CRTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("CREATE PROCEDURE") - 1, "CREATE PROCEDURE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

	/* test procedure name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	STmove(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, ' ', 
	       sizeof(DB_DBP_NAME), dbpname.db_dbp_name);

        /* Verify the user has CREATE_PROCEDURE permission */
        if (!(cb->pss_dbp_flags & PSS_RECREATE))
        {
	    char	*ch1 = yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name;
# ifndef DOUBLEBYTE
	    char	*ch2 = ch1 + CMbytecnt(ch1);
# else
	    char	*ch2;
	    
	    ch2 = ch1 + CMbytecnt(ch1);
# endif /* #ifndef DOUBLEBYTE */
	    
            status = psy_ckdbpr(psq_cb, (u_i4)DBPR_PROC_CREATE);
            if (status)
            {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_ERROR	e_error;
		    /*
		    ** Audit failure to create procedure
		    */
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&dbpname, &cb->pss_user,
			    sizeof(DB_TAB_NAME), SXF_E_PROCEDURE,
			    I_SX2012_DBPROC_CREATE, SXF_A_FAIL | SXF_A_CREATE,
			    &e_error);
		}

                (VOID) psf_error(6246L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
                return(status);
            }

	    /*
	    ** In case of a true CREATE nobody but $ingres user may
	    ** create procedures which name starts with 'ii'.
	    */

	    if (!CMcmpnocase(ch1, &SystemCatPrefix[0]) &&
		!CMcmpnocase(ch2, &SystemCatPrefix[1]) &&
		MEcmp((PTR) &cb->pss_user, (PTR) cb->pss_cat_owner,
		      sizeof(DB_OWN_NAME))
	       )
	    {
		(VOID) psf_error(2432L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    STlength(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name), yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name);
		return(E_DB_ERROR);
	    }
        }
  
	status = pst_dbpshow(cb, &dbpname, &yyvarsp->dbpinfo, (DB_OWN_NAME *) NULL,
	    (DB_TAB_ID *) NULL,
	    (cb->pss_dbp_flags & PSS_RECREATE)
		? PSS_USRDBP : (PSS_NEWDBP | PSS_USRDBP),
		psq_cb, &dbpshow_flags);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (dbpshow_flags & (PSS_MISSING_DBPROC | PSS_DUPL_DBPNAME))
	{
	    /*
	    ** if creating a new dbproc and the current user already owns a
	    ** dbproc with that name or if trying to recreate a dbproc which
	    ** does not exist, appropriate bits in dbpshow_flags will be set,
	    ** but status will not be set to E_DB_ERROR
	    */
	    return (E_DB_ERROR);
	}

	(VOID) QUinit(&yyvarsp->dbpinfo->pss_varq);	/* No parms yet */
	yyvarsp->dbpinfo->pss_curvar = (PSS_DECVAR *) NULL;
	yyvarsp->dbpinfo->pss_varno = 0;
	yyvarsp->dbpinfo->pss_bescope = 0;
	yyvarsp->dbpinfo->pss_inloop = 0;
	(VOID) QUinit(&yyvarsp->dbpinfo->pss_loopq);
	yyvarsp->dbpinfo->pss_link =
	    yyvarsp->dbpinfo->pss_last_stmt = (PST_STATEMENT *) NULL;
	(VOID) QUinit(&yyvarsp->dbpinfo->pss_ifq);
	yyvarsp->dbpinfo->pss_into_clause = (PST_QNODE *) NULL;    /* ptr to INTO
							    ** clause tree
							    */
	yyvarsp->dbpinfo->pss_flags = 0;
	yyvarsp->dbpinfo->pss_unreachable_stmt_lvl = 0;

	/* initialize variables used for set-input parameters
	 */
	yyvarsp->dbpinfo->pss_setparmname = (PSS_DECVAR *) NULL;
	yyvarsp->dbpinfo->pss_setparmno   = 0;
	(VOID) QUinit(&yyvarsp->dbpinfo->pss_setparmq);
	yyvarsp->dbpinfo->pss_resrowno   = 0;
	(VOID) QUinit(&yyvarsp->dbpinfo->pss_resrowq);

	yyvarsp->dbpinfo->pss_procparmno = 0;

	/* Initialize BUILT-INS now, they have to be processed before
	** first parm is seen by the parser, since built-ins are to occupy
	** first n slots in var array.
	*/
	{
	    bool		found = FALSE;
	    DB_PARM_NAME	varname;
	    PSS_DECVAR	*var;
            char		*tempstr;

	    /* iirowcount must be first, iierrornumber must be second;
	    ** (see defn of PST_RCNT and PST_ERNO).
	    */
            if (*cb->pss_dbxlate & CUI_ID_REG_U)
	        tempstr = "IIROWCOUNT";
            else
	        tempstr = "iirowcount";
	    STmove(tempstr, ' ', DB_MAXNAME, (char *) &varname);

	    /* Allocate memory for the var entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_DECVAR), 
		(PTR *) &var, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    var->pss_next = (PSS_DECVAR *) NULL;
	    var->pss_no = yyvarsp->dbpinfo->pss_varno++;
	    STRUCT_ASSIGN_MACRO(varname, var->pss_varname);
	    var->pss_scope = yyvarsp->dbpinfo->pss_bescope;	/* universal */
	    var->pss_out = FALSE;
	    
	    var->pss_dbdata.db_data = (PTR) NULL;
	    var->pss_dbdata.db_length = 4;
	    var->pss_dbdata.db_prec = 0;
	    var->pss_dbdata.db_datatype = DB_INT_TYPE;
	    var->pss_dbdata.db_prec = (i2) 0;
	    var->pss_default = 1;

	    /* Attach element to the list, last one will be at the queue head. */
	    (VOID) QUinsert((QUEUE *) var, &yyvarsp->dbpinfo->pss_varq);
            if (*cb->pss_dbxlate & CUI_ID_REG_U)
	        tempstr = "IIERRORNUMBER";
            else
	        tempstr = "iierrornumber";
	    STmove(tempstr, ' ', DB_MAXNAME, (char *) &varname);

	    /* Allocate memory for the var entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_DECVAR), 
		(PTR *) &var, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    var->pss_next = (PSS_DECVAR *) NULL;
	    var->pss_no = yyvarsp->dbpinfo->pss_varno++;
	    STRUCT_ASSIGN_MACRO(varname, var->pss_varname);
	    var->pss_scope = yyvarsp->dbpinfo->pss_bescope;	/* universal */
	    var->pss_out = FALSE;

	    var->pss_dbdata.db_data = (PTR) NULL;
	    var->pss_dbdata.db_prec = 0;
	    var->pss_dbdata.db_length = 4;
	    var->pss_dbdata.db_datatype = DB_INT_TYPE;
	    var->pss_dbdata.db_prec = (i2) 0;
	    var->pss_default = 1;
	    
	    /* Attach element to the list, last one will be at the queue head */
	    (VOID) QUinsert((QUEUE *) var, &yyvarsp->dbpinfo->pss_varq);
	}

	if (~cb->pss_dbp_flags & PSS_RECREATE)
	{
	    /* 
	    ** if creating procedure via an EXECUTE IMMEDIATE statement,
	    ** check for special flags set by QEF
	    */
	    if (psq_cb->psq_info != (PST_INFO *) NULL)
	    {
		if (psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED)
		    cb->pss_dbp_flags |= PSS_SYSTEM_GENERATED;

		if (psq_cb->psq_info->pst_execflags & PST_NOT_DROPPABLE)
		    cb->pss_dbp_flags |= PSS_NOT_DROPPABLE;

		if (psq_cb->psq_info->pst_execflags 
		    & PST_SUPPORTS_CONSTRAINT)
		    cb->pss_dbp_flags |= PSS_SUPPORTS_CONS;

	    }  /* end psq_info != NULL */
	}  /* end if (~cb->pss_dbp_flags & PSS_RECREATE) */
	else
	{
	    /* check if this is a system-generated procedure and set flag
	     */
	    if (yyvarsp->dbpinfo->pss_ptuple.db_mask[0] & DBP_SYSTEM_GENERATED)
	    {
		cb->pss_dbp_flags |= PSS_SYSTEM_GENERATED;
	    }
	}		    

	/*
	** we need to determine id of a base table (other than a core catalog)
	** on which this dbproc depends.  When recreating a dbproc, one could 
	** argue that we should search for dbproc ubt_id only if the dbproc is 
	** dormant and no independent object/privilege list exists for it.  
	** I am choosing to do it regardless of the current status of the dbproc
	** being recreated for fear that its status may change between the time
	** we obtain its description (in this production) and the time we 
	** actually get to make any changes to the IIPROCEDURE tuple
	*/
	cb->pss_dbp_ubt_id.db_tab_base = cb->pss_dbp_ubt_id.db_tab_index = 0;
    } break;

case 557:
if (!((*yyvarspp)->bypass_actions))
/* # line 12020 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* record the number of parameters (before we add local variables)
	** 
	** Note that we must account for the built-in parameters 
	** (which start counting at 0, so we have to adjust by 1).
	*/
	yyvarsp->dbpinfo->pss_procparmno = yyvarsp->dbpinfo->pss_varno - (PST_DBPBUILTIN +1);
    } break;

case 558:
if (!((*yyvarspp)->bypass_actions))
/* # line 12029 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;
	char 	*dbpname;
	i4	val1=0, val2=0;  /* for trace point checking */

	/*   a set-input parameter is only allowed in a CREATE PROCEDURE
	** statement if it is generated by the system (i.e. QEF) in an 
	** Execute Immediate fashion (check PST_INFO to tell this);
	**     We also allow it if we are RECREATing a procedure
	** to re-generate its query plan.
	**     One final case: allow it if trace point PS177 is turned on.
	** If none of these hold true, return a syntax error,
	** as this syntax is not available to the user (yet).
	*/
	/* These limitations have all been removed as a result of the 
	** statement level rules project and the "temp table as 
	** procedure parm" project. */

	/* flag that we are parsing a set-input parameter
	 */
	cb->pss_dbp_flags |= PSS_PARSING_SET_PARAM;

	/* if recreating a set-input procedure for QEF, check that the
	** procedure hasn't changed since the set-input temp table was created.
	*/
	if (cb->pss_dbp_flags & PSS_RECREATE)
	{

	    /* compare the procid found by PSF with the one passed from QEF
	     */
    	    if (   (yyvarsp->dbpinfo->pss_ptuple.db_procid.db_tab_base
				    != psq_cb->psq_set_procid.db_tab_base)
		|| 
		   (yyvarsp->dbpinfo->pss_ptuple.db_procid.db_tab_index
				    != psq_cb->psq_set_procid.db_tab_index))
	    {
		dbpname = yyvarsp->dbpinfo->pss_ptuple.db_dbpname.db_dbp_name;

		if (psq_cb->psq_set_input_tabid.db_tab_base == 0)
				/* SET OF call w. scalar plist? */
			_VOID_ psf_error(2442L, 0L, PSF_USERERR, 
				 &err_code, &psq_cb->psq_error, 1,
				 psf_trmwhite(DB_MAXNAME, dbpname),
				 dbpname);
		else 		/* just plain didn't find it! */
			_VOID_ psf_error(2405L, 0L, PSF_USERERR, 
				 &err_code, &psq_cb->psq_error, 1,
				 psf_trmwhite(DB_MAXNAME, dbpname),
				 dbpname);
		return(E_DB_ERROR);
	    }
	}  /* end if PSS_RECREATE */


	/* remove set name from var queue, and store it away
	**  (QEF expects a set-input procedure to look like it has no params;
	**   QEF will look for the set-input param in the range table instead)
	*/
	yyvarsp->dbpinfo->pss_setparmname = (PSS_DECVAR *) QUremove((QUEUE *) yacc_cb->yypvt[-3].psl_decvar);
	yyvarsp->dbpinfo->pss_varno--;

	/* flag to tell PSY that we are processing
	** a procedure with a set-input parameter
	*/
	cb->pss_dbp_flags |= PSS_SET_INPUT_PARAM;

    } break;

case 559:
if (!((*yyvarspp)->bypass_actions))
/* # line 12097 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;

	i4		maxparm;
	i4		err_code;
	PSS_DECVAR	*var;

	/* Check if the parm limit has been exceeded
	**  (NOTE that the parm limit for set-input procedures is less than
	**  that for other procedures.  Since the set is implemented via a
	**  temporary table, the set cannot have any more parameters (columns)
	**  than a table can.  Normal procedures allow twice that many parms)
	*/
	var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_setparmq.q_next;
	if (var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_setparmq 
	    && var->pss_no >= DB_MAX_COLS)
	{
	    maxparm = DB_MAX_COLS;
	    (VOID) psf_error(2423L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(maxparm), &maxparm);
	    return (E_DB_ERROR);
	}

	/* build a dummy range table for the set parameter,
	** storing it in pss_dbprng.
	** This will be used when SELECT and other statements attempt to
	** reference the set as a table.
	*/
	status = psl_cdbp_build_setrng(cb, psq_cb,
				       yyvarsp->dbpinfo, &cb->pss_dbprng);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* turn off flag since we are done parsing the set-input parameter
	 */
	cb->pss_dbp_flags &= ~PSS_PARSING_SET_PARAM;
    } break;

case 561:
if (!((*yyvarspp)->bypass_actions))
/* # line 12138 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		maxparm;	/* Fix bug if bad param to psf_error */
	i4		err_code;
	PSS_DECVAR	*var;
	QUEUE		*varq;

	if (cb->pss_dbp_flags & PSS_PARSING_SET_PARAM)
	    varq = &(yyvarsp->dbpinfo->pss_setparmq);
	else
	    varq = &(yyvarsp->dbpinfo->pss_varq);
    
	/* Check if the parm limit has been exceeded */
	var = (PSS_DECVAR *) varq->q_next;
	if ((var != (PSS_DECVAR *) varq)
	    && var->pss_no > PSS_DBPPARMMAX
	   )
	{
	    maxparm = PSS_DBPUSRMAX;
	    (VOID) psf_error(2423L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(maxparm), &maxparm);
	    return (E_DB_ERROR);
	}
    } break;

case 563:
if (!((*yyvarspp)->bypass_actions))
/* # line 12167 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	DB_STATUS	status;
	bool		found = FALSE;
	DB_PARM_NAME	varname;
	PSS_DECVAR	*var;
	QUEUE		*varq;
	char		*ch1 = yacc_cb->yypvt[-0].psl_strtype;
# ifndef DOUBLEBYTE
	char		*ch2 = ch1 + CMbytecnt(ch1);
# else
	char		*ch2;
	
	ch2 = ch1 + CMbytecnt(ch1);
# endif /* ifndef DOUBLEBYTE */

	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, (char *) &varname);

	/* Name must not start with 'ii'... */
	/*
	** ...except for internal db procedures built by the 
	** system to support constraints. This is because we 
	** know what the procedure body is and therefore that
	** the name isn't used in such a way that it can 
	** clash with the current built-ins.
	*/
	if ( !CMcmpnocase(ch1, &SystemCatPrefix[0]) &&
	    !CMcmpnocase(ch2, &SystemCatPrefix[1]) && 
	    (~cb->pss_dbp_flags & (PSS_SUPPORTS_CONS|PSS_NOT_DROPPABLE|PSS_SYSTEM_GENERATED)) )
	{
	    (VOID) psf_error(2433L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype,
		STlength(SystemCatPrefix), SystemCatPrefix);
	    return (E_DB_ERROR);	
	}

	/* Name must not start with '$'. */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* Check if var specified for the first time
	** at this scope level.
	** Actually in this release scope levels should
	** not be implemented, there can be only one
	** BEGIN-END block, moreover parameters should
	** be treated as being at the same scope as local vars
	** which implies that names should be unique.
	*/

	/* get appropriate queue
	 */
	if (cb->pss_dbp_flags & PSS_PARSING_SET_PARAM)
	    varq = &(yyvarsp->dbpinfo->pss_setparmq);
	else if (cb->pss_dbp_flags & PSS_PARSING_RESULT_ROW)
	    varq = &(yyvarsp->dbpinfo->pss_resrowq);
	else
	    varq = &(yyvarsp->dbpinfo->pss_varq);

	for (var = (PSS_DECVAR *) varq->q_next;
	     var != (PSS_DECVAR *) varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    /* Commented out for the reason mentioned in
	    ** the comment above.
	    if (var->pss_scope != $Ydbpinfo->pss_bescope)
		continue;
	    */

	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == TRUE)
	{
	    /* Found a duplicate name */
	    (VOID) psf_error(2401L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Allocate memory for the var entry */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_DECVAR), 
	    (PTR *) &var, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	var->pss_next = (PSS_DECVAR *) NULL;
	STRUCT_ASSIGN_MACRO(varname, var->pss_varname);
	var->pss_scope = yyvarsp->dbpinfo->pss_bescope;
	var->pss_out = FALSE;
	var->pss_flags = yacc_cb->yypvt[-1].psl_tytype;
	
	/* Attach element to the list, last one will be at the queue head.
	 */
	(VOID) QUinsert((QUEUE *) var, varq);

	/* Store var number and increment the appropriate counter
	 */
	if (cb->pss_dbp_flags & PSS_PARSING_SET_PARAM)
	    var->pss_no = yyvarsp->dbpinfo->pss_setparmno++;
	else if (cb->pss_dbp_flags & PSS_PARSING_RESULT_ROW)
	    var->pss_no = yyvarsp->dbpinfo->pss_resrowno++;
	else
	    var->pss_no = yyvarsp->dbpinfo->pss_varno++;

	yyvarsp->dbpinfo->pss_curvar = var;

	yacc_cb->yyval.psl_decvar = var;
    } break;

case 566:
if (!((*yyvarspp)->bypass_actions))
/* # line 12289 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 567:
if (!((*yyvarspp)->bypass_actions))
/* # line 12293 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PSS_PPIN;
    } break;

case 568:
if (!((*yyvarspp)->bypass_actions))
/* # line 12297 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_dbp_flags |= PSS_OUT_PARMS;
	yacc_cb->yyval.psl_tytype = PSS_PPOUT;
    } break;

case 569:
if (!((*yyvarspp)->bypass_actions))
/* # line 12302 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_dbp_flags |= PSS_OUT_PARMS;
	yacc_cb->yyval.psl_tytype = PSS_PPINOUT;
    } break;

case 571:
if (!((*yyvarspp)->bypass_actions))
/* # line 12310 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_dbp_flags |= PSS_PARSING_RESULT_ROW;
    } break;

case 572:
if (!((*yyvarspp)->bypass_actions))
/* # line 12314 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_dbp_flags &= ~PSS_PARSING_RESULT_ROW;
    } break;

case 574:
if (!((*yyvarspp)->bypass_actions))
/* # line 12321 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		maxparm;
	i4		err_code;
	PSS_DECVAR	*var;
	QUEUE		*varq;

	/* Just check for too many "columns". */
	var = (PSS_DECVAR *)yyvarsp->dbpinfo->pss_resrowq.q_next;
	if (var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_resrowq &&
		var->pss_no > PSS_DBPROWMAX)
	{
	    maxparm = PSS_DBPROWMAX;
	    (VOID) psf_error(2423L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(maxparm), &maxparm);
	    return (E_DB_ERROR);
	}
    } break;

case 575:
if (!((*yyvarspp)->bypass_actions))
/* # line 12341 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	DB_STATUS	status;
	bool		found = FALSE;
	DB_PARM_NAME	varname;
	PSS_DECVAR	*var;
	QUEUE		*varq;

	/* get appropriate queue
	 */
	varq = &(yyvarsp->dbpinfo->pss_resrowq);

	for (var = (PSS_DECVAR *) varq->q_next;
	     var != (PSS_DECVAR *) varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	/* Allocate memory for the var entry */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_DECVAR), 
	    (PTR *) &var, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	var->pss_next = (PSS_DECVAR *) NULL;
	STRUCT_ASSIGN_MACRO(varname, var->pss_varname);
	var->pss_scope = yyvarsp->dbpinfo->pss_bescope;
	var->pss_out = FALSE;
	
	/* Attach element to the list, last one will be at the queue head.
	 */
	(VOID) QUinsert((QUEUE *) var, varq);

	/* Store var number and increment the appropriate counter
	 */
	var->pss_no = yyvarsp->dbpinfo->pss_resrowno++;

	yyvarsp->dbpinfo->pss_curvar = var;
    } break;

case 576:
if (!((*yyvarspp)->bypass_actions))
/* # line 12391 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;
	}
	return(0);
}

i4
psls12iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 579:
if (!((*yyvarspp)->bypass_actions))
/* # line 12400 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_DECVAR  	*var;
	PST_STATEMENT	*rnode, *lastnd;
	DB_STATUS	status;

	/*
	** Always allocate and add trailing RETURN statement node.  This cheap
	** node clarifies control during execution.  Lastnd could be null after
	** ENDLOOP though a trailing ENDLOOP couldn't really happen here.
	** Do not attach the RETURN node for internal procedures (PSQ_IPROC)
	** as they handle their own return status in QEF.
	*/
	for (lastnd = yacc_cb->yypvt[-1].psl_stmt; lastnd != NULL && lastnd->pst_next != NULL;
	     lastnd = lastnd->pst_next)
	    ;
	if (   lastnd == NULL
	    || (lastnd->pst_mode != PSQ_RETURN && lastnd->pst_mode != PSQ_IPROC)
	   )
	{
	    status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, PSQ_RETURN, PST_RTN_TYPE,
		&rnode, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    rnode->pst_specific.pst_rtn.pst_rtn_value = NULL;

	    if (lastnd != NULL)
		lastnd->pst_next = rnode;
	}

	yacc_cb->yypvt[-3].psl_stmt->pst_next = yacc_cb->yypvt[-1].psl_stmt;

	/* Place local vars out of scope */
	for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_scope == yyvarsp->dbpinfo->pss_bescope)
		var->pss_out = TRUE;	    
	}

	/* The definition of the new scope ends here. */
	yyvarsp->dbpinfo->pss_bescope--;

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-3].psl_stmt;
    } break;

case 580:
if (!((*yyvarspp)->bypass_actions))
/* # line 12450 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* For proper syntax error reporting */
	psq_cb->psq_mode = 0;
    } break;

case 581:
if (!((*yyvarspp)->bypass_actions))
/* # line 12455 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* For proper syntax error reporting */
	psq_cb->psq_mode = 0;
    } break;

case 584:
if (!((*yyvarspp)->bypass_actions))
/* # line 12466 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		count = 0;
	i4		firstno = 0;
	PST_STATEMENT	*snode;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	PST_DECVAR	*decvar;
	register PSS_DECVAR	*var;
	register DB_DATA_VALUE	*db_data;

	/* Count vars. at this scope level */
	for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_scope != yyvarsp->dbpinfo->pss_bescope)
		continue;

	    /* We're moving in the next direction, therefore
	    ** the last local var is really the first one specified.
	    */
	    firstno = var->pss_no;

	    count++;
	}

	/* Allocate memory for PST_DECVAR */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) (sizeof(PST_DECVAR)), 
	    (PTR *) &decvar, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	decvar->pst_nvars = count;

	/*
	** if no vars were declared, both firstno and count will remain 0.
	** In this case, OPF would like to know the number of the first var in
	** this declare, had there been one
	*/
	decvar->pst_first_varno = (count > 0) ? firstno : yyvarsp->dbpinfo->pss_varno;

	if (count)
	{
	    /* Allocate memory for local variable array */
	    status = psf_malloc(cb, &cb->pss_ostream,
		(i4) (count * sizeof(DB_DATA_VALUE)), 
		(PTR *) &decvar->pst_vardef, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /* Copy db data values, oldest one first. */
	    for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_prev,
		 db_data = decvar->pst_vardef;
		 var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
		 var = (PSS_DECVAR *) var->pss_queue.q_prev
		)
	    {
		if (var->pss_scope != yyvarsp->dbpinfo->pss_bescope)
		    continue;

		STRUCT_ASSIGN_MACRO(var->pss_dbdata, *db_data);

		/* LRC requested that all local vars have a default value
		** assigned, even if 'not null not default' has been specified,
		** for this reason the if below has been commented out and
		** getempty will be called for all local vars.
		**
		** Allocate memory for default values as necessary. *
		if (var->pss_default)
		{ */
		    status = psf_malloc(cb, &cb->pss_ostream, db_data->db_length,
			(PTR *) &db_data->db_data, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return (status);
		    status = adc_getempty (adf_scb, db_data);
		    if (DB_FAILURE_MACRO(status))
			return (status);
	      /*}*/
		db_data++;
	    }
	}
	else
	{
	    decvar->pst_vardef = (DB_DATA_VALUE *) NULL;
	}

	decvar->pst_varname = (DB_PARM_NAME *) NULL;
	decvar->pst_parmmode = (i4 *) NULL;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode, PST_DV_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_dbpvar = decvar;

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 586:
if (!((*yyvarspp)->bypass_actions))
/* # line 12570 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* New scope is being defined */
	yyvarsp->dbpinfo->pss_bescope++;
    } break;

case 587:
if (!((*yyvarspp)->bypass_actions))
/* # line 12577 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Initialize query mode for proper handling of syntax errors. */
	/*
	** Please note that in the course of processing internal dbproc, we rely
	** on the fact that psq_mode is set to PSQ_VAR iff declare was present.
	** Do exersize care when changing this.
	*/
	psq_cb->psq_mode = PSQ_VAR;

	/* New scope is being defined */
	yyvarsp->dbpinfo->pss_bescope++;
    } break;

case 590:
if (!((*yyvarspp)->bypass_actions))
/* # line 12597 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	register PSS_DECVAR  *decvar;

	/* The current one is already initialized. */
	for (decvar = yyvarsp->dbpinfo->pss_curvar->pss_next;
	     decvar != (PSS_DECVAR *) NULL;
	     decvar = decvar->pss_next
	    )
	{
	    /* Copy db_data_value and default info. */
	    STRUCT_ASSIGN_MACRO(yyvarsp->dbpinfo->pss_curvar->pss_dbdata,
		decvar->pss_dbdata);
	    decvar->pss_default = yyvarsp->dbpinfo->pss_curvar->pss_default;
	}
    } break;

case 592:
if (!((*yyvarspp)->bypass_actions))
/* # line 12616 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Will create a linked list in the backwards
	** direction sort of, because previous var nodes
	** will be pointed to by the last processed node.
	*/
	yacc_cb->yypvt[-0].psl_decvar->pss_next = yacc_cb->yypvt[-2].psl_decvar;

	yacc_cb->yyval.psl_decvar = yacc_cb->yypvt[-0].psl_decvar;
    } break;

case 593:
if (!((*yyvarspp)->bypass_actions))
/* # line 12628 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_cdbp_typedesc(cb, yyvarsp->dbpinfo, yacc_cb->yypvt[-1].psl_strtype, 0, (i4 *) NULL, yacc_cb->yypvt[-0].psl_inttype,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 594:
if (!((*yyvarspp)->bypass_actions))
/* # line 12637 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_cdbp_typedesc(cb, yyvarsp->dbpinfo, yacc_cb->yypvt[-4].psl_strtype, 1, (i4 *) &yacc_cb->yypvt[-2].psl_inttype, yacc_cb->yypvt[-0].psl_inttype,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 595:
if (!((*yyvarspp)->bypass_actions))
/* # line 12646 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;
	i4			    parms[2];

	parms[0] = yacc_cb->yypvt[-4].psl_inttype;
	parms[1] = yacc_cb->yypvt[-2].psl_inttype;

	status = psl_cdbp_typedesc(cb, yyvarsp->dbpinfo, yacc_cb->yypvt[-6].psl_strtype, 2, parms, yacc_cb->yypvt[-0].psl_inttype, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 596:
if (!((*yyvarspp)->bypass_actions))
/* # line 12658 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;
	char			    *value;

	/* One of the TIME/TIMESTAMP types. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-3].psl_strtype, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-1].psl_strtype, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_cdbp_typedesc(cb, yyvarsp->dbpinfo, value, 0, (i4 *) NULL,
	    yacc_cb->yypvt[-0].psl_inttype, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 597:
if (!((*yyvarspp)->bypass_actions))
/* # line 12673 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;
	char			    *value;

	/* One of the INTERVAL xxx TO xxx types. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-3].psl_strtype, "to", yacc_cb->yypvt[-1].psl_strtype, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_cdbp_typedesc(cb, yyvarsp->dbpinfo, value, 0, (i4 *) NULL,
	    yacc_cb->yypvt[-0].psl_inttype, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 598:
if (!((*yyvarspp)->bypass_actions))
/* # line 12688 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;
	char			    *value;

	/* One of the multi-name DATE/TIME types. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-6].psl_strtype, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-1].psl_strtype, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_cdbp_typedesc(cb, yyvarsp->dbpinfo, value, 1, (i4 *) &yacc_cb->yypvt[-4].psl_inttype, yacc_cb->yypvt[-0].psl_inttype,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 603:
if (!((*yyvarspp)->bypass_actions))
/* # line 12713 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** if the block contained unreachable statements, decrement the level
	** counter (recall that if non-zero, it gets incremented for every block
	** entered);
	** in future we may choose to report it to the user
	*/
	if (yyvarsp->dbpinfo->pss_unreachable_stmt_lvl)
	{
	    yyvarsp->dbpinfo->pss_unreachable_stmt_lvl--;
	}

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-1].psl_stmt;
    } break;

case 604:
if (!((*yyvarspp)->bypass_actions))
/* # line 12728 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*snode;
	char		*c1 = yyvarsp->dbpinfo->pss_ptuple.db_dbpname.db_dbp_name;
	DB_STATUS	status;
# ifndef DOUBLEBYTE
	char		*c2 = c1 + CMbytecnt(c1);
# else
	char		*c2;

	c2 = c1 + CMbytecnt(c1);
# endif /* # ifndef DOUBLEBYTE */

	/*
	** we are about to process the invocation of the internal dbproc.
	** To be correct, it must be true that
	** 1) procedure name must start with "ii"	AND
	** 2) user must have catalog update privilege	AND
	** 3) user must be $ingres			AND
	** 4) there should be no DECLARE section	AND
	** 5) EXECUTE INTERNAL must be the only statement (enforsed by the
	**						   grammar)
	*/

	if ((cb->pss_dbp_flags & PSS_RECREATE) == 0)
	{
	    if (CMcmpnocase(c1, &SystemCatPrefix[0])
		||
		CMcmpnocase(c2, &SystemCatPrefix[1]) 
		|| 
		!(cb->pss_ses_flag & PSS_CATUPD)
		||
		MEcmp((PTR)&cb->pss_user, (PTR)cb->pss_cat_owner,
		      sizeof(DB_OWN_NAME))
		||
		psq_cb->psq_mode == PSQ_VAR	 /* set to PSQ_VAR when see DECLARE */
		||
		STcompare(yacc_cb->yypvt[-2].psl_strtype, "internal"))
	    {
		i4	err_code;
		/*
		** report error to user.  Note that if any one of the above conditions
		** is violated, user had no business having EXECUTE NAME in his
		** database procedure
		*/

		(VOID) psf_error(2587L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    sizeof("execute") - 1, "execute");
		return (E_DB_ERROR);
	    }
	}
    	cb->pss_dbp_flags |= PSS_IPROC;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, PSQ_IPROC, PST_IP_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* For proper syntax error reporting */
	psq_cb->psq_mode = PSQ_CREDBP;

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 605:
if (!((*yyvarspp)->bypass_actions))
/* # line 12793 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;

	yacc_cb->yyval.psl_stmt = (PST_STATEMENT *) NULL;

	/* Empty statement blocks not allowed yet. */
	(VOID) psf_error(2425L, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 0);
	return (E_DB_ERROR);
    } break;

case 606:
if (!((*yyvarspp)->bypass_actions))
/* # line 12806 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* For proper syntax error reporting */
	psq_cb->psq_mode = 0;

	/*
	** if this block is unreachable, or if it is reachable but the first
	** statement in it is ENDLOOP or RETURN, increment the level counter;
	**
	** Note that ENDLOOP node will never be built if ENDLOOP is the first
	** statement in the block; if this is ever changed, we also need to test
	** for $1->pst_type == PST_ENDLOOP_TYPE
	*/
	if (yyvarsp->dbpinfo->pss_unreachable_stmt_lvl ||
	    yacc_cb->yypvt[-0].psl_stmt == (PST_STATEMENT *) NULL	||
	    yacc_cb->yypvt[-0].psl_stmt->pst_type == PST_RTN_TYPE)
	{
	    yyvarsp->dbpinfo->pss_unreachable_stmt_lvl++;
	}
	
	/* $1 may actually point to 2 statements */
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 607:
if (!((*yyvarspp)->bypass_actions))
/* # line 12829 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** if some preceeding statement in this block or some preceeding
	** statement in one of the surrounding blocks was RETURN or ENDLOOP,
	** this statement is not reachable, so there is no need to attach it to
	** the statement list
	*/
	if (yyvarsp->dbpinfo->pss_unreachable_stmt_lvl == 0)
	{
	    if (!yacc_cb->yypvt[-0].psl_stmt)	    /* ENDLOOP statement for which no block was built */
	    {
		yyvarsp->dbpinfo->pss_unreachable_stmt_lvl = 1;
	    }
	    else
	    {
		
		PST_STATEMENT	*snode;

		/* Find last stmt in the list */
		for (snode = yacc_cb->yypvt[-2].psl_stmt;
		     snode->pst_next != (PST_STATEMENT *) NULL;
		     snode = snode->pst_next
		    )
		;

		/* $3 may actually point to 2 statements */
		snode->pst_next = yacc_cb->yypvt[-0].psl_stmt;

		/*
		** if the last statement added to the list was RETURN or
		** ENDLOOP, any subsequent statements in this block and in any
		** blocks contained in this block and occurring after this
		** statement are unreachable
		*/
		if (yacc_cb->yypvt[-0].psl_stmt->pst_type == PST_ENDLOOP_TYPE ||
		    yacc_cb->yypvt[-0].psl_stmt->pst_type == PST_RTN_TYPE)
		{
		    yyvarsp->dbpinfo->pss_unreachable_stmt_lvl = 1;
		}
	    }
	}

	/* For proper syntax error reporting */
	psq_cb->psq_mode = PSQ_CREDBP;

	/* Return ptr to the first one */
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-2].psl_stmt;
    } break;

case 610:
if (!((*yyvarspp)->bypass_actions))
/* # line 12882 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 611:
if (!((*yyvarspp)->bypass_actions))
/* # line 12886 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
	cb->pss_rsdmno = 0;	/* Statement simulated via SELECT */
    } break;

case 612:
if (!((*yyvarspp)->bypass_actions))
/* # line 12891 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;	/* May be a pair of statements */
    } break;

case 613:
if (!((*yyvarspp)->bypass_actions))
/* # line 12895 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt  = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 623:
if (!((*yyvarspp)->bypass_actions))
/* # line 12912 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_STATEMENT	*snode;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode, PST_QT_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_tree = yacc_cb->yypvt[-0].psl_qttype;

	/*
	** unlike views, dbproc is deemed ungrantable only if there is some
	** object (a table, a view, or a database procedure) which requires some
	** privilege P to be accessed in the manner specified in the database
	** procedure, but the dbproc's owner does not posess P WGO on that
	** object.
	**
	**  03-oct-91 (andre)
	**	If we were reparsing a dbproc to determine if it is grantable
	**	(processing GRANT ON PROCEDURE), dopro() will detect lack of
	**	required privileges and return E_DB_ERROR, so this point would
	**	not be reached.
	*/

	/* All necessary inter stmt cleanup within the create procedure
	** statement should occur here. This includes range tables, YACC
	** variables defined in yyvars.h, fields in PSQ_CB and PSS_SESBLK.
	** This a pain but we can't wait until CREATE PROCEDURE is parsed,
	** since the individual statements should parse pretty much the same
	** way as they usually do. The only exceptions are generation of the
	** query tree (whether it includes statement and procedure nodes)
	** and opening of memory streams.
	*/

	/* Start out outside of all where clauses */
	cb->pss_qualdepth = 0;

	/* Start out assuming we're not doing a "define query" command */
	cb->pss_defqry = 0;

	/* Start out with no result range variable */
	cb->pss_resrng = (PSS_RNGTAB *) NULL;

	/* Start out with no result domains */
	cb->pss_rsdmno = 0;

	/* Start out with no target list */
	cb->pss_tlist = (PST_QNODE *) NULL;

	/* Start out with no repeat query parameters */
	cb->pss_highparm = -1;
	cb->pss_targparm = -1;

	/* Start out with no cursor */
	cb->pss_crsr = (PSC_CURBLK *) NULL;

	/* Start out with no result range variable */
	cb->pss_resrng = NULL;

	/*
	** turn off all bits in pss_stmt_flags except for PSS_TXTEMIT which
	** would be set if this is a new procedure
	** 3/25/91 (andre)
	**	PSS_DISREGARD_GROUP_ROLE_PERMS must also stay set
	*/
	cb->pss_stmt_flags &=
	    (PSS_TXTEMIT | PSS_DISREGARD_GROUP_ROLE_PERMS);

	/* reset all bits in pss_flattening_flags */
	cb->pss_flattening_flags = 0;

	/* Initialize the PST_RESTAB struct contents */
	MEfill(sizeof (PST_RESTAB), (u_char) 0,
	    (PTR) &cb->pss_restab);
	MEfill(sizeof (DB_TAB_NAME), (u_char) ' ',
	    (PTR) &cb->pss_restab.pst_resname);
	MEfill(sizeof (DB_OWN_NAME), (u_char) ' ',
	    (PTR) &cb->pss_restab.pst_resown);
	MEfill(sizeof (DM_DATA), (u_char) 0,
	    (PTR) &cb->pss_restab.pst_resloc);
	cb->pss_restab.pst_resvno = -1;

	/* No rules for tree */
	cb->pss_row_lvl_usr_rules  =
	cb->pss_row_lvl_sys_rules  =
	cb->pss_stmt_lvl_usr_rules =
	cb->pss_stmt_lvl_sys_rules =
	cb->pss_row_lvl_usr_before_rules  =
	cb->pss_row_lvl_sys_before_rules  =
	cb->pss_stmt_lvl_usr_before_rules =
	cb->pss_stmt_lvl_sys_before_rules = (PST_STATEMENT *) NULL;

	psl_yinit(cb);

	status = pst_clrrng(cb, &cb->pss_auxrng, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** init AGG list stack for scope 0 (node that the scope, pss_qualdepth,
	** has been set to 0 above)
	*/
	*yyvarsp->agg_list_stack = (YYAGG_NODE_PTR *) NULL;
	yyvarsp->with_journaling = 0;
	yyvarsp->with_location	= 0;
	yyvarsp->with_dups	= PST_DNTCAREDUPS;
	yyvarsp->is_heapsort	= 0;
	yyvarsp->in_target_clause = FALSE;
	yyvarsp->index_struct_specified = 0;
	yyvarsp->indx_struct	= cb->pss_idxstruct;
	yyvarsp->sort_list	= 0;
	yyvarsp->sort_by	= 0;
	yyvarsp->agg_func	= 0;
	yyvarsp->aggr_allowed	= (PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
	yyvarsp->list_clause	= 0;
	(VOID)MEfill(sizeof(yyvarsp->fe_cursor_id), (u_char)0, (PTR)&yyvarsp->fe_cursor_id);
	yyvarsp->qp_shareable	= TRUE;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&yyvarsp->flists[0]);
	yyvarsp->qry_mask      = 0L;
	yyvarsp->nonupdt	= FALSE;
	yyvarsp->nonupdt_reason = 0;

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 625:
if (!((*yyvarspp)->bypass_actions))
/* # line 13042 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)
	{
	    /* error - can only have query in for loop header */
	    i4		err_code;
	    (VOID) psf_error(2443L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* set on in the "insertkwd" production. */
	yyvarsp->dbpinfo->pss_flags &= ~PSS_1SUB_SEEN;
	cb->pss_dbp_flags |= PSS_DATA_CHANGE;
    } break;

case 626:
if (!((*yyvarspp)->bypass_actions))
/* # line 13056 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)
	{
	    /* error - can only have query in for loop header */
	    i4		err_code;
	    (VOID) psf_error(2443L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* set on in the "delstmnt" production. */
	yyvarsp->dbpinfo->pss_flags &= ~PSS_1SUB_SEEN;
	cb->pss_dbp_flags |= PSS_DATA_CHANGE;
    } break;

case 627:
if (!((*yyvarspp)->bypass_actions))
/* # line 13070 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)
	{
	    /* error - can only have query in for loop header */
	    i4		err_code;
	    (VOID) psf_error(2443L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* set on in the "updatekwd" production. */
	yyvarsp->dbpinfo->pss_flags &= ~PSS_1SUB_SEEN;
	cb->pss_dbp_flags |= PSS_DATA_CHANGE;
    } break;

case 628:
if (!((*yyvarspp)->bypass_actions))
/* # line 13086 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*snode;
	DB_STATUS	status;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode = PSQ_COMMIT,
	    PST_CMT_TYPE, &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 629:
if (!((*yyvarspp)->bypass_actions))
/* # line 13099 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*snode;
	DB_STATUS	status;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo,
	    psq_cb->psq_mode = PSQ_ROLLBACK, PST_RBK_TYPE, &snode,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 630:
if (!((*yyvarspp)->bypass_actions))
/* # line 13116 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Processing of the IF statement will be done
	** using following scheme:
	**
	**  IF (c1) THEN	    IF (c1) THEN
	**	s1			s1
	**  ELSEIF (c2) THEN	    ELSE
	**	s2			IF (c2) THEN
	**  ELSEIF (c3) THEN	=	    s2
	**	s3			ELSE
	**  ELSE			    IF (c3) THEN
	**	s4				s3
	**  ENDIF			    ELSE
	**					s4
	**				    ENDIF
	**				ENDIF
	**			    ENDIF
	*/

	/* wrap up processing of the IF statement */
	psl_ifstmt(yacc_cb->yypvt[-5].psl_stmt, yacc_cb->yypvt[-4].psl_treeinfo_type->pss_tree, yacc_cb->yypvt[-2].psl_stmt, yacc_cb->yypvt[-1].psl_stmt, yyvarsp->dbpinfo);

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-5].psl_stmt;
    } break;
	}
	return(0);
}

i4
psls13iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 631:
if (!((*yyvarspp)->bypass_actions))
/* # line 13143 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_ifkwd(cb, psq_cb, yyvarsp->dbpinfo, &yacc_cb->yyval.psl_stmt);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 632:
if (!((*yyvarspp)->bypass_actions))
/* # line 13156 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psl_thenkwd(yyvarsp->dbpinfo);
    } break;

case 633:
if (!((*yyvarspp)->bypass_actions))
/* # line 13162 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psl_elsekwd(yyvarsp->dbpinfo);
    } break;

case 634:
if (!((*yyvarspp)->bypass_actions))
/* # line 13168 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 635:
if (!((*yyvarspp)->bypass_actions))
/* # line 13172 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*stmt;

	/* The ELSE part of last stmt in the elseifpart IF chain
	** takes on $3.
	*/
	for (stmt = yacc_cb->yypvt[-2].psl_stmt;
	     stmt->pst_specific.pst_if.pst_false != (PST_STATEMENT *) NULL;
	     stmt = stmt->pst_specific.pst_if.pst_false
	    )
	{
	    /* Nothing to do */
	}

	stmt->pst_specific.pst_if.pst_false = yacc_cb->yypvt[-0].psl_stmt;

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-2].psl_stmt;
    } break;

case 636:
if (!((*yyvarspp)->bypass_actions))
/* # line 13191 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 637:
if (!((*yyvarspp)->bypass_actions))
/* # line 13195 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = (PST_STATEMENT *) NULL;
    } break;

case 638:
if (!((*yyvarspp)->bypass_actions))
/* # line 13201 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 639:
if (!((*yyvarspp)->bypass_actions))
/* # line 13205 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*stmt;

	/* The ELSE part of last stmt in the cdbp_elseifpart IF chain
	** takes on $2.
	*/
	for (stmt = yacc_cb->yypvt[-1].psl_stmt;
	     stmt->pst_specific.pst_if.pst_false != (PST_STATEMENT *) NULL;
	     stmt = stmt->pst_specific.pst_if.pst_false
	    )
	{
	    /* Nothing to do */
	}

	stmt->pst_specific.pst_if.pst_false = yacc_cb->yypvt[-0].psl_stmt;

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-1].psl_stmt;
    } break;

case 640:
if (!((*yyvarspp)->bypass_actions))
/* # line 13226 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yypvt[-3].psl_stmt->pst_specific.pst_if.pst_condition = yacc_cb->yypvt[-2].psl_treeinfo_type->pss_tree;
	yacc_cb->yypvt[-3].psl_stmt->pst_specific.pst_if.pst_true = yacc_cb->yypvt[-0].psl_stmt;

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-3].psl_stmt;
    } break;

case 641:
if (!((*yyvarspp)->bypass_actions))
/* # line 13235 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_ifkwd(cb, psq_cb, yyvarsp->dbpinfo, &yacc_cb->yyval.psl_stmt);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 642:
if (!((*yyvarspp)->bypass_actions))
/* # line 13249 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_STATEMENT	*ifstmtp;

	if (yacc_cb->yypvt[-3].psl_stmt == NULL)
	{
	    /* error - no select stmt */
	    i4		err_code;
	    (VOID) psf_error(2443L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Re-link so for->query->if->stmtlist */
	ifstmtp = yacc_cb->yypvt[-4].psl_stmt->pst_specific.pst_for.pst_forhead;
	yacc_cb->yypvt[-4].psl_stmt->pst_specific.pst_for.pst_forhead = yacc_cb->yypvt[-3].psl_stmt;
	yacc_cb->yypvt[-3].psl_stmt->pst_next = ifstmtp;
	ifstmtp->pst_specific.pst_if.pst_true = yacc_cb->yypvt[-1].psl_stmt;
	ifstmtp->pst_next = yacc_cb->yypvt[-1].psl_stmt;
	/* Fill in "if" condition to test iirowcount > 0 */
	status = psl_for_cond(cb, psq_cb, yyvarsp->dbpinfo,
		&ifstmtp->pst_specific.pst_if.pst_condition);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	((PSS_LOOP  *)yacc_cb->yypvt[-4].psl_stmt->pst_opf)->pss_out = TRUE;

	/* Now, loop down the contained stmtlist, looking for the last one
	** which then must be attached to the QTREE of the select query.
	*/
	/* {
	    PST_STATEMENT	*snode;
	
	    for (snode = $4; snode && snode->pst_next; snode = snode->pst_next);
	    if (snode) snode->pst_next = $2;
	} */

	/*
	** pss_patch must now contain address of NULL , so that a correct
	** pointer gets updated should we encounter an ENDLOOP immediately
	** following FOR loop.
	*/
	yyvarsp->dbpinfo->pss_patch = (PST_STATEMENT **) NULL;

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-4].psl_stmt;
    } break;

case 643:
if (!((*yyvarspp)->bypass_actions))
/* # line 13301 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_LOOP 	*fnode;
	DB_STATUS	status;
	char		label[DB_MAXNAME];

	if (FALSE && yyvarsp->dbpinfo->pss_flags & PSS_INFOR)
	{
	    /* error - no nested for's */
	    i4		err_code;
	    (VOID) psf_error(2444L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if (yacc_cb->yypvt[-1].psl_strtype != (char *) NULL)
	{
	    bool		found = FALSE;
	    i4			err_code;

	    STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', DB_MAXNAME, (char *) label);

	    /* Check if label specified for the first time. */
	    for (fnode = (PSS_LOOP  *) yyvarsp->dbpinfo->pss_loopq.q_next;
		 fnode != (PSS_LOOP  *) &yyvarsp->dbpinfo->pss_loopq;
		 fnode = (PSS_LOOP  *) fnode->pss_queue.q_next
		)
	    {
		/* Don't look at loops out of scope */
		if (fnode->pss_out == TRUE)
		    continue;

		if (MEcmp((PTR) label, (PTR) fnode->pss_label,
		    DB_MAXNAME) == 0
		   )
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (found)
	    {
		/* Found a duplicate label */
		(VOID) psf_error(2406L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
		return (E_DB_ERROR);
	    }
	}

	/* Allocate for node. */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_LOOP ),
	    (PTR *) &fnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	fnode->pss_out = FALSE;
	(VOID) QUinit(&fnode->pss_fixq);

	/* Fill in the name */
	if (yacc_cb->yypvt[-1].psl_strtype != (char *) NULL)
	{
	    (VOID) MEcopy((PTR) label, DB_MAXNAME, (PTR) fnode->pss_label);
	}
	else
	{
	    (VOID) MEfill(DB_MAXNAME, (u_char) ' ', (PTR) fnode->pss_label);
	}

	/* Attach element to the list, last one will be at the queue head. */
	(VOID) QUinsert((QUEUE *) fnode, &yyvarsp->dbpinfo->pss_loopq);

	/* Allocate FOR statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, PSQ_FOR, PST_FOR_TYPE,
	    &fnode->pss_stmt, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	fnode->pss_stmt->pst_opf = (PTR) fnode;

	/* Allocate FOR statement's IF node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, PSQ_FOR, PST_IF_TYPE,
	    &fnode->pss_stmt->pst_specific.pst_for.pst_forhead, 
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yyvarsp->dbpinfo->pss_flags |= PSS_INCOND;

	/*
	** The FOR statement is internally implemented
	** as a FOR node, followed by the qtree for the select, followed by
	** an IF to test for rows returned. The FOR and IF are allocated and
	** linked here. The QTREE for the select is linked in between in 
	** cdbp_forstmt. 
	*/
	psq_cb->psq_mode = PSQ_FOR;

	yacc_cb->yyval.psl_stmt = fnode->pss_stmt;
	yyvarsp->dbpinfo->pss_flags |= (PSS_INFOR | PSS_INFORQ);
    } break;

case 644:
if (!((*yyvarspp)->bypass_actions))
/* # line 13404 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-1].psl_strtype;
    } break;

case 645:
if (!((*yyvarspp)->bypass_actions))
/* # line 13408 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = (char *) NULL;
    } break;

case 646:
if (!((*yyvarspp)->bypass_actions))
/* # line 13414 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->dbpinfo->pss_inloop--;
	yyvarsp->dbpinfo->pss_flags &= ~PSS_INFOR;
    } break;

case 647:
if (!((*yyvarspp)->bypass_actions))
/* # line 13422 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yypvt[-4].psl_stmt->pst_specific.pst_if.pst_condition = yacc_cb->yypvt[-3].psl_treeinfo_type->pss_tree;
	yacc_cb->yypvt[-4].psl_stmt->pst_specific.pst_if.pst_true = yacc_cb->yypvt[-1].psl_stmt;

	((PSS_LOOP  *)yacc_cb->yypvt[-4].psl_stmt->pst_opf)->pss_out = TRUE;

	/*
	** pss_patch must now contain address of NULL , so that a correct
	** pointer gets updated should we encounter an ENDLOOP immediately
	** following WHILE...ENDWHILE
	*/
	yyvarsp->dbpinfo->pss_patch = (PST_STATEMENT **) NULL;

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-4].psl_stmt;
    } break;

case 648:
if (!((*yyvarspp)->bypass_actions))
/* # line 13440 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-1].psl_strtype;
    } break;

case 649:
if (!((*yyvarspp)->bypass_actions))
/* # line 13444 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = (char *) NULL;
    } break;

case 650:
if (!((*yyvarspp)->bypass_actions))
/* # line 13450 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_LOOP 	*wnode;
	DB_STATUS	status;
	char		label[DB_MAXNAME];

	if (yacc_cb->yypvt[-1].psl_strtype != (char *) NULL)
	{
	    bool		found = FALSE;
	    i4		err_code;

	    STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', DB_MAXNAME, (char *) label);

	    /* Check if label specified for the first time. */
	    for (wnode = (PSS_LOOP  *) yyvarsp->dbpinfo->pss_loopq.q_next;
		 wnode != (PSS_LOOP  *) &yyvarsp->dbpinfo->pss_loopq;
		 wnode = (PSS_LOOP  *) wnode->pss_queue.q_next
		)
	    {
		/* Don't look at WHILEs out of scope */
		if (wnode->pss_out == TRUE)
		    continue;

		if (MEcmp((PTR) label, (PTR) wnode->pss_label,
		    DB_MAXNAME) == 0
		   )
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (found)
	    {
		/* Found a duplicate label */
		(VOID) psf_error(2406L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
		return (E_DB_ERROR);
	    }
	}

	/* Allocate while node. */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_LOOP),
	    (PTR *) &wnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	wnode->pss_out = FALSE;
	(VOID) QUinit(&wnode->pss_fixq);

	/* Fill in the name */
	if (yacc_cb->yypvt[-1].psl_strtype != (char *) NULL)
	{
	    (VOID) MEcopy((PTR) label, DB_MAXNAME, (PTR) wnode->pss_label);
	}
	else
	{
	    (VOID) MEfill(DB_MAXNAME, (u_char) ' ', (PTR) wnode->pss_label);
	}

	/* Attach element to the list, last one will be at the queue head. */
	(VOID) QUinsert((QUEUE *) wnode, &yyvarsp->dbpinfo->pss_loopq);

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, PSQ_IF, PST_WH_TYPE,
	    &wnode->pss_stmt, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	wnode->pss_stmt->pst_opf = (PTR) wnode;

	yyvarsp->dbpinfo->pss_flags |= PSS_INCOND;

	/*
	** The WHILE statement is internally implemented
	** as the IF statement, but let's indicate WHILE
	** for proper display of syntax errors.
	*/
	psq_cb->psq_mode = PSQ_WHILE;

	yacc_cb->yyval.psl_stmt = wnode->pss_stmt;
    } break;

case 651:
if (!((*yyvarspp)->bypass_actions))
/* # line 13534 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->dbpinfo->pss_flags &= ~(PSS_INCOND | PSS_INFORQ);
	yyvarsp->dbpinfo->pss_inloop++;
    } break;

case 652:
if (!((*yyvarspp)->bypass_actions))
/* # line 13541 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->dbpinfo->pss_inloop--;
    } break;

case 653:
if (!((*yyvarspp)->bypass_actions))
/* # line 13552 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_ENDLOOP;
    } break;

case 654:
if (!((*yyvarspp)->bypass_actions))
/* # line 13556 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*snode;
	i4		err_code;

	if (yyvarsp->dbpinfo->pss_inloop == 0)
	{
	    /* ENDLOOP only allowed in a WHILE. */
	    (VOID) psf_error(2426L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** if this statement is unreachable, avoid creating a fix block, and
	** here's why:
	**	Consider:
	**		a: WHILE <condition> DO
	**			...
	**			b: WHILE <condition> DO
	**				...
	**				IF <condition> THEN
	**				    ...
	**				ENDIF
	**				ENDLOOP a;
	**				** I know it doesn't make much sense,
	**				** but that is not to say that we should
	**				** not be able to handle it
	**				**
	**				ENDLOOP b;  
	**				...
	**			ENDWHILE;
	**		    ENDWHILE;
	**		    ...
	**  In this case, if we do not avoid creating a FIX block for the second
	**  ENDLOOP, pst_next in ENDLOOP statement node will be initialized
	**  before processing the body of the first WHILE (as it should be), but
	**  then it will be overwritten before processing the body of the second
	**  WHILE, so that instead of exiting the outer loop, we will simply
	**  exit the inner loop.  A similar example could be constructed with
	**  the two ENDLOOP statements switched if they follow a statement other
	**  then IF...ENDIF.  In that case, rather than exiting the inner loop,
	**  we will exit the outer loop.
	*/
	if (yyvarsp->dbpinfo->pss_unreachable_stmt_lvl != 0)
	{
	    snode = (PST_STATEMENT *) NULL;
	}
	else
	{
	    DB_STATUS	status;
	    PSS_LOOP 	*wnode, *wlast;
	    bool	found = FALSE;
	    PSS_FIXSTMT	*fix;
	    char	label[DB_MAXNAME];

	    if (yacc_cb->yypvt[-0].psl_strtype)
	    {
		STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, (char *) label);
	    }

	    for (wnode = (PSS_LOOP  *) yyvarsp->dbpinfo->pss_loopq.q_next,
		 wlast = (PSS_LOOP  *) &yyvarsp->dbpinfo->pss_loopq;
		 
		 wnode != wlast;

		 wnode = (PSS_LOOP  *) wnode->pss_queue.q_next
		)
	    {
		/* Don't look at WHILEs out of scope */
		if (wnode->pss_out == TRUE)
		    continue;

		/* If ENDLOOP specified label, compare names
		** otherwise the first WHILE is good enough.
		*/
		if (yacc_cb->yypvt[-0].psl_strtype)
		{
		    if (MEcmp((PTR) label, (PTR) wnode->pss_label,
			DB_MAXNAME) == 0
		       )
		    {
			found = TRUE;
			break;
		    }
		}
		else
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (!found)
	    {
		/* ENDLOOP doesn't have a matching WHILE or
		** label is undeclared.
		*/
		if (yacc_cb->yypvt[-0].psl_strtype)
		{
		    (VOID) psf_error(2407L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		}
		else
		{
		    /*  This code should probably 
		    ** never be reached.
		    */
		    (VOID) psf_error(E_PS0B06_NOWHILE, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
		}
		return (E_DB_ERROR);
	    }

	    /*
	    ** note that psl_init_dbp_stmt() may choose to not allocate a new
	    ** statement block, in which case snode will be set to NULL
	    */
	    status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode,
		PST_ENDLOOP_TYPE, &snode, &psq_cb->psq_error);

	    /* Allocate fix statement node. */
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_FIXSTMT),
		(PTR *) &fix, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    fix->pss_flags = 0;

	    /*
	    ** if psl_init_dbp_stmt() alocated a statement node, we must
	    ** remember to fix it before the body of the WHILE statement is
	    ** processed
	    */

	    if (snode != (PST_STATEMENT *) NULL)
	    {
		fix->pss_flags |= PSS_FIX_EARLY;
	    }

	    /* Remember location to be fixed */
	    fix->pss_stmt_ptr = yyvarsp->dbpinfo->pss_patch;

	    /*
	    ** Attach element to the list, last one will be at the queue head.
	    */
	    (VOID) QUinsert((QUEUE *) fix, &wnode->pss_fixq);
	}

	/* snode will point at a statement block, if one was allocated */
	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 657:
if (!((*yyvarspp)->bypass_actions))
/* # line 13716 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yypvt[-4].psl_stmt->pst_specific.pst_if.pst_condition = yacc_cb->yypvt[-1].psl_treeinfo_type->pss_tree;
	yacc_cb->yypvt[-4].psl_stmt->pst_specific.pst_if.pst_true = yacc_cb->yypvt[-3].psl_stmt;

	((PSS_LOOP  *)yacc_cb->yypvt[-4].psl_stmt->pst_opf)->pss_out = TRUE;
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-3].psl_stmt;

	/*
	** pss_patch must now contain address of NULL , so that a correct
	** pointer gets updated should we encounter an ENDLOOP immediately
	** following REPEAT ... UNTIL ...
	*/
	/* Except, until I figure that stuff out, pss_patch will address 
	** the training "if"s pst_false. The pst_false will eventually have
	** to address the statement following the "repeat".
	*/
	yyvarsp->dbpinfo->pss_patch = &yacc_cb->yypvt[-4].psl_stmt->pst_specific.pst_if.pst_false;

	/* Now, loop down the contained stmtlist, looking for the last one
	** which then must be attached to the trailing "if".
	*/
	{
	    PST_STATEMENT	*snode;
	
	    for (snode = yacc_cb->yypvt[-3].psl_stmt; snode && snode->pst_next; snode = snode->pst_next);
	    if (snode) snode->pst_next = yacc_cb->yypvt[-4].psl_stmt;
	    else yacc_cb->yyval.psl_stmt = NULL;
	}
    } break;

case 658:
if (!((*yyvarspp)->bypass_actions))
/* # line 13748 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_LOOP 	*rnode;
	DB_STATUS	status;
	char		label[DB_MAXNAME];

	if (yacc_cb->yypvt[-1].psl_strtype != (char *) NULL)
	{
	    bool		found = FALSE;
	    i4			err_code;

	    STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', DB_MAXNAME, (char *) label);

	    /* Check if label specified for the first time. */
	    for (rnode = (PSS_LOOP  *) yyvarsp->dbpinfo->pss_loopq.q_next;
		 rnode != (PSS_LOOP  *) &yyvarsp->dbpinfo->pss_loopq;
		 rnode = (PSS_LOOP  *) rnode->pss_queue.q_next
		)
	    {
		/* Don't look at loops out of scope */
		if (rnode->pss_out == TRUE)
		    continue;

		if (MEcmp((PTR) label, (PTR) rnode->pss_label,
		    DB_MAXNAME) == 0
		   )
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (found)
	    {
		/* Found a duplicate label */
		(VOID) psf_error(2406L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
		return (E_DB_ERROR);
	    }
	}

	/* Allocate repeat node. */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_LOOP ),
	    (PTR *) &rnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	rnode->pss_out = FALSE;
	(VOID) QUinit(&rnode->pss_fixq);

	/* Fill in the name */
	if (yacc_cb->yypvt[-1].psl_strtype != (char *) NULL)
	{
	    (VOID) MEcopy((PTR) label, DB_MAXNAME, (PTR) rnode->pss_label);
	}
	else
	{
	    (VOID) MEfill(DB_MAXNAME, (u_char) ' ', (PTR) rnode->pss_label);
	}

	/* Attach element to the list, last one will be at the queue head. */
	(VOID) QUinsert((QUEUE *) rnode, &yyvarsp->dbpinfo->pss_loopq);

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, PSQ_IF, PST_RP_TYPE,
	    &rnode->pss_stmt, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	rnode->pss_stmt->pst_opf = (PTR) rnode;

	yyvarsp->dbpinfo->pss_flags |= PSS_INCOND;

	/*
	** The REPEAT statement is internally implemented
	** as the IF statement, but let's indicate REPEAT
	** for proper display of syntax errors.
	*/
	psq_cb->psq_mode = PSQ_REPEAT;

	yacc_cb->yyval.psl_stmt = rnode->pss_stmt;
    } break;

case 659:
if (!((*yyvarspp)->bypass_actions))
/* # line 13832 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-1].psl_strtype;
    } break;

case 660:
if (!((*yyvarspp)->bypass_actions))
/* # line 13836 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = (char *) NULL;
    } break;

case 661:
if (!((*yyvarspp)->bypass_actions))
/* # line 13842 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->dbpinfo->pss_flags |= PSS_INCOND;
    } break;

case 662:
if (!((*yyvarspp)->bypass_actions))
/* # line 13848 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->dbpinfo->pss_flags &= ~PSS_INCOND;
	yyvarsp->dbpinfo->pss_inloop--;
    } break;
	}
	return(0);
}

i4
psls14iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 663:
if (!((*yyvarspp)->bypass_actions))
/* # line 13855 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 664:
if (!((*yyvarspp)->bypass_actions))
/* # line 13859 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = (char *) NULL;
    } break;

case 665:
if (!((*yyvarspp)->bypass_actions))
/* # line 13866 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*newnode;
	i4		intnum;

	intnum = (i4) yacc_cb->yypvt[-0].psl_inttype;

	/* Non-parameter number constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 4, 
	    (DB_ANYTYPE *) &intnum, &newnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 666:
if (!((*yyvarspp)->bypass_actions))
/* # line 13892 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	i4		errnum = 0L;

	if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_datatype < 0)
	{
	    /* Datatype must be non-nullable */
	    errnum = 2421L;
	}
	else if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_datatype != DB_INT_TYPE)
	{
	    /* Type of $1 must be integer */
	    errnum = 2424L;
	}

	if (errnum)
	{
	    (VOID) psf_error(errnum, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 667:
if (!((*yyvarspp)->bypass_actions))
/* # line 13917 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PST_CNST_NODE	    cconst;
	PST_QNODE	    *newnode;
	DB_PARM_NAME	    varname;
	bool		    found = FALSE;
	i4		    err_code;
	register PSS_DECVAR *var;

	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, varname.db_parm_name);

	/* Find local var/parm by the specified name. */
	for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Unknown local variable or parm spec'd. */
	    (VOID) psf_error(2403L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	if (var->pss_dbdata.db_datatype < 0)
	{
	    /* Datatype must be non-nullable */
	    (VOID) psf_error(2421L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Type of var must be integer */
	if (var->pss_dbdata.db_datatype != DB_INT_TYPE)
	{
	    (VOID) psf_error(2424L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Parm or local variable */
	cconst.pst_tparmtype = PST_LOCALVARNO;
	cconst.pst_parm_no = var->pss_no;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), var->pss_dbdata.db_datatype,
	    (i2) var->pss_dbdata.db_prec, (i4) var->pss_dbdata.db_length, 
	    (DB_ANYTYPE *) var->pss_dbdata.db_data, &newnode,
	    &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 668:
if (!((*yyvarspp)->bypass_actions))
/* # line 13987 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = (PST_QNODE *) NULL;
    } break;

case 669:
if (!((*yyvarspp)->bypass_actions))
/* # line 13993 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* For proper display of syntax errors. */
	psq_cb->psq_mode = PSQ_RETURN;
    } break;

case 670:
if (!((*yyvarspp)->bypass_actions))
/* # line 13998 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*snode;
	DB_STATUS	status;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode,
	    PST_RTN_TYPE, &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_rtn.pst_rtn_value = yacc_cb->yypvt[-0].psl_trtype;

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 671:
if (!((*yyvarspp)->bypass_actions))
/* # line 14015 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	PST_QNODE	    *resdomp, *qlend;
	PST_QNODE	    *rootnode;
	PST_RT_NODE	    root;
	i4		    err_code;
	PST_QTREE	    *tree;
	PST_PROCEDURE	    *pnode;
	PST_STATEMENT	    *snode;

	for (resdomp = yacc_cb->yypvt[-1].psl_trtype; 
	    resdomp && resdomp->pst_sym.pst_type == PST_RESDOM;
	    resdomp = resdomp->pst_left)
	 if (resdomp->pst_right == (PST_QNODE *) NULL)
	{
	    /* Fewer entries in "return row" clause than "result row". */
	    (VOID) psf_error(2446L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Create a QLEND node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &qlend, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Create the ROOT node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	root.pst_tvrc   = 0;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);

	resdomp = yacc_cb->yypvt[-1].psl_trtype;
	status = pst_node(cb, &cb->pss_ostream, resdomp, qlend, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Create the query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, (yyvarsp->isdbp) ? 0 : PST_0FULL_HEADER, 
	    &yyvarsp->xlated_qry);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** set pst_numjoins.  $Yjoin_id contains the highest join id, in this
	** case, 0.
	*/
	tree->pst_numjoins = yyvarsp->join_id;

	/* No need to set root here */

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode, PST_QT_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_tree = tree;
	snode->pst_after_stmt = NULL;

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 672:
if (!((*yyvarspp)->bypass_actions))
/* # line 14086 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_DECVAR	*var;
	QUEUE		*varq;
	PST_QNODE	*resdomp;
	PST_QNODE	*node;
	DB_STATUS	status;
	i4		err_code;
	char		colname[DB_MAXNAME + 2];

	if (yyvarsp->dbpinfo->pss_resrowno <= 0)
	{
	    /* Must be a "result row" declaration to use "return row" */
	    (VOID) psf_error(2445L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	yyvarsp->aggr_allowed &= ~(PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
	psq_cb->psq_mode = PSQ_RETROW;
	
	/* Pre-allocate resdoms for each column in result row definition.
	** NOTE: we go backwards through the list to build RESDOMs in
	** expected sequence. */
	varq = &(yyvarsp->dbpinfo->pss_resrowq);
	for (var = (PSS_DECVAR *)varq->q_prev, resdomp = (PST_QNODE *)NULL;
		var != (PSS_DECVAR *)varq;
		var = (PSS_DECVAR *)var->pss_queue.q_prev)
	{
	    status = pst_adresdom((char *)&var->pss_varname, 
		resdomp, (PST_QNODE *) NULL, cb, psq_cb, &resdomp);
	    if (DB_FAILURE_MACRO(status)) return(status);
	
	    resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsno = var->pss_no;
	    resdomp->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = var->pss_no;
	    resdomp->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_RESROW_COL;
	    STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomp->pst_sym.pst_dataval);
	    STprintf(colname, "result element%d",
		    resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsno);
	    MEmove(STlength(colname), (PTR)colname, ' ',
		    DB_MAXNAME,
		    (PTR) resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsname); 
	}

	yyvarsp->resdmhd = resdomp;		/* save head of chain */

	/* Find the leftmost node in the tree */
	for (node = resdomp; node->pst_left != (PST_QNODE *) NULL; )
	{
	    node = node->pst_left;
	}

	/* Allocate the PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &node->pst_left, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status)) return(status);

	yacc_cb->yyval.psl_trtype = resdomp;
    } break;

case 673:
if (!((*yyvarspp)->bypass_actions))
/* # line 14149 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;

case 674:
if (!((*yyvarspp)->bypass_actions))
/* # line 14154 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*snode;
	DB_DT_ID	dtype1, dtype2;
	i4		err_code;

	dtype1 = yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_dataval.db_datatype;
	dtype2 = yacc_cb->yypvt[-1].psl_trtype->pst_sym.pst_dataval.db_datatype;

	if (dtype1 < 0 || dtype2 < 0)
	{
	    /* Datatype must be non-nullable */
	    (VOID) psf_error(2422L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Type of $2 must be integer (msg no.) */
	/* Type of $3 must be character (msg text) */
	if (dtype1 != DB_INT_TYPE)
	{
	    (VOID) psf_error(2408L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	if (dtype2 != DB_CHR_TYPE && dtype2 != DB_TXT_TYPE &&
	    dtype2 != DB_CHA_TYPE && dtype2 != DB_VCH_TYPE &&
	    dtype2 != DB_NCHR_TYPE && dtype2 != DB_NVCHR_TYPE
	   )
	{
	    (VOID) psf_error(2409L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** $Ydbpinfo->pss_last_stmt points to the last statement block allocated
	** for the dbproc
	*/
	snode = yyvarsp->dbpinfo->pss_last_stmt;

	snode->pst_specific.pst_msg.pst_msgnumber = yacc_cb->yypvt[-2].psl_trtype;
	snode->pst_specific.pst_msg.pst_msgtext = yacc_cb->yypvt[-1].psl_trtype;

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 675:
if (!((*yyvarspp)->bypass_actions))
/* # line 14200 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*snode;
	DB_DT_ID	dtype;
	i4		err_code;

	dtype = yacc_cb->yypvt[-1].psl_trtype->pst_sym.pst_dataval.db_datatype;

	if (dtype < 0)
	{
	    /* Datatype must be non-nullable */
	    (VOID) psf_error(2422L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** $Ydbpinfo->pss_last_stmt points to the last statement block allocated
	** for the dbproc
	*/
	snode = yyvarsp->dbpinfo->pss_last_stmt;

	/* If type of $2 is integer we have msg no.
	** if character msg text.
	*/
	if (dtype == DB_INT_TYPE)
	{
	    snode->pst_specific.pst_msg.pst_msgnumber = yacc_cb->yypvt[-1].psl_trtype;
	    snode->pst_specific.pst_msg.pst_msgtext = (PST_QNODE *) NULL;
	}
	else if (dtype == DB_CHR_TYPE || dtype == DB_TXT_TYPE ||
		 dtype == DB_CHA_TYPE || dtype == DB_VCH_TYPE ||
		 dtype == DB_NCHR_TYPE || dtype == DB_NVCHR_TYPE
		)
	{
	    snode->pst_specific.pst_msg.pst_msgnumber = (PST_QNODE *) NULL;
	    snode->pst_specific.pst_msg.pst_msgtext = yacc_cb->yypvt[-1].psl_trtype;
	}
	else
	{
	    (VOID) psf_error(2410L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_stmt = snode;
     } break;

case 676:
if (!((*yyvarspp)->bypass_actions))
/* # line 14249 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_STATEMENT	*snode;

	/* For proper display of syntax errors. */
	psq_cb->psq_mode = PSQ_MESSAGE;

        /* Allocate statement node. */
        status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode,
            PST_MSG_TYPE, &snode, &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
            return (status);

	snode->pst_specific.pst_msg.pst_msgdest = 0;
	snode->pst_specific.pst_msg.pst_msgnumber = 0;
	snode->pst_specific.pst_msg.pst_msgtext = NULL;
    } break;

case 677:
if (!((*yyvarspp)->bypass_actions))
/* # line 14270 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*new1;
	i4		intnum;

	intnum = (i4) yacc_cb->yypvt[-0].psl_inttype;

	/* Non-parameter number constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 4, 
	    (DB_ANYTYPE *) &intnum, &new1, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = new1;
    } break;

case 678:
if (!((*yyvarspp)->bypass_actions))
/* # line 14294 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*new2;

	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_VCH_TYPE, (i2) 0,
	    (i4) (yacc_cb->yypvt[-0].psl_textype->db_t_count + DB_CNTSIZE),
	    (DB_ANYTYPE *) yacc_cb->yypvt[-0].psl_textype, &new2, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = new2;
    } break;

case 679:
if (!((*yyvarspp)->bypass_actions))
/* # line 14316 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 680:
if (!((*yyvarspp)->bypass_actions))
/* # line 14320 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*newnode;
	DB_PARM_NAME	varname;
	bool		found = FALSE;
	i4		err_code;
	register PSS_DECVAR *var;

	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, varname.db_parm_name);

	/* Find local var/parm by the specified name. */
	for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Unknown local variable or parm spec'd. */
	    (VOID) psf_error(2403L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Parm or local variable */
	cconst.pst_tparmtype = PST_LOCALVARNO;
	cconst.pst_parm_no = var->pss_no;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), var->pss_dbdata.db_datatype,
	    (i2) var->pss_dbdata.db_prec, (i4) var->pss_dbdata.db_length, 
	    (DB_ANYTYPE *) var->pss_dbdata.db_data,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 681:
if (!((*yyvarspp)->bypass_actions))
/* # line 14375 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 682:
if (!((*yyvarspp)->bypass_actions))
/* # line 14381 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*newnode;
	DB_PARM_NAME	varname;
	bool		found = FALSE;
	i4		err_code;
	register PSS_DECVAR *var;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    yacc_cb->yyval.psl_trtype = NULL;
	    break;
	}

	if (yyvarsp->isdbp == FALSE)
	{
	    /* Only allowed in DB procedures */
	    (VOID) psf_error(2414L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);	    
	}

	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, varname.db_parm_name);

	/* Find local var/parm by the specified name. */
	for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Unknown local variable or parm spec'd. */
	    (VOID) psf_error(2403L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Parm or local variable */
	cconst.pst_tparmtype = PST_LOCALVARNO;
	cconst.pst_parm_no = var->pss_no;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), var->pss_dbdata.db_datatype,
	    (i2) var->pss_dbdata.db_prec, (i4) var->pss_dbdata.db_length, 
	    (DB_ANYTYPE *) var->pss_dbdata.db_data,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 687:
if (!((*yyvarspp)->bypass_actions))
/* # line 14461 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        i4     err_code;

        if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "DESTINATION"))
        {
            _VOID_ psf_error(6353L, 0L, PSF_USERERR, &err_code,
                &psq_cb->psq_error, 2,
                (i4) sizeof("MESSAGE/RAISE ERROR")-1,
		"MESSAGE/RAISE ERROR",
                (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
            return (E_DB_ERROR);
        }
    } break;

case 688:
if (!((*yyvarspp)->bypass_actions))
/* # line 14477 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** recall that $Ydbpinfo->pss_last_stmt points at the last allocated
	** dbproc statement block
	*/
	PST_STATEMENT	*snode = yyvarsp->dbpinfo->pss_last_stmt;
        i4		err_code;

	if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "ERROR_LOG"))
	{
	    snode->pst_specific.pst_msg.pst_msgdest |= DB_MSGLOG;
	}
	else if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "AUDIT_LOG"))
	{
	    snode->pst_specific.pst_msg.pst_msgdest |= DB_MSGAUDIT;
	}
	else
        {
            _VOID_ psf_error(6353L, 0L, PSF_USERERR, &err_code,
                &psq_cb->psq_error, 2,
                (i4) sizeof("MESSAGE/RAISE ERROR")-1,
		"MESSAGE/RAISE ERROR",
                (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
            return (E_DB_ERROR);    /* non-zero return means error */
        }
    } break;

case 689:
if (!((*yyvarspp)->bypass_actions))
/* # line 14504 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** recall that $Ydbpinfo->pss_last_stmt points at the last allocated
	** dbproc statement block
	*/
	PST_STATEMENT	*snode = yyvarsp->dbpinfo->pss_last_stmt;

	snode->pst_specific.pst_msg.pst_msgdest |= DB_MSGUSER;
    } break;

case 690:
if (!((*yyvarspp)->bypass_actions))
/* # line 14528 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*snode;
	DB_DT_ID	dtype1, dtype2;
	i4		err_code;


        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(6350L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1,
                (i4) sizeof("RAISE ERROR")-1, "RAISE ERROR");
            return (E_DB_ERROR);    /* non-zero return means error */
        }

	dtype1 = yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_dataval.db_datatype;
	dtype2 = yacc_cb->yypvt[-1].psl_trtype != NULL ? yacc_cb->yypvt[-1].psl_trtype->pst_sym.pst_dataval.db_datatype : 0;

	/* Data types must be non-nullable, 1st = integer, [2nd = string] */
	if (dtype1 < 0 || dtype2 < 0)	/* Datatype must be non-nullable */
	{
	    _VOID_ psf_error(E_US0985_2437_RSER_NUL, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	if (    dtype1 != DB_INT_TYPE 
	    || (   dtype2 != 0 && dtype2 != DB_CHR_TYPE && dtype2 != DB_TXT_TYPE
		&& dtype2 != DB_CHA_TYPE && dtype2 != DB_VCH_TYPE)
	   )
	{
	    _VOID_ psf_error(E_US0984_2436_RSER_TYPE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** $Ydbpinfo->pss_last_stmt points at the last allocated dbproc
	** statement block
	*/
	snode = yyvarsp->dbpinfo->pss_last_stmt;

	snode->pst_specific.pst_msg.pst_msgnumber = yacc_cb->yypvt[-2].psl_trtype;
	snode->pst_specific.pst_msg.pst_msgtext   = yacc_cb->yypvt[-1].psl_trtype;

	yacc_cb->yyval.psl_stmt = snode;
     } break;

case 691:
if (!((*yyvarspp)->bypass_actions))
/* # line 14576 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_STATEMENT	*snode;

	/* For proper display of syntax errors */
	psq_cb->psq_mode = PSQ_RS_ERROR;

        /* Allocate statement node. */
        status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode,
            PST_EMSG_TYPE, &snode, &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
            return (status);

	snode->pst_specific.pst_msg.pst_msgdest = 0;
	snode->pst_specific.pst_msg.pst_msgnumber = 0;
	snode->pst_specific.pst_msg.pst_msgtext = NULL;
    } break;

case 692:
if (!((*yyvarspp)->bypass_actions))
/* # line 14596 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 693:
if (!((*yyvarspp)->bypass_actions))
/* # line 14600 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;
    } break;

case 694:
if (!((*yyvarspp)->bypass_actions))
/* # line 14606 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->dbpinfo->pss_flags |= PSS_INCOND;
	psq_cb->psq_mode = PSQ_ASSIGN;
    } break;

case 695:
if (!((*yyvarspp)->bypass_actions))
/* # line 14611 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	PST_QNODE	    *resdomnode, *qlend;
	PST_QNODE	    *rootnode;
	PST_RT_NODE	    root;
	i4		    err_code;
	PSS_DECVAR	    *var = yacc_cb->yypvt[-2].psl_decvar;
	PST_QTREE	    *tree;
	PST_PROCEDURE	    *pnode;
	PST_STATEMENT	    *snode;

	yyvarsp->dbpinfo->pss_flags &= ~PSS_INCOND;

	/* The assignment statement is implemented as a SELECT
	** query, we need therefore to generate a query tree here.
	** The query tree processing is simplified by the fact that
	** there are no underlying relations AND no QRYMOD routines
	** need to be called.
	*/

	/* Open memory stream for allocating query tree,
	** if not already open.
	*/
	if (!cb->pss_ostream.psf_mstream.qso_handle &&
	    (status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);
	}

	/* Initialize mode to true mode, PSQ_ASSIGN is
	** only used for proper recovery from syntax errors.
	*/
	psq_cb->psq_mode = PSQ_RETRIEVE;

	status = pst_adresdom((char *) &var->pss_varname, (PST_QNODE *)NULL, yacc_cb->yypvt[-0].psl_trtype,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = var->pss_no;
	resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_LOCALVARNO;
	STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomnode->pst_sym.pst_dataval);

	status = pst_parm_resolve(cb, psq_cb, resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* Flag error if assigning the NULL constant to non-nullable variable */
	if (   resdomnode->pst_sym.pst_dataval.db_datatype > 0
	    && resdomnode->pst_right->pst_sym.pst_dataval.db_datatype
				== -DB_LTXT_TYPE
	    && resdomnode->pst_right->pst_sym.pst_dataval.db_length
				== DB_CNTSIZE + 1
	   )
	{
	    (VOID) psf_error(2777L, 0L, PSF_USERERR, &err_code,
		     &psq_cb->psq_error, 1,
		     psf_trmwhite(DB_MAXNAME, var->pss_varname.db_parm_name),
		     var->pss_varname.db_parm_name);
	    return (E_DB_ERROR);
	}

	/* Add a PST_TREE node */
	if (status = pst_trfix(cb, &cb->pss_ostream, resdomnode, &psq_cb->psq_error))
	    return (status);

	/* Create a QLEND node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &qlend, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Create the ROOT node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	root.pst_tvrc   = 0;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);

	status = pst_node(cb, &cb->pss_ostream, resdomnode, qlend, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Create the query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, (yyvarsp->isdbp) ? 0 : PST_0FULL_HEADER, 
	    &yyvarsp->xlated_qry);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** set pst_numjoins.  $Yjoin_id contains the highest join id, in this
	** case, 0.
	*/
	tree->pst_numjoins = yyvarsp->join_id;

	/* No need to set root here */

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, yyvarsp->dbpinfo, psq_cb->psq_mode, PST_QT_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_tree = tree;
	snode->pst_after_stmt = NULL;

	yacc_cb->yyval.psl_stmt = snode;
    } break;

case 696:
if (!((*yyvarspp)->bypass_actions))
/* # line 14727 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_PARM_NAME	    varname;
	i4		    err_code;
	bool		    found = FALSE;
	PSS_DECVAR	    *var;

	/* normalize the var name */
	STmove((char *)yacc_cb->yypvt[-0].psl_strtype, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&varname);

	/* Search for the variable; innermost scope first. */
	for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0)
	    {
		/* Must not be a built-in variable (READONLY). */
		if (var->pss_no == PST_RCNT || var->pss_no == PST_ERNO)
		{
		    (VOID) psf_error(2434L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			sizeof(cb->pss_lineno), &cb->pss_lineno);
		    return (E_DB_ERROR);
		}
		found = TRUE;
		break;
	    }
	}
	if (found == FALSE)
	{
	    /* Var unknown */
	    (VOID) psf_error(2413L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
	yacc_cb->yyval.psl_decvar = var;
    } break;
	}
	return(0);
}

i4
psls15iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 697:
if (!((*yyvarspp)->bypass_actions))
/* # line 14771 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_stmt_flags |= PSS_DBPROC_LHSVAR;
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-1].psl_strtype;
    } break;

case 698:
if (!((*yyvarspp)->bypass_actions))
/* # line 14776 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-2].psl_strtype;
    } break;

case 699:
if (!((*yyvarspp)->bypass_actions))
/* # line 14780 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-1].psl_strtype;
    } break;

case 700:
if (!((*yyvarspp)->bypass_actions))
/* # line 14784 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-2].psl_strtype;
    } break;

case 701:
if (!((*yyvarspp)->bypass_actions))
/* # line 14790 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 702:
if (!((*yyvarspp)->bypass_actions))
/* # line 14794 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 703:
if (!((*yyvarspp)->bypass_actions))
/* # line 14810 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** $Ydbpinfo ->pss_link and ->pss_patch have been already set in
	** execute_dbproc: production
	*/

	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;	/* Single statement */
    } break;

case 704:
if (!((*yyvarspp)->bypass_actions))
/* # line 14819 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_DECVAR	    *res_var = yacc_cb->yypvt[-1].psl_decvar;	/* Result variable (left) */
	PST_RSDM_NODE	    *resdom;
	PST_STATEMENT	    *stmt_cp = yacc_cb->yypvt[-0].psl_stmt;	/* CALLPROC statement */
	i4		    err_code;
	DB_STATUS           status;

	/*
	** This construct will simulate a SELECT statement after the
	** initial EXECUTE statement:
	**	CALLPROC procname (args);
	**	SELECT :result = :iirowcount; -- iirowcount has return value
	*/

	/* Check result variable type is an integer */
	if (abs(res_var->pss_dbdata.db_datatype) != DB_INT_TYPE)
	{
	    (VOID) psf_error(E_US0987_2439_EXEC_TYPE, 0L, PSF_USERERR,
	         &err_code, &psq_cb->psq_error, 1,
		 psf_trmwhite(DB_MAXNAME, (char *) &res_var->pss_varname),
		 &res_var->pss_varname);
	    return (E_DB_ERROR);
	}

	/* Generate a resdom node for left side */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_RSDM_NODE),
			    (PTR *) &resdom, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	stmt_cp->pst_specific.pst_callproc.pst_return_status = resdom;
	resdom->pst_rsno      = 1;
	resdom->pst_ntargno   = res_var->pss_no;
	resdom->pst_ttargtype = PST_LOCALVARNO;
	resdom->pst_rsupdt    = FALSE;
	resdom->pst_rsflags   = PST_RS_PRINT;
	resdom->pst_dmuflags  = 0;
	MEcopy((char *)&res_var->pss_varname, DB_MAXNAME, resdom->pst_rsname);

	yacc_cb->yyval.psl_stmt = stmt_cp;
    } break;

case 705:
if (!((*yyvarspp)->bypass_actions))
/* # line 14860 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ 
         PSS_DECVAR          *res_var = yacc_cb->yypvt[-0].psl_decvar;      /* Result variable (left) */
         PST_RSDM_NODE       *resdom;
         PST_STATEMENT       *stmt_cp = yacc_cb->yypvt[-1].psl_stmt;      /* CALLPROC statement */
         i4                  err_code;
         DB_STATUS           status;
  
         /*
         ** This construct will simulate a SELECT statement after the
         ** initial EXECUTE statement:
         **      CALLPROC procname (args);
         **      SELECT :result = :iirowcount; -- iirowcount has return value
         */
  
         /* Check result variable type is an integer */
         if (abs(res_var->pss_dbdata.db_datatype) != DB_INT_TYPE)
         {
             (VOID) psf_error(E_US0987_2439_EXEC_TYPE, 0L, PSF_USERERR,
                  &err_code, &psq_cb->psq_error, 1,
                  psf_trmwhite(DB_MAXNAME, (char *) &res_var->pss_varname),
                  &res_var->pss_varname);
             return (E_DB_ERROR);
         }
  
         /* Generate a resdom node for left side */
         status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_RSDM_NODE),
                             (PTR *) &resdom, &psq_cb->psq_error);
         if (DB_FAILURE_MACRO(status))
             return (status);
         stmt_cp->pst_specific.pst_callproc.pst_return_status = resdom;
         resdom->pst_rsno      = 1;
         resdom->pst_ntargno   = res_var->pss_no;
         resdom->pst_ttargtype = PST_LOCALVARNO;
         resdom->pst_rsupdt    = FALSE;
         resdom->pst_rsflags   = PST_RS_PRINT;
         resdom->pst_dmuflags  = 0;
         MEcopy((char *)&res_var->pss_varname, DB_MAXNAME, resdom->pst_rsname);
  
         yacc_cb->yyval.psl_stmt = stmt_cp;
     } break;

case 706:
if (!((*yyvarspp)->bypass_actions))
/* # line 14903 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
         DB_PARM_NAME        varname;
         i4             err_code;
         bool                found = FALSE;
         PSS_DECVAR          *var;
  
         /* normalize the var name */
         STmove((char *)yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_ATT_NAME), (char *)&varname);
  
         /* Search for the variable; innermost scope first. */
         for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
              var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
              var = (PSS_DECVAR *) var->pss_queue.q_next
             )
         {
             if (var->pss_out)
                 continue;
             if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
                 sizeof(var->pss_varname)) == 0)
             {
                 /* Must not be a built-in variable (READONLY). */
                 if (var->pss_no == PST_RCNT || var->pss_no == PST_ERNO)
                 {
                     (VOID) psf_error(2434L, 0L, PSF_USERERR,
                         &err_code, &psq_cb->psq_error, 1,
                         sizeof(cb->pss_lineno), &cb->pss_lineno);
                     return (E_DB_ERROR);
                 }
                 found = TRUE;
                 break;
             }
         }
         if (found == FALSE)
         {
             /* Var unknown */
             (VOID) psf_error(2413L, 0L, PSF_USERERR,
                 &err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
             return (E_DB_ERROR);
         }
         yacc_cb->yyval.psl_decvar = var;
     } break;

case 707:
if (!((*yyvarspp)->bypass_actions))
/* # line 14947 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
         yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
 } break;

case 708:
if (!((*yyvarspp)->bypass_actions))
/* # line 14951 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
         yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
 } break;

case 709:
if (!((*yyvarspp)->bypass_actions))
/* # line 14970 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** if this statement is not reachable, do not attach it to the list of
	** statements used by OPF (to save the cost of optimizing it)
	*/
	if (yyvarsp->dbpinfo->pss_unreachable_stmt_lvl == 0)
	{
	    if (yyvarsp->dbpinfo->pss_link != (PST_STATEMENT *) NULL)
		yyvarsp->dbpinfo->pss_link->pst_link = yacc_cb->yypvt[-0].psl_stmt;
	    yyvarsp->dbpinfo->pss_link = yacc_cb->yypvt[-0].psl_stmt;
	}

	yyvarsp->dbpinfo->pss_patch = &yacc_cb->yypvt[-0].psl_stmt->pst_next;

        yacc_cb->yyval.psl_stmt = yyvarsp->dbpinfo->pss_last_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 710:
if (!((*yyvarspp)->bypass_actions))
/* # line 14988 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 711:
if (!((*yyvarspp)->bypass_actions))
/* # line 14992 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 712:
if (!((*yyvarspp)->bypass_actions))
/* # line 14996 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 713:
if (!((*yyvarspp)->bypass_actions))
/* # line 15002 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSC_CURBLK             *cursor;
	DB_STATUS	       status;
	i4		       err_code;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_CLSCURS;

	/* Allocate a QEF control block for doing the close */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(*(yacc_cb->yypvt[-0].psl_cursid), psq_cb->psq_cursid);

	/* Look up the cursor */
	status = psq_crfind(cb, yacc_cb->yypvt[-0].psl_cursid, &cursor, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-0].psl_cursid->db_cur_name),
		yacc_cb->yypvt[-0].psl_cursid->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Get rid of the cursor control block */
	status = psq_crclose(cursor, &cb->pss_curstab, &cb->pss_memleft,
	    &psq_cb->psq_error);
 	if (status != E_DB_OK)
	    return (status);
    } break;

case 714:
if (!((*yyvarspp)->bypass_actions))
/* # line 15058 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSC_CURBLK             *cursor;
	DB_STATUS	       status;
	i4		       err_code;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_RETCURS;

	/* Look up the cursor */
	status = psq_crfind(cb, yacc_cb->yypvt[-0].psl_cursid, &cursor, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-0].psl_cursid->db_cur_name),
		yacc_cb->yypvt[-0].psl_cursid->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Hand the cursor id back to the caller */
	STRUCT_ASSIGN_MACRO(*(yacc_cb->yypvt[-0].psl_cursid), psq_cb->psq_cursid);

	/* Allocate the QEF control block for fetch cursor */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    } break;

case 715:
if (!((*yyvarspp)->bypass_actions))
/* # line 15109 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	if (cb->pss_defqry == PSQ_DEFCURS)
	{
	    /*
	    ** for repeat cursors, we want to insist that the cursor be opened
	    ** FOR READONLY.  Unfortunately, in cases when BE asks FE for the
	    ** cursor definition text (as would happen when a QP became
	    ** obsolete), FE sends the cursor definition text WITHOUT
	    ** FOR READONLY.
	    ** Since these changes are being made to make manman/X run faster
	    ** and are not for general consumption, we will take an easy way out
	    ** and will behave as if FOR READONLY was specified regardless of
	    ** whether it actually was
	    */
	    yacc_cb->yypvt[-0].psl_bool = TRUE;
	}

	status = psl_crsopen(cb, psq_cb, yacc_cb->yypvt[-2].psl_crblk, yacc_cb->yypvt[-1].psl_qttype, yacc_cb->yypvt[-0].psl_bool,
	    yyvarsp->updcollst, yyvarsp->nonupdt, yyvarsp->join_id, FALSE);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* If this is a scrollable cursor, verify that no result columns 
	** are LOBs (though LOB locators are ok). */
	if (cb->pss_stmt_flags & PSS_SCROLL)
	{
	    PST_QNODE	*rsdmp;
	    DB_DT_ID	rtype;
	    i4		err_code;

	    for (rsdmp = yacc_cb->yypvt[-1].psl_qttype->pst_qtree->pst_left; rsdmp && 
			rsdmp->pst_sym.pst_type == PST_RESDOM;
			rsdmp = rsdmp->pst_left)
	     if ((rtype = abs(rsdmp->pst_sym.pst_dataval.db_datatype)) ==
					DB_LVCH_TYPE ||
		rtype == DB_LBYTE_TYPE || rtype == DB_LNVCHR_TYPE)
	     {
		/* Display error. */
		(VOID) psf_error(2231L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	     }
	}

	/* Check for KEYSET cursor. */
	if (yacc_cb->yypvt[-0].psl_bool == 1)
	    cb->pss_stmt_flags &= ~PSS_KEYSET;	/* no KEYSET if READONLY*/
	else if (cb->pss_stmt_flags & PSS_KEYSET)
	{
	    i4		err_code, reason;
	    bool	nonupdt = FALSE;

	    /* Can't have KEYSET cursor on a Star DB. */
	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/* Display error. */
		(VOID) psf_error(2232L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	    }

	    /* Verify that it's updateable - if not, send errors. */
	    (VOID) psl_up(cb, &cb->pss_auxrng, yacc_cb->yypvt[-1].psl_qttype, &nonupdt, &reason);

	    if (nonupdt)
	    {

		(VOID) psf_error(2229L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
		psl_nonupdt_err(psq_cb, cb, reason, &err_code);
		return(E_DB_ERROR);
	    }

	    /*
	    ** Valid KEYSET cursor.
	    ** Identify and flag result columns in keyset.
	    */
	    status = psl_crskeyflag(cb, yacc_cb->yypvt[-1].psl_qttype);
	    if (DB_FAILURE_MACRO(status))
	    {
		/* don't have unique key covered by result set */
		(VOID) psf_error(2307L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	    }
	}

	if (cb->pss_defqry == PSQ_DEFCURS)
	{
	    /* repeat cursors must be opened FOR READONLY */
	    if (!yacc_cb->yypvt[-0].psl_bool)
	    {
		i4	    err_code;
		
		(VOID) psf_error(E_PS0404_REP_CURS_NOT_FOR_RDONLY, 0L,
		    PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
	        return(E_DB_ERROR);
	    }

	    /*
	    ** if processing definition of a sharable repeat cursor, we need to
	    ** determine whether there is already a QP for this cursor or define
	    ** a new QP otherwise;
	    ** NOTE that we should not try to invoke psl_repeat_qry_id() before
	    ** calling psl_crsopen() because the former may deallocate query
	    ** tree needed by the latter
	    */
	    if (yyvarsp->qp_shareable)
	    {
		status = psl_repeat_qry_id(psq_cb, cb, &yacc_cb->yypvt[-2].psl_crblk->psc_curid, yacc_cb->yypvt[-1].psl_qttype,
		    yyvarsp->shr_qryinfo);

		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
	    }

	    if (psq_cb->psq_mode == PSQ_QRYDEFED)
	    {
		/*
		** we found an existing QP for this shareable repeat cursor -
		** overwrite BE QP id in the cursor block with that stored into
		** psq_cb->psq_cursid by psl_repeat_qry_id(); we do NOT need to
		** copy it into the query tree header (pst_cursid) because
		** psl_repeat_qry_id() has already deallocated it
		*/
		STRUCT_ASSIGN_MACRO(psq_cb->psq_cursid, yacc_cb->yypvt[-2].psl_crblk->psc_blkid);
	    }
	}
    } break;

case 718:
if (!((*yyvarspp)->bypass_actions))
/* # line 15266 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PSC_CURBLK	       *curblk;
	i4		       err_code;
	u_i4			l_id;
	char			tempstr[GCA_MAXNAME];
	u_i4			templen;
	u_i4		mode;

	psq_cb->psq_mode = PSQ_DEFCURS;

	/*
	** The cursor name must be translated here
	*/
	l_id = sizeof(yacc_cb->yypvt[-3].psl_cursid->db_cur_name);
	templen = sizeof(tempstr);
	mode = *cb->pss_dbxlate | CUI_ID_STRIP;
	status = cui_idxlate((u_char *) yacc_cb->yypvt[-3].psl_cursid->db_cur_name, &l_id,
			     (u_char *)tempstr, &templen, mode,
			     (u_i4 *) NULL, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    /*@FIX_ME@ Customize message with line number? */
	    (VOID) psf_error(psq_cb->psq_error.err_code, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(ERx("Cursor name"))-1,
		ERx("Cursor name"),
		l_id, yacc_cb->yypvt[-3].psl_cursid->db_cur_name);
	    return (E_DB_ERROR);
	}
	(VOID)MEmove(templen, (PTR)tempstr, ' ',
		     sizeof(yacc_cb->yypvt[-3].psl_cursid->db_cur_name),yacc_cb->yypvt[-3].psl_cursid->db_cur_name);

	/* This is not a repeat cursor */
	cb->pss_defqry = 0;

	/* look for cursor by its FE id. It should not exist. */
	status = psq_crffind(cb, yacc_cb->yypvt[-3].psl_cursid, &curblk, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	if (curblk != (PSC_CURBLK *) NULL)
	{
	    (VOID) psf_error(2201L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-3].psl_cursid->db_cur_name), yacc_cb->yypvt[-3].psl_cursid->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Create cursor control block */
	status = psq_crcreate(cb, yacc_cb->yypvt[-3].psl_cursid, psq_cb->psq_mode, &curblk,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(curblk->psc_blkid, psq_cb->psq_cursid);

	yacc_cb->yyval.psl_crblk = curblk;
    } break;

case 719:
if (!((*yyvarspp)->bypass_actions))
/* # line 15329 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PSC_CURBLK	       *curblk;
	i4		       err_code;
	u_i4			l_id;
	char			tempstr[GCA_MAXNAME];
	u_i4			templen;
	u_i4		mode;

	{
	    i4	val1 = 0, val2 = 0;

	    /* repeat cursors only available if user set trace point ps151 */
	    if (!ult_check_macro(&cb->pss_trace, 23, &val1, &val2))
	    {
	        psl_yerror(3, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	}

	psq_cb->psq_mode = PSQ_DEFCURS;

	/* This is a repeat cursor */
	cb->pss_defqry = PSQ_DEFCURS;

	/*
	** The cursor name must be translated here
	*/
	l_id = sizeof(yacc_cb->yypvt[-2].psl_cursid->db_cur_name);
	templen = sizeof(tempstr);
	mode = *cb->pss_dbxlate | CUI_ID_STRIP;
	status = cui_idxlate((u_char *) yacc_cb->yypvt[-2].psl_cursid->db_cur_name, &l_id,
			     (u_char *)tempstr, &templen, mode,
			     (u_i4 *) NULL, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    /*@FIX_ME@ Customize message with line number? */
	    (VOID) psf_error(psq_cb->psq_error.err_code, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof(ERx("Cursor name"))-1,
		ERx("Cursor name"),
		l_id, yacc_cb->yypvt[-2].psl_cursid->db_cur_name);
	    return (E_DB_ERROR);
	}

	(VOID)MEmove(templen, (PTR)tempstr, ' ',
		     sizeof(yacc_cb->yypvt[-2].psl_cursid->db_cur_name), yacc_cb->yypvt[-2].psl_cursid->db_cur_name);

	/* look for cursor by its FE id. */
	status = psq_crffind(cb, yacc_cb->yypvt[-2].psl_cursid, &curblk, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** it is possible to find an existing cursor block describing a repeat
	** cursor if we were asked to reparse a cursor definition; it's quite
	** acceptable unless the cursor is opened
	*/
	if (curblk != (PSC_CURBLK *) NULL && curblk->psc_open)
	{
	    (VOID) psf_error(2210L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_cursid->db_cur_name), yacc_cb->yypvt[-2].psl_cursid->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Create cursor control block */
	status = psq_crcreate(cb, yacc_cb->yypvt[-2].psl_cursid, psq_cb->psq_mode, &curblk,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(curblk->psc_blkid, psq_cb->psq_cursid);

	/* remember to check for illegal VLUPs */
	yyvarsp->check_for_vlups = TRUE;
	
	yacc_cb->yyval.psl_crblk = curblk;
    } break;

case 721:
if (!((*yyvarspp)->bypass_actions))
/* # line 15414 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_stmt_flags |= PSS_SCROLL;
	if (yacc_cb->yypvt[-1].psl_inttype)
	    cb->pss_stmt_flags |= PSS_KEYSET;
    } break;

case 722:
if (!((*yyvarspp)->bypass_actions))
/* # line 15422 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = 0;
    } break;

case 723:
if (!((*yyvarspp)->bypass_actions))
/* # line 15426 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* It's either "keyset" or it's an error. */
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "keyset") != 0)
	    psl_yerror(3, cb, psq_cb);
	yacc_cb->yyval.psl_inttype = 1;
    } break;

case 724:
if (!((*yyvarspp)->bypass_actions))
/* # line 15435 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_bool = TRUE;
    } break;

case 725:
if (!((*yyvarspp)->bypass_actions))
/* # line 15439 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_bool = FALSE;
    } break;

case 726:
if (!((*yyvarspp)->bypass_actions))
/* # line 15445 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	i4			i, err_code,dummy;
	PST_PROCEDURE		*pnode;
	register PST_QTREE	*tree;
	PST_RNGENTRY		*rtptr;

	/*
	** Substitute values from using list, if present.
	*/
	if (yacc_cb->yypvt[-0].psl_bool == FALSE)
	{
	    if (yyvarsp->dsql_maxparm >= 0)
	    {	/* error if no parms */
		(VOID) psf_error(2300L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);		    
		return (E_DB_ERROR);
	    }
	}
	else 
	{
	    if (cb->pss_highparm != yyvarsp->dsql_maxparm)
	    {	/* error if not enough parms */
		(VOID) psf_error(2301L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	}

	pnode = (PST_PROCEDURE *) cb->pss_object; /* get ptr to procedure node */
	tree = pnode->pst_stmts->pst_specific.pst_tree;

	/* Skip the parm setting, if repeat dynamic query that's already
	** compiled. */
	if (yyvarsp->dynqp_comp)
	{
	    if (((cb->pss_stmt_flags & PSS_SCROLL) &&
			!(tree->pst_mask1 & PST_SCROLL)) ||
		(!(cb->pss_stmt_flags & PSS_SCROLL) &&
			(tree->pst_mask1 & PST_SCROLL)))
	    {
		/* If shared plan's scrollability doesn't match OPEN, 
		** compile this one as private plan. */
		yyvarsp->dynqp_comp = yyvarsp->repeat_dyn = FALSE;
		pnode->pst_flags &= ~PST_REPEAT_DYNAMIC;
		tree->pst_mask1 &= ~(PST_SCROLL | PST_KEYSET);
					/* flags will be set again later */
		psq_cb->psq_mode = PSQ_DEFCURS;
		/* Then fall into regular code. */
	    }
	    else goto repdyn0;		/* skip private plan stuff */
	}

	/* Loop over range table, looking for derived tables or common
	** query expressions that may also contain dynamic parameters. */
	for (i = 0; i < tree->pst_rngvar_count; i++)
	{
	    rtptr = tree->pst_rangetab[i];
	    if (rtptr && (rtptr->pst_rgtype == PST_DRTREE ||
			rtptr->pst_rgtype == PST_WETREE))
	    {
		status = pst_prmsub(psq_cb, cb, rtptr->pst_rgroot, 
						yyvarsp->dsql_plist, yyvarsp->repeat_dyn);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	}

	status = pst_prmsub(psq_cb, cb, tree->pst_qtree, yyvarsp->dsql_plist,
						yyvarsp->repeat_dyn);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** We only need to resolve unions that contained parameters at this
	** point.  Other unions should have already been resolved.
	*/
	if ((tree->pst_qtree->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		!= (PST_QNODE *) NULL)
	    && (cb->pss_highparm != -1)
	   )
	{
	    status = pst_union_resolve(cb, tree->pst_qtree, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	psq_cb->psq_mode = PSQ_DEFCURS;
	psq_cb->psq_pnode = (PTR)pnode;

repdyn0:
	status = psl_crsopen(cb, psq_cb, yacc_cb->yypvt[-2].psl_crblk, tree, yacc_cb->yypvt[-1].psl_bool,
	    yyvarsp->updcollst, yyvarsp->nonupdt, yyvarsp->join_id, yyvarsp->dynqp_comp);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	/*
	** At this point we are done with parm substitution, if any.
	*/
	if (!yyvarsp->repeat_dyn)
	    tree->pst_numparm = 0;

	dummy = 0;

	/* If this is a scrollable cursor, verify that no result columns 
	** are LOBs (though LOB locators are ok). */
	if (cb->pss_stmt_flags & PSS_SCROLL)
	{
	    PST_QNODE	*rsdmp;
	    DB_DT_ID	rtype;
	    i4		err_code;

	    for (rsdmp = tree->pst_qtree->pst_left; rsdmp && 
			rsdmp->pst_sym.pst_type == PST_RESDOM;
			rsdmp = rsdmp->pst_left)
	     if ((rtype = abs(rsdmp->pst_sym.pst_dataval.db_datatype)) ==
					DB_LVCH_TYPE ||
		rtype == DB_LBYTE_TYPE || rtype == DB_LNVCHR_TYPE)
	     {
		/* Display error. */
		(VOID) psf_error(2231L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	     }
	    tree->pst_mask1 |= PST_SCROLL;
	}

	/* Check for KEYSET cursor. */
	if (yacc_cb->yypvt[-1].psl_bool == 1)
	    cb->pss_stmt_flags &= ~PSS_KEYSET;	/* no KEYSET if READONLY*/
	else if (cb->pss_stmt_flags & PSS_KEYSET)
	{
	    i4		err_code, reason;
	    bool	nonupdt = FALSE;

	    /* Can't have KEYSET cursor on a Star DB. */
	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/* Display error. */
		(VOID) psf_error(2232L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	    }

	    /* Verify that it's updateable - if not, send errors. */
	    (VOID) psl_up(cb, &cb->pss_auxrng, tree, &nonupdt, &reason);

	    if (nonupdt)
	    {

		(VOID) psf_error(2229L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
		psl_nonupdt_err(psq_cb, cb, reason, &err_code);
		return(E_DB_ERROR);
	    }

	    /*
	    ** Valid KEYSET cursor.
	    ** Identify and flag result columns in keyset.
	    */
	    status = psl_crskeyflag(cb, tree);
	    if (DB_FAILURE_MACRO(status))
	    {
		/* don't have unique key covered by result set */
		(VOID) psf_error(2307L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name),
		    yacc_cb->yypvt[-2].psl_crblk->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	    }
	    tree->pst_mask1 |= PST_KEYSET;
	}
    } break;

case 727:
if (!((*yyvarspp)->bypass_actions))
/* # line 15637 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_PROCEDURE	    *pnode;
	PST_QTREE	    *tree;
	DB_STATUS	    status;
	i4		    i;
	PSS_RNGTAB	    *rngvar;
	i4		    err_code;
	bool		    use_view;
	i4		    rng_count;
	bool		    qpcomp;

	/*
	** Obtain the prototype query tree from QSF and duplicate the tree.
	*/
	status = pst_execute(psq_cb, cb, yacc_cb->yypvt[-0].psl_strtype, &pnode, &yyvarsp->dsql_maxparm,
	    (PTR *) &yyvarsp->dsql_plist, &yyvarsp->nonupdt, &yyvarsp->dynqp_comp, &yyvarsp->updcollst);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	if (yyvarsp->dynqp_comp)
	{
	    psq_cb->psq_mode = PSQ_REPDYN;
	    yyvarsp->repeat_dyn = TRUE;
	}

	if (pnode->pst_flags & PST_REPEAT_DYNAMIC)
	    yyvarsp->repeat_dyn = TRUE;

	tree = pnode->pst_stmts->pst_specific.pst_tree;

	if (cb->pss_viewrng.pss_maxrng > 0)
	{
		use_view = TRUE;
		rng_count = cb->pss_viewrng.pss_maxrng;
	}
	else
	{
		use_view = FALSE;
		rng_count = tree->pst_rngvar_count;
	}

	/* QRYMOD execution requires entries in the range table.
	** This has to be done, otherwise integrities and permissions
	** for the cursor are likely to be screwed up (qrymod code
	** relies heavily on the parser range var. table.
	** We no longer need to look at PST_NUMVARS entries - pst_rngvar_count
	** tells us how many entries there are
	*/
	for (i = 0; i < rng_count; i++)
	{
	    if (tree->pst_rangetab[i] == (PST_RNGENTRY *) NULL ||
		tree->pst_rangetab[i]->pst_rgtype == PST_UNUSED)
	    {
		/*
		** this should never happen since we have not run psy_view()
		** over this tree yet
		*/
		(VOID) psf_error(E_PS0C04_BAD_TREE, 0L, PSF_INTERR,
		    &err_code, &psq_cb->psq_error, 0);
		return(E_DB_ERROR);
	    }

	    /*
	    ** Range variable name "!" means don't look for and
	    ** try to replace a range variable of the same name.
	    */

	    /*
	    ** Process derived tables and with elements separately.
	    */
	    if (tree->pst_rangetab[i]->pst_rgtype == PST_DRTREE ||
		tree->pst_rangetab[i]->pst_rgtype == PST_WETREE)
		status = pst_sdent(&cb->pss_auxrng, -1, "!", cb,
		    &rngvar, tree->pst_rangetab[i]->pst_rgroot,
		    tree->pst_rangetab[i]->pst_rgtype, 
		    &psq_cb->psq_error);
	    else if (use_view)
	    	status = pst_rgent(cb, &cb->pss_auxrng, -1, "!", PST_SHWID, 
		    (DB_TAB_NAME*) NULL, (DB_TAB_OWN*) NULL,
		    &cb->pss_viewrng.pss_rngtab[i].pss_tabid, FALSE, 
		    &rngvar, psq_cb->psq_mode, &psq_cb->psq_error);
	    else
	    	status = pst_rgent(cb, &cb->pss_auxrng, -1, "!", PST_SHWID, 
		    (DB_TAB_NAME*) NULL, (DB_TAB_OWN*) NULL,
		    &tree->pst_rangetab[i]->pst_rngvar, FALSE, 
		    &rngvar, psq_cb->psq_mode, &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
	    {
		if (psq_cb->psq_error.err_code == E_PS0903_TAB_NOTFOUND)
		{
		    (VOID) psf_error(E_US1265_QEP_INVALID, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		}
		else
		{
		    (VOID) psf_error(E_PS0E03_RGENT_ERR, psq_cb->psq_error.err_code,
			PSF_INTERR, &err_code, &psq_cb->psq_error, 0);
		}
		return (status);
	    }

	    /* If we haven't assign the pss_viewrng structure yet set it up */
	    if (use_view == FALSE)
	    {
		STRUCT_ASSIGN_MACRO(*rngvar,cb->pss_viewrng.pss_rngtab[i]);
	    	if (rngvar->pss_tabdesc->tbl_status_mask & DMT_VIEW)
                   cb->pss_viewrng.pss_maxrng = tree->pst_rngvar_count;
	    }
		
	    /* Reconstruct cb->pss_resrng */
	    if (i == tree->pst_restab.pst_resvno)
	    {
		cb->pss_resrng = rngvar;
	    }

	    /*
	    ** reconstruct the range variable name; this is required since we
	    ** may end up copying it into the PST_RNGENTRY structure, and "!"
	    ** will not do as a correlation name
	    */
	    MEcopy((PTR) &tree->pst_rangetab[i]->pst_corr_name,
		DB_MAXNAME, (PTR) rngvar->pss_rgname);

	    /*
	    ** copy inner and outer join maps into the new range table
	    ** entry
	    */
	    STRUCT_ASSIGN_MACRO(tree->pst_rangetab[i]->pst_inner_rel,
	        rngvar->pss_inner_rel);
	    STRUCT_ASSIGN_MACRO(tree->pst_rangetab[i]->pst_outer_rel,
	        rngvar->pss_outer_rel);
	}

	/* Restore query mode to `open cursor' - but only if not already
	** compiled cached query. */
	if (!yyvarsp->dynqp_comp)
	    psq_cb->psq_mode = PSQ_DEFCURS;

	/* reconstruct $Yjoin_id from tree->pst_numjoins */
	yyvarsp->join_id = tree->pst_numjoins;

	yacc_cb->yyval.psl_crblk = yacc_cb->yypvt[-1].psl_crblk;
    } break;

case 728:
if (!((*yyvarspp)->bypass_actions))
/* # line 15787 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_bool = TRUE;
    } break;

case 729:
if (!((*yyvarspp)->bypass_actions))
/* # line 15791 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_bool = FALSE;
    } break;
	}
	return(0);
}

i4
psls16iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 732:
if (!((*yyvarspp)->bypass_actions))
/* # line 15802 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	++cb->pss_highparm;
	if (yyvarsp->in_target_clause)
	   ++cb->pss_targparm;
	if (cb->pss_highparm <= yyvarsp->dsql_maxparm)
	{
	    *(yyvarsp->dsql_plist + cb->pss_highparm) = yacc_cb->yypvt[-0].psl_dbval;
	}
    } break;

case 733:
if (!((*yyvarspp)->bypass_actions))
/* # line 15814 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;
	DB_STATUS   status;

	if ((psq_cb->psq_mode == PSQ_REPCURS) ||
	    (psq_cb->psq_mode == PSQ_DELCURS))
	{
	    (VOID) psf_error(2216L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DEFQRY;

	/*
	** For shared QEP's we need to define or translate
	** the FE object id.
	*/
	if (yyvarsp->qp_shareable)
	{
	    status = psl_repeat_qry_id(psq_cb, cb, &yyvarsp->fe_cursor_id, yacc_cb->yypvt[-0].psl_qttype,
		yyvarsp->shr_qryinfo);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}
    } break;

case 734:
if (!((*yyvarspp)->bypass_actions))
/* # line 15846 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_DEFQRY;
	cb->pss_defqry = PSQ_DEFQRY;

	/* For shared QEP's save the original FE id. */
	STRUCT_ASSIGN_MACRO(*(yacc_cb->yypvt[-1].psl_cursid), yyvarsp->fe_cursor_id);

	/* 
	** Hand cursor id back to caller. PSF fills in a part of cursor id.
	** The part consists of two i4's. The only requirement here is that
	** they be unique. So we use pss_sessid which is always unique and
	** a counter (pss_crsid) within each session. We used TMnow before
	** but it turns out that the granularity of the system clock is not
	** good enough to make the timestamp unique.
	*/
	STRUCT_ASSIGN_MACRO(*(yacc_cb->yypvt[-1].psl_cursid), psq_cb->psq_cursid);
	psq_cb->psq_cursid.db_cursor_id[0] = (i4) cb->pss_psessid;
	psq_cb->psq_cursid.db_cursor_id[1] = (i4) ++cb->pss_crsid;
    } break;

case 735:
if (!((*yyvarspp)->bypass_actions))
/* # line 15868 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_qttype = yacc_cb->yypvt[-0].psl_qttype;
    } break;

case 736:
if (!((*yyvarspp)->bypass_actions))
/* # line 15872 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_qttype = yacc_cb->yypvt[-0].psl_qttype;
    } break;

case 737:
if (!((*yyvarspp)->bypass_actions))
/* # line 15876 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->check_for_vlups = TRUE;
    } break;

case 738:
if (!((*yyvarspp)->bypass_actions))
/* # line 15880 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_qttype = yacc_cb->yypvt[-0].psl_qttype;
    } break;

case 739:
if (!((*yyvarspp)->bypass_actions))
/* # line 15884 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_qttype = yacc_cb->yypvt[-0].psl_qttype;
    } break;

case 740:
if (!((*yyvarspp)->bypass_actions))
/* # line 15894 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE              *tidnode;
	PST_VAR_NODE	       tidvar;
	PST_QNODE	       *rsdmnode;
	PST_RSDM_NODE	       resdom;
	PST_QNODE	       *rootnode;
	PST_RT_NODE	       root;
	PST_QTREE	       *tree;
	DB_STATUS	       status;
	i4		       err_code;
	i4                qrymod_resp_mask;
	PSC_CURBLK	       *cursor;
	PST_PROCEDURE          *pnode;
	i4		       tbl_stat_mask;
	i4		       tbl_2_stat_mask;
	i4		       hdr_mask;

	if (psq_cb->psq_mode == PSQ_DELETE)
	{
	    if (~cb->pss_distrib & DB_3_DDB_SESS)
	    {
		hdr_mask = 0;

		/* Set up a var. node representing the tid.
		** pst_adresdom should not be used here because it relies on
		** cb->pss_rsdmno, which may be incorrect now due to the fact
		** that subselects in the where clause reset it every time a new
		** target list is started.
		*/
		tidvar.pst_vno = yacc_cb->yypvt[-1].psl_rngtype->pss_rgno;
		tidvar.pst_atno.db_att_id = 0;	    /* tid is always column 0 */

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &tidvar,
		    sizeof(tidvar), DB_TID8_TYPE, (i2) 0, (i4) DB_TID8_LENGTH,
		    (DB_ANYTYPE *) NULL,
		    &tidnode, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);	    /* non-zero return means error */
		}

		/* Set up a resdom result domain representing a tid. */
		resdom.pst_rsno = 0;
		cb->pss_rsdmno++; /* Count resdoms */
		resdom.pst_ntargno = (i4) 0;
		resdom.pst_ttargtype = (i4) PST_ATTNO;
		resdom.pst_rsupdt = FALSE;
		resdom.pst_rsflags = 0; /* no PST_RS_PRINT */
	        resdom.pst_dmuflags = 0;

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    tidnode, PST_RESDOM, (PTR) &resdom, sizeof(resdom),
		    DB_TID8_TYPE, (i2) 0, (i4) DB_TID8_LENGTH, 
		    (DB_ANYTYPE *) NULL, &rsdmnode,
		    &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);	/* non-zero return means error */
		}
	    }
	    else
	    {
		rsdmnode = (PST_QNODE *) NULL;
		hdr_mask = PST_1INSERT_TID;
	    }

	    /* Make the root node */
	    root.pst_rtuser = TRUE;
	    root.pst_union.pst_next  = 0;
	    root.pst_dups   = PST_ALLDUPS;
	    MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&yyvarsp->from_list);
	    root.pst_tvrc   = BTcount((char *) &yyvarsp->from_list, 
				      BITS_IN(yyvarsp->from_list));
	    MEcopy((char *)&yyvarsp->from_list, sizeof(PST_J_MASK),
						(char *)&root.pst_tvrm);

	    status = pst_node(cb, &cb->pss_ostream, rsdmnode, yacc_cb->yypvt[-0].psl_trtype, PST_ROOT,
		(PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);	/* non-zero return means error */
	    }

	    /* Remember the result variable */
	    cb->pss_resrng = yacc_cb->yypvt[-1].psl_rngtype;

	    /* For repeat queries we must determine if the query is shareable.
	    ** We already know that this is an SQL query, so the only criterion
	    ** to be checked out is whether all relations/views are DBA owned or
	    ** are catalogs.
	    */
	    if (cb->pss_defqry == PSQ_DEFQRY)
	    {
		status = psl_shareable(psq_cb, cb,&yyvarsp->qp_shareable,
			&yyvarsp->shr_qryinfo);
		if (status != E_DB_OK)
		{
		    return (status);
		}
	    }

	    /* Apply qrymod algorithm (views, permits, integrities) */
	    status = psy_qrymod(rootnode, cb, psq_cb, &yyvarsp->join_id,
	    	&qrymod_resp_mask);
	    if (status != E_DB_OK)
		return (status);

	    tbl_stat_mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	    tbl_2_stat_mask = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	    /* Make sure base table is updateable;
	    ** In case of an index or a non-extended catalog
	    ** catalog update privilege must be on.
	    ** In case of security catalog session must have security 
	    ** privilege active.
	    ** Bug 34079, since 6.0 you were never supposed to be 
            ** able to update a secondary index.  Fixed it so 
            ** the same error is returned whether you have update 
            ** syscat or not (jennifer)
	    **
	    ** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
	    ** allow DELETE on indexes which are non-extended catalogs
	    */
            if (tbl_2_stat_mask & DMT_READONLY)
            {
                (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L,
                           PSF_USERERR, &err_code, &psq_cb->psq_error, 0);
                return(E_DB_ERROR);
            }
	    else if (tbl_stat_mask & DMT_IDX)
	    {
		if (!(   tbl_stat_mask & DMT_CATALOG
		      && ~tbl_stat_mask & DMT_EXTENDED_CAT
		      && cb->pss_ses_flag & PSS_CATUPD
		      && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
		     )
		   )
		{
		    _VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &cb->pss_resrng->pss_tabname),
			&cb->pss_resrng->pss_tabname);
		    return(E_DB_ERROR);
		}
	    }
	    else if (   ((tbl_stat_mask & DMT_CATALOG ||
			 tbl_2_stat_mask & DMT_TEXTENSION)
		     && ~tbl_stat_mask & DMT_EXTENDED_CAT
		     && !(cb->pss_ses_flag & PSS_CATUPD)) 
		     ||
		     ((tbl_stat_mask & DMT_SECURE) &&
        	       !(cb->pss_ustat & DU_USECURITY)))
	    {
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_DELETE, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_DELETE, &e_error);
		if (local_status > status)
		    status = local_status;

		_VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return (E_DB_ERROR);
	    }
	}
	else	/* DELETE CURSOR */
	{
	    cursor = (PSC_CURBLK *)yacc_cb->yypvt[-0].psl_trtype;

	    /* We must compare names of objects and of object owners. */
	    if (MEcmp((PTR) &(cursor->psc_tabnm),
		      (PTR) &(yacc_cb->yypvt[-1].psl_rngtype->pss_tabname), sizeof(DB_TAB_NAME)) ||
		MEcmp((PTR) &(cursor->psc_ownnm),
		      (PTR) &(yacc_cb->yypvt[-1].psl_rngtype->pss_ownname), sizeof(DB_OWN_NAME)))
	    {
		(VOID) psf_error(2227L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 4,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &cursor->psc_tabnm),
		    &cursor->psc_tabnm,
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &cursor->psc_ownnm),
		    &cursor->psc_ownnm,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &yacc_cb->yypvt[-1].psl_rngtype->pss_tabname),
		    &yacc_cb->yypvt[-1].psl_rngtype->pss_tabname,
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &yacc_cb->yypvt[-1].psl_rngtype->pss_ownname),
		    &yacc_cb->yypvt[-1].psl_rngtype->pss_ownname);
		return(E_DB_ERROR);
	    }

	    /* Make the root node */
	    root.pst_tvrc = 0;
	    root.pst_lvrc = 0;
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_lvrm);
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_rvrm);
	    root.pst_mask1 = 0;
	    root.pst_qlang = DB_SQL;
	    root.pst_rtuser = TRUE;
	    root.pst_union.pst_next  = NULL;
	    root.pst_dups = PST_ALLDUPS;
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL,
		(PST_QNODE *)NULL, PST_ROOT, (PTR)&root, sizeof(PST_RT_NODE),
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &rootnode,
		&psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
		return (status);

	    /* Remember the result variable */
	    cb->pss_resrng = yacc_cb->yypvt[-1].psl_rngtype;

	    /* Apply qrymod (currently only rules for DELETE cursor) */
	    status = psy_rules(cb, psq_cb->psq_mode, rootnode,
			       &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	cb->pss_qualdepth--;

	/* Make the header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *)NULL,
			    rootnode, &tree, &pnode,
			    hdr_mask | ((yyvarsp->isdbp) ? 0: PST_0FULL_HEADER),
			    &yyvarsp->xlated_qry);
	if (status != E_DB_OK)
	    return (status);

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = yyvarsp->join_id;

	/* Fix the root in QSF */
	if (pnode != (PST_PROCEDURE *)NULL)
	{
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR)pnode,
			       &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	yacc_cb->yyval.psl_qttype = tree;
    } break;

case 741:
if (!((*yyvarspp)->bypass_actions))
/* # line 16166 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;

	/* Set query mode */
	psq_cb->psq_mode = PSQ_DELETE;

	/* Open memory stream for allocating query tree */
	if (yyvarsp->isdbp == FALSE)
	{
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error)) != E_DB_OK)
	    {
		return (status);    /* non-zero return means error */
	    }
	}
	else
	{
	    /*
	    ** To indicate that in 'i= :i' in a subselect the first
	    ** "i" must not be processed as a local var (bug 8269).
	    */
	    yyvarsp->dbpinfo->pss_flags |= PSS_1SUB_SEEN;
	}

	MEfill(sizeof(PST_J_MASK), 0, (char *)&yyvarsp->flists[++cb->pss_qualdepth]);

	/* Start off with no columns */
	cb->pss_rsdmno = 0;
    } break;

case 742:
if (!((*yyvarspp)->bypass_actions))
/* # line 16198 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	if (psy_cb->psy_numtabs == 0)
	{
	    /*
	    **  If there are no tables specified we just want to return.
	    **  Error messages should have already been displayed.
	    **  It is not possible for the user to type in DROP and get
	    **  to this production; he would first get a syntax error.
	    **  Upon return to SCF the sequencer will examine the return
	    **	code (E_DB_ERROR), then evaluate err_code, which in this
	    **  case will be set to indicate user error and just return
	    **  to the front end without any complaints, and that is what
	    **  we want.
	    */
	    psq_cb->psq_error.err_code = E_PS0001_USER_ERROR;
	    return (E_DB_ERROR);
	}
    } break;

case 745:
if (!((*yyvarspp)->bypass_actions))
/* # line 16226 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	if (yyvarsp->upobjtype < REMOVE_OBJ)
	{
	    psq_cb->psq_mode = PSQ_DESTROY;
	}
	else
	{
            /*
            ** schang: change from psq_remove to psq_reg_remove
            ** this change may cause problem in STAR.  Consult with
            ** Barbara if trouble occurs
            */
	    psq_cb->psq_mode = PSQ_REG_REMOVE;
	}

	/* Create a PSY_CB to do the destruction of tables and views */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	if (cb->pss_distrib & DB_3_DDB_SESS /* && $Yupobjtype < DROP_LINK */)
	{
	    /* q_next will be used to point to the first element of the queue */
	    psy_cb->psy_tblq.q_next = (PSF_QUEUE *) NULL;

	    /* q_prev will be used to point to the last element of the queue */
	    psy_cb->psy_tblq.q_prev = (PSF_QUEUE *) NULL;
	}

	if (yyvarsp->upobjtype == REMOVE_PROCEDURE)
	{
	    /* set flag so that psy_kview will destroy QP */
	    psy_cb->psy_flags |= PSY_REMOVE_PROC;
	}
    } break;

case 746:
if (!((*yyvarspp)->bypass_actions))
/* # line 16269 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* initialize object type var */
	yyvarsp->upobjtype = 0L;
    } break;

case 747:
if (!((*yyvarspp)->bypass_actions))
/* # line 16274 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* set object type var */
	yyvarsp->upobjtype = DROP_BASETABLE;
    } break;

case 748:
if (!((*yyvarspp)->bypass_actions))
/* # line 16279 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* set object type var */
	yyvarsp->upobjtype = DROP_VIEW;
    } break;

case 749:
if (!((*yyvarspp)->bypass_actions))
/* # line 16284 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	/* "DROP INDEX" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5208L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error,0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	/* set object type var */
	yyvarsp->upobjtype = DROP_INDEX;
    } break;

case 750:
if (!((*yyvarspp)->bypass_actions))
/* # line 16299 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* DROP LINK is allowed ONLY in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;

	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,sizeof("DROP LINK") - 1,
			     "DROP LINK");
	    return (E_DB_ERROR);
	}

	/* set object type var */
	yyvarsp->upobjtype = DROP_LINK;
    } break;

case 751:
if (!((*yyvarspp)->bypass_actions))
/* # line 16315 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* set object type var */
	yyvarsp->upobjtype = REMOVE_OBJ;
    } break;

case 752:
if (!((*yyvarspp)->bypass_actions))
/* # line 16320 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* set object type var */
	yyvarsp->upobjtype = REMOVE_TBL;
    } break;

case 753:
if (!((*yyvarspp)->bypass_actions))
/* # line 16325 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* REMOVE VIEW is allowed ONLY in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;

	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,STlength("REMOVE VIEW"),
			     "REMOVE VIEW");
	    return (E_DB_ERROR);
	}

	/* set object type var */
	yyvarsp->upobjtype = REMOVE_VIEW;
    } break;

case 754:
if (!((*yyvarspp)->bypass_actions))
/* # line 16341 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	/* set object type var */
	yyvarsp->upobjtype = REMOVE_INDEX;
	
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* Note that in this release it is not allowed in STAR */
	    (VOID) psf_error(5208L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error,0);
	    return(E_DB_ERROR);
	}
    } break;

case 755:
if (!((*yyvarspp)->bypass_actions))
/* # line 16356 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* REMOVE PROCEDURE is allowed ONLY in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;

	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,STlength("REMOVE PROCEDURE"),
			     "REMOVE PROCEDURE");
	    return (E_DB_ERROR);
	}

	/* set object type var */
	yyvarsp->upobjtype = REMOVE_PROCEDURE;
    } break;

case 756:
if (!((*yyvarspp)->bypass_actions))
/* # line 16374 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	/* "DROP SYNONYM" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP SYNONYM")-1, "DROP SYNONYM");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psq_cb->psq_mode = PSQ_DSYNONYM;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);
    } break;

case 761:
if (!((*yyvarspp)->bypass_actions))
/* # line 16403 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_RNGTAB		*resrange;
	i4			err_code;
	DB_STATUS		status;
	i4			rngvar_info;

	/*
	** First we need to determine if the name specified by the user
	** refers to a synonym owned by this user
	*/
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp(cb->pss_user.db_own_name, 
		  yacc_cb->yypvt[-0].psl_objspec->pss_owner.db_own_name, sizeof(DB_OWN_NAME)))
	{
	    (VOID) psf_error(E_PS042E_DROPSYN_NOT_OBJ_OWNER, 0L,
		PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
	}
	else
	{
	    /* only search for objects owned by the current user */
	    status = psl0_orngent(&cb->pss_auxrng, -1, "", &cb->pss_user,
		&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info, 0);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    /* current user doesn't own an object with this name */
	    if (resrange == (PSS_RNGTAB *) NULL)
	    {
		(VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2,
		    sizeof("DROP SYNONYM") - 1, "DROP SYNONYM",
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
		    &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name);
	    }
	    else if (~rngvar_info & PSS_BY_SYNONYM)
	    {
		/* object is not a synonym */

		char	    *obj_type, *op;
		i4	    mask;
		i4	    obj_len, op_len;

		mask = resrange->pss_tabdesc->tbl_status_mask;
		if (mask & DMT_VIEW)
		{
		    obj_type = "view";
		    obj_len  = sizeof("view") - 1;
		    op       = "DROP [VIEW]";
		    op_len   = sizeof("DROP [VIEW]") - 1;
		}
		else if (mask & DMT_IDX)
		{
		    obj_type = "index";
		    obj_len  = sizeof("index") - 1;
		    op       = "DROP [INDEX]";
		    op_len   = sizeof("DROP [INDEX]") - 1;
		}
		else
		{
		    obj_type = "table";
		    obj_len  = sizeof("table") - 1;
		    op       = "DROP [TABLE]";
		    op_len   = sizeof("DROP [TABLE]") - 1;
		}

		(VOID) psf_error(E_PS0457_DROPSYN_NOT_SYN, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 3,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
		    &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, 
		    obj_len, obj_type, 
		    op_len, op);
	    }
	    else
	    {
		PSY_CB	*psy_cb = (PSY_CB *) cb->pss_object;
		i4	mask = resrange->pss_tabdesc->tbl_status_mask;

		/* Check for too many tables to fit into control block */
		if (psy_cb->psy_numtabs == PSY_MAXTABS)
		{
		    (VOID) psf_error(2754L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}

		/* Put synonym name into PSY_CB */
		STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
				    psy_cb->psy_tabname[psy_cb->psy_numtabs]);

		/*
		** store id of the object whose synonym is being dropped so that
		** we can change its timestamp (if it is not a view) or that of
		** an underlying base table (if it is a view)
		*/
		STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
				    psy_cb->psy_tables[psy_cb->psy_numtabs]);

		/*
		** if dropping a synonym which was created for a view, set a
		** flag for psy_drop_synonym()
		*/
		psy_cb->psy_obj_mask[psy_cb->psy_numtabs++] = (mask & DMT_VIEW)
								? PSY_IS_VIEW
								: 0;
	    }
	}
    } break;

case 762:
if (!((*yyvarspp)->bypass_actions))
/* # line 16521 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DD_OBJ_DESC		*obj_desc;
	DD_OBJ_TYPE		ldb_obj_type;
	PSS_RNGTAB		*resrange;
	i4			err_code;
	DB_STATUS		status;
	i4			rngvar_info;
	char			*cmnd;
	i4			cmnd_len;
	i4			op_code;

	/* Set up parameters for various error messages */
	if (yyvarsp->upobjtype <= DROP_LINK)
	{
	    cmnd = "DROP";
	    cmnd_len = 4;
	}
	else if (yyvarsp->upobjtype == REMOVE_PROCEDURE)
	{
	    cmnd = "REMOVE PROCEDURE";
	    cmnd_len = 16;
	}
	else
	{
	    cmnd = "REMOVE";
	    cmnd_len = 6;
	}

	/* First try to obtain table description */
	{
	    i4		lookup_mask = 0;

	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/*
		** RDF flags to distinguish between drop and remove;
		** also (if user has system catalog update privilege)
		** to let RDF know that local object owner may be
		** different from current user
		*/
		lookup_mask = ((yyvarsp->upobjtype >= DROP_LINK) ?
				PST_CHECK_EXIST | PST_REMOVE : PST_DTBL);
		if (lookup_mask & PST_DTBL && cb->pss_ses_flag & PSS_CATUPD)
		    lookup_mask |= PST_IS_CATALOG;
	    }

	    if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {	
		status = psl0_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
		    &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		    &psq_cb->psq_error, &rngvar_info, lookup_mask);
	    }
	    else
	    {
		i4	tbls_to_lookup;
		char	*ch1, *ch2;

		if (~cb->pss_distrib & DB_3_DDB_SESS)
		{
		    tbls_to_lookup = PSS_USRTBL | PSS_DBATBL | PSS_INGTBL;
		    
		    /* One may drop an index on a session temp table */
		    if ( yyvarsp->upobjtype == DROP_INDEX ||
			cb->pss_ses_flag & PSS_GTT_SYNTAX_SHORTCUT )
			tbls_to_lookup |= PSS_SESTBL;
		}
		else
		{
		    ch1 = yacc_cb->yypvt[-0].psl_objspec->pss_obj_name.db_tab_name;
		    ch2 = ch1 + CMbytecnt(ch1);

		    /* If table name starts with "ii" and user has system
		    ** catalog update privilege check table as an "INGRES"
		    ** table only.
		    */

		    if (  !CMcmpnocase(ch1, &SystemCatPrefix[0]) &&
			  !CMcmpnocase(ch2, &SystemCatPrefix[1]) &&
			  cb->pss_ses_flag & PSS_CATUPD
			)
		    {
			tbls_to_lookup = PSS_INGTBL;
		    }
		    else
		    {
			tbls_to_lookup = PSS_USRTBL;
		    }
		}
		status = psl0_rngent(&cb->pss_auxrng, -1, "",
		    &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		    &psq_cb->psq_error, tbls_to_lookup, &rngvar_info,
		    lookup_mask);
	    }
	    
	    if (DB_FAILURE_MACRO(status))
	    {
		if (~cb->pss_distrib & DB_3_DDB_SESS)
		    return (status);
		if (    psq_cb->psq_error.err_code != E_PS0916_USER_NOT_OWNER
		    &&	psq_cb->psq_error.err_code != E_PS0919_BAD_CATALOG_ENTRY
		    &&	psq_cb->psq_error.err_code != E_PS091A_CANNOT_CONNECT)
		{
		    return (status);
		}
	    }

	    if (resrange == (PSS_RNGTAB *) NULL)
	    {
		if (DB_FAILURE_MACRO(status))	/* Star */
		{
		    (VOID) psf_error(psq_cb->psq_error.err_code, 0L,
			PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
				(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
				&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name);
		}
		else if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
		{
		    (VOID) psf_error(2764L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 3, cmnd_len, cmnd,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
			&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
			psf_trmwhite(sizeof(DB_OWN_NAME),
			    (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
			&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
		}
		else
		{
		    (VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, cmnd_len, cmnd,
			psf_trmwhite(sizeof(DB_TAB_NAME), 
			    (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
			&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name);
		}
	    }
	    /*
	    ** DROP synonym_name will be disallowed
	    */
	    else if (rngvar_info & PSS_BY_SYNONYM && yyvarsp->upobjtype == 0)
	    {
		(VOID) psf_error(E_PS0452_CANT_DROP_SYN, 0L,
		    PSF_USERERR, &err_code, &psq_cb->psq_error, 1, 
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
		    &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name);

		resrange = (PSS_RNGTAB *) NULL;
	    }
	    /*								    
	    ** Object is not a catalog (i.e. it is a table) AND
	    ** it is not owned by the user AND
	    ** is not a DGTT, AND
	    ** (the user is neither a DBA nor $ingres OR
	    ** dba_drop_all flag is not set OR
	    ** object name was not explicitly qualified OR
	    ** user used a synonym).
	    */
	    else if (~resrange->pss_tabdesc->tbl_status_mask & DMT_CATALOG
		     &&
		     MEcmp((PTR) &resrange->pss_ownname, 
			    (PTR) &cb->pss_user, sizeof(DB_OWN_NAME))
		     && 
		     MEcmp((PTR) &resrange->pss_ownname,
			    (PTR) &cb->pss_sess_owner,
			    sizeof(DB_OWN_NAME))
		     &&
		     (~yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			||
		      !(cb->pss_ses_flag & PSS_DBA_DROP_ALL)
			||
		      rngvar_info & PSS_BY_SYNONYM
		        ||
		      (MEcmp((PTR) &cb->pss_user, (PTR) &cb->pss_dba.db_tab_own,
			    sizeof(DB_OWN_NAME))
			    &&
		      MEcmp((PTR) &cb->pss_user, (PTR) cb->pss_cat_owner,
			    sizeof(DB_OWN_NAME)))
		     )
		    )
	    {
		if ( yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
		     Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{ 
		    /*
		    ** Only audit if fully qualified object name used
		    */
		    /* Must audit DROP Failure. */
		    DB_STATUS	local_status;
		    DB_ERROR	e_error;
		    i4	mask = resrange->pss_tabdesc->tbl_status_mask;
		    i4	msg_id;
		    i4		auditevent;
		    i4	accessmask = SXF_A_FAIL;

		    if (mask & DMT_VIEW)
		    {
		    	auditevent = SXF_E_VIEW;
		    	msg_id     = I_SX2015_VIEW_DROP;
		    	accessmask |= SXF_A_DROP;
		    }
		    else if (mask & DMT_IDX)
		    {
		    	auditevent = SXF_E_TABLE;
		    	msg_id     = I_SX2010_INDEX_DROP;
                    	accessmask |= SXF_A_INDEX;
		    }
		    else
		    {
		    	auditevent = SXF_E_TABLE;
		    	msg_id     = I_SX2025_TABLE_DROP;
		    	accessmask |= SXF_A_DROP;
		    }
	            local_status = psy_secaudit(FALSE, cb,
	    		(char *)&resrange->pss_tabdesc->tbl_name,
			&resrange->pss_tabdesc->tbl_owner,
	    		sizeof(DB_TAB_NAME), auditevent,
	      		msg_id, accessmask,
	      		&e_error);
		}
		/*
		** let user know if name supplied by the user was resolved to a
		** synonym
		*/
		if (rngvar_info & PSS_BY_SYNONYM)
		{
		    char	*op;
		    i4		len;

		    switch(yyvarsp->upobjtype)
		    {
			case DROP_BASETABLE:
			    op = "DROP TABLE";
			    len = sizeof("DROP TABLE") - 1;
			    break;
			case DROP_INDEX:
			    op = "DROP INDEX";
			    len = sizeof("DROP INDEX") - 1;
			    break;
			case DROP_VIEW:
			    op = "DROP VIEW";
			    len = sizeof("DROP VIEW") - 1;
			    break;
			case REMOVE_TBL:
			    op = "REMOVE TABLE";
			    len = sizeof("REMOVE TABLE") - 1;
			    break;
			case REMOVE_OBJ:
			    op = "REMOVE";
			    len = sizeof("REMOVE") -1;
			    break;
			default:
			    /*
			    ** E_PS1004_BAD_OBJ_TYPE:
			    ** Invalid type '%0d' detected when '%1c'
			    */
			    (VOID) psf_error(E_PS1004_BAD_OBJ_TYPE, 
				0L, PSF_INTERR, &err_code,
				&psq_cb->psq_error, 2,
				sizeof(yyvarsp->upobjtype), &yyvarsp->upobjtype,
				sizeof("SYNONYM DROP/REMOVE") - 1,
				"SYNONYM DROP/REMOVE");
					
			    /* Should never get here */
			    break;
		    }

		    psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
			len, op, &psq_cb->psq_error);
		}

		if (   yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA 
		    && ~rngvar_info & PSS_BY_SYNONYM)
		{
		    /*
		    ** this error msg will be printed only if the user qualified
		    ** table name with its owner's name + and it was not a
		    ** synonym
		    */
		    (VOID) psf_error(2765L, 0L, PSF_USERERR,&err_code, 
			&psq_cb->psq_error, 3, cmnd_len, cmnd,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname,
			psf_trmwhite(sizeof(DB_OWN_NAME),
			    (char *) &resrange->pss_ownname),
			&resrange->pss_ownname);
		}
		else
		{
		    (VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, cmnd_len, cmnd,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);
		}
		resrange = (PSS_RNGTAB *) NULL;
	    }
	}

	/*
	** If we passed the above checks, do some some more consistency
	** checking, and, if everything computes, add table to the list of
	** objects to be dropped
	*/
	if (resrange != (PSS_RNGTAB *) NULL)
	{
	    PSY_CB	    *psy_cb;
	    i4	    mask, err_num = 0L;
	    i4         mask2;
	    char	    *tab_name, *op;
	    i4		    len;
	    
	    status = E_DB_OK;		    /* being optimistic */
		
	    cb->pss_resrng = resrange;
	    tab_name = resrange->pss_tabname.db_tab_name;
	    mask = resrange->pss_tabdesc->tbl_status_mask;
	    mask2 = resrange->pss_tabdesc->tbl_2_status_mask;

	    psy_cb = (PSY_CB *) cb->pss_object;

	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/* distributed only checks handled later */
		err_num = 0;
	    }
	    /* Make sure we have the right type of object */
	    else if (yyvarsp->upobjtype == DROP_BASETABLE)
	    {
		if (mask & DMT_VIEW || mask & DMT_IDX)
		{
		    err_num = 2750L;
		}
	    }
	    else if (yyvarsp->upobjtype == DROP_VIEW)
	    {
		if (~mask & DMT_VIEW)
		{
		    err_num = 2751L;
		}
	    }
	    else if (yyvarsp->upobjtype == DROP_INDEX)
	    {
		if (~mask & DMT_IDX)
		{
		    err_num = 2752L;
		}
	    }
	    else if (yyvarsp->upobjtype == REMOVE_TBL) 
	    {
		if (~mask & DMT_GATEWAY)
		{
			/* E_US2233_8755 REMOVE [TABLE]: object '%0c' is not a gateway object*/
			err_num=8755L;
		}
	    }
	    else if (yyvarsp->upobjtype == REMOVE_OBJ)
	    {
		if (~mask & DMT_GATEWAY)
		{
			/* E_US2233_8755 REMOVE [TABLE]: object '%0c' is not a gateway object*/
			err_num=8755L;
		}
	    }

	    /* make sure object is user-droppable
	    ** (but don't change error number if already found an error)
	    */
	    if ((resrange->pss_tabdesc->tbl_2_status_mask & DMT_NOT_DROPPABLE)
		&& (err_num == 0L))
	    {
		err_num = E_US18AB_6315_NOT_DROPPABLE;
	    }

	    if ((resrange->pss_tabdesc->tbl_2_status_mask & DMT_READONLY)
		&& (err_num == 0L))
	    {
		err_num = E_US14E8_5352_DROP_READONLY;
	    }  

	    if (err_num != 0L)
	    {
		/* find out which command this is, for error text
		 */
		switch (yyvarsp->upobjtype)
		{
		case DROP_BASETABLE:
		    op = "DROP TABLE";
		    len = sizeof("DROP TABLE") - 1;
		    break;
		case DROP_VIEW:
		    op = "DROP VIEW";
		    len = sizeof("DROP VIEW") - 1;
		    break;
		case DROP_INDEX:
		    op = "DROP INDEX";
		    len = sizeof("DROP INDEX") - 1;
		    break;
		case REMOVE_TBL:
		    op="REMOVE TABLE";
		    len = sizeof("REMOVE TABLE") - 1;
		    break;
		case REMOVE_OBJ:
		    op="REMOVE";
		    len = sizeof("REMOVE") - 1;
		    break;
		default:
		    op = "";
		    len = 0;
		}
		
		/*
		** let user know if name supplied by the user was resolved
		** to a synonym
		*/
		if (rngvar_info & PSS_BY_SYNONYM)
		{
		    psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
			len, op, &psq_cb->psq_error);
		}

		if ((err_num == E_US18AB_6315_NOT_DROPPABLE) 
				||
		    (err_num == E_US14E8_5352_DROP_READONLY) )
		{
		    (VOID) psf_error(err_num, 0L, PSF_USERERR,
				&err_code, &psq_cb->psq_error, 2,
				len, op, 
				psf_trmwhite(sizeof(DB_TAB_NAME), tab_name),
				tab_name);
		}
		else
		{
		    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 1,
				psf_trmwhite(sizeof(DB_TAB_NAME), tab_name),
				tab_name);
		}
		status = E_DB_ERROR;
	    }
	    /*
	    ** If object is a catalog, one may drop it if one has a
	    ** catalog update privilege AND it is not a CORE catalog.
	    ** For distributed, mask will not be set to DMT_CATALOG.
	    **
	    ** 13-jan-93 (andre)
	    **	    if running UPGRADEDB and possess CATUPD, allow destruction
	    **	    of one core catalog - IIDEVICES
	    */
	    else if (   (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
		     && (   !(cb->pss_ses_flag & PSS_CATUPD)
			 || (   mask & DMT_CONCURRENCY
			     && (   resrange->pss_tabid.db_tab_base !=
					DM_B_DEVICE_TAB_ID
				 || resrange->pss_tabid.db_tab_index !=
					DM_I_DEVICE_TAB_ID
				 || ~cb->pss_ses_flag & PSS_RUNNING_UPGRADEDB
				)
			    )
			)
		    )
	    {
		/* Must audit DROP Failure. */
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS       local_status;
		    DB_ERROR	e_error;
		    i4		msg_id;
		    i4		auditevent;
		    i4		accessmask = SXF_A_FAIL | SXF_A_DROP;

		    if (yyvarsp->upobjtype == DROP_VIEW)
		    {
			auditevent = SXF_E_VIEW;
			msg_id     = I_SX2015_VIEW_DROP;
		    }
		    else
		    {
			if (yyvarsp->upobjtype == DROP_INDEX)
			{
			    msg_id = I_SX2010_INDEX_DROP;
			    accessmask |= SXF_A_INDEX;
			}
			else
			    msg_id = I_SX2025_TABLE_DROP;
			auditevent = SXF_E_TABLE;
		    }
		    local_status = psy_secaudit(FALSE, cb,
			    tab_name, &cb->pss_user,
			    sizeof(DB_TAB_NAME), auditevent,
			    msg_id, accessmask,
			    &e_error);
		}

		/*
		** let user know if name supplied by the user was resolved
		** to a synonym
		*/
		if (rngvar_info & PSS_BY_SYNONYM)
		{
		    switch(yyvarsp->upobjtype)
		    {
			case DROP_BASETABLE:
			    op = "DROP TABLE";
			    len = sizeof("DROP TABLE") - 1;
			    break;
			case DROP_INDEX:
			    op = "DROP INDEX";
			    len = sizeof("DROP INDEX") - 1;
			    break;
			case DROP_VIEW:
			    op = "DROP VIEW";
			    len = sizeof("DROP VIEW") - 1;
			    break;
		    }

		    psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
			len, op, &psq_cb->psq_error);
		}

		(VOID) psf_error(5103L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, sizeof ("DROP") - 1, "DROP",
		    psf_trmwhite(sizeof(DB_TAB_NAME), tab_name), tab_name);
		status = E_DB_ERROR;
	    }

	    else if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/*
		** Gather information on local object for QEF; also
		** do some error checking regarding local object.
		*/

		DD_OBJ_TYPE		ddb_obj_type;

		obj_desc = resrange->pss_rdrinfo->rdr_obj_desc;

		ddb_obj_type = obj_desc->dd_o6_objtype;
		ldb_obj_type = obj_desc->dd_o9_tab_info.dd_t3_tab_type;

		/* Make sure we have the right type of object */

		if ((psq_cb->psq_error.err_code != E_PS0000_OK) &&
		    (psq_cb->psq_error.err_code != E_PS0001_USER_ERROR))
		{
		    /*
		    ** Some errors mean only that we wouldn't be able to DROP
		    ** the LDB object, but we will still drop the DDB object
		    */
		    psq_cb->psq_error.err_code = E_PS0000_OK;
		    op_code = (i4) QED_DLINK;
		}
		else
		{
		    switch (yyvarsp->upobjtype)
		    {
			case 0L:
			{
			    if (ddb_obj_type == DD_1OBJ_LINK)
			    {
				/*
				** Cannot DROP an object that is a LINK,
				** includes registered table, view and procedure
				*/
                                (VOID) psf_error(2759L, 0L, PSF_USERERR,
                                    &err_code, &psq_cb->psq_error, 2, 
				    4, "DROP",
                                    psf_trmwhite(sizeof(DB_TAB_NAME),
                                    tab_name), tab_name);
                                status = E_DB_ERROR;
			    }
			    else if (ddb_obj_type == DD_3OBJ_VIEW)
			    {
				op_code = (i4) QEU_DVIEW;
			    }
			    else if (ddb_obj_type == DD_2OBJ_TABLE)
			    {
				op_code = (i4) DMU_DESTROY_TABLE;
			    }
			    else 
			    {
				/*
				** Can not DROP an object if the underlying LDB
				** object is of type INDEX
				*/
				(VOID) psf_error(5211L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 2,
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name, cmnd_len, cmnd);
				status = E_DB_ERROR;
			    }

			    break;
			}
			/*
			** STAR object HAS to have been created using
			** CREATE TABLE. 
			*/
			case DROP_BASETABLE:
			{
                            if (ddb_obj_type == DD_1OBJ_LINK)
                            {
                                /*
                                ** Cannot DROP an object that is a LINK
                                */
                                (VOID) psf_error(2759L, 0L, PSF_USERERR,
                                    &err_code, &psq_cb->psq_error, 2,
                                    10, "DROP TABLE",
                                    psf_trmwhite(sizeof(DB_TAB_NAME),
                                    tab_name), tab_name);
                                status = E_DB_ERROR;
                            }
			    else if (ddb_obj_type == DD_2OBJ_TABLE)
			    {
				op_code = (i4) DMU_DESTROY_TABLE;
			    }
			    else
			    {
				char    *type = (ddb_obj_type == DD_3OBJ_VIEW)
								    ? "VIEW"
								    : "INDEX";

				(VOID) psf_error(2755L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 3,5, "TABLE",
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name, STlength(type), type);

				status = E_DB_ERROR;
			    }

			    break;
			}

			case DROP_VIEW:
			{
                            if (ddb_obj_type == DD_1OBJ_LINK)
                            {
                                /*
                                ** Cannot DROP an object that is a LINK
                                */
                                (VOID) psf_error(2759L, 0L, PSF_USERERR,
                                    &err_code, &psq_cb->psq_error, 2,
                                    9, "DROP VIEW",
                                    psf_trmwhite(sizeof(DB_TAB_NAME),
                                    tab_name), tab_name);
                                status = E_DB_ERROR;
                            }
			    else if (ddb_obj_type == DD_3OBJ_VIEW)
			    {
				op_code = (i4) QEU_DVIEW;
			    }
			    else
			    {
				char    *type = (ddb_obj_type == DD_2OBJ_TABLE)
								      ? "TABLE"
								      : "INDEX";

				(VOID) psf_error(2755L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 3,4, "VIEW",
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name, STlength(type), type);

				status = E_DB_ERROR;
			    }

			    break;
			}

			case DROP_INDEX:
			{
                            if (ddb_obj_type == DD_1OBJ_LINK)
                            {
                                /*
                                ** Cannot DROP an object that is a LINK
                                */
                                (VOID) psf_error(2759L, 0L, PSF_USERERR,
                                    &err_code, &psq_cb->psq_error, 2,
                                    10, "DROP INDEX",
                                    psf_trmwhite(sizeof(DB_TAB_NAME),
                                    tab_name), tab_name);
                                status = E_DB_ERROR;
                            }
			    else if (ddb_obj_type == DD_4OBJ_INDEX)
			    {
				op_code = (i4) DMU_DESTROY_TABLE;
			    }
			    else
			    {
				char    *type = (ddb_obj_type == DD_3OBJ_VIEW)
								      ? "VIEW"
								      : "TABLE";

				(VOID) psf_error(2755L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 3,5, "INDEX",
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name, STlength(type), type);

				status = E_DB_ERROR;
			    }

			    break;
			}

			case DROP_LINK:
			case REMOVE_OBJ:
			case REMOVE_TBL:
			case REMOVE_VIEW:
			case REMOVE_INDEX:
			case REMOVE_PROCEDURE:
			{
			    /*
			    ** remove can now be used on all objects, not just
			    ** those created using REGISTER/CREATE LINK, but we
			    ** still cannot REMOVE an object created via CREATE
			    ** VIEW
			    */
			    if (ddb_obj_type == DD_3OBJ_VIEW)
			    {
				(VOID) psf_error(2758L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 1,
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name);

				status = E_DB_ERROR;
			    }
			    else
			    {
				char	*type;
				char	*rmv_word;
				
				if (ldb_obj_type == DD_2OBJ_TABLE)
				    type = "TABLE";
				else if (ldb_obj_type == DD_3OBJ_VIEW)
				    type = "VIEW";
				else if (ldb_obj_type == DD_4OBJ_INDEX)
				    type = "INDEX";
				else if (ldb_obj_type == DD_5OBJ_REG_PROC)
				    type = "PROCEDURE";
 			   	else type = "UNKNOWN";

				/*
				** first check if there is a conflict between
				** object type as specified by the user and the
				** actual object type
				*/

				if ((yyvarsp->upobjtype == DROP_LINK ||
					 yyvarsp->upobjtype == REMOVE_OBJ)
				    && (ldb_obj_type == DD_5OBJ_REG_PROC))
				{
				    status = E_DB_ERROR;
				    rmv_word = "";
				}
				else if ((yyvarsp->upobjtype == REMOVE_TBL) &&
				    (ldb_obj_type != DD_2OBJ_TABLE))
				{
				    status = E_DB_ERROR;
				    rmv_word = "TABLE";
				}
				else if ((yyvarsp->upobjtype == REMOVE_VIEW) &&
					 (ldb_obj_type != DD_3OBJ_VIEW))
				{
				    status = E_DB_ERROR;
				    rmv_word = "VIEW";
				}
				else if ((yyvarsp->upobjtype == REMOVE_INDEX) &&
					 (ldb_obj_type != DD_4OBJ_INDEX))
				{
				    status = E_DB_ERROR;
				    rmv_word = "INDEX";
				}
				else if ((yyvarsp->upobjtype == REMOVE_PROCEDURE) &&
					 (ldb_obj_type != DD_5OBJ_REG_PROC))
				{
				    status = E_DB_ERROR;
				    rmv_word = "PROCEDURE";
				}
				else 
				{
				    op_code = (i4) QED_DLINK;
				}

				/*
				** if user specified incorrect type, report
				** error; otherwise check if the user tried to
				** use DROP LINK or REMOVE to remove an index,
				** and if so, report an error
				*/
				if (status == E_DB_ERROR)
				{
				    if (ldb_obj_type == DD_5OBJ_REG_PROC)
				    {
					(VOID) psf_error(E_PS1204_RMV_WRONGTYPE, 
					    0L, PSF_USERERR,
					    &err_code, &psq_cb->psq_error,2,
					    STlength(rmv_word), rmv_word,
					    psf_trmwhite(sizeof(DB_TAB_NAME),
				            tab_name), tab_name);
				    }
				    else
				    {
				        (VOID) psf_error(2757L, 0L, PSF_USERERR,
					    &err_code, &psq_cb->psq_error,3,
					    STlength(rmv_word), rmv_word,
					    psf_trmwhite(sizeof(DB_TAB_NAME),
				            tab_name), tab_name,
					    STlength(type),type);
				    }
				}
				else if (ldb_obj_type == DD_4OBJ_INDEX &&
				         yyvarsp->upobjtype != REMOVE_INDEX)
				{
				    if (yyvarsp->upobjtype == REMOVE_OBJ)
				    {
					rmv_word = "REMOVE";
				    }
				    else    /* must be DROP LINK */
				    {
					rmv_word = "DROP LINK";
				    }

				    (VOID) psf_error(5211L, 0L, PSF_USERERR,
					&err_code, &psq_cb->psq_error,2,
					psf_trmwhite(sizeof(DB_TAB_NAME),
				        tab_name), tab_name, STlength(rmv_word),
					rmv_word);

				    status = E_DB_ERROR;
				}
			    }

			    break;
			}
		    }
		}	/* else if there were no errors from pst_rgent */
	    }

	    if (status == E_DB_OK)
	    {
		/* Check for too many tables to fit into control block */
		if (psy_cb->psy_numtabs == PSY_MAXTABS)
		{
		    (VOID) psf_error(2754L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}

		/* Put it in the control block, along with the table name */
		if (~cb->pss_distrib & DB_3_DDB_SESS)
		{
		    STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
				    psy_cb->psy_tables[psy_cb->psy_numtabs]);
		    STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
				    psy_cb->psy_tabname[psy_cb->psy_numtabs]);

		    if (resrange->pss_tabdesc->tbl_temporary)
		    {
			/* if dropping a temp table, set a flag for psy_kview */
			psy_cb->psy_obj_mask[psy_cb->psy_numtabs++]
							= PSY_IS_TMPTBL;
		    }
		    else if (mask & DMT_VIEW)
		    {
			/* if dropping a view, set a flag for psy_kview() */
			psy_cb->psy_obj_mask[psy_cb->psy_numtabs++]
							= PSY_IS_VIEW; 
		    }
		    else
		    {
			psy_cb->psy_obj_mask[psy_cb->psy_numtabs++] = 0;
		    }
		}
		else	/* distributed */
		{
		    psy_cb->psy_numbs[psy_cb->psy_numtabs] = op_code;

		    if (yyvarsp->upobjtype == REMOVE_PROCEDURE)
		    {
			/* psy_kregproc needs procedure name to remove QP */
		    	STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
				    psy_cb->psy_tabname[psy_cb->psy_numtabs]);
		    }

		    STRUCT_ASSIGN_MACRO(obj_desc->dd_o3_objid,
			psy_cb->psy_tables[psy_cb->psy_numtabs++]);

		    /*
		    ** If dropping a STAR object where the underlying LDB
		    ** object is a TABLE or an INDEX, we need to provide some
		    ** additional info for QEF in psy_kview().
		    */

		    if (op_code == DMU_DESTROY_TABLE)
		    {
			PSS_LTBL_INFO	    *ltbl_info;		    
			PSS_LTBL_INFO	    **last =
				    (PSS_LTBL_INFO **) &psy_cb->psy_tblq.q_prev;

			status = psf_malloc(cb, &cb->pss_ostream,
				sizeof(PSS_LTBL_INFO), (PTR *) &ltbl_info,
				&psq_cb->psq_error);

			if (status != E_DB_OK)
			{
			    return (status);
			}

			/* store LDB table name */
			MEcopy((PTR) obj_desc->dd_o9_tab_info.dd_t1_tab_name,
			       sizeof(DD_NAME),
			       (PTR) ltbl_info->pss_tbl_name);

			/* store LDB object type; will be TABLE, VIEW or INDEX */
			if (ldb_obj_type == DD_2OBJ_TABLE)
			{
			    ltbl_info->pss_obj_type = PSS_LTBL_IS_BASETABLE;
			}
			else if (ldb_obj_type == DD_3OBJ_VIEW)
			{
			    ltbl_info->pss_obj_type = PSS_LTBL_IS_VIEW;
			}
			else
			{
			    ltbl_info->pss_obj_type = PSS_LTBL_IS_INDEX;
			}

			/* Flag whether or not table name should be delimited */
			if (resrange->pss_rdrinfo->rdr_obj_desc->dd_o9_tab_info.
				dd_t9_ldb_p->dd_i2_ldb_plus.dd_p3_ldb_caps.
				dd_c1_ldb_caps & DD_8CAP_DELIMITED_IDS)
			{
			    ltbl_info->pss_delim_tbl = 1;
			}
			else
			{
			    ltbl_info->pss_delim_tbl = 0;
			}
			STRUCT_ASSIGN_MACRO(
			    obj_desc->dd_o9_tab_info.dd_t9_ldb_p->dd_i1_ldb_desc,
			    ltbl_info->pss_ldb_desc); 

			if (*last == (PSS_LTBL_INFO *) NULL)
			{
			    *last = ltbl_info;
			    psy_cb->psy_tblq.q_next = (PSF_QUEUE *) ltbl_info;
			}
			else
			{
			    (*last)->pss_next = ltbl_info;
			    *last = ltbl_info;
			}
		    }    /* dropping a table */
		}    /* distributed */
	    }    /* status == OK */
	}    /* store the object ID for QEF */
    } break;

case 763:
if (!((*yyvarspp)->bypass_actions))
/* # line 17481 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		    *psy_cb;
	DB_STATUS	    status;
	i4		    rngvar_info;
	PSS_RNGTAB	    *resrange;
	i4		    err_code;
	i4		    mask;
	i4		    mask2;

	/* Find table id */

	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-1].psl_objspec->pss_owner,
			&yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, cb,
		FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (status != E_DB_OK)
	    return (status);

	mask = resrange->pss_tabdesc->tbl_status_mask;
	mask2 = resrange->pss_tabdesc->tbl_2_status_mask;

	if (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
	{
	    /* If not an extended catalog and no catalog update
	    ** permission - error.
	    */
	    if (~mask & DMT_EXTENDED_CAT && !(cb->pss_ses_flag & PSS_CATUPD) )
	    {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS	local_status;
		    DB_ERROR	e_error;
		    /*
		    ** Audit failure to drop integrity
		    */
		    local_status = psy_secaudit( FALSE, cb,
			    resrange->pss_tabname.db_tab_name, 
			    &resrange->pss_ownname,
			    sizeof(resrange->pss_tabname), SXF_E_TABLE,
			    I_SX2036_INTEGRITY_DROP, SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
		}

		/*
		** let user know if name supplied by the user was resolved to a
		** synonym
		*/
		if (rngvar_info & PSS_BY_SYNONYM)
		{
		    psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-1].psl_objspec, rngvar_info,
			sizeof("DROP INTEGRITY")-1, "DROP INTEGRITY",
			&psq_cb->psq_error);
		}

		(VOID) psf_error(5103L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, 
		    sizeof ("DROP INTEGRITY") - 1, "DROP INTEGRITY", 
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname), 
		    &resrange->pss_tabname);
		return (E_DB_ERROR);
	    }
	}
	else if (MEcmp((PTR) &resrange->pss_ownname, 
	    (PTR) &cb->pss_user, sizeof(DB_OWN_NAME)))
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;
		/*
		** Audit failure to drop integrity
		*/
		local_status = psy_secaudit( FALSE, cb,
		    resrange->pss_tabname.db_tab_name, &resrange->pss_ownname,
		    sizeof(resrange->pss_tabname), SXF_E_TABLE,
		    I_SX2036_INTEGRITY_DROP, SXF_A_FAIL | SXF_A_CONTROL,
		    &e_error);
	    }

	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-1].psl_objspec, rngvar_info,
		    sizeof("DROP INTEGRITY")-1, "DROP INTEGRITY",
		    &psq_cb->psq_error);
	    }

	    (VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("DROP INTEGRITY") - 1, "DROP INTEGRITY",
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &resrange->pss_ownname),
		&resrange->pss_ownname);
	    return (E_DB_ERROR);
	}

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Put it in the control block, along with the table name */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
			    psy_cb->psy_tables[psy_cb->psy_numtabs]);
	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-1].psl_objspec->pss_obj_name,
			    psy_cb->psy_tabname[psy_cb->psy_numtabs++]);
    } break;

case 764:
if (!((*yyvarspp)->bypass_actions))
/* # line 17613 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_DSTINTEG;

	/* "drop integrity" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5206L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a PSY_CB for drop integrity */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 765:
if (!((*yyvarspp)->bypass_actions))
/* # line 17636 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB                 *psy_cb;

	DB_STATUS	    status;
	PSS_RNGTAB	    *resrange;
	i4		    err_code;
	i4		    mask;
	i4		    mask2;
	DB_STATUS	    local_status;
	char		    obj_name[sizeof(DB_TAB_NAME) + sizeof(DB_OWN_NAME)];
	char		    *op = (psq_cb->psq_mode == PSQ_DSTPERM)
					? "DROP PERMIT"
					: "DROP SECURITY_ALARM";
	i4		    len = (psq_cb->psq_mode == PSQ_DSTPERM)
					? sizeof("DROP PERMIT") - 1
					: sizeof("DROP SECURITY_ALARM") - 1;
	i4		    rngvar_info;


	/******************************************************************
	** NOTE * NOTE * NOTE * NOTE * NOTE * NOTE * NOTE * NOTE * NOTE *
	*******************************************************************
	**
	** The DROP SECURITY_ALARM statement is also recognized thru these
	** productions.  Semantic checks to ensure statement consistency
	** is performed in this production.  When extending DROP PERMIT,
	** be sure to preserve the integrity of DROP SECURITY_ALARM.
	**
	******************************************************************/
	
	/* Find table id */

	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-1].psl_objspec->pss_owner,
			&yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, cb,
		FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (status != E_DB_OK)
	    return (status);

	mask = resrange->pss_tabdesc->tbl_status_mask;
	mask2 = resrange->pss_tabdesc->tbl_2_status_mask;

	MEcopy(resrange->pss_tabdesc->tbl_name.db_tab_name, 
	       sizeof(DB_TAB_NAME), obj_name);
	MEcopy(resrange->pss_tabdesc->tbl_owner.db_own_name, 
	       sizeof(DB_OWN_NAME), obj_name + sizeof(DB_TAB_NAME));

	/*
	** One no longer has to be a DBA or $INGRES in order to
	** DROP PERMIT/SECURITY_ALARM on tables other than catalogues.
	*/
	
	if (!psy_permit_ok(mask, cb, &resrange->pss_ownname))
	{
	    /* audit DROP PERMIT/SECURITY ALARM */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR		e_error;

		local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrange->pss_tabdesc->tbl_name,
			    &resrange->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX2018_PROT_TAB_DROP,
			    SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
	    }
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-1].psl_objspec, rngvar_info,
		    len, op, &psq_cb->psq_error);
	    }

	    if (   (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
		&& ~mask & DMT_EXTENDED_CAT)
	    {
		/*
		** tried to DROP PERMIT/SECURITY_ALARM on system catalog
		** w/o catalog update privilege
		*/

		(VOID) psf_error(5103L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, 
		    len, op,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname),
		    &resrange->pss_tabname);
	    }
	    else if (   yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA 
		     && ~rngvar_info & PSS_BY_SYNONYM)
	    {
		/*
		** this error msg will be printed only if the user qualified
		** table name with its owner's name + and it was not a synonym
		*/
		(VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 3, 
		    len, op,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname),
		    &resrange->pss_tabname,
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &resrange->pss_ownname),
		    &resrange->pss_ownname);
	    }
	    else
	    {
		(VOID) psf_error(2753L, 0L, PSF_USERERR,&err_code, 
		    &psq_cb->psq_error, 2, 
		    len, op,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname),
		    &resrange->pss_tabname);
	    }

	    return(E_DB_ERROR);
	}

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Put id in the control block, along with the table name */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
			    psy_cb->psy_tables[psy_cb->psy_numtabs]);
	STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
			    psy_cb->psy_tabname[psy_cb->psy_numtabs++]);
    } break;

case 766:
if (!((*yyvarspp)->bypass_actions))
/* # line 17785 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** indicate to PSYKPERM that a permit on a database procedure is
	** being dropped
	*/
	psy_cb->psy_grant = PSY_PDROP;
    } break;

case 767:
if (!((*yyvarspp)->bypass_actions))
/* # line 17797 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	        status;
	DB_TAB_NAME	        dbpname;
	i4			err_code;
	i4			dbpshow_flags;
	DB_OWN_NAME		*dbp_owner;

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    /*
	    ** Audit failure to drop permit on database procedure
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name,
		    (DB_OWN_NAME *)&yacc_cb->yypvt[-1].psl_objspec->pss_owner, sizeof(yacc_cb->yypvt[-1].psl_objspec->pss_obj_name),
		    SXF_E_PROCEDURE, I_SX2019_PROT_DBP_DROP,
		    SXF_A_FAIL | SXF_A_CONTROL, &e_error);
	    }
		
	    (VOID) psf_error(E_PS0425_ILLEGAL_DBP_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("DROP PERMIT") - 1, "DROP PERMIT",
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name),
		&yacc_cb->yypvt[-1].psl_objspec->pss_obj_name,
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-1].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Find dbp id for this dbp name */
 	STmove(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_TAB_NAME),
	    (char *) &dbpname);
	    
	dbp_owner = (DB_OWN_NAME *) NULL;

	status = pst_dbpshow(cb, (DB_DBP_NAME *) &dbpname, &yyvarsp->dbpinfo,
	    dbp_owner, (DB_TAB_ID *) NULL, PSS_USRDBP, psq_cb, &dbpshow_flags);
	if (DB_FAILURE_MACRO(status))
        {
	    /*
	    ** if pst_dbpshow() returned error, some internal error happened,
	    ** nothing that need be audited
	    */
	    return(status);
	}
	else if (dbpshow_flags & PSS_MISSING_DBPROC)
	{
	    return(E_DB_ERROR);
	}
	else
        {
	    PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

	    /*
	    ** Copy procedure id and procedure name to table entry.
	    */
	    STRUCT_ASSIGN_MACRO(yyvarsp->dbpinfo->pss_ptuple.db_procid,
				psy_cb->psy_tables[psy_cb->psy_numtabs]);
	    STRUCT_ASSIGN_MACRO(dbpname,
				psy_cb->psy_tabname[psy_cb->psy_numtabs++]);
	}
    } break;
	}
	return(0);
}

i4
psls17iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 768:
if (!((*yyvarspp)->bypass_actions))
/* # line 17866 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	
	if (CMcmpcase(yacc_cb->yypvt[-0].psl_strtype, "d") || STcompare(yacc_cb->yypvt[-0].psl_strtype, "dbevent"))
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	psy_cb = (PSY_CB *) cb->pss_object;
	
	/* indicate to PSYKPERM that a permit on an dbevent is being dropped */
	psy_cb->psy_grant = PSY_EVDROP;
    } break;

case 769:
if (!((*yyvarspp)->bypass_actions))
/* # line 17881 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb;
	i4		err_code;
	DB_TAB_NAME	*nameplace;
	DB_TAB_ID	*idplace;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    /*
	    ** Audit failure to drop permit on dbevent
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name,
		    (DB_OWN_NAME *)&yacc_cb->yypvt[-1].psl_objspec->pss_owner, sizeof(yacc_cb->yypvt[-1].psl_objspec->pss_obj_name),
		    SXF_E_EVENT, I_SX2031_PROT_EV_DROP, 
		    SXF_A_FAIL | SXF_A_CONTROL, &e_error);
	    }

	    (VOID) psf_error(E_PS0426_ILLEGAL_EVENT_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("DROP PERMIT") - 1, "DROP PERMIT",
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name),
		&yacc_cb->yypvt[-1].psl_objspec->pss_obj_name,
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-1].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Figure out where dbevent name and id go */
	idplace = &psy_cb->psy_tables[psy_cb->psy_numtabs];
	nameplace = &psy_cb->psy_tabname[psy_cb->psy_numtabs++];

	/* Get DUMMY table id - use iievent until later looked up in QEU */
	idplace->db_tab_base = DM_B_EVENT_TAB_ID;
	idplace->db_tab_index = DM_I_EVENT_TAB_ID;

 	STmove(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_TAB_NAME),
	    (char *) nameplace);
    } break;

case 770:
if (!((*yyvarspp)->bypass_actions))
/* # line 17931 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_DSTPERM;

	/* "drop permit is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5207L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a PSY_CB for drop permit */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** indicate to PSYKPERM	what kind of object is being dropped - initially
	** assume that dropping permit on a table
	*/
	psy_cb->psy_grant = PSY_TDROP;
    } break;

case 775:
if (!((*yyvarspp)->bypass_actions))
/* # line 17974 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		       *psy_cb;
	i4		       err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (++psy_cb->psy_numnms > PSY_MAXTABS)
	{
	    (VOID) psf_error(2754L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	psy_cb->psy_numbs[psy_cb->psy_numnms - 1] = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 776:
if (!((*yyvarspp)->bypass_actions))
/* # line 17991 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DBP_NAME	dbpname;
	i4		err_code;
	i4		dbpshow_flags;
	PSY_CB		*psy_cb;

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    /*
	    ** Audit failure to drop a database procedure
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
		    (DB_OWN_NAME *)&yacc_cb->yypvt[-0].psl_objspec->pss_owner, sizeof(yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
		    SXF_E_PROCEDURE, I_SX2013_DBPROC_DROP,
		    SXF_A_FAIL | SXF_A_DROP, &e_error);
	    }

	    (VOID) psf_error(E_PS0425_ILLEGAL_DBP_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("DROP PROCEDURE") - 1, "DROP PROCEDURE",
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
		&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

	STmove(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, ' ', 
	       sizeof(DB_DBP_NAME), dbpname.db_dbp_name);

	/* Open the stream now because dbpinfo will be allocated from it. */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* dbproc is expected to exist */
	status = pst_dbpshow(cb, &dbpname, &yyvarsp->dbpinfo, (DB_OWN_NAME *) NULL,
	    (DB_TAB_ID *) NULL, PSS_USRDBP, psq_cb, &dbpshow_flags);
	if (DB_FAILURE_MACRO(status))
	{
	    /*
	    ** pst_dbpshow() will return error if some internal error takes
	    ** place - need not audit
	    */
	    return (status);
	}
	else if (dbpshow_flags & PSS_MISSING_DBPROC)
	{
	    /* Procedure not found */
	    return (E_DB_ERROR);
	}

	/* make sure object is user-droppable;
	** don't allow users to drop internal procedures
	*/
	if (yyvarsp->dbpinfo->pss_ptuple.db_mask[0] & DBP_NOT_DROPPABLE)
	{
	    psf_error(E_US18AB_6315_NOT_DROPPABLE, 0L, PSF_USERERR,
		      &err_code, &psq_cb->psq_error, 2,
		      sizeof(ERx("DROP PROCEDURE"))-1, ERx("DROP PROCEDURE"),
		      psf_trmwhite(DB_MAXNAME, dbpname.db_dbp_name),
		      dbpname.db_dbp_name);
	    return(E_DB_ERROR);
	}

	/* Create the PSY_CB for the DROP PROCEDURE */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Fill in the procedure name to be destroyed. */
	(VOID) MEcopy(dbpname.db_dbp_name, sizeof(DB_DBP_NAME),   
		      psy_cb->psy_tabname[0].db_tab_name);
        /* Fill in a procedure id */
	STRUCT_ASSIGN_MACRO(yyvarsp->dbpinfo->pss_ptuple.db_procid,
			    psy_cb->psy_tables[0]);
    } break;

case 777:
if (!((*yyvarspp)->bypass_actions))
/* # line 18081 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        /* "DROP PROCEDURE" is not allowed in distributed yet */
        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
	    i4         err_code;

            (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
               	&psq_cb->psq_error, 1, 
		sizeof("DROP PROCEDURE") - 1, "DROP PROCEDURE");
            return (E_DB_ERROR);
        }

	psq_cb->psq_mode = PSQ_DRODBP;
    } break;

case 778:
if (!((*yyvarspp)->bypass_actions))
/* # line 18107 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	/* "drop rule" is not allowed in Star */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    _VOID_ psf_error(E_US18A0_6304_RULE_STAR, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    /*
	    ** Audit failure to drop a rule
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *)&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
		    (DB_OWN_NAME *)&yacc_cb->yypvt[-0].psl_objspec->pss_owner, sizeof(yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
		    SXF_E_RULE, I_SX2038_RULE_DROP, 
		    SXF_A_FAIL | SXF_A_DROP, &e_error);
	    }

	    (VOID) psf_error(E_PS0420_DROPOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("DROP RULE") - 1, "DROP RULE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Allocate the PSY_CB for the DROP RULE statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *)cb->pss_object;

	/* Initialize rule tuple */
	MEfill(sizeof(psy_cb->psy_tuple.psy_rule), '\0',
	       (PTR)&psy_cb->psy_tuple.psy_rule);
	STmove(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_rule.dbr_name);
    } break;

case 779:
if (!((*yyvarspp)->bypass_actions))
/* # line 18161 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_DSTRULE;
    } break;

case 780:
if (!((*yyvarspp)->bypass_actions))
/* # line 18167 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_ENDTRANS;

	/* Allocate the QEF control block for 'end transaction' */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 781:
if (!((*yyvarspp)->bypass_actions))
/* # line 18219 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*stmt_cp;	/* CALLPROC statement */
	PST_CPROCSTMT	*cps;	
	DB_STATUS	status;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
	{
	    /* 
	    ** Add the rest of the execute procedure statement.
	    */
	    status = psq_x_add(cb, yyvarsp->scanbuf_ptr, &cb->pss_ostream,
                yyvarsp->xlated_qry.pss_buf_size, &yyvarsp->xlated_qry.pss_q_list,
                (i4) ((char *) cb->pss_endbuf - (char *) yyvarsp->scanbuf_ptr),
                " ", " ", (char *) NULL, &psq_cb->psq_error);
            if (DB_FAILURE_MACRO(status))
		return (status);

            status = psf_mroot(cb, &cb->pss_ostream,
                        (PTR) yyvarsp->xlated_qry.pss_q_list.pss_head, 
			&psq_cb->psq_error);
            if (DB_FAILURE_MACRO(status))
            	return (status);

	    yacc_cb->yyval.psl_stmt = NULL;
	    break;		/* done for distributed case */
        }
	
	/*
	** Allocate CALLPROC statement and fill.  If this is not inside a
	** DBP then package the whole thing as a statement in a procedure and
	** ship.  If this is in a procedure then just build the statement.
	**
	** Note that this statement may have a result variable attached to it
	** later (when nested in a DBP).
	*/

	/*
	** Allocate CALLPROC statement node and initialize fields
	** NOTE: we do not use psl_init_dbp_stmt() here since we do not want
	**       this statement node linked into the statement list (especially
	**	 if we are not parsing a dbproc, in which case there is no list
	**	 to speak of); if this is a statement in a database procedure,
	**	 it will be linked in later.
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_STATEMENT),
			    (PTR *)&stmt_cp, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	MEfill(sizeof(PST_STATEMENT), (u_char) 0, (PTR) stmt_cp);

	stmt_cp->pst_mode = PSQ_CALLPROC;
	stmt_cp->pst_type = PST_CP_TYPE;
#ifdef xDEBUG
	stmt_cp->pst_lineno = cb->pss_lineno;
#endif
	stmt_cp->pst_lineno = cb->pss_stmtno;
	cps = &stmt_cp->pst_specific.pst_callproc;
	cps->pst_pmask = PST_CPUSER;
	cps->pst_rulename.db_name[0] = EOS;

	cps->pst_procname.qso_n_id.db_cursor_id[0] =
	    cps->pst_procname.qso_n_id.db_cursor_id[1] = 0;

	MEcopy((PTR)&yacc_cb->yypvt[-1].psl_dbpinfo->pss_ptuple.db_dbpname, DB_MAXNAME,
	       (PTR)cps->pst_procname.qso_n_id.db_cur_name);
	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-1].psl_dbpinfo->pss_ptuple.db_owner,
			    cps->pst_procname.qso_n_own);
	cps->pst_procname.qso_n_dbid = cb->pss_udbid;

	/* Are there arguments? */
	if ((cps->pst_arglist = yacc_cb->yypvt[-0].psl_trtype) != (PST_QNODE *) NULL)
	    cps->pst_argcnt = yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_rsno;
	else
	    cps->pst_argcnt = 0;

	if (yyvarsp->isdbp) 		/* Return statement to be patched later */
	{
	    /*
	    ** if this statement is not reachable, do not attach it to the
	    ** list of statements used by OPF (to save the cost of
	    ** optimizing it)
	    */
	    if (yyvarsp->dbpinfo->pss_unreachable_stmt_lvl == 0)
	    {
		if (yyvarsp->dbpinfo->pss_link != (PST_STATEMENT *) NULL)
		{
		    yyvarsp->dbpinfo->pss_link->pst_link = stmt_cp;
		}

		yyvarsp->dbpinfo->pss_link = stmt_cp;
	    }

	    yyvarsp->dbpinfo->pss_last_stmt = stmt_cp;
	    yyvarsp->dbpinfo->pss_patch = &stmt_cp->pst_next;

	    yacc_cb->yyval.psl_stmt = stmt_cp;
	}
	else			/* Not a DBP */
	{
	    PST_PROCEDURE   *prnode;	/* Procedure node to create */

	    /* Create procedure (for OPC) and attach the CALLPROC statement */
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_PROCEDURE),
				(PTR *)&prnode, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    prnode->pst_mode = 0;
	    prnode->pst_vsn = PST_CUR_VSN;
	    prnode->pst_isdbp = FALSE;
	    prnode->pst_flags = 0;
	    prnode->pst_stmts = stmt_cp;
	    prnode->pst_parms = (PST_DECVAR *)NULL;
	    MEfill(sizeof(prnode->pst_dbpid), (u_char)0,
		   (PTR)&prnode->pst_dbpid);
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR)prnode,
			       &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    yacc_cb->yyval.psl_stmt = NULL;		/* Unused outside of DBP */
	}
    } break;

case 782:
if (!((*yyvarspp)->bypass_actions))
/* # line 18344 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            psq_cb->psq_mode = PSQ_DDEXECPROC;

            /* Open QSF memory stream for the EXECUTE PROCEDURE text */
            status = psf_mopen(cb, QSO_QTEXT_OBJ, &cb->pss_ostream, 
			&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	    break;		/* bypass the rest of the parsing */
        }

	psq_cb->psq_mode = PSQ_CALLPROC;

	/* Open memory stream for allocating objects */
	if (yyvarsp->isdbp == FALSE)
	{
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
				    &psq_cb->psq_error)) != E_DB_OK)
		return (status);
	}
    } break;

case 785:
if (!((*yyvarspp)->bypass_actions))
/* # line 18375 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	DB_DBP_NAME	dbpname;
	PSS_DBPINFO	*dbp;
	i4		err_code;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    PSS_RNGTAB	    	*resrange;
	    i4		    	rngvar_info;
	    i4		    	lookup_mask;
	    DD_OBJ_DESC         *obj_desc;
	    DD_2LDB_TAB_INFO    *ldb_tab_info;

	    lookup_mask = PST_REGPROC;

	    if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
                status = psl0_orngent(&cb->pss_auxrng, -1, 
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &yacc_cb->yypvt[-0].psl_objspec->pss_owner, &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, 
		    cb, TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error, 
		    &rngvar_info, lookup_mask);
	    }
	    else
	    {
                status = psl0_rngent(&cb->pss_auxrng, -1, 
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, 
		    cb, TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		    (PSS_USRTBL | PSS_DBATBL | PSS_INGTBL),
                    &rngvar_info, lookup_mask);
	    }

	    if (DB_FAILURE_MACRO(status))
	    {
   		return (status);
	    }
	    else if (resrange == (PSS_RNGTAB *) NULL)
	    {
                /*
                ** If reg proc wasn't found, report it to user here.
                */
	        if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
		{
                    (VOID) psf_error(2764L, 0L, PSF_USERERR, &err_code,
                    &psq_cb->psq_error, 3, 17, "EXECUTE PROCEDURE",
                    psf_trmwhite(sizeof(DB_TAB_NAME),
		    	(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name), 
		    &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
                    psf_trmwhite(sizeof(DB_OWN_NAME),
		    	(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner), 
		    &yacc_cb->yypvt[-0].psl_objspec->pss_owner);
		}
		else
		{
                    (VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
                    &psq_cb->psq_error, 2, 17, "EXECUTE PROCEDURE",
                    psf_trmwhite(sizeof(DB_TAB_NAME),
		    	(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name), 
		    &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name);
		}

                return (E_DB_ERROR);
	    }
	    else
	    {
		/* translate registered name and built query text in buffer */
		obj_desc = resrange->pss_rdrinfo->rdr_obj_desc;
		ldb_tab_info = &obj_desc->dd_o9_tab_info;

        	status = psq_x_add(cb, "", &cb->pss_ostream, 
			yyvarsp->xlated_qry.pss_buf_size, &yyvarsp->xlated_qry.pss_q_list, 
			-1, (char *)NULL, (char *)NULL, 
			"execute immediate execute procedure ", 
		        &psq_cb->psq_error);

        	if (DB_FAILURE_MACRO(status))
            	    return(status);

		/* 
		** Although qmode != PSQ_COPY, the rules for owners and
		** delimiters are the same.
		*/
        	status = psq_prt_tabname(cb, &yyvarsp->xlated_qry, &cb->pss_ostream, 
			resrange, PSQ_COPY, &psq_cb->psq_error);

        	if (DB_FAILURE_MACRO(status))
        	    return(status);

        	/* remember table site */
        	STRUCT_ASSIGN_MACRO(ldb_tab_info->dd_t9_ldb_p->dd_i1_ldb_desc,
                        *(psq_cb->psq_ldbdesc));
    	    }

    	    cb->pss_resrng = resrange;

	    /*
	    ** Set buffer pointer; later we'll copy from here till
	    ** the end of the input text to the QSF QTEXT object.
	    */
            if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
                yyvarsp->scanbuf_ptr = (PTR) cb->pss_nxtchar;
            else
                yyvarsp->scanbuf_ptr = (PTR) cb->pss_prvtok;   /* already looked ahead */
	    yacc_cb->yyval.psl_dbpinfo = NULL;
	    break;		/* done for distributed case */
	}

	/* normalize dbproc name */
	MEmove(sizeof(DB_TAB_NAME), (PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, ' ',
	       sizeof(dbpname), (PTR) &dbpname);

	/*
	** IF
	** - we are creating a dbproc AND
	** - dbproc name specified by the user is the same as that of the one
	**   being defined AND
	**	EITHER
	**	- dbproc name was explicitly qualified AND
	**	- owner name as specified by the user is the same as that of the
	**	  user
	**	OR
	**	- procedure name was NOT explicitly qualified
	**
	** this is a recursive call, and we don't need to look up a procedure
	**
	** Otherwise, call pst_dbpshow()
	*/

	if ((dbp = yyvarsp->dbpinfo) == NULL
	    || !yyvarsp->isdbp
	    || MEcmp((PTR)&dbpname, (PTR)&dbp->pss_ptuple.db_dbpname,
		     sizeof(dbpname))
	    || (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	        MEcmp((PTR) &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		      sizeof(yacc_cb->yypvt[-0].psl_objspec->pss_owner))))
	{
	    i4		    dbp_mask;
	    DB_OWN_NAME	    *dbp_owner;
	    i4		    dbpshow_flags;

	    if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
		dbp_owner = &yacc_cb->yypvt[-0].psl_objspec->pss_owner;
		dbp_mask = PSS_DBP_PERM_AND_AUDIT | PSS_DBP_BY_OWNER;
	    }
	    else
	    {
		dbp_owner = (DB_OWN_NAME *) NULL;
		dbp_mask = PSS_DBP_PERM_AND_AUDIT |
		    PSS_USRDBP | PSS_DBADBP | PSS_INGDBP;
	    }

	    status = pst_dbpshow(cb, &dbpname, &dbp, dbp_owner,
		(DB_TAB_ID *) NULL, dbp_mask, psq_cb, &dbpshow_flags);

	    if (DB_FAILURE_MACRO(status))
		return (status);
	    else if (dbpshow_flags & (PSS_MISSING_DBPROC | PSS_INSUF_DBP_PRIVS))
	    {
		/*
		**    dbproc does not exist
		** or the current user may not execute it
		** or we are reparsing a dbproc in order to determine if it is
		** grantable and the user does not posess EXECUTE WGO on this
		** dbproc
		*/
		return (E_DB_ERROR);
	    }

	    /*
	    ** dbp has names set from pst_dbpshow 
	    */

	    /* check if user is trying to execute a
	    ** system-generated procedure from the command line
	    **
	    ** Note that it is OK to have system-generated rule or dbproc fire a
	    **      system-generated dbproc
	    */
	    if (	/* system generated dbproc */
		   dbp->pss_ptuple.db_mask[0] & DBP_SYSTEM_GENERATED
		   
			/* not fired by a system-generated rule */
		&& !(   psq_cb->psq_mode == PSQ_RULE
		     && psq_cb->psq_info != (PST_INFO *) NULL
		     && psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED)
		     
			/* not fired by system-generated dbproc */
		&& !(yyvarsp->isdbp && cb->pss_dbp_flags & PSS_SYSTEM_GENERATED)
	       )
	    {

		if ((cb->pss_ses_flag & PSS_RUNNING_UPGRADEDB) == 0)
		{
		    (void) psf_error(E_PS049E_CANT_EXEC_SYSGEN_PROC, 
				 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 1,
				 psf_trmwhite(DB_MAXNAME,
				       dbp->pss_ptuple.db_dbpname.db_dbp_name),
				 dbp->pss_ptuple.db_dbpname.db_dbp_name);
		    return(E_DB_ERROR);
		}
	    }

	    /* if emitting query text, and the schema/owner name has not been
	    ** specified, add the procedure's schema name to the query
	    */
	    if (   (cb->pss_stmt_flags & PSS_TXTEMIT) 
		&& (~yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA))
	    {
		status = psl_prepend_schemaname(cb->pss_tchain, 
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, 
		    (u_char *) dbp->pss_ptuple.db_owner.db_own_name,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }

	    /* dbp has names set from pst_dbpshow */
	}
	else
	{
	    /* this is a recursive procedure call;
	    ** if emitting query text, must be creating procedure
	    ** and that means this EXEC PROC must be owned by current user;
	    ** so
	    ** if emitting query text, and the schema/owner name has not been
	    ** specified, add the current schema name to the query
	    */
	    if (   (cb->pss_stmt_flags & PSS_TXTEMIT) 
		&& (~yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA))
	    {
		status = psl_prepend_schemaname(cb->pss_tchain, 
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, (u_char *) cb->pss_user.db_own_name,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }
	}
	    
	yacc_cb->yyval.psl_dbpinfo = dbp;
    } break;

case 786:
if (!((*yyvarspp)->bypass_actions))
/* # line 18620 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;
    } break;

case 787:
if (!((*yyvarspp)->bypass_actions))
/* # line 18624 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 788:
if (!((*yyvarspp)->bypass_actions))
/* # line 18630 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PST_QNODE	    *treenode;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    yacc_cb->yyval.psl_trtype = NULL;
	    break;
	}

	/* First node - create the tail PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream,
			  (PST_QNODE *)NULL, (PST_QNODE *)NULL,
			  PST_TREE, (PTR)NULL, 0,
			  DB_NODT, (i2) 0, (i4)0, (DB_ANYTYPE *)NULL,
			  &treenode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);

	/* Keep track of parameter number */
	yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_rsno = 1;
	yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = 1;

	yacc_cb->yypvt[-0].psl_trtype->pst_left = treenode;
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 789:
if (!((*yyvarspp)->bypass_actions))
/* # line 18658 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    yacc_cb->yyval.psl_trtype = NULL;
	    break;
	}

	/* Make sure there is only one temptab proc param */
	if (yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype 
		== PST_TTAB_DBPARM ||
	    yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		== PST_TTAB_DBPARM)
	{	/* uh, oh! */
	    i4                err_code;
	    (VOID) psf_error(E_US0989_2441_TTAB_PARM, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Bump current parameter number */
	yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_rsno =
	    yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_rsno + 1;
	yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_ntargno =
	    yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_ntargno + 1;

	yacc_cb->yypvt[-0].psl_trtype->pst_left = yacc_cb->yypvt[-2].psl_trtype;
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 790:
if (!((*yyvarspp)->bypass_actions))
/* # line 18688 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* First option is the temp table parameter ("parm = session.table") */
	DB_STATUS	    status;
	PST_QNODE	    *argnode;
	PST_QNODE	    *ttabnode = (PST_QNODE *)NULL;
	PST_TAB_NODE	    tabnode;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    yacc_cb->yyval.psl_trtype = NULL;
	    break;
	}

	/* Turn temp table name into a TAB node, to be hung from 
	** procparm RESDOM. */
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, tabnode.pst_owner);
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_TAB_NAME), (char *)&tabnode.pst_tabname);
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL,
	    (PST_QNODE *)NULL, PST_TAB, (char *)&tabnode, sizeof(tabnode),
	    DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &ttabnode,
	    &psq_cb->psq_error, (i4)0);
	if (status != E_DB_OK)
	    return(status);

	status = psl_dbproc_param(psq_cb, cb, yacc_cb->yypvt[-4].psl_strtype, ttabnode, FALSE, &argnode);
	if (status != E_DB_OK)
	    return (status);
	argnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_TTAB_DBPARM;
	yacc_cb->yyval.psl_trtype = argnode;
    } break;

case 791:
if (!((*yyvarspp)->bypass_actions))
/* # line 18720 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PST_QNODE	    *argnode;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    yacc_cb->yyval.psl_trtype = NULL;
	    break;
	}

	status = psl_dbproc_param(psq_cb, cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_trtype, FALSE, &argnode);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = argnode;
    } break;

case 792:
if (!((*yyvarspp)->bypass_actions))
/* # line 18737 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PST_QNODE	    *argnode;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    yacc_cb->yyval.psl_trtype = NULL;
	    break;
	}

	status = psl_dbproc_param(psq_cb, cb, yacc_cb->yypvt[-5].psl_strtype, yacc_cb->yypvt[-1].psl_trtype, TRUE, &argnode);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = argnode;
    } break;

case 793:
if (!((*yyvarspp)->bypass_actions))
/* # line 18754 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PST_QNODE	    *argnode;
	
	if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    yacc_cb->yyval.psl_trtype = NULL;
	    break;
	}

	status = psl_dbproc_param(psq_cb, cb, yacc_cb->yypvt[-5].psl_strtype, yacc_cb->yypvt[-1].psl_trtype, TRUE, &argnode);

	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = argnode;
    } break;

case 796:
if (!((*yyvarspp)->bypass_actions))
/* # line 18798 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		    err_code;

	(VOID) psf_error(2350L, 0L, PSF_USERERR, &err_code, &psq_cb->psq_error,
	    0);
	return (E_DB_ERROR);
    } break;

case 911:
if (TRUE)	/* NOBYPASS */
/* # line 18932 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
/* GRANT ... ON [TABLE] ... [WITH GRANT OPTION] */

	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PTR                 piece;
	i4		    err_code;
	u_char		    ident_placeholder[DB_MAX_DELIMID + 1];
	char		    text[512];
	i4		    textcnst, noncol = FALSE, curoff;
	bool		    updtcols, insrtcols, refcols;
	i4		    colprivs;
	char		    *str;
	i4		    str_len;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special processing for CREATE SCHEMA
	    */
	    status = psl_cs05s_grant(cb, psq_cb, yyvarsp->stmtstart, yyvarsp->deplist);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	    return(E_DB_OK);
	}

	/*
	** Set grantee type; default is USER 
	*/
	psy_cb->psy_gtype = (yacc_cb->yypvt[-1].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-1].psl_tytype;

	/*
	** if WITH GRANT OPTION was specified, make sure that the grantee is of
	** type USER or PUBLIC (recall that PUBLIC could be specified as a user
	** authorization identifier) 
	*/
	if (   psy_cb->psy_opmap & DB_GRANT_OPTION
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(E_PS0550_GRANTEE_TYPE_FOR_WGO, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* remember if column-specific privileges were specified */
	colprivs = 0;

	if (updtcols  = psy_cb->psy_u_numcols != 0)
	    colprivs |= (i4) DB_REPLACE;
	    
	if (insrtcols = psy_cb->psy_i_numcols != 0)
	    colprivs |= (i4) DB_APPEND;
	    
	if (refcols   = psy_cb->psy_r_numcols != 0)
	    colprivs |= (i4) DB_REFERENCES;

	/*
	** The "grant" statement requires query text to be stored
	** in the iiqrytext relation. In general case there may be three
	** iiqrytext templates generated here. Later on, in psy_dgrant,
	** table and grantee names will be substituted.
	** The first template is produced for the version that
	** doesn't have columns. The version of grant with
	** UPDATE columns requires second template and if a list of columns 
	** associated with REFERENCES privilege is also unempty, we will build a
	** third template. The first template is always built and part of it is 
	** used for creation of the other templates. The first template will be 
	** stored only when there are table-wide privileges.
	*/

	/* fill in an identifier placeholder */
	MEfill(DB_MAX_DELIMID, '?', (PTR) ident_placeholder);
	ident_placeholder[DB_MAX_DELIMID] = EOS;
    
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft, 
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Text is a buffer where templates are built */
	text[0] = EOS;

	if (~psy_cb->psy_flags & PSY_ALL_PRIVS)	
	{
	    i4		tbl_wide_privs;

	    /* privilege list was specified */

	    /*
	    ** check whether table-wide privileges (i.e. SELECT, INSERT, DELETE,
	    ** UPDATE, or REFERENCES) are being granted;
	    ** we can tell that table-wide privileges were granted if the map of
	    ** privileges being granted contains privilege(s) besides those
	    ** found in colprivs (as in many other cases, for purposes of the
	    ** comparison DB_GRANT_OPTION is not treated as a privilege)
	    */
	    tbl_wide_privs = psy_cb->psy_opmap & ~(colprivs | DB_GRANT_OPTION);
	    if (tbl_wide_privs)
	    {
		/*
		** if a list of table-wide privileges was specified, we need a
		** placeholder for word GRANT followed by the longest of
		** privilege names of those which were specified.
		** If only one privilege (possibly WITH GRANT OPTION) is being
		** specified, we will insert it into the text now.
		*/
		noncol = TRUE;

		if (BTcount((char *) &tbl_wide_privs, BITS_IN(tbl_wide_privs))
			> 1)
		{
		    /* make placeholder big enough for REFERENCES */
		    str = "grant ??????????";
		}
		else if (tbl_wide_privs == DB_RETRIEVE)
		{
		    str = "grant select";
		}
		else if (tbl_wide_privs == DB_REPLACE)
		{
		    str = "grant update";
		}
		else if (tbl_wide_privs == DB_DELETE)
		{
		    str = "grant delete";
		}
		else if (tbl_wide_privs == DB_APPEND)
		{
		    str = "grant insert";
		}
		else if (tbl_wide_privs == DB_COPY_INTO)
		{
		    str = "grant copy_into";
		}
		else if (tbl_wide_privs == DB_COPY_FROM)
		{
		    str = "grant copy_from";
		}
		else
		{
		    str = "grant references";
		}

		STcat(text, str);
	    }
	}	/* privilege list was suppled */
	else
	{
	    noncol = TRUE;

	    /*
	    ** note that we will generate an IIPROTECT (and IIQRYTEXT) tuple to
	    ** represent each of privileges being granted even for ALL TO PUBLIC
	    ** permit
	    ** (make privilege name placeholder big enough to accomodate
	    ** REFERENCES)
	    */
	    STcat(text, "grant ??????????");
	}

	/*
	** For update/references columns we need to store the beginning of the
	** variable part of text so that the iiqrytext for UPDATE/REFERENCES 
	** permits may be easily generated.
	*/
	textcnst = STlength(text);

	if (yacc_cb->yypvt[-2].psl_tytype == 0)
	{
	    str = " on ";
	    str_len = sizeof(" on ") - 1;
	}
	else
	{
	    str = " on table ";
	    str_len = sizeof(" on table ") - 1;
	}
	
	STcat(text, str);
	
	/* Remember offset to the 'owner'.table name in the first template. */
	psy_cb->psy_noncol_obj_name_off = textcnst + str_len;
	
	/* Append the place holder for schema.table */
	STcat(text, (char *) ident_placeholder);
	STcat(text, ".");
	STcat(text, (char *) ident_placeholder);

	psl_grantee_type_to_str(yacc_cb->yypvt[-1].psl_tytype, &str, &str_len, FALSE);
	if (!str)
	{
	    /* this is very bad */
	    (VOID) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	STcat(text, str);

	/* remember offset to the grantee name in the first template */
	psy_cb->psy_noncol_grantee_off = 
	      psy_cb->psy_noncol_obj_name_off 	/* begining of schema name */
	    + DB_MAX_DELIMID			/* schema name placeholder */
	    + CMbytecnt(".")			/* separator b/w schema and 
						** object name */
	    + DB_MAX_DELIMID                    /* object name placeholder */
	    + str_len;				/* TO <grantee type> */

	/* append the place holder for grantee name */
	STcat(text, (char *) ident_placeholder);

	if (psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    STcat(text, " with grant option ");
	}

	/*
	** First template is ready now. It should be stored only
	** if non-column specific privileges have been defined.
	*/
	if (noncol)
	{
	    status = psq_tadd(cb->pss_tchain, (u_char *) text,
		STlength(text), &piece, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* Determine size of the first iiqrytext */
	    status = psq_tqrylen(cb->pss_tchain, &psy_cb->psy_noncol_qlen);
	    if (status != E_DB_OK)
		return (status);
	}
	else
	{
	    psy_cb->psy_noncol_qlen = 0;
	}

	/*
	** Now emit iiqrytext for UPDATE [EXCLUDING] (cols) case, if necessary.
	*/
	if (updtcols)
	{
	    status = psl_bld_col_spec_grant_template(cb->pss_tchain, "update",
		(bool) ((psy_cb->psy_flags & PSY_EXCLUDE_UPDATE_COLUMNS) != 0),
		&psy_cb->psy_u_colq, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    /* Obtain the size of the current iiqrytext (1 & 2) */
	    status = psq_tqrylen(cb->pss_tchain, &curoff);
	    if (status != E_DB_OK)
		return (status);

	    /* compute the length of the second template built so far */
	    curoff -= psy_cb->psy_noncol_qlen;

	    /*
	    ** Compute offset to the beginning of the object name and grantee
	    ** name in the second template.
	    ** To do this we need to subtract from the table/grantee name offset
	    ** in the first template the length of
	    ** "GRANT <non-column privileges>" and add the length of the second
	    ** template text built so far (i.e. "GRANT UPDATE (...) ".)
	    */
	    psy_cb->psy_updt_obj_name_off =
		psy_cb->psy_noncol_obj_name_off - textcnst + curoff;
	    psy_cb->psy_updt_grantee_off =
		psy_cb->psy_noncol_grantee_off - textcnst + curoff;

	    /* copy the first template starting with ON [TABLE] */
	    status = psq_tadd(cb->pss_tchain, (u_char *) (text + textcnst),
		STlength(text + textcnst), &piece, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* compute length of second template */

	    /* Obtain the size of the current iiqrytext (1 & 2) */
	    status = psq_tqrylen(cb->pss_tchain, &curoff);
	    if (status != E_DB_OK)
		return (status);

	    /* 
	    ** subtract length of first template to derive length of the second 
	    ** one
	    */
	    psy_cb->psy_updt_qlen = curoff - psy_cb->psy_noncol_qlen;
	}
	else
	{
	    psy_cb->psy_updt_qlen = 0;
	}

	/*
	** Now emit iiqrytext for REFERENCES [EXCLUDING] (cols) case, 
	** if necessary.
	*/
	if (refcols)
	{
	    status = psl_bld_col_spec_grant_template(cb->pss_tchain, 
		"references",
		(bool) ((psy_cb->psy_flags & PSY_EXCLUDE_REFERENCES_COLUMNS) 
			!= 0),
		&psy_cb->psy_r_colq, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    /* Obtain the size of the current iiqrytext (1 & 2 & 3) */
	    status = psq_tqrylen(cb->pss_tchain, &curoff);
	    if (status != E_DB_OK)
		return (status);

	    /* compute the length of the second template built so far */
	    curoff -= (psy_cb->psy_noncol_qlen + psy_cb->psy_updt_qlen);

	    /*
	    ** Compute offset to the beginning of the object name and grantee
	    ** name in the third template.
	    ** To do this we need to subtract from the table/grantee name offset
	    ** in the first template the length of
	    ** "GRANT <non-column privileges>" and add the length of the third
	    ** template text built so far (i.e. "GRANT REFERENCES (...) ".)
	    */
	    psy_cb->psy_ref_obj_name_off =
		psy_cb->psy_noncol_obj_name_off - textcnst + curoff;
	    psy_cb->psy_ref_grantee_off =
		psy_cb->psy_noncol_grantee_off - textcnst + curoff;

	    /* copy the first template starting with ON [TABLE] */
	    status = psq_tadd(cb->pss_tchain, (u_char *) (text + textcnst),
		STlength(text + textcnst), &piece, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* compute length of third template */

	    /* Obtain the size of the current iiqrytext (1 & 2 & 3) */
	    status = psq_tqrylen(cb->pss_tchain, &curoff);
	    if (status != E_DB_OK)
		return (status);

	    /* 
	    ** subtract length of first two stored templates to derive length of
	    ** the third one
	    */
	    psy_cb->psy_ref_qlen =
		curoff - psy_cb->psy_noncol_qlen - psy_cb->psy_updt_qlen;
	}
	else
	{
	    psy_cb->psy_ref_qlen = 0;
	}

	/*
	** All needed templates are ready now. Put the iiqrytext in a contiguous
	** block in QSF.
	*/
	status = psq_tout(cb, (PSS_USRRANGE *) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Copy the object id for the query text to the control block.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	
	/* DONE GENERATING QUERY TEXT */

    } break;

case 912:
if (TRUE)	/* NOBYPASS */
/* # line 19308 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
/* GRANT ... ON PROCEDURE ... WITH GRANT OPTION */
	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PTR                 piece;
	i4		    err_code;
	u_char              ident_placeholder[DB_MAX_DELIMID + 1];
	char		    text[512];
	char		    *str;
	i4		    str_len;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** GRANT ... ON PROCEDURE not allowed in CREATE SCHEMA
	    */
	    (VOID) psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("GRANT ... ON PROCEDURE")-1,
				 "GRANT ... ON PROCEDURE");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/*
	** Set grantee type; default is USER 
	*/
	psy_cb->psy_gtype = (yacc_cb->yypvt[-1].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-1].psl_tytype;

	/*
	** if WITH GRANT OPTION was specified, make sure that the grantee is of
	** type USER or PUBLIC (recall that PUBLIC may be specified as one of
	** user authorization identifier(s))
	*/
	if (   psy_cb->psy_opmap & DB_GRANT_OPTION
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(E_PS0550_GRANTEE_TYPE_FOR_WGO, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** The "grant" statement requires query text to be stored
	** in the iiqrytext relation. A template will be generated here.
	** Later on, in psy_dgrant, dbproc and grantee names will be
	** substituted.
	*/

	/* fill in an identifier placeholder */
	MEfill(DB_MAX_DELIMID, '?', (PTR) ident_placeholder);
	ident_placeholder[DB_MAX_DELIMID] = EOS;

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Text is a buffer where templates are built */
	text[0] = EOS;

	/* EXECUTE, ALL, or ALL PRIVILEGES mean the same thing: EXECUTE */
	STcat(text, "grant execute on procedure ");

	/* Remember offset to the dbproc name. */
	psy_cb->psy_noncol_obj_name_off = STlength(text);

	/* Append the place holder for schema.dbproc name */
	STcat(text, (char *) ident_placeholder);
	STcat(text, ".");
	STcat(text, (char *) ident_placeholder);

	psl_grantee_type_to_str(yacc_cb->yypvt[-1].psl_tytype, &str, &str_len, FALSE);
	if (!str)
	{
	    /* this is very bad */
	    (VOID) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	STcat(text, str);

	/* remember offset to the grantee name in the template */
	psy_cb->psy_noncol_grantee_off = 
	      psy_cb->psy_noncol_obj_name_off 	/* begining of schema name */
	    + DB_MAX_DELIMID			/* schema name placeholder */
	    + CMbytecnt(".")			/* separator b/w schema and 
						** object name */
	    + DB_MAX_DELIMID                    /* object name placeholder */
	    + str_len;				/* TO <grantee type> */

	/* append the place holder for grantee name */
	STcat(text, (char *) ident_placeholder);

	if (psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    STcat(text, " with grant option ");
	}

	/* The template is ready now. */
	status = psq_tadd(cb->pss_tchain, (u_char *) text, STlength(text),
	    &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Determine size of the template */
	status = psq_tqrylen(cb->pss_tchain, &psy_cb->psy_noncol_qlen);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Put the iiqrytext in a contiguous block in QSF.
	*/
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Copy the object id for the query text to the control block.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	
	/* DONE GENERATING QUERY TEXT */

    } break;

case 913:
if (TRUE)	/* NOBYPASS */
/* # line 19441 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
/* GRANT ... ON SEQUENCE ... WITH GRANT OPTION */
	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PTR                 piece;
	i4		    err_code;
	u_char              ident_placeholder[DB_MAX_DELIMID + 1];
	char		    text[512];
	char		    *str;
	i4		    str_len;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** GRANT ... ON SEQUENCE not allowed in CREATE SCHEMA
	    */
	    (void)psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("GRANT ... ON SEQUENCE")-1,
				 "GRANT ... ON SEQUENCE");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/*
	** Set grantee type; default is USER 
	*/
	psy_cb->psy_gtype = (yacc_cb->yypvt[-1].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-1].psl_tytype;

	/*
	** if WITH GRANT OPTION was specified, make sure that the grantee is of
	** type USER or PUBLIC (recall that PUBLIC may be specified as one of
	** user authorization identifier(s))
	*/
	if (   psy_cb->psy_opmap & DB_GRANT_OPTION
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (void)psf_error(E_PS0550_GRANTEE_TYPE_FOR_WGO, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** The "grant" statement requires query text to be stored
	** in the iiqrytext relation. A template will be generated here.
	** Later on, in psy_dgrant, sequence and grantee names will be
	** substituted.
	*/

	/* fill in an identifier placeholder */
	MEfill(DB_MAX_DELIMID, '?', (PTR) ident_placeholder);
	ident_placeholder[DB_MAX_DELIMID] = EOS;

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Text is a buffer where templates are built */
	text[0] = EOS;

	/* NEXT, ALL, or ALL PRIVILEGES mean the same thing: NEXT */
	STcat(text, "grant next on sequence ");

	/* Remember offset to the sequence name. */
	psy_cb->psy_noncol_obj_name_off = STlength(text);

	/* Append the place holder for schema.sequence name */
	STcat(text, (char *) ident_placeholder);
	STcat(text, ".");
	STcat(text, (char *) ident_placeholder);

	psl_grantee_type_to_str(yacc_cb->yypvt[-1].psl_tytype, &str, &str_len, FALSE);
	if (!str)
	{
	    /* this is very bad */
	    (void)psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	STcat(text, str);

	/* remember offset to the grantee name in the template */
	psy_cb->psy_noncol_grantee_off = 
	      psy_cb->psy_noncol_obj_name_off 	/* begining of schema name */
	    + DB_MAX_DELIMID			/* schema name placeholder */
	    + CMbytecnt(".")			/* separator b/w schema and 
						** object name */
	    + DB_MAX_DELIMID                    /* object name placeholder */
	    + str_len;				/* TO <grantee type> */

	/* append the place holder for grantee name */
	STcat(text, (char *) ident_placeholder);

	if (psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    STcat(text, " with grant option ");
	}

	/* The template is ready now. */
	status = psq_tadd(cb->pss_tchain, (u_char *) text, STlength(text),
	    &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Determine size of the template */
	status = psq_tqrylen(cb->pss_tchain, &psy_cb->psy_noncol_qlen);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Put the iiqrytext in a contiguous block in QSF.
	*/
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Copy the object id for the query text to the control block.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	
	/* DONE GENERATING QUERY TEXT */

    } break;

case 914:
if (TRUE)	/* NOBYPASS */
/* # line 19574 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
/* GRANT ... ON DBEVENT ... WITH GRANT OPTION */
	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PTR                 piece;
	i4		    err_code;
	u_char              ident_placeholder[DB_MAX_DELIMID + 1];
	char		    text[512];
	char		    *str;
	i4		    str_len;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** GRANT ... ON DBEVENT not allowed in CREATE SCHEMA
	    */
	    (VOID) psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("GRANT ... ON DBEVENT")-1,
				 "GRANT ... ON DBEVENT");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/*
	** Set grantee type; default is USER 
	*/
	psy_cb->psy_gtype = (yacc_cb->yypvt[-1].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-1].psl_tytype;

	/*
	** if WITH GRANT OPTION was specified, make sure that the grantee is of
	** type USER or PUBLIC (recall that PUBLIC would be specified as one of
	** user authorization identifiers)
	*/
	if (   psy_cb->psy_opmap & DB_GRANT_OPTION
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(E_PS0550_GRANTEE_TYPE_FOR_WGO, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** The "grant" statement requires query text to be stored
	** in the iiqrytext relation. A template will be generated here.
	** Later on, in psy_dgrant, dbevent and grantee names will be
	** substituted.
	*/

	/* fill in an identifier placeholder */
	MEfill(DB_MAX_DELIMID, '?', (PTR) ident_placeholder);
	ident_placeholder[DB_MAX_DELIMID] = EOS;

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft, 
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Text is a buffer where templates are built */
	text[0] = EOS;

	/*
	** ALL [PRIVILEGES] will get translated into two tuples - for REGISTER
	** and RAISE; template will contain a placeholder for the longest of
	** them - REGISTER
	*/
	if (psy_cb->psy_opmap & DB_EVREGISTER && psy_cb->psy_opmap & DB_EVRAISE)
	{
	    /*
	    ** 2 permit tuples will be generated - template will contain a
	    ** placeholder for the longest privilege - REGISTER
	    */
	    str = "grant ???????? on dbevent ";
	}
	else if (psy_cb->psy_opmap & DB_EVREGISTER)
	{
	    str = "grant register on dbevent ";
	}
	else
	{
	    str = "grant raise on dbevent ";
	}

	STcat(text, str);

	/* Remember offset to the dbevent name. */
	psy_cb->psy_noncol_obj_name_off = STlength(text);

	/* Append the place holder for 'owner'.dbevent name. */
	STcat(text, (char *) ident_placeholder);
	STcat(text, ".");
	STcat(text, (char *) ident_placeholder);

	psl_grantee_type_to_str(yacc_cb->yypvt[-1].psl_tytype, &str, &str_len, FALSE);
	if (!str)
	{
	    /* this is very bad */
	    (VOID) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	STcat(text, str);

	/* remember offset to the grantee name in the template */
	psy_cb->psy_noncol_grantee_off = 
	      psy_cb->psy_noncol_obj_name_off 	/* begining of schema name */
	    + DB_MAX_DELIMID			/* schema name placeholder */
	    + CMbytecnt(".")			/* separator b/w schema and 
						** object name */
	    + DB_MAX_DELIMID                    /* object name placeholder */
	    + str_len;				/* TO <grantee type> */

	/* append the place holder for grantee name */
	STcat(text, (char *) ident_placeholder);

	if (psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    STcat(text, " with grant option ");
	}

	/*
	** The template is ready now. 
	*/
	status = psq_tadd(cb->pss_tchain, (u_char *) text,
	    STlength(text), &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Determine size of the iiqrytext */
	status = psq_tqrylen(cb->pss_tchain, &psy_cb->psy_noncol_qlen);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Put the iiqrytext in a contiguous block in QSF.
	*/
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Copy the object id for the query text to the control block.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	
	/* DONE GENERATING QUERY TEXT */

    } break;

case 915:
if (TRUE)	/* NOBYPASS */
/* # line 19729 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** GRANT ... ON DATABASE|INSTALLATION not allowed in CREATE SCHEMA
	    */
	    (VOID) psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("GRANT ... ON DATABASE|INSTALLATION")-1,
				 "GRANT ... ON DATABASE|INSTALLATION");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/* Translate ALL [PRIVILEGES] */
	if (psy_cb->psy_flags & PSY_ALL_PRIVS)
	{
	    psy_cb->psy_ctl_dbpriv = DBPR_C_ALLPRIVS;
	    psy_cb->psy_fl_dbpriv  = DBPR_F_ALLPRIVS;
	}

	/* Set grantee type; default is USER */
	psy_cb->psy_gtype = (yacc_cb->yypvt[-0].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-0].psl_tytype;

	/* 
	** Set statement mode depending upon what privileges are granted:
	**	PSQ_GDBPRIV - One or more restricted privileges are granted
	**	PSQ_GOKPRIV - No restricted privileges are being granted
	*/

	if (   (psy_cb->psy_flags & PSY_GR_REV_ROLE)
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(9341, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Set mode in the PSY_CB */
	if (psy_cb->psy_flags & PSY_GR_REV_ROLE)
	{
		psy_cb->psy_grant = PSY_RGRANT;
		psq_cb->psq_mode = PSQ_RGRANT;
	}
	else
	{
		psy_cb->psy_grant = PSY_DGRANT;
		psq_cb->psq_mode = (psy_cb->psy_ctl_dbpriv & DBPR_RESTRICTED)
								? PSQ_GDBPRIV
								: PSQ_GOKPRIV;
	}
    } break;

case 916:
if (!((*yyvarspp)->bypass_actions))
/* # line 19789 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_GRANT_OPTION;
    } break;

case 918:
if (TRUE)	/* NOBYPASS */
/* # line 19796 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    yyvarsp->submode = PSQ_GRANT;
	    yyvarsp->deplist = (PST_OBJDEP *) NULL;
	    yyvarsp->stmtstart = (char *) cb->pss_prvgoval;
	    yyvarsp->cons_list = (PSS_CONS *) NULL;
	    return(E_DB_OK);
	}
	    
	psq_cb->psq_mode = PSQ_GRANT;

	/* "grant" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(2325L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the grant statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Default terminal name is "" */
	MEfill(sizeof(psy_cb->psy_terminal), ' ', (PTR) &psy_cb->psy_terminal);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/*
	** Default time is all day, starting at 00:00 and ending at 24:00,
	** given as minutes after 00:00.
	*/
	psy_cb->psy_timbgn = 0;
	psy_cb->psy_timend = 1440;

	/*
	** Default days are all week, starting with Sunday and ending with
	** Saturday.  Sunday = 0, Saturday = 6.
	*/
	psy_cb->psy_daybgn = 0;
	psy_cb->psy_dayend = 6;

	/*
	** next we will be processing the list of privileges, psl_sscan() will
	** accord special treatment to words REGISTER and RAISE (dbevent
	** privileges) only when processing the privilege specification of 
	** GRANT or REVOKE statements
	*/
	cb->pss_stmt_flags |= PSS_PARSING_PRIVS;

	if ((psq_cb->psq_info != (PST_INFO *) NULL) &&
            (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	    psy_cb->psy_flags |= PSY_SCHEMA_MODE;

	/* Initialize object queue */
	(VOID) QUinit((QUEUE *) &psy_cb->psy_objq); /* No objects */

    } break;

case 921:
if (!((*yyvarspp)->bypass_actions))
/* # line 19877 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* granting/revoking privilege(s) on a Table */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_TGRANT
							    : PSY_TREVOKE;
	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    } break;

case 922:
if (!((*yyvarspp)->bypass_actions))
/* # line 19890 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* granting/revoking privilege(s) on a Table */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_TGRANT
							    : PSY_TREVOKE;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;

	/*
	** defined ops are the same as allowed ops
	*/
	psy_cb->psy_opctl =
	    (psy_cb->psy_opmap |=
		DB_RETRIEVE | DB_APPEND | DB_REPLACE | DB_DELETE
		    | DB_REFERENCES | DB_COPY_INTO | DB_COPY_FROM);

	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    } break;
	}
	return(0);
}

i4
psls18iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 925:
if (!((*yyvarspp)->bypass_actions))
/* # line 19921 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_RETRIEVE;
    } break;

case 926:
if (!((*yyvarspp)->bypass_actions))
/* # line 19925 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_DELETE;
    } break;

case 927:
if (!((*yyvarspp)->bypass_actions))
/* # line 19929 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** @FIX_ME@:
	**	when we start supporting INSERT(column_list), having processed 
	**	the grant_col_spec we will need to recompute 
	** 	psy_cb->psy_r_col_offset which depends on psy_cb->psy_i_numcols
	** @FIX_ME@
	*/
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_APPEND;
    } break;

case 928:
if (!((*yyvarspp)->bypass_actions))
/* # line 19940 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->priv = DB_REPLACE;
    } break;

case 929:
if (!((*yyvarspp)->bypass_actions))
/* # line 19944 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= DB_REPLACE;

	/*
	** recompute offset of the beginning of the attribute list
	** associated with INSERT and REFERENCES privileges
	** (attributes (if any) to which UPDATE will/won't apply
	** will be placed in the beginning of the list - offset 0)
	*/
	psy_cb->psy_u_col_offset = 0;
	psy_cb->psy_i_col_offset = psy_cb->psy_u_numcols;
	psy_cb->psy_r_col_offset =
	    psy_cb->psy_i_col_offset + psy_cb->psy_i_numcols;
    } break;

case 930:
if (!((*yyvarspp)->bypass_actions))
/* # line 19961 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->priv = DB_REFERENCES;
    } break;

case 931:
if (!((*yyvarspp)->bypass_actions))
/* # line 19965 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_REFERENCES;
    } break;

case 932:
if (!((*yyvarspp)->bypass_actions))
/* # line 19969 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_COPY_FROM;
	((PSY_CB *) cb->pss_object)->psy_opctl |= DB_COPY_FROM;
    } break;

case 933:
if (!((*yyvarspp)->bypass_actions))
/* # line 19974 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_COPY_INTO;
	((PSY_CB *) cb->pss_object)->psy_opctl |= DB_COPY_INTO;
    } break;

case 934:
if (!((*yyvarspp)->bypass_actions))
/* # line 19981 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* granting/revoking privilege on a Procedure */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_PGRANT
							    : PSY_PREVOKE;
	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    } break;

case 935:
if (!((*yyvarspp)->bypass_actions))
/* # line 19994 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* granting/revoking privilege on a Procedure */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_PGRANT
							    : PSY_PREVOKE;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;

	/*
	** defined ops are the same as allowed ops
	*/
	psy_cb->psy_opctl = (psy_cb->psy_opmap |= DB_EXECUTE);

	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    } break;

case 938:
if (!((*yyvarspp)->bypass_actions))
/* # line 20022 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_EXECUTE;
    } break;

case 939:
if (!((*yyvarspp)->bypass_actions))
/* # line 20028 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* granting/revoking privilege on a sequence */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_SQGRANT
							    : PSY_SQREVOKE;
	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    } break;

case 940:
if (!((*yyvarspp)->bypass_actions))
/* # line 20041 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* granting/revoking privilege on a sequence */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_SQGRANT
							    : PSY_SQREVOKE;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;

	/*
	** defined ops are the same as allowed ops
	*/
	psy_cb->psy_opctl = (psy_cb->psy_opmap |= DB_NEXT);

	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    } break;

case 943:
if (!((*yyvarspp)->bypass_actions))
/* # line 20069 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* "next" privilege is same as "select", but avoids grammar ambiguity. */
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_NEXT;
    } break;

case 944:
if (!((*yyvarspp)->bypass_actions))
/* # line 20076 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* Granting/revoking privilege(s) on a dbevent */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_EVGRANT
							    : PSY_EVREVOKE;

	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    } break;

case 945:
if (!((*yyvarspp)->bypass_actions))
/* # line 20090 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* Granting/revoking privilege(s) on a dbevent */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_EVGRANT
							    : PSY_EVREVOKE;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;

	/*
	** defined ops are the same as allowed ops
	*/
	psy_cb->psy_opctl = (psy_cb->psy_opmap |= DB_EVREGISTER | DB_EVRAISE);

	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    } break;

case 948:
if (!((*yyvarspp)->bypass_actions))
/* # line 20118 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_EVREGISTER;
    } break;

case 949:
if (!((*yyvarspp)->bypass_actions))
/* # line 20122 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_EVRAISE;
    } break;

case 950:
if (!((*yyvarspp)->bypass_actions))
/* # line 20128 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    } break;

case 951:
if (!((*yyvarspp)->bypass_actions))
/* # line 20133 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* REVOKE GRANT OPTION FOR <database_privs> is not supported yet */
	if (   psq_cb->psq_mode == PSQ_REVOKE
	    && psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
	
	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    } break;

case 952:
if (!((*yyvarspp)->bypass_actions))
/* # line 20156 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* REVOKE GRANT OPTION FOR <database_privs> is not supported yet */
	if (   psq_cb->psq_mode == PSQ_REVOKE
	    && ((PSY_CB *) cb->pss_object)->psy_opmap & DB_GRANT_OPTION)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    } break;

case 954:
if (!((*yyvarspp)->bypass_actions))
/* # line 20179 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;
	DB_STATUS   status;

	status=psl_dp1_dbp_nonkeyword(cb, psy_cb, psq_cb, yacc_cb->yypvt[-0].psl_strtype);
	if(status!=E_DB_OK)
		return status;
    } break;

case 955:
if (!((*yyvarspp)->bypass_actions))
/* # line 20188 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;
	i4	    err_code;
	i4	    err_num = 0;

	if (psq_cb->psq_mode == PSQ_REVOKE)
	{
	    if ((STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_IO_LIMIT") == 0) ||
		(STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_ROW_LIMIT") == 0) ||
		(STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_CPU_LIMIT") == 0) ||
		(STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_PAGE_LIMIT") == 0) ||
		(STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_COST_LIMIT") == 0) ||
		(STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "IDLE_TIME_LIMIT") == 0) ||
		(STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "CONNECT_TIME_LIMIT") == 0) ||
		(STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "SESSION_PRIORITY") == 0)
	       )
		err_num = 6286L;
	    else
		err_num = 6287L;
	}
	else if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_IO_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QDIO_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QDIO_LIMIT) ||
		  (psy_cb->psy_qdio_limit != yacc_cb->yypvt[-0].psl_inttype)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QDIO_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QDIO_LIMIT;
		psy_cb->psy_qdio_limit = yacc_cb->yypvt[-0].psl_inttype;
	    }
	}
	else if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_ROW_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QROW_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QROW_LIMIT) ||
		  (psy_cb->psy_qrow_limit != yacc_cb->yypvt[-0].psl_inttype)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QROW_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QROW_LIMIT;
		psy_cb->psy_qrow_limit = yacc_cb->yypvt[-0].psl_inttype;
	    }
	}
	else if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_CPU_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QCPU_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QCPU_LIMIT) ||
		  (psy_cb->psy_qcpu_limit != yacc_cb->yypvt[-0].psl_inttype)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QCPU_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QCPU_LIMIT;
		psy_cb->psy_qcpu_limit = yacc_cb->yypvt[-0].psl_inttype;
	    }
	}
	else if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_PAGE_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QPAGE_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QPAGE_LIMIT) ||
		  (psy_cb->psy_qpage_limit != yacc_cb->yypvt[-0].psl_inttype)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QPAGE_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QPAGE_LIMIT;
		psy_cb->psy_qpage_limit = yacc_cb->yypvt[-0].psl_inttype;
	    }
	}
	else if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "IDLE_TIME_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_IDLE_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_IDLE_LIMIT) ||
		  (psy_cb->psy_idle_limit != yacc_cb->yypvt[-0].psl_inttype)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_IDLE_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_IDLE_LIMIT;
		psy_cb->psy_idle_limit = yacc_cb->yypvt[-0].psl_inttype;
	    }
	}
	else if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "CONNECT_TIME_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_CONNECT_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_CONNECT_LIMIT) ||
		  (psy_cb->psy_connect_limit != yacc_cb->yypvt[-0].psl_inttype)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_CONNECT_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_CONNECT_LIMIT;
		psy_cb->psy_connect_limit = yacc_cb->yypvt[-0].psl_inttype;
	    }
	}
	else if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "SESSION_PRIORITY") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_PRIORITY_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_PRIORITY_LIMIT) ||
		  (psy_cb->psy_priority_limit != yacc_cb->yypvt[-0].psl_inttype)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_PRIORITY_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_PRIORITY_LIMIT;
		psy_cb->psy_priority_limit = yacc_cb->yypvt[-0].psl_inttype;
	    }
	}
	else if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "QUERY_COST_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QCOST_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QCOST_LIMIT) ||
		  (psy_cb->psy_qcost_limit != yacc_cb->yypvt[-0].psl_inttype)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QCOST_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QCOST_LIMIT;
		psy_cb->psy_qcost_limit = yacc_cb->yypvt[-0].psl_inttype;
	    }
	}
	else if ((STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "CREATE_TABLE") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "CREATE_PROCEDURE") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "CREATE_SEQUENCE") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "LOCKMODE") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "ACCESS") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "UPDATE_SYSCAT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "SELECT_SYSCAT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "TABLE_STATISTICS") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "DB_ADMIN") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOCREATE_TABLE") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOCREATE_PROCEDURE") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOCREATE_SEQUENCE") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOLOCKMODE") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOACCESS") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOUPDATE_SYSCAT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOSELECT_SYSCAT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOTABLE_STATISTICS") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOCONNECT_TIME_LIMIT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOSESSION_PRIORITY") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOIDLE_TIME_LIMIT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NODB_ADMIN") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOQUERY_IO_LIMIT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOQUERY_ROW_LIMIT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOQUERY_CPU_LIMIT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOQUERY_PAGE_LIMIT") == 0) ||
		 (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "NOQUERY_COST_LIMIT") == 0)
		)
	    err_num = 6287L;
	else
	    err_num = 6288L;

	if (err_num != 0)
	{
	    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
	    return (E_DB_ERROR);
	}
	/*
	** Mark this as a dbpriv
	*/
	psy_cb->psy_flags |= PSY_GR_REV_DBPRIV;
    } break;

case 956:
if (!((*yyvarspp)->bypass_actions))
/* # line 20357 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb;
	i4	    err_code;
	/* must be ON CURRENT INSTALLATION */
    	psy_cb = (PSY_CB *) cb->pss_object;
	if (CMcmpcase(yacc_cb->yypvt[-0].psl_strtype, "i") || STcompare(yacc_cb->yypvt[-0].psl_strtype, "installation"))
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	if(psy_cb->psy_flags & PSY_GR_REV_ROLE)
	{
	    /*
	    ** Assume role name(s) are illegal database priv names
	    ** since the format is of a database grant
	    */
	    (VOID) psf_error(6288, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) 0, "");
	    return E_DB_ERROR;
	}
    } break;

case 957:
if (!((*yyvarspp)->bypass_actions))
/* # line 20379 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		PSY_CB          *psy_cb;
		i4	    err_code;

		psy_cb = (PSY_CB *) cb->pss_object;
		if(psy_cb->psy_flags & PSY_GR_REV_ROLE)
		{
		    /*
		    ** Assume role name(s) are illegal database priv names
		    ** since the format is of a database grant
		    */
		    (VOID) psf_error(6288, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, (i4) 0, "");
		    return E_DB_ERROR;
		}
	    } break;

case 958:
if (!((*yyvarspp)->bypass_actions))
/* # line 20396 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		PSY_CB          *psy_cb;
		/*
		** This clause is missing for ROLE grants, so
		** mark we are doing a role grant. Also check at this
		** point we have at least one role name
		*/
    		psy_cb = (PSY_CB *) cb->pss_object;
		if(!((psy_cb->psy_flags & PSY_GR_REV_ROLE) ||
		    psy_cb->psy_ctl_dbpriv & (DBPR_ALLPRIVS | DBPR_ALL)) ||
		    (psy_cb->psy_flags & PSY_GR_REV_DBPRIV))
		{
			psl_yerror(3, cb, psq_cb);
			return E_DB_ERROR;
		}
	    } break;

case 961:
if (!((*yyvarspp)->bypass_actions))
/* # line 20419 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	bool		found = FALSE;
	DB_TAB_NAME	db_name;


	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_TAB_NAME), (char *) &db_name);

	/* database and location names must be in lowercase */
	if (*cb->pss_dbxlate & CUI_ID_REG_U)
	    CVlower(db_name.db_tab_name);
	
    	psy_cb = (PSY_CB *) cb->pss_object;

	/* Check if database is being specified for the first time. */
	for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
	     psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
	     psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
	    )
	{
	    if (!MEcmp((PTR) &db_name, (PTR) &psy_tbl->psy_tabnm,
		       sizeof(psy_tbl->psy_tabnm)))
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Allocate memory for an object entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_TBL),
		(PTR *) &psy_tbl, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** Copy database name to object entry.
	    */
	    STRUCT_ASSIGN_MACRO(db_name, psy_tbl->psy_tabnm);

	    /*
	    ** Attach element to the list.
	    */
	    (VOID) QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	}
    } break;

case 962:
if (!((*yyvarspp)->bypass_actions))
/* # line 20473 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}

	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 963:
if (!((*yyvarspp)->bypass_actions))
/* # line 20489 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}

	yacc_cb->yyval.psl_tytype = 1;
    } break;
	}
	return(0);
}

i4
psls19iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 966:
if (TRUE)	/* NOBYPASS */
/* # line 20511 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	bool		found = FALSE;
	PSS_RNGTAB	*resrange;
	i4		rngvar_info;
	bool		updtcols, insrtcols, refcols, colprivs;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    return(psl_cs06s_obj_spec(cb, psq_cb, &(yyvarsp->deplist), yacc_cb->yypvt[-0].psl_objspec,
				      (u_i4)0));
	}

	/*
	** remember whether one or more of UPDATE, INSERT, REFERENCES privilege
	** will or will not apply to a set of columns
	*/

	updtcols = psy_cb->psy_u_numcols != 0;
	insrtcols = psy_cb->psy_i_numcols != 0;
	refcols = psy_cb->psy_r_numcols != 0;

	colprivs = updtcols || insrtcols || refcols;

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl0_orngent(&cb->pss_auxrng, -1, yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name,
		&yacc_cb->yypvt[-0].psl_objspec->pss_owner, &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, !colprivs, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info, 0);
	}
	else
	{
	    status = psl0_rngent(&cb->pss_auxrng, -1, yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name,
		&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, !colprivs, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error,
		PSS_USRTBL | PSS_DBATBL | PSS_INGTBL, &rngvar_info, 0);
	}

	if (status != E_DB_OK)
	{
	    return (status);
	}
	else if (resrange == (PSS_RNGTAB *) NULL)
	{
	    /* table doesn't exist */

	    /* 
	    ** if the user spevcified name of the schema, we will issue a vague
	    ** message saying that EITHER the table did not exist or the user
	    ** lacked required privileges on it; this way the user who possesses
	    ** no privileges on a table will not be able to find out about its
	    ** existence based on error messages.  If the schema name was not 
	    ** specified, we will continue issuing the old "table does not 
	    ** exist or is not owned by you" message
	    */

	    if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
		char        command[PSL_MAX_COMM_STRING];
		i4     length;

		psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, 
		    &length);

		(VOID) psf_error(E_US088E_2190_INACCESSIBLE_TBL, 0L, 
		    PSF_USERERR,&err_code, &psq_cb->psq_error, 3,
		    length, command,
		    psf_trmwhite(sizeof(yacc_cb->yypvt[-0].psl_objspec->pss_owner), 
			(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner),
		    &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
		    psf_trmwhite(sizeof(yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
			(char *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name),
		    &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name);
	    }
	    else
	    {
	        (VOID) psf_error(2117L, 0L, PSF_USERERR,&err_code,
		    &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name),
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name);
	    }

	    /*
	    ** if processing GRANT inside CREATE SCHEMA, non-existent table 
	    ** constitutes a Syntax Rule violation and will result in the 
	    ** CREATE SCHEMA being rolled back; 
	    ** otherwise, for the sake of backward compatibility, we will 
	    ** proceed to the next object name (if any) specified in the 
	    ** statement
	    */
	    if (   psq_cb->psq_mode == PSQ_GRANT 
		&& psy_cb->psy_flags & PSY_SCHEMA_MODE)
	    {
		return(E_DB_ERROR);
	    }
	}
	else
	{
	    i4	    mask;
	    
	    /* Check if table is specified for the first time */
	    for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
		 psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
		 psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
		)
	    {
		/*
		** compare components of DB_TAB_ID rather than using more
		** expensive MEcmp()
		*/
		if (resrange->pss_tabid.db_tab_base ==
		    psy_tbl->psy_tabid.db_tab_base
		    &&
		    resrange->pss_tabid.db_tab_index ==
		    psy_tbl->psy_tabid.db_tab_index
		   )
		{
		    found = TRUE;

		    /*
		    ** if the same object is mentioned more than once by its 
		    ** name (as opposed to by synonym name) remember whether 
		    ** its schema and/or object name may be expressed as regular
		    ** identifiers
		    */
		    if (~rngvar_info & PSS_BY_SYNONYM)
		    {
			if (   ~psy_tbl->psy_mask & PSY_REGID_SCHEMA_NAME
			    && yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			    && yacc_cb->yypvt[-0].psl_objspec->pss_schema_id_type == PSS_ID_REG
			   )
			{
			    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
			}

			if (   ~psy_tbl->psy_mask & PSY_REGID_OBJ_NAME
			    && yacc_cb->yypvt[-0].psl_objspec->pss_obj_id_type == PSS_ID_REG)
			{
			    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
			}
		    }

		    break;
		}
	    }

	    if (!found)
	    {
		mask = resrange->pss_tabdesc->tbl_status_mask;

		if (mask & DMT_IDX)
		{
		    /*
		    ** let user know if name supplied by the user was
		    ** resolved to a synonym
		    */
		    if (rngvar_info & PSS_BY_SYNONYM)
		    {
			char        qry[PSL_MAX_COMM_STRING];
			i4     qry_len;

			psl_command_string(psq_cb->psq_mode, cb->pss_lang, 
			    qry, &qry_len);

			psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
			    (i4) qry_len, qry, &psq_cb->psq_error);
		    }

		    /* 
		    ** GRANT/REVOKE/CREATE SECURITY_ALARM on an index is not 
		    ** allowed 
		    */
		    (VOID) psf_error(2328L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);

		    /*
		    ** if processing GRANT inside CREATE SCHEMA, violation of
		    ** a syntax rule will result in the whole statement being 
		    ** rolled back;
		    ** otherwise, for the sake of backward compatibility, we 
		    ** will proceed to the next object name (if any) specified 
		    ** in the statement
		    */
		    if (   psq_cb->psq_mode == PSQ_GRANT 
			&& psy_cb->psy_flags & PSY_SCHEMA_MODE)
		    {
			return(E_DB_ERROR);
		    }
		}
		else if (   mask & DMT_VIEW 
			 && (psy_cb->psy_opmap & DB_REFERENCES) 
			 && ~psy_cb->psy_flags & PSY_ALL_PRIVS
			)
		{
		    /* 
		    ** one may not explicitly GRANT/REVOKE REFERENCES on a view;
		    ** if ALL [PRIIVLEGES] was specified, code in 
		    ** psy_dgrant()/psy_revoke() will "know" to not try to 
		    ** GRANT/REVOKE REFERENCES on views
		    */
		    (VOID) psf_error(E_PS0470_REFERENCES_ON_VIEW, 0L, 
			PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);

		    /*
		    ** if processing GRANT inside CREATE SCHEMA, this error
		    ** will result in the whole statement being rolled back;
		    ** otherwise, for the sake of backward compatibility, we 
		    ** will proceed to the next object name (if any) specified 
		    ** in the statement
		    */
		    if (   psq_cb->psq_mode == PSQ_GRANT 
			&& psy_cb->psy_flags & PSY_SCHEMA_MODE)
		    {
			return(E_DB_ERROR);
		    }
		}
		else if (   mask & DMT_VIEW 
			 && (psy_cb->psy_opmap & (DB_COPY_INTO|DB_COPY_FROM)) 
			 && ~psy_cb->psy_flags & PSY_ALL_PRIVS
			)
		{
		    /* 
		    ** one may not explicitly GRANT/REVOKE COPY on a view;
		    ** if ALL [PRIIVLEGES] was specified, code in 
		    ** psy_dgrant()/psy_revoke() will "know" to not try to 
		    ** GRANT/REVOKE REFERENCES on views
		    */
		    (VOID) psf_error(E_PS04D0_GRANT_COPY_ON_VIEW, 0L, 
			PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);
		    /* do not return error; just a warning */
		}
		else
		{
		    /*
		    ** One no longer has to be a DBA or $INGRES in order to
		    ** GRANT or CREATE SECURITY_ALARM
		    */

		    /*
		    ** The following now applies to
		    ** GRANT and CREATE SECURITY_ALARM:
		    ** DBA can run the query against extended catalogs.
		    ** User may run the query against catalogs if he has a
		    ** catalog update privilege.
		    ** Any user may run the query against his table.
		    ** If !psy_permit_ok(), we definitely need to report an
		    ** error.
		    **
		    ** And one more change: we will no longer invoke
		    ** psy_permit_ok() when parsing GRANT/REVOKE.  A user may be
		    ** able to grant/revoke access to another user's object
		    ** providing he was given GRANT OPTION FOR/has previously
		    ** granted the same privileges on this object
		    */

		    if (psq_cb->psq_mode == PSQ_CALARM &&
			!psy_permit_ok(mask, cb, &resrange->pss_ownname))
		    {
			/*
			** Must audit CREATE SECURITY_ALARM failure.
			*/
			if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
			{
			    DB_STATUS       local_status;
			    DB_ERROR         e_error;

			    local_status = psy_secaudit(FALSE, cb,
				(char *)&resrange->pss_tabdesc->tbl_name,	
				&resrange->pss_tabdesc->tbl_owner,
				sizeof(DB_TAB_NAME), SXF_E_TABLE,
				I_SX202D_ALARM_CREATE, SXF_A_FAIL | SXF_A_CREATE,
				&e_error);
			}

			/*
			** let user know if name supplied by the user was
			** resolved to a synonym
			*/
			if (rngvar_info & PSS_BY_SYNONYM)
			{
			    psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
				sizeof("CREATE SECURITY_ALARM") - 1,
				"CREATE SECURITY_ALARM", &psq_cb->psq_error);
			}

			(VOID) psf_error(2327L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 1,
			    psf_trmwhite(sizeof(DB_TAB_NAME),
				(char *) &resrange->pss_tabname),
			    &resrange->pss_tabname);
				
			return (E_DB_ERROR);
		    }

		    /* Allocate memory for a table entry */
		    status = psf_malloc(cb, &cb->pss_ostream,
			(i4) (sizeof(PSY_TBL) +
			    (psy_cb->psy_u_numcols + psy_cb->psy_i_numcols +
			      psy_cb->psy_r_numcols) * sizeof(i4)), 
			(PTR *) &psy_tbl, &psq_cb->psq_error);
		    if (status != E_DB_OK)
		    {
			return (status);
		    }

		    /*
		    ** Copy table id, table name, and owner name in table entry.
		    */
		    STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
					psy_tbl->psy_tabid);
		    STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
					psy_tbl->psy_tabnm);
		    STRUCT_ASSIGN_MACRO(resrange->pss_ownname,
					psy_tbl->psy_owner);

		    if (updtcols)	/* there are UPDATE cols */
		    {
			i4		    *attrid;
			DMT_ATT_ENTRY	    *attribute;
			register i4	    i;
			PSY_COL		    *psy_col;

			/*
			** Verify column existence, store attribute nos.
			*/
			for (psy_col = (PSY_COL *) psy_cb->psy_u_colq.q_next,
			     i = 0,
			     attrid = psy_tbl->psy_colatno +
				psy_cb->psy_u_col_offset;
				
			     i < psy_cb->psy_u_numcols;
			     
			     psy_col = (PSY_COL *) psy_col->queue.q_next,
			     i++,
			     attrid++
			    )
			{
			    /*
			    ** Store a attribute no. for each column.
			    */

			    /* Look up the attribute */
			    attribute = pst_coldesc(resrange,
				&psy_col->psy_colnm);

			    /*
			    ** Check for attribute not found;
			    ** user may not grant UPDATE on TID (attr 0)
			    */
			    if (attribute == (DMT_ATT_ENTRY *) NULL ||
				attribute->att_number == 0)
			    {
				(VOID) psf_error(2100L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 4,
				    sizeof(cb->pss_lineno), &cb->pss_lineno,
				    psf_trmwhite(sizeof(DB_TAB_NAME),
					(char *) &resrange->pss_tabname),
				    &resrange->pss_tabname,
				    psf_trmwhite(sizeof(DB_OWN_NAME),
					(char *) &resrange->pss_ownname),
				    &resrange->pss_ownname,
				    psf_trmwhite(sizeof(DB_ATT_NAME),
					(char *) &psy_col->psy_colnm),
				    &psy_col->psy_colnm);
				return (E_DB_ERROR);
			    }

			    *attrid = attribute->att_number;	

			}	    /* for each column */

		    }	    /* there are update cols */

		    if (insrtcols)	/* there are INSERT columns */
		    {
			/*
			** start inserting attribute numbers starting at offset
			** psy_cb->psy_i_col_offset into psy_tbl->psy_colatno[]
			*/
		    }

		    if (refcols)	/* there are REFERENCES columns */
		    {
			i4		    *attrid;
			DMT_ATT_ENTRY	    *attribute;
			register i4	    i;
			PSY_COL		    *psy_col;

			/*
			** Verify column existence, store attribute nos.
			*/
			for (psy_col = (PSY_COL *) psy_cb->psy_r_colq.q_next,
			     i = 0,
			     attrid = psy_tbl->psy_colatno +
				psy_cb->psy_r_col_offset;
				
			     i < psy_cb->psy_r_numcols;
			     
			     psy_col = (PSY_COL *) psy_col->queue.q_next,
			     i++,
			     attrid++
			    )
			{
			    /*
			    ** Store a attribute no. for each column.
			    */

			    /* Look up the attribute */
			    attribute = pst_coldesc(resrange,
				&psy_col->psy_colnm);

			    /*
			    ** Check for attribute not found;
			    ** user may not grant REFERENCES on TID (attr 0)
			    */
			    if (attribute == (DMT_ATT_ENTRY *) NULL ||
				attribute->att_number == 0)
			    {
				(VOID) psf_error(2100L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 4,
				    sizeof(cb->pss_lineno), &cb->pss_lineno,
				    psf_trmwhite(sizeof(DB_TAB_NAME),
					(char *) &resrange->pss_tabname),
				    &resrange->pss_tabname,
				    psf_trmwhite(sizeof(DB_OWN_NAME),
					(char *) &resrange->pss_ownname),
				    &resrange->pss_ownname,
				    psf_trmwhite(sizeof(DB_ATT_NAME),
					(char *) &psy_col->psy_colnm),
				    &psy_col->psy_colnm);
				return (E_DB_ERROR);
			    }

			    *attrid = attribute->att_number;	

			}	    /* for each column */

		    }

		    /* remember the object type */
		    psy_tbl->psy_mask = (mask & DMT_VIEW) ? PSY_OBJ_IS_VIEW
							  : PSY_OBJ_IS_TABLE;

		    /*
		    ** if the object was specified using its real name (as 
		    ** opposed to a name of a synonym defined for it), remember
		    ** whether the schema and/or object name may be expressed 
		    ** as regular identifiers
		    */
		    if (~rngvar_info & PSS_BY_SYNONYM)
		    {
			if (   yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			    && yacc_cb->yypvt[-0].psl_objspec->pss_schema_id_type == PSS_ID_REG
			   )
			{
			    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
			}

			if (yacc_cb->yypvt[-0].psl_objspec->pss_obj_id_type == PSS_ID_REG)
			{
			    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
			}
		    }

		    /*
		    ** Attach element to the list.
		    */
		    (VOID) QUinsert((QUEUE *) psy_tbl, 
			(QUEUE *) &psy_cb->psy_tblq);

		}	    /* table is not an index */
	    }	    /* if (!found) */
	}	/* resrange != NULL */
    } break;

case 967:
if (!((*yyvarspp)->bypass_actions))
/* # line 21002 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}
    } break;

case 970:
if (!((*yyvarspp)->bypass_actions))
/* # line 21022 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	bool		found = FALSE;
	i4		dbp_mask;
	i4		dbpshow_flags;
	DB_OWN_NAME	*dbp_owner;

	/*
	** NOTE: we no longer insist that only the owner of the dbproc can
	**	 grant privileges on it; in psy_dgrant() we will verify that
	**	 this user can grant the specified privilege
	*/

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    dbp_owner = &yacc_cb->yypvt[-0].psl_objspec->pss_owner;
	    dbp_mask = PSS_DBP_BY_OWNER;
	}
	else
	{
	    dbp_owner = (DB_OWN_NAME *) NULL;
	    dbp_mask = PSS_USRDBP | PSS_DBADBP | PSS_INGDBP;
	}

	status = pst_dbpshow(cb, (DB_DBP_NAME *) &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
	    &yyvarsp->dbpinfo, dbp_owner, (DB_TAB_ID *) NULL, dbp_mask, psq_cb,
	    &dbpshow_flags);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	if (dbpshow_flags & PSS_MISSING_DBPROC)
	{
	    /* Procedure doesn't exist - do not return error; just a warning */
	}
	else
	{
	    /* don't allow users to grant/revoke on system-generated procedures
	     */
	    if (yyvarsp->dbpinfo->pss_ptuple.db_mask[0] & DBP_SYSTEM_GENERATED)
	    {
		psf_error(E_PS04A3_NO_GRANT, 0L, PSF_USERERR,
			  &err_code, &psq_cb->psq_error, 1,
			  psf_trmwhite(DB_MAXNAME,
			       yyvarsp->dbpinfo->pss_ptuple.db_dbpname.db_dbp_name),
			  yyvarsp->dbpinfo->pss_ptuple.db_dbpname.db_dbp_name);
		return(E_DB_ERROR);
	    }


	    /*
	    ** Check if dbproc is specified for the first time (compare proc ids
	    ** since it is cheaper than comparing dbproc names and owner names +
	    ** it will not fail if a user U enters something like
	    **	    "GRANT EXECUTE ON PROCEDURE Z.P, P to X"
	    ** if Z is the DBA or $ingres and U does not own a dbproc named P.
	    */
	    for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
		 psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
		 psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
		)
	    {
		if (psy_tbl->psy_tabid.db_tab_base ==
		    yyvarsp->dbpinfo->pss_ptuple.db_procid.db_tab_base
		    &&
		    psy_tbl->psy_tabid.db_tab_index ==
		    yyvarsp->dbpinfo->pss_ptuple.db_procid.db_tab_index
		   )
		{
		    found = TRUE;

		    /*
		    ** if the same object is mentioned more than once, remember
		    ** whether its schema and/or object name may be expressed 
		    ** as regular identifiers
		    */
		    if (   ~psy_tbl->psy_mask & PSY_REGID_SCHEMA_NAME
		        && yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		        && yacc_cb->yypvt[-0].psl_objspec->pss_schema_id_type == PSS_ID_REG
		       )
		    {
		        psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		    }

		    if (   ~psy_tbl->psy_mask & PSY_REGID_OBJ_NAME
		        && yacc_cb->yypvt[-0].psl_objspec->pss_obj_id_type == PSS_ID_REG)
		    {
		        psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		    }

		    break;
		}
	    }

	    if (!found)
	    {
		/* Allocate memory for a table entry */
		status = psf_malloc(cb, &cb->pss_ostream,
		    (i4) sizeof(PSY_TBL), (PTR *) &psy_tbl,
		    &psq_cb->psq_error);
		if (status != E_DB_OK)
		{
		    return (status);
		}

		/*
		** Copy procedure id, procedure name, and owner name to
		** table entry.
		*/
		STRUCT_ASSIGN_MACRO(yyvarsp->dbpinfo->pss_ptuple.db_procid,
				    psy_tbl->psy_tabid);
		STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, psy_tbl->psy_tabnm);
		STRUCT_ASSIGN_MACRO(yyvarsp->dbpinfo->pss_ptuple.db_owner,
				    psy_tbl->psy_owner);

		/* init psy_mask */
		psy_tbl->psy_mask = PSY_OBJ_IS_DBPROC;


		/*
		** remember whether the schema and/or object name may be 
		** expressed as regular identifiers
		*/
		if (   yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		    && yacc_cb->yypvt[-0].psl_objspec->pss_schema_id_type == PSS_ID_REG
		   )
		{
		    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		}

		if (yacc_cb->yypvt[-0].psl_objspec->pss_obj_id_type == PSS_ID_REG)
		{
		    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		}

		/*
		** Attach element to the list.
		*/
		(VOID) QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	    }
	}	/* database procedure exists */
    } break;

case 971:
if (!((*yyvarspp)->bypass_actions))
/* # line 21171 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}
    } break;

case 974:
if (!((*yyvarspp)->bypass_actions))
/* # line 21191 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	i4		nopriv = 0;
	i4		gseq_flags;
	i4		seq_mask = 0;
	DB_IISEQUENCE	seqtup;

	seq_mask |= ((yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_SEQ_BY_OWNER
	    : PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ);

	/* If name wasn't qualified, fill in default user name. */
	if (!(yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA))
	    STmove((PTR)&cb->pss_user, ' ', sizeof(DB_OWN_NAME),
	       (PTR)&yacc_cb->yypvt[-0].psl_objspec->pss_owner);
	/* Find the sequence first. */
	status = psy_gsequence(cb, &yacc_cb->yypvt[-0].psl_objspec->pss_owner, (DB_NAME *)&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, 
		seq_mask, NULL, &seqtup, &gseq_flags, (i4 *)NULL, 
		psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	else if (gseq_flags & PSS_MISSING_SEQUENCE)
	{
	    /* sequence doesn't exist - do not return error; just a warning */
	}
	else
	{
	    DB_TAB_ID	*seq_id = &seqtup.dbs_uniqueid;
	    bool	found = FALSE;

	    /* see if sequence is specified for the first time */
	    for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
		 psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
		 psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
		)
	    {
		/*
		** compare sequence ids since it is cheaper than MEcmp'ing
		** sequence names and owner names;
		*/
		if (   psy_tbl->psy_tabid.db_tab_base == seq_id->db_tab_base
		    && psy_tbl->psy_tabid.db_tab_index == seq_id->db_tab_index)
		{
		    found = TRUE;

		    /*
		    ** if the same object is mentioned more than once, remember
		    ** whether its schema and/or object name may be expressed 
		    ** as regular identifiers
		    */
		    if (   ~psy_tbl->psy_mask & PSY_REGID_SCHEMA_NAME
		        && yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		        && yacc_cb->yypvt[-0].psl_objspec->pss_schema_id_type == PSS_ID_REG
		       )
		    {
		        psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		    }

		    if (   ~psy_tbl->psy_mask & PSY_REGID_OBJ_NAME
		        && yacc_cb->yypvt[-0].psl_objspec->pss_obj_id_type == PSS_ID_REG)
		    {
		        psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		    }

		    break;
		}
	    }

	    if (!found)
	    {
		/* Allocate memory for a sequence entry */
		status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_TBL),
		    (PTR *) &psy_tbl, &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);

		psy_tbl->psy_tabid.db_tab_base = seq_id->db_tab_base;
		psy_tbl->psy_tabid.db_tab_index = seq_id->db_tab_index;

		/* Save sequence name */
		STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, psy_tbl->psy_tabnm);

		/* save sequence owner name */
		STRUCT_ASSIGN_MACRO(seqtup.dbs_owner, psy_tbl->psy_owner);

		/* init psy_mask */
		psy_tbl->psy_mask = 0;

		/*
		** remember whether the schema and/or object name may be 
		** expressed as regular identifiers
		*/
		if (   yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		    && yacc_cb->yypvt[-0].psl_objspec->pss_schema_id_type == PSS_ID_REG
		   )
		{
		    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		}

		if (yacc_cb->yypvt[-0].psl_objspec->pss_obj_id_type == PSS_ID_REG)
		{
		    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		}


		/* Attach element to the list */
		(void)QUinsert((QUEUE *)psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	    }
	}
    } break;

case 975:
if (!((*yyvarspp)->bypass_actions))
/* # line 21307 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}
    } break;

case 978:
if (!((*yyvarspp)->bypass_actions))
/* # line 21327 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	i4		ev_mask = 0;
	i4		gevent_flags;
	PSS_EVINFO	ev_info;
	i4		nopriv = 0;

	ev_mask |= ((yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_EV_BY_OWNER
	    : PSS_USREVENT | PSS_DBAEVENT | PSS_INGEVENT);

	/*
	** at this point we will not be checking permissions - only look up the
	** dbevent
	*/
	status = psy_gevent(cb, &yacc_cb->yypvt[-0].psl_objspec->pss_owner, &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
	    (DB_TAB_ID *) NULL, ev_mask, &ev_info, &gevent_flags, &nopriv,
	    psq_cb->psq_mode, (i4) FALSE, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gevent_flags & PSS_MISSING_EVENT)
	{
	    /* dbevent doesn't exist - do not return error; just a warning */
	}
	else
	{
	    DB_TAB_ID	*ev_id = &ev_info.pss_ev_id;
	    bool	found = FALSE;

	    /* see if dbevent is specified for the first time */
	    for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
		 psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
		 psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
		)
	    {
		/*
		** compare dbevent ids since it is cheaper than MEcmp'ing
		** dbevent names and dbevent owner names;
		*/
		if (   psy_tbl->psy_tabid.db_tab_base == ev_id->db_tab_base
		    && psy_tbl->psy_tabid.db_tab_index == ev_id->db_tab_index)
		{
		    found = TRUE;

		    /*
		    ** if the same object is mentioned more than once, remember
		    ** whether its schema and/or object name may be expressed 
		    ** as regular identifiers
		    */
		    if (   ~psy_tbl->psy_mask & PSY_REGID_SCHEMA_NAME
		        && yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		        && yacc_cb->yypvt[-0].psl_objspec->pss_schema_id_type == PSS_ID_REG
		       )
		    {
		        psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		    }

		    if (   ~psy_tbl->psy_mask & PSY_REGID_OBJ_NAME
		        && yacc_cb->yypvt[-0].psl_objspec->pss_obj_id_type == PSS_ID_REG)
		    {
		        psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		    }

		    break;
		}
	    }

	    if (!found)
	    {
		/* Allocate memory for an dbevent entry */
		status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_TBL),
		    (PTR *) &psy_tbl, &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);

		psy_tbl->psy_tabid.db_tab_base = ev_id->db_tab_base;
		psy_tbl->psy_tabid.db_tab_index = ev_id->db_tab_index;

		/* Save dbevent name */
		STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, psy_tbl->psy_tabnm);

		/* save dbevent owner name */
		STRUCT_ASSIGN_MACRO(ev_info.pss_alert_name.dba_owner,
				    psy_tbl->psy_owner);

		/* init psy_mask */
		psy_tbl->psy_mask = 0;

		/*
		** remember whether the schema and/or object name may be 
		** expressed as regular identifiers
		*/
		if (   yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		    && yacc_cb->yypvt[-0].psl_objspec->pss_schema_id_type == PSS_ID_REG
		   )
		{
		    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		}

		if (yacc_cb->yypvt[-0].psl_objspec->pss_obj_id_type == PSS_ID_REG)
		{
		    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		}


		/* Attach element to the list */
		(VOID) QUinsert((QUEUE *)psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	    }
	}
    } break;

case 979:
if (!((*yyvarspp)->bypass_actions))
/* # line 21443 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if before processing this grant_col_list, the column queue for this
	** privilege consisted of names of columns to which the privilege did
	** not apply, it is possible that this list became empty as a result of
	** processing this grant_col_list; if so, we will reset the
	** PSY_EXCLUDE_<privilege>_COLUMN bit to indicate that the column queue
	** no longer contains any "excluded" columns
	*/
	if (yyvarsp->priv == (i4) DB_REPLACE)
	{
	    if (   !psy_cb->psy_u_numcols
		&& psy_cb->psy_flags & PSY_EXCLUDE_UPDATE_COLUMNS)
	    {
		psy_cb->psy_flags &= ~PSY_EXCLUDE_UPDATE_COLUMNS;
	    }
	}
	else if (yyvarsp->priv == (i4) DB_REFERENCES)
	{
	    if (   !psy_cb->psy_r_numcols
		&& psy_cb->psy_flags & PSY_EXCLUDE_REFERENCES_COLUMNS)
	    {
		psy_cb->psy_flags &= ~PSY_EXCLUDE_REFERENCES_COLUMNS;
	    }
	}
    } break;

case 980:
if (!((*yyvarspp)->bypass_actions))
/* # line 21472 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** remember that we will be processing a list of columns to which a
	** privilege (specified by $Ypriv) will NOT apply
	*/
	yyvarsp->qry_mask |= PSS_EXCLUDE_COLUMNS;

	/* initialize the "excluded column" queue header */
	QUinit((QUEUE *) &yyvarsp->excluded_colq);

	/*
	** column list associated with the specified (in $Ypriv) privilege) will
	** be reinitialized - reset count of columns in the list to 0 here
	*/
	if (yyvarsp->priv == (i4) DB_REPLACE)
	{
  	    psy_cb->psy_u_numcols = 0; 
	}
	else if (yyvarsp->priv == DB_REFERENCES || 
		 yyvarsp->priv == DB_COPY_INTO ||
		 yyvarsp->priv == DB_COPY_FROM )
	{
	    psy_cb->psy_r_numcols = 0;
	}
    } break;

case 981:
if (!((*yyvarspp)->bypass_actions))
/* # line 21500 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* finished processing a list of excluded columns */
	yyvarsp->qry_mask &= ~PSS_EXCLUDE_COLUMNS;

	/*
	** "excluded column" queue built during processing of the
	** grant_col_list represents the set of columns to which the privilege
	** should not apply - overwrite the appropriate column queue with
	** contents of "excluded column" queue;
	**
	** if "excluded column" queue is empty, reset the
        ** PSY_EXCLUDE_<privilege>_COLUMNS bit to indicate that the user is
        ** granting table wide <privilege> and make the appropriate column queue
	** empty;
        ** otherwise set PSY_EXCLUDE_<privilege>_COLUMNS bit to indicate that
        ** the queue consists of names of columns to which privilege should not
        ** apply and overwrite the column queue with contents of "excluded
        ** column" queue
	*/

	if (yyvarsp->priv == (i4) DB_REPLACE)
	{
	    if (!psy_cb->psy_u_numcols)
	    {
		psy_cb->psy_flags &= ~PSY_EXCLUDE_UPDATE_COLUMNS;
		QUinit((QUEUE *) &psy_cb->psy_u_colq);
	    }
	    else
	    {
		STRUCT_ASSIGN_MACRO(yyvarsp->excluded_colq, psy_cb->psy_u_colq);

		/* reset pointers which were pointing at $Yexcluded_colq */
		psy_cb->psy_u_colq.q_next->q_prev =
		    psy_cb->psy_u_colq.q_prev->q_next = &psy_cb->psy_u_colq;

		psy_cb->psy_flags |= PSY_EXCLUDE_UPDATE_COLUMNS;
	    }
	}
	else if (yyvarsp->priv == DB_REFERENCES  ||
		 yyvarsp->priv == DB_COPY_INTO ||
		 yyvarsp->priv == DB_COPY_FROM )
	{
	    if (!psy_cb->psy_r_numcols)
	    {
		psy_cb->psy_flags &= ~PSY_EXCLUDE_REFERENCES_COLUMNS;
		QUinit((QUEUE *) &psy_cb->psy_r_colq);
	    }
	    else
	    {
		STRUCT_ASSIGN_MACRO(yyvarsp->excluded_colq, psy_cb->psy_r_colq);

		/* reset pointers which were pointing at $Yexcluded_colq */
		psy_cb->psy_r_colq.q_next->q_prev =
		    psy_cb->psy_r_colq.q_prev->q_next = &psy_cb->psy_r_colq;

		psy_cb->psy_flags |= PSY_EXCLUDE_REFERENCES_COLUMNS;
	    }
	}
    } break;

case 982:
if (!((*yyvarspp)->bypass_actions))
/* # line 21562 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if prior to specifying privilege P, user specified
	** P [EXCLUDING] (<column list>), clear the column list as P overrides
	** P [EXCLUDING] (<column list>)
	*/
	if (yyvarsp->priv == (i4) DB_REPLACE && psy_cb->psy_u_numcols > 0)
	{
	    psy_cb->psy_flags &= ~PSY_EXCLUDE_UPDATE_COLUMNS;
	    QUinit((QUEUE *) &psy_cb->psy_u_colq);
	    psy_cb->psy_u_numcols = 0;
	}
	else if (yyvarsp->priv == DB_REFERENCES && psy_cb->psy_r_numcols > 0)
	{
	    psy_cb->psy_flags &= ~PSY_EXCLUDE_REFERENCES_COLUMNS;
	    QUinit((QUEUE *) &psy_cb->psy_r_colq);
	    psy_cb->psy_r_numcols = 0;
	}
    } break;

case 983:
if (!((*yyvarspp)->bypass_actions))
/* # line 21586 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	/* save address of the queue header for the privilege being processed */
	if (yyvarsp->priv == DB_REPLACE)
	{
	    yyvarsp->priv_colq = &psy_cb->psy_u_colq;
	}
	else if (yyvarsp->priv == DB_REFERENCES)
	{
	    yyvarsp->priv_colq = &psy_cb->psy_r_colq;
	}
	else
	{
	    /* this should never happen */
	    return(E_DB_ERROR);
	}
    } break;

case 986:
if (!((*yyvarspp)->bypass_actions))
/* # line 21609 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PSY_COL		    *psy_col;
	i4		    err_code;
	bool		    found = FALSE;
	DB_STATUS	    status;
	DB_ATT_NAME	    colname;
	PSF_QUEUE	    *colq = yyvarsp->priv_colq;
	bool		    cur_list_including;
	i4		    *col_cnt;

	{
	    /* 
	    ** determine whether the existing list contains column to which 
	    ** privilege will apply + remember address of the counter keeping 
	    ** track of the number of column in the list being constructed
	    */

	    i4		excl_mask;

	    if (yyvarsp->priv == (i4) DB_REPLACE)
	    {
		excl_mask = PSY_EXCLUDE_UPDATE_COLUMNS;
		col_cnt = &psy_cb->psy_u_numcols;
	    }
	    else if (yyvarsp->priv == (i4) DB_REFERENCES)
	    {
		excl_mask = PSY_EXCLUDE_REFERENCES_COLUMNS;
		col_cnt = &psy_cb->psy_r_numcols;
	    }

	    cur_list_including = (psy_cb->psy_flags & excl_mask) == 0;
	}

	/*
	** if the privilege bit corresponding to the privilege being processed
	** is not set (i.e. this privilege has not been speciifed before in this
	** statement), or the column queue associated with this privilege is not
	** empty (i.e. it contains a list of columns to which the privilege
	** should or should not apply), process this column name; otherwise
	** simply discard it as a table-wide privilege overrides any
	** specifications of columns to which a privilege should [not] apply
	*/
	if (~psy_cb->psy_opmap & yyvarsp->priv || colq->q_next != colq)
	{
	    STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_ATT_NAME), (char *) &colname);

	    /*
	    ** at this point four different scenarios are possible:
	    ** 
	    **   (1) user is specifying a list of columns to which a privilege
	    **       should not apply and the existing column queue contains
	    **	     names of columns to which that privilege should apply (or
	    **	     is empty);
	    **
	    **       we will compute a set difference of the names specified by
	    **	     the user and names contained in the existing list - the
	    **	     resulting set (if any) will represent names of columns to
	    **	     which privilege should not apply
	    **
	    **   (2) user is specifying a list of columns to which a privilege
	    **       should not apply and the existing column queue contains
	    **	     names of columns to which that privilege should not apply
	    **
	    **       we will compute conjunction (AND) of the names specified by
	    **	     the user and names contained in the existing list - the
	    **	     resulting set (if any) will represent names of columns to
	    **	     which privilege should not apply
	    **
	    **   (3) user is specifying a list of columns to which a privilege
	    **       should apply and the existing column queue contains names
	    **	     of columns to which that privilege should apply (or is
	    **	     empty);
	    **
	    **	     we will compute disjunction (OR) of the names specified by
	    **	     the user and names contained in the existing list - the
	    **	     resulting set will represent names of columns to which
	    **	     privilege should apply
	    **	 
	    **   (4) user is specifying a list of columns to which a privilege
	    **       should apply and the existing column queue contains names
	    **	     of columns to which that privilege should not apply
	    **
	    **	     we will compute a set difference of the names contained in
	    **	     the existing list and the names specified by the user - the
	    **	     resulting set (if any) will represent names of columns to
	    **	     which privilege should not apply
	    */

	    if (yyvarsp->qry_mask & PSS_EXCLUDE_COLUMNS)
	    {
		if (cur_list_including)
		{
		    /* case (1) */

		    /*
		    ** first check whether this column appears in the column 
		    ** list consisting of names of columns to which the 
		    ** privilege in $Ypriv will apply
		    */
		    for (psy_col = (PSY_COL *) colq->q_next;
			 psy_col != (PSY_COL *) colq;
			 psy_col = (PSY_COL *) psy_col->queue.q_next
			)
		    {
			if (!MEcmp((PTR) &colname, (PTR) &psy_col->psy_colnm,
			         sizeof(psy_col->psy_colnm)))
			{
			    found = TRUE;
			    break;
			}
		    }

		    /*
		    ** if the user has previously specified that the privilege
		    ** should apply to a column C and now specifies that the
		    ** privilege should apply to the table except for the column
		    ** C (and possibly other columns), privilege will continue
		    ** to apply to C; otherwise we will add the column to the
		    ** "excluded column" queue unless it has been added before
		    */

		    if (!found)
		    {
			for (psy_col = (PSY_COL *) yyvarsp->excluded_colq.q_next;
			     psy_col != (PSY_COL *) &yyvarsp->excluded_colq;
			     psy_col = (PSY_COL *) psy_col->queue.q_next
			    )
			{
			    if (!MEcmp((PTR) &colname,
				     (PTR) &psy_col->psy_colnm,
				     sizeof(psy_col->psy_colnm)))
			    {
				found = TRUE;

				/*
				** if the same column was specified more than 
				** once and was not consistently specified using
				** either a regular or a delimited identifier, 
				** we want to ensure that it is represented by 
				** a regular identifier in the final text
				*/
				if (   ~psy_col->psy_col_flags & 
					   PSY_REGID_COLSPEC
				    && yyvarsp->id_type == PSS_ID_REG
				   )
				{
				    psy_col->psy_col_flags |=
					PSY_REGID_COLSPEC;
				}

				break;
			    }
			}

			if (!found)
			{
			    /*
			    ** column has not been added before; will add it to
			    ** the "excluded column" queue unless the queue
			    ** already contains DB_MAX_COLS elements
			    */
			    if (*col_cnt == DB_MAX_COLS)
			    {
				(VOID) psf_error(2113L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 1,
				    sizeof(cb->pss_lineno), &cb->pss_lineno);
				return (E_DB_ERROR);
			    }

			    /* Allocate memory for a column entry */
			    status = psf_malloc(cb, &cb->pss_ostream,
				(i4) sizeof(PSY_COL), (PTR *) &psy_col,
				&psq_cb->psq_error);
			    if (status != E_DB_OK)
			    {
				return (status);
			    }

			    /*
			    ** Copy update column name to column entry.
			    */
			    STRUCT_ASSIGN_MACRO(colname, psy_col->psy_colnm);

			    psy_col->psy_col_flags = 0;

			    /*
			    ** remember whether the column name was specified 
			    ** using a regular or a delimited identifier
			    */
			    if (yyvarsp->id_type == PSS_ID_REG)
			    {
				psy_col->psy_col_flags |= PSY_REGID_COLSPEC;
			    }

			    /*
			    ** Attach element to the "excluded column" list.
			    */
			    (VOID) QUinsert((QUEUE *) psy_col,
				(QUEUE *) &yyvarsp->excluded_colq);
				
			    /*
			    ** increment number of elements in the new list of
			    ** columns to which privilege will not apply
			    */
			    ++*col_cnt;
			}
		    }
		}
		else
		{
		    /* case (2) */

		    for (psy_col = (PSY_COL *) colq->q_next;
			 psy_col != (PSY_COL *) colq;
			 psy_col = (PSY_COL *) psy_col->queue.q_next
			)
		    {
			if (!MEcmp((PTR) &colname, (PTR) &psy_col->psy_colnm,
			         sizeof(psy_col->psy_colnm)))
			{
			    /*
			    ** column appears both in the existing column list
			    ** containing names of columns to which privilege
			    ** will not apply and in the new list supplied by
			    ** the user - thus the privilege will continue to
			    ** NOT apply to this column; move it from the
			    ** current column list into the "excluded column"
			    ** list unless the queue already contains 
			    ** DB_MAX_COLS elements
			    */
			    if (*col_cnt == DB_MAX_COLS)
			    {
				(VOID) psf_error(2113L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 1,
				    sizeof(cb->pss_lineno), &cb->pss_lineno);
				return (E_DB_ERROR);
			    }

			    /*
			    ** if the same column was specified more than 
			    ** once and was not consistently specified using
			    ** either a regular or a delimited identifier, 
			    ** we want to ensure that it is represented by 
			    ** a regular identifier in the final text
			    */
			    if (   ~psy_col->psy_col_flags & PSY_REGID_COLSPEC
				&& yyvarsp->id_type == PSS_ID_REG
			       )
			    {
			        psy_col->psy_col_flags |= PSY_REGID_COLSPEC;
			    }

			    (VOID) QUinsert(QUremove((QUEUE *) psy_col),
				(QUEUE *) &yyvarsp->excluded_colq);

			    /*
			    ** increment number of elements in the new list of
			    ** columns to which privilege will not apply
			    */
			    ++*col_cnt;

			    break;
			}
		    }
		}
	    }
	    else if (cur_list_including)
	    {
		/* case (3) */

		/*
		** Check if column specified for the first time.
		*/
		for (psy_col = (PSY_COL *) colq->q_next;
		     psy_col != (PSY_COL *) colq;
		     psy_col = (PSY_COL *) psy_col->queue.q_next
		    )
		{
		    if (!MEcmp((PTR) &colname, (PTR) &psy_col->psy_colnm,
			    sizeof(psy_col->psy_colnm)))
		    {
			found = TRUE;
			/*
			** if the same column was specified more than 
			** once and was not consistently specified using
			** either a regular or a delimited identifier, 
			** we want to ensure that it is represented by 
			** a regular identifier in the final text
			*/
			if (   ~psy_col->psy_col_flags & PSY_REGID_COLSPEC
			    && yyvarsp->id_type == PSS_ID_REG
			   )
			{
			    psy_col->psy_col_flags |= PSY_REGID_COLSPEC;
			}

			break;
		    }
		}

		/*
		** Store only if not found. No need to keep duplicates.
		*/
		if (!found)
		{
		    /* make sure the list is not longer than DB_MAX_COLS */
		    if (*col_cnt == DB_MAX_COLS)
		    {
			(VOID) psf_error(2113L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
			    &cb->pss_lineno);
			return (E_DB_ERROR);
		    }

		    /* Allocate memory for a column entry */
		    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_COL),
			(PTR *) &psy_col, &psq_cb->psq_error);
		    if (status != E_DB_OK)
		    {
			return (status);
		    }

		    /*
		    ** Copy column name to column entry.
		    */
		    STRUCT_ASSIGN_MACRO(colname, psy_col->psy_colnm);

		    psy_col->psy_col_flags = 0;

		    /*
		    ** remember whether the column name was specified 
		    ** using a regular or a delimited identifier
		    */
		    if (yyvarsp->id_type == PSS_ID_REG)
		    {
			psy_col->psy_col_flags |= PSY_REGID_COLSPEC;
		    }

		    /*
		    ** Attach element to the list.
		    */
		    (VOID) QUinsert((QUEUE *) psy_col, (QUEUE *) colq);

		    /* increment number of elements in the list */
		    ++*col_cnt;
		}
	    }
	    else
	    {
		/* case (4) */

		for (psy_col = (PSY_COL *) colq->q_next;
		     psy_col != (PSY_COL *) colq;
		     psy_col = (PSY_COL *) psy_col->queue.q_next
		    )
		{
		    if (!MEcmp((PTR) &colname, (PTR) &psy_col->psy_colnm,
			     sizeof(psy_col->psy_colnm)))
		    {
			/*
			** column appears both in the existing column list
			** containing names of columns to which privilege
			** will not apply and in the new list of columns to
			** which privilege will apply - thus the privilege will
			** apply to this column; remove it from the current
			** column list
			*/
			(VOID) QUremove((QUEUE *) psy_col);

			/*
			** decrement number of elements in the list of columns
			** to which privilege will not apply
			*/
			--*col_cnt;
			break;
		    }
		}
	    }
	}
    } break;

case 987:
if (!((*yyvarspp)->bypass_actions))
/* # line 21993 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_DEFAULT;
    } break;

case 988:
if (!((*yyvarspp)->bypass_actions))
/* # line 21997 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_USER;
    } break;

case 989:
if (!((*yyvarspp)->bypass_actions))
/* # line 22001 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_GROUP;
    } break;

case 990:
if (!((*yyvarspp)->bypass_actions))
/* # line 22005 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_APLID;
    } break;

case 993:
if (!((*yyvarspp)->bypass_actions))
/* # line 22015 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_add_grantee(cb, yacc_cb->yypvt[-0].psl_strtype, yyvarsp->id_type, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 994:
if (!((*yyvarspp)->bypass_actions))
/* # line 22026 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_flags |= PSY_PUBLIC;
    } break;

case 997:
if (!((*yyvarspp)->bypass_actions))
/* # line 22038 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_add_grantee(cb, yacc_cb->yypvt[-0].psl_strtype, yyvarsp->id_type, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 998:
if (!((*yyvarspp)->bypass_actions))
/* # line 22063 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* REVOKE <db_privileges>|role [ON <db_object_spec>] FROM <auth_spec> */
	
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	i4                err_code;


	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = (yacc_cb->yypvt[-0].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-0].psl_tytype;

	/* Translate ALL [PRIVILEGES] */
	if (psy_cb->psy_flags & PSY_ALL_PRIVS)
	{
	    psy_cb->psy_ctl_dbpriv = DBPR_ALLPRIVS | DBPR_ALL;
	}

	if (   (psy_cb->psy_flags & PSY_GR_REV_ROLE)
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(9344, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Set mode in the PSY_CB */
	if (psy_cb->psy_flags & PSY_GR_REV_ROLE)
	{
		psy_cb->psy_grant = PSY_RREVOKE;
		psq_cb->psq_mode = PSQ_RREVOKE;
	}
	else
	{
		psy_cb->psy_grant = PSY_DREVOKE;
		psq_cb->psq_mode = (psy_cb->psy_ctl_dbpriv & DBPR_RESTRICTED)
								? PSQ_RDBPRIV
								: PSQ_ROKPRIV;
	}
    } break;

case 999:
if (!((*yyvarspp)->bypass_actions))
/* # line 22103 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** REVOKE [GRANT OPTION FOR] <tbl priv>(s) ON <tbl spec>
	**     FROM <grantee>(s)
	*/
	
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;

	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = (yacc_cb->yypvt[-1].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-1].psl_tytype;

	if (yacc_cb->yypvt[-0].psl_tytype == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    } break;

case 1000:
if (!((*yyvarspp)->bypass_actions))
/* # line 22119 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** REVOKE [GRANT OPTION FOR] <dbproc priv>(s) ON <dbproc spec>
	**     FROM <grantee>(s)
	*/

	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;

	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = (yacc_cb->yypvt[-1].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-1].psl_tytype;

	if (yacc_cb->yypvt[-0].psl_tytype == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    } break;

case 1001:
if (!((*yyvarspp)->bypass_actions))
/* # line 22135 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** REVOKE [GRANT OPTION FOR] <seq priv>(s) ON <seq spec>
	**     FROM <grantee>(s)
	*/

	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;

	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = (yacc_cb->yypvt[-1].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-1].psl_tytype;

	if (yacc_cb->yypvt[-0].psl_tytype == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    } break;

case 1002:
if (!((*yyvarspp)->bypass_actions))
/* # line 22151 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** REVOKE [GRANT OPTION FOR] <dbevent priv>(s) ON <dbevent spec>
	**     FROM <grantee>(s)
	*/

	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;

	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = (yacc_cb->yypvt[-1].psl_tytype == DBGR_DEFAULT) ? DBGR_USER : yacc_cb->yypvt[-1].psl_tytype;

	if (yacc_cb->yypvt[-0].psl_tytype == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    } break;

case 1003:
if (!((*yyvarspp)->bypass_actions))
/* # line 22168 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_GRANT_OPTION;
    } break;

case 1005:
if (!((*yyvarspp)->bypass_actions))
/* # line 22175 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_REVOKE;

	/* "revoke" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6290L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the revoke statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Default terminal name is "" */
	MEfill(sizeof(psy_cb->psy_terminal), ' ', (PTR) &psy_cb->psy_terminal);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/*
	** Default time is all day, starting at 00:00 and ending at 24:00,
	** given as minutes after 00:00.
	*/
	psy_cb->psy_timbgn = 0;
	psy_cb->psy_timend = 1440;

	/*
	** Default days are all week, starting with Sunday and ending with
	** Saturday.  Sunday = 0, Saturday = 6.
	*/
	psy_cb->psy_daybgn = 0;
	psy_cb->psy_dayend = 6;

	/*
	** next we will be processing the list of privileges, psl_sscan() will
	** accord special treatment to words REGISTER and RAISE (dbevent
	** privileges) only when processing the privilege specification of 
	** GRANT or REVOKE statements
	*/
	cb->pss_stmt_flags |= PSS_PARSING_PRIVS;
	/* Initialize object queue */
	(VOID) QUinit((QUEUE *) &psy_cb->psy_objq); /* No objects */
    } break;

case 1006:
if (!((*yyvarspp)->bypass_actions))
/* # line 22230 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1007:
if (!((*yyvarspp)->bypass_actions))
/* # line 22234 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_USER;
    } break;

case 1008:
if (!((*yyvarspp)->bypass_actions))
/* # line 22238 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_GROUP;
    } break;
	}
	return(0);
}

i4
psls20iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1009:
if (!((*yyvarspp)->bypass_actions))
/* # line 22244 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* This is either a "role" qualified list, or a syntax error. */
	if (STcompare(yacc_cb->yypvt[-1].psl_strtype, "role") == 0)
	{
	    yacc_cb->yyval.psl_tytype = DBGR_APLID;
	}
	else
	{
	    (void) psl_sx_error(2728L, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    } break;

case 1010:
if (!((*yyvarspp)->bypass_actions))
/* # line 22257 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_DEFAULT;
    } break;

case 1011:
if (!((*yyvarspp)->bypass_actions))
/* # line 22263 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = CASCADING_DESTRUCTION;
    } break;

case 1012:
if (!((*yyvarspp)->bypass_actions))
/* # line 22267 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = RESTRICTED_DESTRUCTION;
    } break;

case 1013:
if (!((*yyvarspp)->bypass_actions))
/* # line 22288 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_al1_create_alarm(cb, psy_cb, psq_cb, yacc_cb->yypvt[-1].psl_tytype, yacc_cb->yypvt[-4].psl_inttype);
	if(status!=E_DB_OK)
		return status;
    } break;

case 1014:
if (!((*yyvarspp)->bypass_actions))
/* # line 22298 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CALARM;

	/* "create security_alarm" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE SECURITY_ALARM")-1,
		"CREATE SECURITY_ALARM");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	/* Allocate the PSY_CB for the create security_alarm statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_opctl   = DB_ALARM;  /* Indicate security alarm */
	psy_cb->psy_opmap   = DB_ALARM;  /* Indicate security alarm */

	/* Reset alarm tuple */
	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm), 0, 
	    (PTR) &psy_cb->psy_tuple.psy_alarm);

	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm.dba_alarmname), ' ', 
	    (PTR) &psy_cb->psy_tuple.psy_alarm.dba_alarmname);

	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm.dba_objname), ' ', 
	    (PTR) &psy_cb->psy_tuple.psy_alarm.dba_objname);

	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm.dba_reserve), ' ', 
	    (PTR) &psy_cb->psy_tuple.psy_alarm.dba_reserve);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/* event information */
	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm.dba_eventtext),' ',
		(PTR)&psy_cb->psy_tuple.psy_alarm.dba_eventtext);

	psy_cb->psy_alflag = PSY_CALARM;	/* CREATE SECURITY_ALARM */
    } break;

case 1015:
if (!((*yyvarspp)->bypass_actions))
/* # line 22347 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;

	/* test alarm name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_NAME),
	      (char *)&((PSY_CB *)cb->pss_object)->psy_tuple.psy_alarm.dba_alarmname);
    } break;

case 1017:
if (!((*yyvarspp)->bypass_actions))
/* # line 22366 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		DB_STATUS status;
		PSY_CB	  *psy_cb;
		psy_cb = (PSY_CB *) cb->pss_object;
		/* must be ON CURRENT INSTALLATION */
		if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "installation"))
		{
		    psl_yerror(3, cb, psq_cb);
		    return(E_DB_ERROR);
		}
		status=psl_al3_db_obj_spec(cb, psy_cb, psq_cb, NULL, FALSE);
		if(status!=E_DB_OK)
			return status;
		yacc_cb->yyval.psl_inttype=DBOB_DATABASE;
	    } break;

case 1018:
if (!((*yyvarspp)->bypass_actions))
/* # line 22382 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		DB_STATUS status;
		PSY_CB	  *psy_cb;
		psy_cb = (PSY_CB *) cb->pss_object;
		status=psl_al3_db_obj_spec(cb, psy_cb, psq_cb, yacc_cb->yypvt[-0].psl_strtype, 
						TRUE);
		if(status!=E_DB_OK)
			return status;

		yacc_cb->yyval.psl_inttype = DBOB_DATABASE;
	    } break;

case 1019:
if (!((*yyvarspp)->bypass_actions))
/* # line 22394 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		PSY_CB		       *psy_cb;
		DB_STATUS status;
		psy_cb = (PSY_CB *) cb->pss_object;
		status=psl_al2_tbl_obj_spec(cb, psy_cb, psq_cb, yacc_cb->yypvt[-0].psl_objspec);
		if(status!=E_DB_OK)
			return status;
		/* Default to table */
		yacc_cb->yyval.psl_inttype=DBOB_TABLE;
	
	    } break;

case 1020:
if (!((*yyvarspp)->bypass_actions))
/* # line 22406 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		PSY_CB		       *psy_cb;
		DB_STATUS status;
		psy_cb = (PSY_CB *) cb->pss_object;
		status=psl_al2_tbl_obj_spec(cb, psy_cb, psq_cb, yacc_cb->yypvt[-0].psl_objspec);
		if(status!=E_DB_OK)
			return status;
		yacc_cb->yyval.psl_inttype = DBOB_TABLE;
	    } break;

case 1021:
if (!((*yyvarspp)->bypass_actions))
/* # line 22417 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 1022:
if (!((*yyvarspp)->bypass_actions))
/* # line 22421 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB                 *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_alflag |= (PSY_ALMSUCCESS | PSY_ALMFAILURE);
	psy_cb->psy_opmap  |= (DB_ALMSUCCESS  | DB_ALMFAILURE);
	psy_cb->psy_opctl  |= (DB_ALMSUCCESS  | DB_ALMFAILURE);

	yacc_cb->yyval.psl_tytype = 1;
    } break;

case 1025:
if (!((*yyvarspp)->bypass_actions))
/* # line 22438 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;

	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "SUCCESS") == 0)
	{
	    psy_cb->psy_alflag |= PSY_ALMSUCCESS;
	    psy_cb->psy_opmap  |= DB_ALMSUCCESS;
	    psy_cb->psy_opctl  |= DB_ALMSUCCESS;
	}
	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "FAILURE") == 0)
	{
	    psy_cb->psy_alflag |= PSY_ALMFAILURE;
	    psy_cb->psy_opmap  |= DB_ALMFAILURE;
	    psy_cb->psy_opctl  |= DB_ALMFAILURE;
	}
	else
	{
	    /* Invalid condition specified */
	    (VOID) psf_error(6384, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 1028:
if (!((*yyvarspp)->bypass_actions))
/* # line 22469 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_RETRIEVE;
    } break;

case 1029:
if (!((*yyvarspp)->bypass_actions))
/* # line 22473 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_DELETE;
    } break;

case 1030:
if (!((*yyvarspp)->bypass_actions))
/* # line 22477 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_APPEND;
    } break;

case 1031:
if (!((*yyvarspp)->bypass_actions))
/* # line 22481 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_REPLACE;
    } break;

case 1032:
if (!((*yyvarspp)->bypass_actions))
/* # line 22485 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** CONNECT | DISCONNECT
	*/
	if(!STcasecmp(yacc_cb->yypvt[-0].psl_strtype,"connect"))
		((PSY_CB *) cb->pss_object)->psy_opmap |= DB_CONNECT;
	else if(!STcasecmp(yacc_cb->yypvt[-0].psl_strtype,"disconnect"))
		((PSY_CB *) cb->pss_object)->psy_opmap |= DB_DISCONNECT;
	else
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    } break;

case 1033:
if (!((*yyvarspp)->bypass_actions))
/* # line 22502 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 1034:
if (!((*yyvarspp)->bypass_actions))
/* # line 22511 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Empty */
	yacc_cb->yyval.psl_tytype=0;
     } break;

case 1035:
if (!((*yyvarspp)->bypass_actions))
/* # line 22518 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yacc_cb->yypvt[-0].psl_tytype == DBGR_DEFAULT)
	{
	    PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	    /*
	    **      Check if production used PUBLIC, set accordingly
	    */
	    if( psy_cb->psy_flags& PSY_PUBLIC)
		yacc_cb->yyval.psl_tytype = DBGR_PUBLIC;
	    else
		yacc_cb->yyval.psl_tytype = DBGR_USER;
	}
	else yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1036:
if (!((*yyvarspp)->bypass_actions))
/* # line 22533 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_GROUP;
    } break;

case 1037:
if (!((*yyvarspp)->bypass_actions))
/* # line 22537 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_USER;
    } break;

case 1038:
if (!((*yyvarspp)->bypass_actions))
/* # line 22541 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DBGR_DEFAULT;
    } break;

case 1039:
if (!((*yyvarspp)->bypass_actions))
/* # line 22546 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	    /*
	    ** Save event name/owner
	    */
	    PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	    DB_STATUS	status;
	    i4		ret_flags;
	    PSS_EVINFO	ev_info;
	    i4		stmt_type;
	    i4		priv_to_check;
	    i4		ev_mask;
	    i4		err_code;

	    stmt_type = PST_EVRAISE_TYPE;
	    priv_to_check = (i4) DB_EVRAISE;
	    /*
	    ** If user specified a schema then tell psy_gevent to 
	    ** check that, otherwise lookup in regular namespace
	    */
	    if(yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags&PSS_OBJSPEC_EXPL_SCHEMA)
		ev_mask = ( PSS_EV_BY_OWNER );
	    else
	        ev_mask = ( PSS_USREVENT | PSS_DBAEVENT | PSS_INGEVENT);

	    /*
	    ** Look up the event, making sure we can access it
	    */
	    status = psy_gevent(cb, &yacc_cb->yypvt[-1].psl_objspec->pss_owner, &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name,
	       (DB_TAB_ID*)0, ev_mask, &ev_info, &ret_flags, &priv_to_check,
	       psq_cb->psq_mode, (i4) FALSE, &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
	    	return (status);
	    else if (ret_flags & (PSS_MISSING_EVENT | PSS_INSUF_EV_PRIVS))
	    {
	        /*
	        **    dbevent does not exist
	        ** or the current user lacks a required privilege on it
	        */
	        return(E_DB_ERROR);
	     }

	     /*
	     ** copy event id structure into the alarm structure
	     ** Note this effectively resolves the dbevent early 
	     */
	     STRUCT_ASSIGN_MACRO(ev_info.pss_ev_id, 
			psy_cb->psy_tuple.psy_alarm.dba_eventid);

	     psy_cb->psy_tuple.psy_alarm.dba_flags|=DBA_DBEVENT; 

	} break;

case 1041:
if (!((*yyvarspp)->bypass_actions))
/* # line 22602 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	    PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	    /*
	    ** Save optional event text  (note: this silently
	    ** truncates very long text currently)
	    */
	    STmove(sconvert(yacc_cb->yypvt[-0].psl_textype),' ',sizeof(psy_cb->psy_tuple.psy_alarm.dba_eventtext),
				psy_cb->psy_tuple.psy_alarm.dba_eventtext);

	    psy_cb->psy_tuple.psy_alarm.dba_flags|=DBA_DBEVTEXT; 
	} break;

case 1043:
if (!((*yyvarspp)->bypass_actions))
/* # line 22624 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	    DB_STATUS status;
	    PSY_CB   *psy_cb = (PSY_CB *) cb->pss_object;
	    status=psl_al4_drop_alarm(cb, psy_cb, psq_cb, yacc_cb->yypvt[-1].psl_inttype);
	    if(status!=E_DB_OK)
		return status;
	} break;

case 1044:
if (!((*yyvarspp)->bypass_actions))
/* # line 22634 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_KALARM;

	/* "drop security_alarm" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP SECURITY_ALARM")-1,
		"DROP SECURITY_ALARM");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a PSY_CB for drop security_alarm */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_alflag = PSY_KALARM;	/* DROP SECURITY_ALARM */
	(VOID) QUinit((QUEUE *) &psy_cb->psy_objq); /* No objects */
	psy_cb->psy_numnms=0;
	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm), 0, 
	    (PTR) &psy_cb->psy_tuple.psy_alarm);
    } break;

case 1049:
if (!((*yyvarspp)->bypass_actions))
/* # line 22674 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	    PSY_OBJ *psy_obj;
	    PSY_CB  *psy_cb;
	    DB_STATUS status;
	    /*
	    ** Build list of identifiers in psy_objq
	    */
	    psy_cb = (PSY_CB *) cb->pss_object;

	    /* Allocate memory for an object entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_OBJ), 
		(PTR *) &psy_obj, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    (VOID) QUinsert((QUEUE *)psy_obj, (QUEUE *) &psy_cb->psy_objq);

	    STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_NAME), (char *) &psy_obj->psy_objnm);
	} break;
	}
	return(0);
}

i4
psls21iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1051:
if (!((*yyvarspp)->bypass_actions))
/* # line 22700 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ DB_STATUS status;

	  status=psl_as3_alter_secaud(psq_cb, cb);
	  if(DB_FAILURE_MACRO(status))
		return status;
	} break;

case 1052:
if (!((*yyvarspp)->bypass_actions))
/* # line 22708 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_ALTAUDIT;

	/* "alter security_audit" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER SECURITY_AUDIT")-1,
		"ALTER SECURITY_AUDIT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter security_audit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER SECURITY_AUDIT */
	psy_cb->psy_auflag  = PSY_ALTAUDIT;
    } break;

case 1053:
if (!((*yyvarspp)->bypass_actions))
/* # line 22737 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_auflag |= PSY_AURESTART;
    } break;

case 1054:
if (!((*yyvarspp)->bypass_actions))
/* # line 22744 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_as1_nonkeyword(psy_cb, psq_cb, yacc_cb->yypvt[-0].psl_strtype);

	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1060:
if (!((*yyvarspp)->bypass_actions))
/* # line 22763 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_as2_with_nonkw_eq_sconst(psy_cb, psq_cb, cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_strtype);

	if(DB_FAILURE_MACRO(status))
		return status;
	} break;

case 1062:
if (!((*yyvarspp)->bypass_actions))
/* # line 22778 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_ENAUDIT;

	/* "enable security_audit" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ENABLE SECURITY_AUDIT")-1,
		"ENABLE SECURITY_AUDIT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the enable security_audit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ENABLE SECURITY_AUDIT */
	psy_cb->psy_auflag  = PSY_ENAUDIT;
	psy_cb->psy_autype  = 0;
    } break;

case 1064:
if (!((*yyvarspp)->bypass_actions))
/* # line 22812 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_DISAUDIT;

	/* "disable security_audit" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DISABLE SECURITY_AUDIT")-1,
		"DISABLE SECURITY_AUDIT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the disable security_audit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to DISABLE SECURITY_AUDIT */
	psy_cb->psy_auflag  = PSY_DISAUDIT;
	psy_cb->psy_autype  = 0;
    } break;

case 1066:
if (!((*yyvarspp)->bypass_actions))
/* # line 22844 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   local_status;
	DB_ERROR    e_error;
	PSY_CB	    *psy_cb;
	i4	    error;
	i4     msg_id;

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_autype = (i4)yacc_cb->yypvt[-0].psl_tytype;

        /* Make sure user is authorized */

        if (cb->pss_ustat & DU_UALTER_AUDIT)
	    return(E_DB_OK);

	/* User not authorized */

	/*
	** Audit the failure to ENABLE/DISABLE SECURITY AUDITing
	*/
	if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	{
	    /*
	    ** Pick out the text of message, depending on if the SECURITY_AUDIT
	    ** profile was ENABLEd/DISABLEd, and the profile element that was
	    ** modified.
	    */
	    if (psq_cb->psq_mode == PSQ_ENAUDIT)
		switch(yacc_cb->yypvt[-0].psl_tytype)
		{
		    case(DU_SALL):
			msg_id = I_SX2502_ENAB_AUDIT_ALL;
			break;
		    case(DU_SVIEW):
			msg_id = I_SX2506_ENAB_AUDIT_VIEW;
			break;
		    case(DU_SDATABASE):
			msg_id = I_SX2508_ENAB_AUDIT_DATABASE;
			break;
		    case(DU_SUSER):
			msg_id = I_SX250A_ENAB_AUDIT_USER;
			break;
		    case(DU_SPROCEDURE):
			msg_id = I_SX250C_ENAB_AUDIT_PROCEDURE;
			break;
		    case(DU_SSECURITY):
			msg_id = I_SX250E_ENAB_AUDIT_SECURITY;
			break;
		    case(DU_SALARM):
			msg_id = I_SX2510_ENAB_AUDIT_ALARM;
			break;
		    case(DU_SALERT):
			msg_id = I_SX2512_ENAB_AUDIT_DBEVENT;
			break;
		    case(DU_SRULE):
			msg_id = I_SX2514_ENAB_AUDIT_RULE;
			break;
		    case(DU_SLOCATION):
			msg_id = I_SX2516_ENAB_AUDIT_LOCATION;
			break;
		    case(DU_SRESOURCE):
			msg_id = I_SX2519_ENAB_AUDIT_RESOURCE;
			break;
		    case(DU_SQRYTEXT):
			msg_id = I_SX251B_ENAB_AUDIT_QRYTEXT;
			break;
		    default:
			msg_id = I_SX2501_CHANGE_AUDIT_PROFILE;
			break;
		}
	    else
	    {
		switch(yacc_cb->yypvt[-0].psl_tytype)
		{
		    case(DU_SALL):
			msg_id = I_SX2503_DISB_AUDIT_ALL;
			break;
		    case(DU_STABLE):
			msg_id = I_SX2505_DISB_AUDIT_TABLE;
			break;
		    case(DU_SVIEW):
			msg_id = I_SX2507_DISB_AUDIT_VIEW;
			break;
		    case(DU_SDATABASE):
			msg_id = I_SX2509_DISB_AUDIT_DATABASE;
			break;
		    case(DU_SUSER):
			msg_id = I_SX250B_DISB_AUDIT_USER;
			break;
		    case(DU_SPROCEDURE):
			msg_id = I_SX250D_DISB_AUDIT_PROCEDURE;
			break;
		    case(DU_SSECURITY):
			msg_id = I_SX250F_DISB_AUDIT_SECURITY;
			break;
		    case(DU_SALARM):
			msg_id = I_SX2511_DISB_AUDIT_ALARM;
			break;
		    case(DU_SALERT):
			msg_id = I_SX2513_DISB_AUDIT_DBEVENT;
			break;
		    case(DU_SRULE):
			msg_id = I_SX2515_DISB_AUDIT_RULE;
			break;
		    case(DU_SLOCATION):
			msg_id = I_SX2517_DISB_AUDIT_LOCATION;
			break;
		    case(DU_SRESOURCE):
			msg_id = I_SX251A_DISB_AUDIT_RESOURCE;
			break;
		    case(DU_SQRYTEXT):
			msg_id = I_SX251C_DISB_AUDIT_QRYTEXT;
			break;
		    default:
			msg_id = I_SX2501_CHANGE_AUDIT_PROFILE;
			break;
		}
	    }
	    local_status = psy_secaudit(FALSE, cb,
			    ERx("SECURITY_AUDIT"), (DB_OWN_NAME *)NULL,
			    sizeof(ERx("SECURITY_AUDIT")), SXF_E_SECURITY,
			    msg_id, SXF_A_FAIL | SXF_A_ALTER,
			    &e_error);
	}

        error = E_US18D3_6355_NOT_AUTH;

        (VOID) psf_error(E_US18D3_6355_NOT_AUTH, 0L,
                         PSF_USERERR, &error, &psq_cb->psq_error, 1,
                         sizeof("ENABLE/DISABLE SECURITY_AUDIT")-1,
                         "ENABLE/DISABLE SECURITY_AUDIT");

	return(E_DB_ERROR);
    } break;

case 1067:
if (!((*yyvarspp)->bypass_actions))
/* # line 22982 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DU_SALL;
    } break;

case 1068:
if (!((*yyvarspp)->bypass_actions))
/* # line 22986 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DU_STABLE;
    } break;

case 1069:
if (!((*yyvarspp)->bypass_actions))
/* # line 22990 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DU_SUSER;
    } break;

case 1070:
if (!((*yyvarspp)->bypass_actions))
/* # line 22994 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DU_SVIEW;
    } break;

case 1071:
if (!((*yyvarspp)->bypass_actions))
/* # line 22998 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        yacc_cb->yyval.psl_tytype = DU_SPROCEDURE;
    } break;

case 1072:
if (!((*yyvarspp)->bypass_actions))
/* # line 23002 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{	
	yacc_cb->yyval.psl_tytype = DU_SRECORD;
    } break;

case 1073:
if (!((*yyvarspp)->bypass_actions))
/* # line 23006 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "DATABASE") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SDATABASE;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "ROLE") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SAPPLICATION;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "LOCATION") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SLOCATION;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "SECURITY") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SSECURITY;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "ALARM") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SALARM;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "RULE") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SRULE;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "DBEVENT") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SALERT;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "RESOURCE") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SRESOURCE;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "QUERY_TEXT") == 0)
	    yacc_cb->yyval.psl_tytype = DU_SQRYTEXT;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "LEVEL") == 0)
	{
	    /* Level omitted */
	    (VOID) psf_error(6371, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else
	{
	    	if(psq_cb->psq_mode == PSQ_ENAUDIT)
			{
			(VOID) psf_error(3833, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 2, 
				(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
				(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
			}
			else 
			{
			(VOID) psf_error(3834, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 2, 
				(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
				(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
			}
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1074:
if (!((*yyvarspp)->bypass_actions))
/* # line 23068 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "LEVEL") == 0)
	{
	    psy_cb->psy_autype  = DU_SLVL;
	    return (E_DB_OK);
	}

	/* Invalid audit type */
	if(psq_cb->psq_mode == PSQ_ENAUDIT)
	{
	(VOID) psf_error(3833, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 2, 
	    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
	    (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	}
	else 
	{
	(VOID) psf_error(3834, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 2, 
	    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
	    (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	}
	return (E_DB_ERROR);    /* non-zero return means error */
    } break;

case 1075:
if (!((*yyvarspp)->bypass_actions))
/* # line 23098 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	char	    *str = yacc_cb->yypvt[-0].psl_strtype;
	i4	    error;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;

        /* Make sure user is authorized */

        if (!(cb->pss_ustat & DU_UALTER_AUDIT))
	{
	    /* User not authorized  - create security audit record */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		status = psy_secaudit(FALSE, cb,
			    ERx("SECURITY_AUDIT"), (DB_OWN_NAME *)NULL,
			    sizeof(ERx("SECURITY_AUDIT")), SXF_E_SECURITY,
			    I_SX2501_CHANGE_AUDIT_PROFILE, 
			    SXF_A_FAIL | SXF_A_ALTER,
			    &psq_cb->psq_error);
	    }

	    error = E_US18D3_6355_NOT_AUTH;
	    (VOID) psf_error(E_US18D3_6355_NOT_AUTH, 0L,
                         PSF_USERERR, &error, &psq_cb->psq_error, 1,
                         sizeof("ENABLE/DISABLE SECURITY_AUDIT")-1,
                         "ENABLE/DISABLE SECURITY_AUDIT");

	    return(E_DB_ERROR);
	}
    } break;

case 1076:
if (!((*yyvarspp)->bypass_actions))
/* # line 23138 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	PSY_USR	    *psy_usr;
	/* test profilename for reserved name
	 */
	psy_cb  = (PSY_CB *) cb->pss_object;
	psy_usr = (PSY_USR *) psy_cb->psy_usrq.q_next;
	
	/* test user name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(psy_usr->psy_usrnm.db_own_name, 
				  cb, psq_cb, TRUE))
	    return(E_DB_ERROR);
    } break;

case 1077:
if (!((*yyvarspp)->bypass_actions))
/* # line 23155 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CPROFILE;

	/* "create profile" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE PROFILE")-1, "CREATE PROFILE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create profile statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to CREATE PROFILE */
	psy_cb->psy_usflag  = PSY_CPROFILE;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
    } break;

case 1079:
if (!((*yyvarspp)->bypass_actions))
/* # line 23191 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_APROFILE;

	/* "alter profile" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER PROFILE")-1, "ALTER PROFILE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER PROFILE */
	psy_cb->psy_usflag  = PSY_APROFILE;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
	MEfill(sizeof(psy_cb->psy_bpass), ' ', (PTR) &psy_cb->psy_bpass);
    } break;

case 1081:
if (!((*yyvarspp)->bypass_actions))
/* # line 23226 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ 
	/*
	** ALTER DEFAULT PROFILE is transformed into an ALTER operation
	** on the default profile, named "all-spaces"
	*/
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	PSY_USR	    		*psy_usr;

	psq_cb->psq_mode = PSQ_APROFILE;

	if(STcasecmp(yacc_cb->yypvt[-0].psl_strtype,"profile")!=0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		sizeof("ALTER PROFILE")-1,
		"ALTER PROFILE",
		(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* "alter profile" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER PROFILE")-1, "ALTER PROFILE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER PROFILE */
	psy_cb->psy_usflag  = PSY_APROFILE;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
	MEfill(sizeof(psy_cb->psy_bpass), ' ', (PTR) &psy_cb->psy_bpass);



	/* Allocate memory for a user entry */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_USR), 
		(PTR *) &psy_usr, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
		return (status);
	}

	 /*
	 ** Copy user name to user entry.
	 */
	STmove("", ' ', sizeof(DB_OWN_NAME), (char *) &psy_usr->psy_usrnm);

	/*
	** Attach element to the list.
	*/
	(VOID) QUinsert((QUEUE *) psy_usr, (QUEUE *)&psy_cb->psy_usrq);

	psy_cb->psy_usflag |= PSY_USRNAME;
    } break;

case 1083:
if (!((*yyvarspp)->bypass_actions))
/* # line 23300 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_DPROFILE;

	/* "drop profile" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP PROFILE")-1, "DROP PROFILE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the drop profile statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to DROP PROFILE */
	psy_cb->psy_usflag  = PSY_DPROFILE;
    } break;

case 1086:
if (!((*yyvarspp)->bypass_actions))
/* # line 23331 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{PSY_CB *psy_cb;

		psy_cb = (PSY_CB *) cb->pss_object;

		psy_cb->psy_usflag  |= PSY_USRCASCADE;
		} break;

case 1087:
if (!((*yyvarspp)->bypass_actions))
/* # line 23344 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	PSY_USR	    *psy_usr;
	/* test username for reserved name
	 */
	psy_cb  = (PSY_CB *) cb->pss_object;
	psy_usr = (PSY_USR *) psy_cb->psy_usrq.q_next;
	
	/* test user name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(psy_usr->psy_usrnm.db_own_name, 
				  cb, psq_cb, TRUE))
	    return(E_DB_ERROR);
    } break;

case 1088:
if (!((*yyvarspp)->bypass_actions))
/* # line 23362 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CUSER;

	/* "create user" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE USER")-1, "CREATE USER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to CREATE USER */
	psy_cb->psy_usflag  = PSY_CUSER;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usprofile), ' ', (PTR) &psy_cb->psy_usprofile);
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
    } break;

case 1090:
if (!((*yyvarspp)->bypass_actions))
/* # line 23400 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_AUSER;

	/* "alter user" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER USER")-1, "ALTER USER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER USER */
	psy_cb->psy_usflag  = PSY_AUSER;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
	MEfill(sizeof(psy_cb->psy_bpass), ' ', (PTR) &psy_cb->psy_bpass);
	MEfill(sizeof(psy_cb->psy_usprofile), ' ', (PTR) &psy_cb->psy_usprofile);
    } break;

case 1091:
if (!((*yyvarspp)->bypass_actions))
/* # line 23436 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		PSY_CB	    *psy_cb;
		DB_STATUS   status;

		psy_cb = (PSY_CB *) cb->pss_object;
/*
		TRdisplay ( "usr_adp_spec: ADD P L list R - calling psl_us5_usr_priv_def\n" ) ;
*/
		status=psl_us5_usr_priv_def(psy_cb,psq_cb, cb, PSY_USRAPRIVS, yacc_cb->yypvt[-1].psl_inttype);
		if(DB_FAILURE_MACRO(status))
			return status;
	      } break;

case 1092:
if (!((*yyvarspp)->bypass_actions))
/* # line 23449 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		PSY_CB	    *psy_cb;
		DB_STATUS   status;

		psy_cb = (PSY_CB *) cb->pss_object;
/*
		TRdisplay ( "usr_adp_spec : DROP P L list R - calling psl_us5_usr_priv_def\n" ) ;
*/
		status=psl_us5_usr_priv_def(psy_cb,psq_cb, cb, PSY_USRDPRIVS, yacc_cb->yypvt[-1].psl_inttype);
		if(DB_FAILURE_MACRO(status))
			return status;
	      } break;

case 1098:
if (!((*yyvarspp)->bypass_actions))
/* # line 23473 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_with : GROUP EQUAL auth_ident - calling psl_us2_with\n" ) ;
*/
	status=psl_us2_with_nonkw_eq_nmsconst(psy_cb,psq_cb, cb, "group", yacc_cb->yypvt[-0].psl_strtype);
	if(DB_FAILURE_MACRO(status))
			return status;
    } break;

case 1099:
if (!((*yyvarspp)->bypass_actions))
/* # line 23486 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_with : ADD P L list R - calling psl_us5_usr_priv_def\n" ) ;
*/
	status=psl_us5_usr_priv_def(psy_cb,psq_cb, cb, PSY_USRPRIVS, yacc_cb->yypvt[-1].psl_inttype);
	if(DB_FAILURE_MACRO(status))
		return status;
      } break;
	}
	return(0);
}

i4
psls22iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1100:
if (!((*yyvarspp)->bypass_actions))
/* # line 23499 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_us4_usr_priv_or_nonkw(psy_cb,psq_cb, cb, yacc_cb->yypvt[-4].psl_strtype, yacc_cb->yypvt[-1].psl_inttype);
	if(DB_FAILURE_MACRO(status))
		return status;
      } break;

case 1101:
if (!((*yyvarspp)->bypass_actions))
/* # line 23509 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_with : nonkeyword EQUAL sconst_ident - calling psl_us2_with\n" ) ;
*/
	status=psl_us2_with_nonkw_eq_nmsconst(psy_cb,psq_cb, cb, yacc_cb->yypvt[-2].psl_strtype, yacc_cb->yypvt[-0].psl_strtype);
	if(DB_FAILURE_MACRO(status))
			return status;
    } break;

case 1102:
if (!((*yyvarspp)->bypass_actions))
/* # line 23522 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_us2_with_nonkw_eq_hexconst(psy_cb, psq_cb, cb, yacc_cb->yypvt[-2].psl_strtype,
	    yacc_cb->yypvt[-0].psl_textype->db_t_count, (char *)yacc_cb->yypvt[-0].psl_textype->db_t_text);
	if(DB_FAILURE_MACRO(status))
			return status;
    } break;

case 1103:
if (!((*yyvarspp)->bypass_actions))
/* # line 23533 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_with : nonkeyword EQUAL ALL - calling psl_us2_with\n" ) ;
*/
	status=psl_us2_with_nonkw_eq_nmsconst(psy_cb,psq_cb, cb, yacc_cb->yypvt[-2].psl_strtype, "ALL");
	if(DB_FAILURE_MACRO(status))
			return status;
    } break;

case 1104:
if (!((*yyvarspp)->bypass_actions))
/* # line 23546 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_us1_with_nonkeyword(psy_cb, psq_cb, cb, yacc_cb->yypvt[-0].psl_strtype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1105:
if (!((*yyvarspp)->bypass_actions))
/* # line 23558 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ yacc_cb->yyval.psl_inttype= (yacc_cb->yypvt[-2].psl_inttype|yacc_cb->yypvt[-0].psl_inttype);} break;

case 1106:
if (!((*yyvarspp)->bypass_actions))
/* # line 23560 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ yacc_cb->yyval.psl_inttype= yacc_cb->yypvt[-0].psl_inttype;} break;

case 1107:
if (!((*yyvarspp)->bypass_actions))
/* # line 23564 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_priv : nonkeyword - calling psl_us3_usrpriv\n" ) ;
*/
	status=psl_us3_usrpriv(psy_cb, psq_cb, yacc_cb->yypvt[-0].psl_strtype, &yacc_cb->yyval.psl_inttype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1108:
if (!((*yyvarspp)->bypass_actions))
/* # line 23577 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_priv : nonkeyword ALL - calling psl_us3_usrpriv\n" ) ;
*/
	status=psl_us3_usrpriv(psy_cb, psq_cb, "all", &yacc_cb->yyval.psl_inttype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1110:
if (!((*yyvarspp)->bypass_actions))
/* # line 23595 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_KUSER;

	/* "drop user" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP USER")-1, "DROP USER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the drop user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to DROP USER */
	psy_cb->psy_usflag  = PSY_KUSER;
    } break;

case 1111:
if (!((*yyvarspp)->bypass_actions))
/* # line 23624 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure AREA was specified */
	if (!(psy_cb->psy_loflag & PSY_LOCAREA))
	{
	    (VOID) psf_error(6360L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Usage is ALL if usage clause was not specified */
	if (!(psy_cb->psy_loflag & PSY_LOCUSAGE))
	{
	    psy_cb->psy_lousage = DU_ALL_LOCS;
	    psy_cb->psy_loflag |= PSY_LOCUSAGE;
	}

	/* RAW percent can only be specified with usage=database */
	if ( psy_cb->psy_loc_rawpct && psy_cb->psy_lousage != DU_DBS_LOC )
	{
	    (VOID) psf_error(E_US18DE_6366_INVALID_RAW_USAGE, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1112:
if (!((*yyvarspp)->bypass_actions))
/* # line 23656 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CLOC;

	/* "create location" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE LOCATION")-1, "CREATE LOCATION");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create location statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
	    
	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to CREATE LOCATION */
	psy_cb->psy_loflag  = PSY_CLOC;
	psy_cb->psy_lousage = 0;
	psy_cb->psy_loc_rawpct = 0;
    } break;

case 1113:
if (!((*yyvarspp)->bypass_actions))
/* # line 23687 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure AREA was *not* specified */
	if (psy_cb->psy_loflag & PSY_LOCAREA)
	{
	    (VOID) psf_error(6361L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1114:
if (!((*yyvarspp)->bypass_actions))
/* # line 23704 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_ALOC;

	/* "alter location" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER LOCATION")-1, "ALTER LOCATION");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter location statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER LOCATION */
	psy_cb->psy_loflag  = PSY_ALOC;
	psy_cb->psy_lousage = 0;
    } break;

case 1122:
if (!((*yyvarspp)->bypass_actions))
/* # line 23747 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	i4                err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure word is AREA */

	if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "AREA") != 0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) STtrmwhite(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Ensure AREA was not previously specified */
	if (psy_cb->psy_loflag & PSY_LOCAREA)
	{
	    (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) sizeof("AREA")-1, "AREA");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Indicate AREA was specified */
	psy_cb->psy_loflag |= PSY_LOCAREA;
    } break;

case 1123:
if (!((*yyvarspp)->bypass_actions))
/* # line 23780 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure first word is USAGE */
	if (STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "USAGE") != 0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) STtrmwhite(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Ensure USAGE was not previously specified */
	if (psy_cb->psy_loflag & PSY_LOCUSAGE)
	{
	    (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) sizeof("[NO]USAGE")-1, "[NO]USAGE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Indicate USAGE was specified */
	psy_cb->psy_loflag |= PSY_LOCUSAGE;
    } break;

case 1124:
if (!((*yyvarspp)->bypass_actions))
/* # line 23812 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure first word is NOUSAGE */
	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "NOUSAGE") != 0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Ensure USAGE was not previously specified */
	if (psy_cb->psy_loflag & PSY_LOCUSAGE)
	{
	    (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) sizeof("[NO]USAGE")-1, "[NO]USAGE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Indicate USAGE was specified */
	psy_cb->psy_loflag |= PSY_LOCUSAGE;
    } break;

case 1125:
if (!((*yyvarspp)->bypass_actions))
/* # line 23844 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_AREANAME),
	       (char *) &psy_cb->psy_area);
    } break;

case 1128:
if (!((*yyvarspp)->bypass_actions))
/* # line 23859 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_loflag & PSY_LOCUSED)	/* ALL/NONE prev specified */
	{
	    /* Inconsistent use of ALL or NONE -- other usages specified  */
	    (VOID) psf_error(6363L, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if ((yacc_cb->yypvt[-0].psl_tytype == 0) ||	    		/* NONE specified */
	    (yacc_cb->yypvt[-0].psl_tytype == DU_ALL_LOCS))		/* ALL  specified */
	{
	    if (psy_cb->psy_lousage)		/* Other prev specified */
	    {
		/* Inconsistent use of ALL or NONE -- other usages specified  */
		(VOID) psf_error(6363L, 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);    /* non-zero return means error */
	    }
	    psy_cb->psy_loflag |= PSY_LOCUSED;	/* No more usages allowed */
	}

	psy_cb->psy_lousage |= yacc_cb->yypvt[-0].psl_tytype;		/* Indicate usage */
    } break;

case 1129:
if (!((*yyvarspp)->bypass_actions))
/* # line 23891 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DU_ALL_LOCS;
    } break;

case 1130:
if (!((*yyvarspp)->bypass_actions))
/* # line 23895 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DU_WORK_LOC;
    } break;

case 1131:
if (!((*yyvarspp)->bypass_actions))
/* # line 23899 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "DATABASE") == 0)
	    yacc_cb->yyval.psl_tytype = DU_DBS_LOC;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "JOURNAL") == 0)
	    yacc_cb->yyval.psl_tytype = DU_JNLS_LOC;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "CHECKPOINT") == 0)
	    yacc_cb->yyval.psl_tytype = DU_CKPS_LOC;

	else if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "DUMP") == 0)
	    yacc_cb->yyval.psl_tytype = DU_DMPS_LOC;

	else
	{
	    /* Unknown usage specified */
	    (VOID) psf_error(6362L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1132:
if (!((*yyvarspp)->bypass_actions))
/* # line 23929 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure RAWPCT was not previously specified */
	if (psy_cb->psy_loc_rawpct)
	{
	    (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE LOCATION")-1, "CREATE LOCATION",
		(i4) sizeof("RAWPCT")-1, "RAWPCT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1133:
if (!((*yyvarspp)->bypass_actions))
/* # line 23948 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_loc_rawpct = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1134:
if (!((*yyvarspp)->bypass_actions))
/* # line 23957 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Must be between 0 and 100 */
	if ( yacc_cb->yypvt[-0].psl_inttype < 0 || yacc_cb->yypvt[-0].psl_inttype > 100 )
	{
	    /* Bad value for rawpct specified */
	    (VOID) psf_error(6365L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1136:
if (!((*yyvarspp)->bypass_actions))
/* # line 23980 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_KLOC;

	/* "drop location" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP LOCATION")-1, "DROP LOCATION");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the drop location statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to DROP LOCATION */
	psy_cb->psy_loflag  = PSY_KLOC;
	psy_cb->psy_lousage = 0;
    } break;

case 1138:
if (!((*yyvarspp)->bypass_actions))
/* # line 24013 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CGROUP;

	/* "create group" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6274L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
	    
	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_grpflag = PSY_CGROUP;

	/* we are about to process the new object name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    } break;

case 1141:
if (!((*yyvarspp)->bypass_actions))
/* # line 24047 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	i4	    err_code;

	/* we are done processing the new object name */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure "USERS" was specified */

	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "USERS"))
	{
	    (VOID) psf_error(6270L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1143:
if (!((*yyvarspp)->bypass_actions))
/* # line 24071 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	/*
	** Set statement mode to ALTER GROUP ... ADD;
	** just in case of parser error before EOS.
	** Reset to correct statement mode later,
	** when we determine what kind of ALTER we have.
	*/
	psq_cb->psq_mode = PSQ_AGROUP;

	/* "alter group" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6275L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 1144:
if (!((*yyvarspp)->bypass_actions))
/* # line 24099 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psq_cb->psq_mode = PSQ_AGROUP;
	psy_cb->psy_grpflag = PSY_AGROUP;
    } break;
	}
	return(0);
}

i4
psls23iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1145:
if (!((*yyvarspp)->bypass_actions))
/* # line 24107 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psq_cb->psq_mode = PSQ_DGROUP;
	psy_cb->psy_grpflag = PSY_DGROUP;
    } break;

case 1146:
if (!((*yyvarspp)->bypass_actions))
/* # line 24115 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psq_cb->psq_mode = PSQ_DGROUP;
	psy_cb->psy_grpflag = PSY_DGROUP;
    } break;

case 1147:
if (!((*yyvarspp)->bypass_actions))
/* # line 24125 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure "USERS" was specified */

	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "users"))
	{
	    (VOID) psf_error(6271L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1149:
if (!((*yyvarspp)->bypass_actions))
/* # line 24146 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_KGROUP;

	/* "drop group" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6276L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_grpflag = PSY_KGROUP;
    } break;

case 1151:
if (!((*yyvarspp)->bypass_actions))
/* # line 24176 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CAPLID;

	/* "create role" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6277L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create appication_id statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_aplflag = PSY_CAPLID;

	/* we are about to process new object names */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;

	(VOID)MEfill(sizeof(DB_OWN_NAME), (u_char)' ', (PTR)&psy_cb->psy_apass);
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;

    } break;

case 1153:
if (!((*yyvarspp)->bypass_actions))
/* # line 24216 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_AAPLID;

	/* "alter role" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6278L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create appication_id statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_aplflag = PSY_AAPLID;
	(VOID)MEfill(sizeof(DB_OWN_NAME), (u_char)' ', (PTR)&psy_cb->psy_apass);
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
    } break;

case 1155:
if (!((*yyvarspp)->bypass_actions))
/* # line 24250 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_KAPLID;

	/* "drop role" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6279L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_aplflag = PSY_KAPLID;
    } break;

case 1158:
if (!((*yyvarspp)->bypass_actions))
/* # line 24281 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	PSY_USR	    *psy_usr;
	bool	    found = FALSE;
	DB_STATUS   status;
	DB_OWN_NAME username;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Normalize the user name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_OWN_NAME), (char *) &username);

	/*
	** Check if user specified for the first time.
	*/
	for (psy_usr = (PSY_USR *) psy_cb->psy_usrq.q_next;
	     psy_usr != (PSY_USR *) &psy_cb->psy_usrq;
	     psy_usr = (PSY_USR *) psy_usr->queue.q_next
	    )
	{
	    if (MEcmp((PTR) &username, (PTR) &psy_usr->psy_usrnm,
		sizeof(psy_usr->psy_usrnm)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	/*
	** Store only if not found. No need to keep duplicates.
	*/
	if (found == FALSE)
	{
	    /* Allocate memory for a user entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_USR), 
		(PTR *) &psy_usr, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** Copy user name to user entry.
	    */
	    STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_OWN_NAME), (char *) &psy_usr->psy_usrnm);

	    /*
	    ** Attach element to the list.
	    */
	    (VOID) QUinsert((QUEUE *) psy_usr, (QUEUE *) &psy_cb->psy_usrq);

	    psy_cb->psy_usflag |= PSY_USRNAME;
	}
    } break;

case 1161:
if (!((*yyvarspp)->bypass_actions))
/* # line 24343 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	PSY_TBL	    *psy_tbl;
	bool	    found = FALSE;
	DB_STATUS   status;
	DB_OWN_NAME objname;

	/* test username for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb, FALSE))
	    return(E_DB_ERROR);
	    
	psy_cb = (PSY_CB *) cb->pss_object;

	/* Normalize the object name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_OWN_NAME), (char *) &objname);

	/*
	** Check if object specified for the first time.
	*/
	for (psy_tbl  = (PSY_TBL *) psy_cb->psy_tblq.q_next;
	     psy_tbl != (PSY_TBL *)&psy_cb->psy_tblq;
	     psy_tbl  = (PSY_TBL *) psy_tbl->queue.q_next
	    )
	{
	    if (MEcmp((PTR) &objname, (PTR) &psy_tbl->psy_tabnm,
		sizeof(psy_tbl->psy_tabnm)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	/*
	** Store only if not found. No need to keep duplicates.
	*/
	if (found == FALSE)
	{
	    /* Allocate memory for a user entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_TBL), 
		(PTR *) &psy_tbl, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** Copy object name to table entry.
	    */
	    STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_OWN_NAME), (char *) &psy_tbl->psy_tabnm);

	    /*
	    ** Attach element to the list.
	    */
	    (VOID) QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	}
    } break;

case 1162:
if (!((*yyvarspp)->bypass_actions))
/* # line 24409 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	DB_IISEQUENCE	       *seqp;

	/* test event name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (void)psf_error(E_PS0421_CRTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("CREATE SEQUENCE") - 1, "CREATE SEQUENCE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-1].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

        status = psy_ckdbpr(psq_cb, (u_i4)DBPR_SEQ_CREATE);
        if (status)
        {
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;
		DB_STATUS	local_status;
		DB_NAME		seqname;
		/*
		** Audit failure to create sequence
		*/
		STmove(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, ' ', 
		    sizeof(DB_NAME), seqname.db_name);
		local_status = psy_secaudit(FALSE, cb,
		    (char *)&seqname, &cb->pss_user,
		    sizeof(DB_TAB_NAME), SXF_E_PROCEDURE,
		    I_SX2045_SEQUENCE_CREATE, SXF_A_FAIL | SXF_A_CREATE,
		    &e_error);
	    }

            (void)psf_error(6321L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
            return(status);
        }

	psy_cb = (PSY_CB *) cb->pss_object;

	seqp = &psy_cb->psy_tuple.psy_sequence;

	STmove(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&seqp->dbs_name);

	status = psl_csequence(cb, &psq_cb->psq_error);	/* set default parms 
						** and verify them all */
	if (status != E_DB_OK)
	    return(status);
    } break;

case 1163:
if (!((*yyvarspp)->bypass_actions))
/* # line 24473 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CSEQUENCE;

	/* "create sequence" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void)psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE SEQUENCE")-1, "CREATE SEQUENCE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create sequence statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block and tuple fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   		
	MEfill(sizeof(psy_cb->psy_tuple.psy_sequence), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_sequence);
	psy_cb->psy_seqflag |= PSY_CSEQ;
	psy_cb->psy_tuple.psy_sequence.dbs_cache = 20;
					/* default cache value */
    } break;

case 1168:
if (!((*yyvarspp)->bypass_actions))
/* # line 24515 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;

	if (psq_cb->psq_mode != PSQ_CSEQUENCE)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	/* Verify that the type is either int4 or dec with no scale or
	** precision > 31 digits - the 31 digit limitation is likely 
	** just temporary (Ingres supports 39 for decimal), hence the use
	** of an explicit constant. */
	if ((yacc_cb->yypvt[-0].psl_dbval->db_datatype == DB_INT_TYPE && yacc_cb->yypvt[-0].psl_dbval->db_length != 4) ||
		(yacc_cb->yypvt[-0].psl_dbval->db_datatype == DB_DEC_TYPE &&
			(DB_S_DECODE_MACRO(yacc_cb->yypvt[-0].psl_dbval->db_prec) != 0 ||
			 DB_P_DECODE_MACRO(yacc_cb->yypvt[-0].psl_dbval->db_prec) > 31)) ||
	    (yacc_cb->yypvt[-0].psl_dbval->db_datatype != DB_INT_TYPE && yacc_cb->yypvt[-0].psl_dbval->db_datatype != DB_DEC_TYPE))
	{
	    (void)psf_error(6318L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	
	psy_cb = (PSY_CB *) cb->pss_object;

	/* Assign datatype, length, precision. */
	psy_cb->psy_tuple.psy_sequence.dbs_type = yacc_cb->yypvt[-0].psl_dbval->db_datatype;
	psy_cb->psy_tuple.psy_sequence.dbs_length = yacc_cb->yypvt[-0].psl_dbval->db_length;
	psy_cb->psy_tuple.psy_sequence.dbs_prec = 
				DB_P_DECODE_MACRO(yacc_cb->yypvt[-0].psl_dbval->db_prec);
	if (yacc_cb->yypvt[-0].psl_dbval->db_datatype == DB_DEC_TYPE)
	    psy_cb->psy_seqflag |= PSY_DECTYPE;
				/* and note declared decimal type */

    } break;

case 1169:
if (!((*yyvarspp)->bypass_actions))
/* # line 24554 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, DBS_START,
	    (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    } break;

case 1170:
if (!((*yyvarspp)->bypass_actions))
/* # line 24564 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, DBS_RESTART,
	    (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    } break;

case 1171:
if (!((*yyvarspp)->bypass_actions))
/* # line 24574 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, DBS_INCR,
	    (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    } break;

case 1172:
if (!((*yyvarspp)->bypass_actions))
/* # line 24585 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, DBS_MAXVAL,
	    (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    } break;

case 1173:
if (!((*yyvarspp)->bypass_actions))
/* # line 24596 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, DBS_MINVAL,
	    (yacc_cb->yypvt[-1].psl_tytype == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    } break;

case 1174:
if (!((*yyvarspp)->bypass_actions))
/* # line 24607 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	i4		cacheval;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	/* FIXME disallow i8 cache value for now */
	if (yacc_cb->yypvt[-0].psl_dbval->db_datatype != DB_INT_TYPE || yacc_cb->yypvt[-0].psl_dbval->db_length == 8)
	{
	    /* Cache value must be integer. */
	    (void)psf_error(6316L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CACHE")-1, "CACHE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_NOCACHE)
	{
	    /* Inconsistent options - CACHE and NOCACHE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CACHE/NOCACHE")-1, "CACHE/NOCACHE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	switch (yacc_cb->yypvt[-0].psl_dbval->db_length) {
	  case 1:
	    cacheval = *(i1 *)yacc_cb->yypvt[-0].psl_dbval->db_data;
	    break;
	  case 2:
	    cacheval = *(i2 *)yacc_cb->yypvt[-0].psl_dbval->db_data;
	    break;
	  case 4:
	    cacheval = *(i4 *)yacc_cb->yypvt[-0].psl_dbval->db_data;
	    break;
	}

	if (cacheval <= 0)
	{
	    /* Cache value must be positive integer constant. */
	    (void)psf_error(6316L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CACHE")-1, "CACHE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_cache = cacheval;
	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_CACHE;

    } break;

case 1175:
if (!((*yyvarspp)->bypass_actions))
/* # line 24660 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_NOCYCLE)
	{
	    /* Inconsistent options - CYCLE and NOCYCLE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CYCLE/NOCYCLE")-1, "CYCLE/NOCYCLE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_CYCLE;
    } break;

case 1176:
if (!((*yyvarspp)->bypass_actions))
/* # line 24679 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_NOORDER)
	{
	    /* Inconsistent options - ORDER and NOORDER. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ORDER/NOORDER")-1, "ORDER/NOORDER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_ORDER;
    } break;

case 1177:
if (!((*yyvarspp)->bypass_actions))
/* # line 24698 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_MAXVAL)
	{
	    /* Inconsistent options - MAXVALUE and NOMAXVALUE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("MAXVALUE/NOMAXVALUE")-1, "MAXVALUE/NOMAXVALUE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOMAXVAL;
    } break;

case 1178:
if (!((*yyvarspp)->bypass_actions))
/* # line 24717 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_MINVAL)
	{
	    /* Inconsistent options - MINVALUE and NOMINVALUE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("MINVALUE/NOMINVALUE")-1, "MINVALUE/NOMINVALUE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOMINVAL;
    } break;

case 1179:
if (!((*yyvarspp)->bypass_actions))
/* # line 24736 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_CACHE)
	{
	    /* Inconsistent options - CACHE and NOCACHE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CACHE/NOCACHE")-1, "CACHE/NOCACHE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOCACHE;
	psy_cb->psy_tuple.psy_sequence.dbs_cache = 0;
    } break;

case 1180:
if (!((*yyvarspp)->bypass_actions))
/* # line 24756 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_CYCLE)
	{
	    /* Inconsistent options - CYCLE and NOCYCLE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CYCLE/NOCYCLE")-1, "CYCLE/NOCYCLE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOCYCLE;
    } break;

case 1181:
if (!((*yyvarspp)->bypass_actions))
/* # line 24775 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_ORDER)
	{
	    /* Inconsistent options - ORDER and NOORDER. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ORDER/NOORDER")-1, "ORDER/NOORDER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOORDER;
    } break;

case 1182:
if (!((*yyvarspp)->bypass_actions))
/* # line 24796 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	i4                err_code;
	DB_STATUS	status;
	
	status = adi_encode_colspec(adf_scb, yacc_cb->yypvt[-0].psl_strtype, 0, NULL, 0, &yyvarsp->db_pdata);
	if (status != E_DB_OK) 
	{
	    /* Bad datatype definition */
	    (VOID) psf_error(6323, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1183:
if (!((*yyvarspp)->bypass_actions))
/* # line 24813 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	i4                err_code;
	DB_STATUS	status;
	i4		len = yacc_cb->yypvt[-2].psl_inttype;

	status = adi_encode_colspec(adf_scb, yacc_cb->yypvt[-4].psl_strtype, 1, &len, 0, &yyvarsp->db_pdata);
	if (status != E_DB_OK) 
	{
	    /* Bad datatype definition */
	    (VOID) psf_error(6323, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, STtrmwhite(yacc_cb->yypvt[-4].psl_strtype), yacc_cb->yypvt[-4].psl_strtype);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1185:
if (!((*yyvarspp)->bypass_actions))
/* # line 24835 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yacc_cb->yypvt[-0].psl_inttype != 0)
	{
	    i4 err_code;
	    (VOID) psf_error(6318, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
    } break;

case 1186:
if (!((*yyvarspp)->bypass_actions))
/* # line 24847 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	DB_IISEQUENCE		oldseq;
	i4			seq_mask = 0;
	i4			gseq_flags;

	/* test event name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (void)psf_error(E_PS0427_ALTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("ALTER SEQUENCE") - 1, "ALTER SEQUENCE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-1].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

        status = psy_ckdbpr(psq_cb, (u_i4)DBPR_SEQ_CREATE);
        if (status)
        {
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;
		DB_STATUS	local_status;
		DB_NAME		seqname;
		/*
		** Audit failure to create sequence
		*/
		STmove(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, ' ', 
		    sizeof(DB_NAME), seqname.db_name);
		local_status = psy_secaudit(FALSE, cb,
		    (char *)&seqname, &cb->pss_user,
		    sizeof(DB_TAB_NAME), SXF_E_PROCEDURE,
		    I_SX2046_SEQUENCE_ALTER, SXF_A_FAIL | SXF_A_ALTER,
		    &e_error);
	    }

            (void)psf_error(6321L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
            return(status);
        }

	psy_cb = (PSY_CB *) cb->pss_object;

	seq_mask |= ((yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_SEQ_BY_OWNER
	    : PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ);

	STmove(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_sequence.dbs_name);
	STmove((PTR)&cb->pss_user, ' ', sizeof(DB_OWN_NAME),
	       (char *)&psy_cb->psy_tuple.psy_sequence.dbs_owner);

	/* Find the old sequence first. */
	status = psy_gsequence(cb, &psy_cb->psy_tuple.psy_sequence.dbs_owner, 
		&psy_cb->psy_tuple.psy_sequence.dbs_name, seq_mask, NULL, &oldseq,
		&gseq_flags, (i4 *)NULL, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}

	/* Then merge sequence tuples and perform validation. */
	status = psl_asequence(cb, &oldseq, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

    } break;

case 1187:
if (!((*yyvarspp)->bypass_actions))
/* # line 24933 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_ASEQUENCE;

	/* "alter sequence" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void)psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER SEQUENCE")-1, "ALTER SEQUENCE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter sequence statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block and tuple fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   		
	MEfill(sizeof(psy_cb->psy_tuple.psy_sequence), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_sequence);
	psy_cb->psy_seqflag |= PSY_ASEQ;

    } break;
	}
	return(0);
}

i4
psls24iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1188:
if (!((*yyvarspp)->bypass_actions))
/* # line 24966 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	DB_IISEQUENCE		oldseq;
	i4			seq_mask = 0;
	i4			gseq_flags;

	/* test event name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* If name was qualified, it'd better be the same as the user */
	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (void)psf_error(E_PS0420_DROPOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("DROP SEQUENCE") - 1, "DROP SEQUENCE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &yacc_cb->yypvt[-1].psl_objspec->pss_owner),
		&yacc_cb->yypvt[-1].psl_objspec->pss_owner);
	    return(E_DB_ERROR);
	}

        status = psy_ckdbpr(psq_cb, (u_i4)DBPR_SEQ_CREATE);
        if (status)
        {
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;
		DB_STATUS	local_status;
		DB_NAME		seqname;
		STmove(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, ' ', 
		    sizeof(DB_NAME), seqname.db_name);
		/*
		** Audit failure to drop sequence
		*/
		local_status = psy_secaudit(FALSE, cb,
		    (char *)&seqname, &cb->pss_user,
		    sizeof(DB_TAB_NAME), SXF_E_PROCEDURE,
		    I_SX2047_SEQUENCE_DROP, SXF_A_FAIL | SXF_A_DROP,
		    &e_error);
	    }

            (void)psf_error(6321L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
            return(status);
        }

	psy_cb = (PSY_CB *) cb->pss_object;

	seq_mask |= ((yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_SEQ_BY_OWNER
	    : PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ);

	STmove(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_sequence.dbs_name);
	STmove((PTR)&cb->pss_user, ' ', sizeof(DB_OWN_NAME),
	       (char *)&psy_cb->psy_tuple.psy_sequence.dbs_owner);

	/* Find the old sequence first. */
	status = psy_gsequence(cb, &psy_cb->psy_tuple.psy_sequence.dbs_owner, 
		&psy_cb->psy_tuple.psy_sequence.dbs_name, seq_mask, NULL, &oldseq,
		&gseq_flags, (i4 *)NULL, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}
	STRUCT_ASSIGN_MACRO(oldseq.dbs_uniqueid, 
			psy_cb->psy_tuple.psy_sequence.dbs_uniqueid);
					/* copy internal ID */
    } break;

case 1189:
if (!((*yyvarspp)->bypass_actions))
/* # line 25049 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_DSEQUENCE;

	/* "drop sequence" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void)psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP SEQUENCE")-1, "DROP SEQUENCE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block and tuple fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   		
	MEfill(sizeof(psy_cb->psy_tuple.psy_sequence), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_sequence);
	psy_cb->psy_seqflag |= PSY_DSEQ;

    } break;

case 1192:
if (!((*yyvarspp)->bypass_actions))
/* # line 25086 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	i;

	psq_cb->psq_mode = PSQ_FREELOCATOR;
	
	/* Set remaining locators to -1. */
	for (i = yyvarsp->loc_count; i < 10; i++)
	    psq_cb->psq_locator[i].db_datatype = DB_NODT;
    } break;

case 1195:
if (!((*yyvarspp)->bypass_actions))
/* # line 25102 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{

	if (yacc_cb->yypvt[-0].psl_dbval->db_datatype != DB_LCLOC_TYPE && 
	    yacc_cb->yypvt[-0].psl_dbval->db_datatype != DB_LNLOC_TYPE &&
	    yacc_cb->yypvt[-0].psl_dbval->db_datatype != DB_LBLOC_TYPE)
	{
	    /* Bad data type for locator. */
	}

	STRUCT_ASSIGN_MACRO(*(yacc_cb->yypvt[-0].psl_dbval), psq_cb->psq_locator[yyvarsp->loc_count++]);

    } break;

case 1196:
if (!((*yyvarspp)->bypass_actions))
/* # line 25117 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE		*node;
	PST_QNODE		*qlend;
	PST_RT_NODE		root;
	PST_QTREE		*tree;
	i4			err_code;
	DB_STATUS		status;

	/* Check if column and value list are of the same length */
	for (node = yyvarsp->resdmhd; node->pst_sym.pst_type != PST_TREE;
	     node = node->pst_left
	    )
	{
	    /* NOTE: if $4 is NULL, this was "insert ... default values"
	    ** and there are no rhs' to the resdoms. */
	    if (yacc_cb->yypvt[-0].psl_trtype != NULL && node->pst_right == (PST_QNODE *) NULL)
	    {
		/* # of values does not match # of cols */
		(VOID) psf_error(2775L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }
	}

	if (yacc_cb->yypvt[-0].psl_trtype == NULL)
	    yacc_cb->yypvt[-0].psl_trtype = node;			/* address the PST_TREE */

	/* create QLEND node */

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &qlend, &psq_cb->psq_error,
		(i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_DNTCAREDUPS;
	root.pst_tvrc   = 0;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);
	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_trtype, qlend, PST_ROOT, 
	        (PTR) &root, sizeof(root), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &node, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	status = psl_do_insert(cb, psq_cb, node, &yyvarsp->qp_shareable, &tree,
	   yyvarsp->isdbp, yyvarsp->join_id, &yyvarsp->xlated_qry, &yyvarsp->shr_qryinfo,
	    NULL, NULL, NULL);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_qttype = tree;
    } break;

case 1197:
if (!((*yyvarspp)->bypass_actions))
/* # line 25181 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE		*node, *ssnode, *subsel;
	PST_QTREE		*tree = 0;
	i4			err_code;
	DB_DT_ID		datatype, adatatype;
	DB_DT_ID		ssdatatype, assdtype;
	ADI_DT_BITMASK		typeset;
	DB_STATUS		status;
	bool			sane_order = TRUE;

	/* restore mode that was changed for subselect processing */
	psq_cb->psq_mode = PSQ_APPEND;

	if (yacc_cb->yypvt[-2].psl_tytype != 0)
	    yyvarsp->sort_list = (PST_QNODE *) NULL;

	/* ORDER BY is only allowed if there is at least an offset or first
	** "n" clause. */
	if (yyvarsp->sort_list != NULL && yyvarsp->first_n == NULL && yyvarsp->offset_n == NULL)
	{
	    (VOID) psf_error(2160L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}

	/*
	** First we have to determine whether number of resdoms 
	** and columns is equal.
	*/
	for (node = yacc_cb->yypvt[-4].psl_trtype, ssnode = yacc_cb->yypvt[-3].psl_trtype->pst_left;
	     (node->pst_sym.pst_type == PST_RESDOM &&
	      ssnode->pst_sym.pst_type == PST_RESDOM);
	     node = node->pst_left, ssnode = ssnode->pst_left)
		;

	/*
	** Once we run out of RESDOMs, we'd better be looking at TREEs in both
	** lists
	*/
	if (node->pst_sym.pst_type != PST_TREE ||
	    ssnode->pst_sym.pst_type != PST_TREE)
	{
	    /* numbers of columns and resdoms are not equal */
	    (VOID) psf_error(2776L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** By now we know that we have equal number of RESDOMs in both lists,
	** and that both lists are terminated with PST_TREE
	**
	** NOTE: If handling a union, the pst_s_root.pst_union.pst_next will be
	**   the chain of subselects, each of which will have been setup by
	**   pst_union_resolve to have the same type. We will be re-doing that
	**   as the resolved type is not of interest as the target type needs
	**   to be that of the table columns!
	**
	** Union or not, in this loop we will be propagating the attributes of
	** the table columns resdoms to the select list resdoms,
        */

	for (subsel = yacc_cb->yypvt[-3].psl_trtype; subsel;
	           subsel = subsel->pst_sym.pst_value.pst_s_root.pst_union.pst_next)
	{
	    for (node = yacc_cb->yypvt[-4].psl_trtype, ssnode = subsel->pst_left;
		node->pst_sym.pst_type != PST_TREE;
		node = node->pst_left, ssnode = ssnode->pst_left)
	    {
		/* update RESDOM in subselect with info from 'incolspec' RESDOM. */
    
		/* copy domain name */
		MEcopy((char *) node->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
			sizeof(DB_ATT_NAME),
			(char *) ssnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
    
		/* copy attribute number */
		ssnode->pst_sym.pst_value.pst_s_rsdm.pst_rsno =
		    node->pst_sym.pst_value.pst_s_rsdm.pst_rsno;
    
		/* reinitialize target number (to be equal to resdom number). */
		ssnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno =
		    node->pst_sym.pst_value.pst_s_rsdm.pst_rsno;

		if (subsel == yacc_cb->yypvt[-3].psl_trtype) /* Dealing with first sub-select list */
		{
		    /* Note if any of the resdoms are out of sequence */
		    if (node->pst_left &&
			    node->pst_sym.pst_value.pst_s_rsdm.pst_rsno <
			    node->pst_left->pst_sym.pst_value.pst_s_rsdm.pst_rsno)
			sane_order = FALSE;

		    /*
		    ** Fix datatype if necessary.
		    */
		    ssdatatype = ssnode->pst_sym.pst_dataval.db_datatype;
		    datatype = node->pst_sym.pst_dataval.db_datatype;
		    /*
		    ** We pretty much ignore nullability in the coercion business.
		    */
		    assdtype = abs(ssdatatype);
		    adatatype = abs(datatype);
    
		    /*
		    ** Fix for B64341 - if this is a prepare, we may not yet
		    ** know the assdtype (it may be 0, indicating a '?' place
		    ** marker. In this case, don't error, just allow the copy
		    ** of the result colum to the resdom. (added assdtype != 0)
		    */

		    if ((adatatype != assdtype) && (assdtype != 0))
		    {
			if ((status = adi_tycoerce((ADF_CB *)cb->pss_adfcb, 
						assdtype, &typeset))
			    || !BTtest((i4) ADI_DT_MAP_MACRO(adatatype),
				    (char*) &typeset))
			{
			    /* error 2913 - incompatible type coercion */
			    ADI_DT_NAME	    right_name;
			    ADI_DT_NAME	    res_name;

			    /* Get the names of the left & right operands, if any */
			    STmove("<none>", ' ', sizeof (ADI_DT_NAME),
						(char *) &right_name);
			    STmove("<none>", ' ', sizeof (ADI_DT_NAME), 
						(char *) &res_name);

			    status = adi_tyname((ADF_CB *)cb->pss_adfcb, 
						ssdatatype, &right_name);
			    status = adi_tyname((ADF_CB *)cb->pss_adfcb, 
						datatype, &res_name);
    
			    /* Now report the error */
			    (VOID) psf_error(2913, 0L, PSF_USERERR, &err_code,
					&psq_cb->psq_error, 3,
					sizeof(cb->pss_lineno), &cb->pss_lineno, 
					psf_trmwhite(sizeof(ADI_DT_NAME), 
					    (char *) &right_name), 
					&right_name, 
					psf_trmwhite(sizeof (ADI_DT_NAME), 
					    (char *) &res_name),
					&res_name);
			    return (E_DB_ERROR);
			}
		    }
		}
		/*
		** Fix a long-standing bug: RESDOM must contain attributes of the
		** result column, not of the target list element.
		*/
		STRUCT_ASSIGN_MACRO(node->pst_sym.pst_dataval,
						ssnode->pst_sym.pst_dataval);
	    }
	}
	/* If we spotted resdoms that were out of order we reorder them so that
	** they are correct. We do so for two reasons: Firstly, there are
	** assumptions in the optimiser that the tuple buffers don't need the
	** columns rearranging between nodes and when a union is present these
	** assumption mean a missmatch with the table and the resdoms will not be
	** corrected. Secondly, there is a benefit to having the columns in the
	** correct order in that the optimser is more likely to be able to
	** coalesce adjacent tuples.
	*/
	if (!sane_order)
	{
	    PST_QNODE **pnode, **head, *next;
	    /* First the table resdoms */
	    head = &yacc_cb->yypvt[-4].psl_trtype;
	    node = *head;
	    while (node &&
		    (next = node->pst_left) &&
		    next->pst_sym.pst_type == PST_RESDOM)
	    {
		if (node->pst_sym.pst_value.pst_s_rsdm.pst_rsno <
		    next->pst_sym.pst_value.pst_s_rsdm.pst_rsno)
		{
		    /* Unlink next */
		    node->pst_left = next->pst_left;
		    /* Reset pnode to head and look for insert point */
		    pnode = head;
		    while ((node = *pnode) &&
			    node->pst_sym.pst_value.pst_s_rsdm.pst_rsno >
			    next->pst_sym.pst_value.pst_s_rsdm.pst_rsno)
			pnode = &node->pst_left;
		    /* Link in here */
		    next->pst_left = node;
		    *pnode = next;
		    /* node already pointing where needed */
		}
		else
		    node = next;
	    }
	    /* Next the sub-select(s) */
	    for (subsel = yacc_cb->yypvt[-3].psl_trtype; subsel;
		    subsel = subsel->pst_sym.pst_value.pst_s_root.pst_union.pst_next)
	    {
		head = &subsel->pst_left;
		node = *head;
		while (node &&
			(next = node->pst_left) &&
			next->pst_sym.pst_type == PST_RESDOM)
		{
		    if (node->pst_sym.pst_value.pst_s_rsdm.pst_rsno <
			next->pst_sym.pst_value.pst_s_rsdm.pst_rsno)
		    {
			/* Unlink next */
			node->pst_left = next->pst_left;
			/* Reset pnode to head and look for insert point */
			pnode = head;
			while ((node = *pnode) &&
				node->pst_sym.pst_value.pst_s_rsdm.pst_rsno >
				next->pst_sym.pst_value.pst_s_rsdm.pst_rsno)
			    pnode = &node->pst_left;
			/* Link in here */
			next->pst_left = node;
			*pnode = next;
			/* node already pointing where needed */
		    }
		    else
			node = next;
		}
	    }
	}
	/*
	** Convert the root node of the subselect into the root node
	** for the query.
	*/
	yacc_cb->yypvt[-3].psl_trtype->pst_sym.pst_type = PST_ROOT;
	yacc_cb->yypvt[-3].psl_trtype->pst_sym.pst_value.pst_s_root.pst_rtuser = TRUE;

	status = psl_do_insert(cb, psq_cb, yacc_cb->yypvt[-3].psl_trtype, &yyvarsp->qp_shareable, &tree, yyvarsp->isdbp,
			       yyvarsp->join_id, &yyvarsp->xlated_qry, &yyvarsp->shr_qryinfo,
				yyvarsp->sort_list, yyvarsp->first_n, yyvarsp->offset_n);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	if (tree)
	    tree->pst_firstn = yyvarsp->first_n;
	if (yyvarsp->first_n != (PST_QNODE *) NULL && cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* No "select first n ..." allowed in Star queries. */
	    (VOID) psf_error(E_PS091F_STAR_NO_FIRSTN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	yacc_cb->yyval.psl_qttype = tree;
    } break;

case 1198:
if (!((*yyvarspp)->bypass_actions))
/* # line 25435 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;

	psq_cb->psq_mode = PSQ_APPEND;
	if (yyvarsp->isdbp == FALSE)
	{
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error)) != E_DB_OK)
	    {
		return (status);	    /* non-zero return means error */
	    }
	}
	else
	{
	    /*
	    ** To indicate that in 'i= :i' in a subselect the first
	    ** "i" must not be processed as a local var (bug 8269).
	    */
	    yyvarsp->dbpinfo->pss_flags |= PSS_1SUB_SEEN;
	}
    } break;

case 1199:
if (!((*yyvarspp)->bypass_actions))
/* # line 25459 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	PSS_RNGTAB	    *resrange;
	i4		    rngvar_info;

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
			&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb,
		FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** In case of DB procedures table name needs to be qualified
	** by the owner name. 
	** But don't qualify name if it's a set-input parameter.
	*/
	if (yyvarsp->isdbp 
	    && (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    && ~yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
	    && (resrange->pss_rgtype != PST_SETINPUT))
	{
	    u_char 	    *owner;

	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		/*
		** special care must be exercised when dealing with synonyms:
		** if the object referenced by the user was a synonym, name of
		** its owner must be determined by consulting rngvar_info.
		*/
		if (rngvar_info & PSS_USR_OBJ)
		{
		    owner = (u_char *) &cb->pss_user;
		}
		else if (rngvar_info & PSS_DBA_OBJ)
		{
		    owner = (u_char *) &cb->pss_dba;
		}
		else if (rngvar_info & PSS_SYS_OBJ)
		{
		    owner = (u_char *) cb->pss_cat_owner;
		}
		else	    /* user name was explicitly specified */
		{
		    owner = (u_char *) &yacc_cb->yypvt[-0].psl_objspec->pss_owner;
		}
	    }
	    else
	    {
		owner = (u_char *) &resrange->pss_ownname;
	    }

	    status = psl_prepend_schemaname(cb->pss_tchain, 
					    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, 
					    owner, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	}  /* end if ($Yisdbp && PSS_TXTEMIT) */

	cb->pss_resrng = resrange;
    } break;

case 1200:
if (!((*yyvarspp)->bypass_actions))
/* # line 25543 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	register PST_QNODE  *node;

	/* Find the leftmost node in the tree */
	for (node = yacc_cb->yypvt[-1].psl_trtype; node->pst_left != (PST_QNODE *) NULL; )
	{
	    node = node->pst_left;
	}

	/* Allocate the PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &node->pst_left,
		&psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = yyvarsp->resdmhd = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 1201:
if (!((*yyvarspp)->bypass_actions))
/* # line 25566 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DMT_ATT_ENTRY	    **attribute;
	PST_QNODE	    *rsdmnode = (PST_QNODE *) NULL;
	DB_STATUS	    status;
	PSS_RNGTAB	    *rngtabp;
	i4		    i;
	register PST_QNODE  *node;

	rngtabp = (PSS_RNGTAB *) cb->pss_resrng;

	/* Start at first attribute */
	for (i = 0, attribute = rngtabp->pss_attdesc + 1;
	     i < rngtabp->pss_tabdesc->tbl_attr_count;
	     i++, attribute++)
	{
	    if ((*attribute)->att_flags & DMT_F_HIDDEN)
		continue;

	    /* Create the result domain node with null right child */
	    status = pst_adresdom((char *) &(*attribute)->att_name, rsdmnode,
		(PST_QNODE *) NULL, cb, psq_cb, &rsdmnode);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	yyvarsp->resdmhd = rsdmnode;

	/* Find the leftmost node in the tree */
	for (node = rsdmnode; node->pst_left != (PST_QNODE *) NULL; )
	{
	    node = node->pst_left;
	}

	/* Allocate the PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &node->pst_left, &psq_cb->psq_error,
	    (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = rsdmnode;
    } break;

case 1202:
if (!((*yyvarspp)->bypass_actions))
/* # line 25614 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1203:
if (!((*yyvarspp)->bypass_actions))
/* # line 25618 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE   *node;
	i4	    err_code;
	char	    *rsname;

	/* Check for duplicate names */
	rsname = yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_rsname;
	for (node = yacc_cb->yypvt[-2].psl_trtype; node != (PST_QNODE *) NULL;
	     node = node->pst_left
	    )
	{
	    if (!MEcmp((char *) rsname,
		(char *) node->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
		DB_MAXNAME)
	       )
	    {
		(VOID) psf_error(2774L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    psf_trmwhite(DB_MAXNAME, rsname), rsname);
		return (E_DB_ERROR);
	    }
	}

	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	yacc_cb->yyval.psl_trtype = pst_tlprpnd(yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype);
    } break;

case 1204:
if (!((*yyvarspp)->bypass_actions))
/* # line 25649 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_RNGTAB	       *rngtabp;
	DMT_ATT_ENTRY          *attribute;
	DB_ATT_NAME	       atname;
	i4		       err_code;
	DB_STATUS	       status;
	PST_QNODE	       *resdomnode;

	rngtabp = cb->pss_resrng;

	/* Normalize the attribute name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_ATT_NAME), (char *) &atname);

	/* Look up the attribute */
	attribute = pst_coldesc(rngtabp, &atname);

	/* Check for attribute not found */
	if (attribute == (DMT_ATT_ENTRY *) NULL)
	{
	    (VOID) psf_error(2100L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 4,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno, 
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &rngtabp->pss_tabname),
		&rngtabp->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &rngtabp->pss_ownname),
		&rngtabp->pss_ownname,
		(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
		
	status = pst_adresdom((char *) &atname, (PST_QNODE *) NULL, 
	    (PST_QNODE *) NULL, cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1205:
if (!((*yyvarspp)->bypass_actions))
/* # line 25691 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;		/* no RESDOM structure - all defaults */
    } break;

case 1206:
if (!((*yyvarspp)->bypass_actions))
/* # line 25695 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yyvarsp->resdmhd;
    } break;

case 1207:
if (!((*yyvarspp)->bypass_actions))
/* # line 25701 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->aggr_allowed &= ~(PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
	yyvarsp->check_for_vlups = FALSE;
    } break;

case 1208:
if (!((*yyvarspp)->bypass_actions))
/* # line 25708 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* This is not necessary, but for the sake of completeness. */
	yyvarsp->aggr_allowed |= (PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
    } break;

case 1211:
if (!((*yyvarspp)->bypass_actions))
/* # line 25719 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*node;
	bool		found;
	DB_DT_ID	datatype, adatatype;
	DB_DT_ID	db_right, adb_right;
	ADI_DT_BITMASK	typeset;
	i4		err_code;

	/*
	** Check whether it is a constant or expression thereof.
	** No VAR nodes must be present.
	*/
	status = chkcnst(yacc_cb->yypvt[-0].psl_trtype);
	if (status != E_DB_OK)
	{   /* not a constant expression */
	    (VOID) psf_error(2778L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** Walk down the RESDOM tree to find the last node
	** that has a null right node.
	*/
	node = yyvarsp->resdmhd;
	found = FALSE;
	for ( ; node->pst_sym.pst_type != PST_TREE; node = node->pst_left)
	{
	    if (((node->pst_left->pst_sym.pst_type == PST_TREE) ||
		 (node->pst_left->pst_right != (PST_QNODE *)NULL))
		&& (node->pst_right == (PST_QNODE *)NULL)	    )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == FALSE)
	{
	    /* # of values does not match # of cols */
	    i4	errcode = 2775;

	    if (psq_cb->psq_mode == PSQ_RETROW)
		errcode = 2446;
	    (VOID) psf_error(errcode, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* attach the 'select_expr' subtree to the found RESDOM node */
	node->pst_right = yacc_cb->yypvt[-0].psl_trtype;

	/*
	** Fix datatype if necessary.
	** (this code comes from pst_node procedure)
	*/
	/* Skip type checking if preparing a dynamic SQL with parm nodes */

	if ((cb->pss_defqry != PSQ_PREPARE) || (cb->pss_highparm == -1))
	{
	    db_right = yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_datatype;
	    datatype = node->pst_sym.pst_dataval.db_datatype;
	    /*
	    ** We pretty much ignore nullability in the coercion business.
	    */
	    adb_right = abs(db_right);
	    adatatype = abs(datatype);
	    if (adatatype != adb_right)
	    {
		/* Check coercibility - pst_convlit() tries to convert
		** between string & numeric literals so user can be sloppy. */
		if ((status = adi_tycoerce((ADF_CB *)cb->pss_adfcb, 
					   adb_right, &typeset)
		    || !BTtest((i4) ADI_DT_MAP_MACRO(adatatype), (char*) &typeset))
		    && !pst_convlit(cb, &cb->pss_ostream, 
				&node->pst_sym.pst_dataval, yacc_cb->yypvt[-0].psl_trtype))
		{
		    /* error 2913 - incompatible type coercion */
		    ADI_DT_NAME	    right_name;
		    ADI_DT_NAME	    res_name;
		
		    /* Get the names of the left & right operands, if any */
		    STmove("<none>", ' ', sizeof (ADI_DT_NAME),
			 (char *) &right_name);
		    STmove("<none>", ' ', sizeof (ADI_DT_NAME), 
			(char *) &res_name);

		    status = adi_tyname((ADF_CB *)cb->pss_adfcb, 
					db_right, &right_name);
		    status = adi_tyname((ADF_CB *)cb->pss_adfcb, 
					datatype, &res_name);

		    /* Now report the error */
		    (VOID) psf_error(2913, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 3, 
			sizeof(cb->pss_lineno),&cb->pss_lineno, 
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &right_name),
			&right_name,
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &res_name), 
			&res_name);
		    return (E_DB_ERROR);
		}
	    }
	}
    } break;

case 1212:
if (!((*yyvarspp)->bypass_actions))
/* # line 25826 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*node, *newnode;
	PST_CNST_NODE	pst_cnst_node;
	DB_DT_ID	datatype;
	bool		found;
	i2		dataprec;
	i4		datalen;
	i4		err_code;
	/*
	** Walk down the RESDOM tree to find the last node
	** that has a null right node.
	*/
	node = yyvarsp->resdmhd;
	found = FALSE;
	for ( ; node->pst_sym.pst_type != PST_TREE; node = node->pst_left)
	{
	    if (((node->pst_left->pst_sym.pst_type == PST_TREE) ||
		 (node->pst_left->pst_right != (PST_QNODE *)NULL))
		&& (node->pst_right == (PST_QNODE *)NULL)	    )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == FALSE)
	{
	    /* # of values does not match # of cols */
	    (VOID) psf_error(2775L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	dataprec = node->pst_sym.pst_dataval.db_prec;
	datalen = node->pst_sym.pst_dataval.db_length;
	datatype = node->pst_sym.pst_dataval.db_datatype;
	if (datatype > 0)
	{
	    /* nonnullable data type */
	    (VOID) psf_error(2777L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(DB_MAXNAME,
		    node->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
		node->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
	    return (E_DB_ERROR);
	}

        if (abs(datatype) == DB_VCH_TYPE)
        {
        datalen = sizeof(DB_VCH_TYPE)+1;
        }
	/* following added for b67293 070395 newca01 as a test !!!   */
	if ((cb->pss_distrib & DB_3_DDB_SESS) && 
	    (abs(datatype) == DB_LVCH_TYPE)) 
	{ 
	  	datatype = - DB_VCH_TYPE; 
		datalen = 23;
	}
	/*
	** Create a constant node for the NULL value.
	*/
	pst_cnst_node.pst_tparmtype = PST_USER;
	pst_cnst_node.pst_parm_no = 0;
	pst_cnst_node.pst_pmspec = PST_PMNOTUSED;
	pst_cnst_node.pst_cqlang = DB_SQL;
	pst_cnst_node.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &pst_cnst_node,
	    sizeof (PST_CNST_NODE), datatype, dataprec, datalen,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
	/* Allocate space and set to 0's. */
	status = psf_malloc(cb, &cb->pss_ostream, datalen,
		(PTR *) &newnode->pst_sym.pst_dataval.db_data, 
		&psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEfill(datalen, 0, (PTR)newnode->pst_sym.pst_dataval.db_data);

	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, 
			       &newnode->pst_sym.pst_dataval);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* attach the newnode to the found RESDOM node */
	newnode->pst_sym.pst_len += datalen;	/* add NULL const to length */
	node->pst_right = newnode;
    } break;

case 1213:
if (!((*yyvarspp)->bypass_actions))
/* # line 25923 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*node, *prevnode;
	bool		found;
	i4		err_code;
	/*
	** Walk down the RESDOM tree to find the last node
	** that has a null right node.
	*/
	node = yyvarsp->resdmhd;
	found = FALSE;
	for (prevnode = NULL; node->pst_sym.pst_type != PST_TREE; 
				prevnode = node, node = node->pst_left)
	{
	    if (((node->pst_left->pst_sym.pst_type == PST_TREE) ||
		 (node->pst_left->pst_right != (PST_QNODE *)NULL))
		&& (node->pst_right == (PST_QNODE *)NULL)	    )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == FALSE)
	{
	    /* # of values does not match # of cols */
	    (VOID) psf_error(2775L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Just drop the corresponding resdom node. */
	if (prevnode == NULL)
	    yyvarsp->resdmhd = node->pst_left;
	else prevnode->pst_left = node->pst_left;
    } break;

case 1214:
if (!((*yyvarspp)->bypass_actions))
/* # line 25962 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_md1_modify(cb, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1215:
if (!((*yyvarspp)->bypass_actions))
/* # line 25973 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_md2_modstmnt(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* In case we have modify pmast PARTITION ... */
	cb->pss_yacc->yy_partalt_kwds = TRUE;
    } break;

case 1216:
if (!((*yyvarspp)->bypass_actions))
/* # line 25988 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_md8_modtable(cb, yacc_cb->yypvt[-0].psl_objspec, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 1218:
if (!((*yyvarspp)->bypass_actions))
/* # line 26005 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_yacc->yy_partalt_kwds = FALSE;
    } break;

case 1219:
if (!((*yyvarspp)->bypass_actions))
/* # line 26009 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	cb->pss_yacc->yy_partalt_kwds = FALSE;
	status = psl_md_modpart(cb, psq_cb, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 1222:
if (!((*yyvarspp)->bypass_actions))
/* # line 26024 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_md_logpartname(cb, psq_cb, yyvarsp, yacc_cb->yypvt[-0].psl_strtype);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    } break;

case 1226:
if (!((*yyvarspp)->bypass_actions))
/* # line 26042 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_md3_modstorage(cb,
				    yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1228:
if (!((*yyvarspp)->bypass_actions))
/* # line 26055 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/* ****FIXME what about unique_scope = row? !!! */
	if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "unique_scope") || 
		(STcompare(yacc_cb->yypvt[-0].psl_strtype, "statement") && (STcompare(yacc_cb->yypvt[-0].psl_strtype, "row"))))
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	status = psl_md4_modstorname(cb, "unique_scope", yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1229:
if (!((*yyvarspp)->bypass_actions))
/* # line 26073 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_md4_modstorname(cb, yacc_cb->yypvt[-0].psl_strtype, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1230:
if (!((*yyvarspp)->bypass_actions))
/* # line 26082 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_md4_modstorname(cb, "relocate", yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;
	}
	return(0);
}

i4
psls25iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1231:
if (!((*yyvarspp)->bypass_actions))
/* # line 26091 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/* ****FIXME what about unique_scope = row? !!! */
	if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "unique_scope") || 
		(STcompare(yacc_cb->yypvt[-0].psl_strtype, "statement") && (STcompare(yacc_cb->yypvt[-0].psl_strtype, "row"))))
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	status = psl_md4_modstorname(cb, "unique_scope", yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1234:
if (!((*yyvarspp)->bypass_actions))
/* # line 26111 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_md5_modkeys(cb, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1238:
if (!((*yyvarspp)->bypass_actions))
/* # line 26127 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;

	status = psl_md6_modbasekey(cb, (i4) (yacc_cb->yypvt[-0].psl_tytype == PSS_ASCENDING),
	    yyvarsp->is_heapsort, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1239:
if (!((*yyvarspp)->bypass_actions))
/* # line 26139 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PSS_ASCENDING;
    } break;

case 1240:
if (!((*yyvarspp)->bypass_actions))
/* # line 26143 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "desc"))
	{
	    i4	    err_code;

	    /*
	    ** NOTE: this production is curently used only by MODIFY.
	    ** Should you change it, make sure that the correct message gets
	    ** displayed.
	    ** (andre 4/26/90)
	    */
	    (VOID) psf_error(2511L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_tytype = PSS_DESCENDING;
    } break;

case 1241:
if (!((*yyvarspp)->bypass_actions))
/* # line 26165 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_md7_modkeyname(cb, yacc_cb->yypvt[-0].psl_strtype, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1245:
if (!((*yyvarspp)->bypass_actions))
/* # line 26184 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;

	if (psq_cb->psq_mode != PSQ_RETRIEVE)
	    yacc_cb->yypvt[-1].psl_bool = yyvarsp->repeat_dyn = FALSE;

	/* Extract information from PSQ_CB and PSS_SESBLK.
	** Save it in the prototype header */

	status = pst_prepare(psq_cb, cb, yacc_cb->yypvt[-3].psl_strtype, yyvarsp->nonupdt, yacc_cb->yypvt[-1].psl_bool, yacc_cb->yypvt[-2].psl_strtype, yyvarsp->updcollst);
	psq_cb->psq_mode = PSQ_PREPARE;

	if (status != E_DB_OK)
    	    return(status);
    } break;

case 1246:
if (!((*yyvarspp)->bypass_actions))
/* # line 26202 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;

	if (psq_cb->psq_mode != PSQ_RETRIEVE)
	    yacc_cb->yypvt[-1].psl_bool = yyvarsp->repeat_dyn = FALSE;

	/* Extract information from PSQ_CB and PSS_SESBLK.
	** Save it in the prototype header */

	status = pst_prepare(psq_cb, cb, yacc_cb->yypvt[-6].psl_strtype, yyvarsp->nonupdt, yacc_cb->yypvt[-1].psl_bool, yacc_cb->yypvt[-2].psl_strtype, yyvarsp->updcollst);
	psq_cb->psq_mode = PSQ_INPREPARE;

	if (status != E_DB_OK)
	    return (status);

	/* Return query descriptor in SQLDA */

	if ((status = pst_describe(psq_cb, cb, yacc_cb->yypvt[-6].psl_strtype)) != E_DB_OK)
	    return (status);
    } break;

case 1247:
if (!((*yyvarspp)->bypass_actions))
/* # line 26226 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Indicate processing a PREPARE statement */

	cb->pss_defqry = PSQ_PREPARE;
    } break;

case 1248:
if (!((*yyvarspp)->bypass_actions))
/* # line 26234 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	dummy;
	if (((Psf_srvblk->psf_flags & PSF_CACHEDYN) && 
		!(cb->pss_ses_flag & PSS_NO_CACHEDYN)) || 
	    (cb->pss_ses_flag & PSS_CACHEDYN))
	{
	    /* CBF or "set cache_dynamic" or "set session cache_dynamic" and
	    ** not "set session nocache_dynamic". */
	    yyvarsp->repeat_dyn = TRUE;
	    yacc_cb->yyval.psl_bool = TRUE;
	}
	else yacc_cb->yyval.psl_bool = FALSE;
    } break;

case 1249:
if (!((*yyvarspp)->bypass_actions))
/* # line 26248 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->repeat_dyn = TRUE;
	yacc_cb->yyval.psl_bool = TRUE;
    } break;

case 1250:
if (!((*yyvarspp)->bypass_actions))
/* # line 26255 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = cb->pss_nxtchar;
    } break;

case 1306:
if (!((*yyvarspp)->bypass_actions))
/* # line 26318 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    i, err_code;
	DB_STATUS   status;
	PST_QTREE   *tree = (PST_QTREE *) NULL;
	PST_RNGENTRY	*rtptr;

	if (yacc_cb->yypvt[-1].psl_prtype != (PST_PROCEDURE *) NULL)
	{
	    if (psq_cb->psq_mode == PSQ_VIEW)
	    {
		/*
		** view tree for CREATE VIEW statement is found in
		** PST_CREATE_VIEW.pst_view_tree
		*/
		tree =
		    yacc_cb->yypvt[-1].psl_prtype->pst_stmts->pst_specific.pst_create_view.pst_view_tree;
	    }
	    else
	    {
		tree = yacc_cb->yypvt[-1].psl_prtype->pst_stmts->pst_specific.pst_tree;
	    }
	}

	if (yacc_cb->yypvt[-0].psl_bool == FALSE)
	{
	    if (yyvarsp->dsql_maxparm >= 0)
	    {	/* error if no parms */
		(VOID) psf_error(2300L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	}
	else
	{
	    if (cb->pss_highparm != yyvarsp->dsql_maxparm)
	    {	/* error if not enough parms */
		(VOID) psf_error(2301L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	    /*
	    ** If there is a tree, start from the right child of the root node,
	    ** substitute all constant nodes with values from user's parameter
	    ** list.
	    */

	    if (tree != (PST_QTREE *) NULL)
	    {
		/* Must also loop over range table, looking for derived tables 
		** or common query expressions that may also contain dynamic 
		** parameters. */
		for (i = 0; i < tree->pst_rngvar_count; i++)
		{
		    rtptr = tree->pst_rangetab[i];
		    if (rtptr && (rtptr->pst_rgtype == PST_DRTREE ||
			rtptr->pst_rgtype == PST_WETREE))
		    {
			status = pst_prmsub(psq_cb, cb, rtptr->pst_rgroot, 
						yyvarsp->dsql_plist, yyvarsp->repeat_dyn);
			if (DB_FAILURE_MACRO(status))
			    return(status);
		    }
		}

		status = pst_prmsub(psq_cb, cb, tree->pst_qtree,
		    				yyvarsp->dsql_plist, yyvarsp->repeat_dyn);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }
	    else if (psq_cb->psq_mode == PSQ_SET_SESS_AUTH_ID)
	    {
		DB_TEXT_STRING  *str;
		u_i4		len, save_len, id_len = DB_MAXNAME;
		i4		leading_blanks;
		char		*c;
		DB_DT_ID	totype;
		
		/*
		** if the prepared statement was SET SESSION AUTHORIZATION, we
		** need to store the supplied value in PSQ_CB
		*/

		/*
		** if the input datatype was nullable, so must be the output
		** datatype
		*/

		totype = ((*yyvarsp->dsql_plist)->db_datatype < 0) ? -DB_LTXT_TYPE
							    : DB_LTXT_TYPE;
							   
		status = qdata_cvt(cb, psq_cb, *yyvarsp->dsql_plist, totype,
		    (PTR *) &str);
		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}

		/*
		** according to SQL92, we need to strip off leading and trailing
		** blanks from the contents of the string constant and only then
		** may we verify that the remainder represents a valid
		** identifier
		*/

		c = (char *) str->db_t_text;

		len = psf_trmwhite((u_i4) str->db_t_count, c);

		for (leading_blanks = 0;
		     CMspace(c);
		     leading_blanks++, CMnext(c))
		;

		/*
		** we are saving length of the string to be passed to
		** cui_idxlate() so that we can ensure that the entire string
		** was "consumed" by it
		*/
		save_len = len -= leading_blanks;

		status = cui_idxlate((u_char *) c, &len,
		    (u_char *) &psq_cb->psq_user, &id_len,
		    (u_i4) *cb->pss_dbxlate,
		    (u_i4 *) NULL, &psq_cb->psq_error);

		if (save_len != len || DB_FAILURE_MACRO(status))
		{
		    psf_error(E_PS0359_NOT_A_VALID_AUTH_ID, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			(i4) save_len, (PTR) c);

		    return(E_DB_ERROR);
		}

		/* fill the rest of psq_cb->psq_user with blanks */
		if (id_len < DB_MAXNAME)
		{
		    MEfill(DB_MAXNAME - id_len, (u_char) ' ',
			(PTR) ((char *) &psq_cb->psq_user + id_len));
		}
	    }
	}

	/* At this point we are done with parm substitution, if any.
	** If there is a query tree, indicate this in the header.
	*/
	if (tree != (PST_QTREE *) NULL)
	{
	    tree->pst_numparm = 0;
	}
    } break;

case 1307:
if (!((*yyvarspp)->bypass_actions))
/* # line 26474 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_PROCEDURE   *pnode;
	DB_STATUS	status;
	bool		qpcomp;

	psq_cb->psq_mode = PSQ_EXECQRY;

	status = pst_execute(psq_cb, cb, yacc_cb->yypvt[-0].psl_strtype, &pnode, &yyvarsp->dsql_maxparm,
	    (PTR *) &yyvarsp->dsql_plist, &yyvarsp->nonupdt, &yyvarsp->dynqp_comp, &yyvarsp->updcollst);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_prtype = pnode;
    } break;

case 1308:
if (!((*yyvarspp)->bypass_actions))
/* # line 26491 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;

	psq_cb->psq_mode = PSQ_DESCRIBE;
	if ((status = pst_describe(psq_cb, cb, yacc_cb->yypvt[-1].psl_strtype)) != E_DB_OK)
	    return (status);
    } break;

case 1309:
if (!((*yyvarspp)->bypass_actions))
/* # line 26501 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "names") != 0)
	{
	    (VOID) psf_error(2303L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1310:
if (!((*yyvarspp)->bypass_actions))
/* # line 26513 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;

case 1311:
if (!((*yyvarspp)->bypass_actions))
/* # line 26519 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;

	psq_cb->psq_mode = PSQ_DESCINPUT;
	if ((status = pst_descinput(psq_cb, cb, yacc_cb->yypvt[-0].psl_strtype)) != E_DB_OK)
	    return (status);
    } break;

case 1312:
if (!((*yyvarspp)->bypass_actions))
/* # line 26533 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PST_QTREE	    *tree;
	i4		    updtmode;
	i4		    err_code;
	PST_PROCEDURE	    *pnode;
	PST_QNODE	    *res, *ss, *s1;

	/* For the database procedure case */
	if (yyvarsp->isdbp == TRUE)
	{
	    /* Reset some flags */
	    yyvarsp->dbpinfo->pss_flags &= ~PSS_1SUB_SEEN; /*
						    ** Haven't seen the first
						    ** query term yet
						    */
	    yyvarsp->dbpinfo->pss_flags &= ~PSS_LVAR_SEEN; /* No local vars seen yet */

	    /* Now that we have processed the query_clause let's update
	    ** the target list if INTO clause present.
	    */
	    if (yyvarsp->dbpinfo->pss_into_clause != (PST_QNODE *) NULL)
	    {
		yacc_cb->yypvt[-2].psl_trtype->pst_left = yyvarsp->dbpinfo->pss_into_clause;
		yyvarsp->dbpinfo->pss_into_clause = (PST_QNODE *) NULL;
	    }

	    /* Ensure that builtins are WRITE PROTECTED;
	    ** they are READONLY by definition.
	    ** (builtins in question are iirowcount and iierrornumber) 
	    */
	    for (res = yacc_cb->yypvt[-2].psl_trtype->pst_left;
		 res->pst_sym.pst_type == PST_RESDOM;
		 res = res->pst_left
		)
	    {
		    i4	    tno;

		    tno =  res->pst_sym.pst_value.pst_s_rsdm.pst_ntargno;
		    if ((tno == PST_RCNT || tno == PST_ERNO) &&
			res->pst_sym.pst_value.pst_s_rsdm.pst_rsflags&PST_RS_PRINT)
		    {
			(VOID) psf_error(2434L, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 1,
			    sizeof(cb->pss_lineno), &cb->pss_lineno);
			return (E_DB_ERROR);
		    }
	    }

	    /* Make sure that all UNIONed subselects have target lists
	    ** refer to same local vars and in the same sequence as the
	    ** first subselect.
	    */
	    for (ss = yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_value.pst_s_root.pst_union.pst_next; ss; 
		    ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next)
	    {	    
		for (res = ss->pst_left, s1 = yacc_cb->yypvt[-2].psl_trtype->pst_left;
		     res->pst_sym.pst_type == PST_RESDOM;
		     res = res->pst_left, s1 = s1->pst_left
		    )
		{
		    res->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype =
			s1->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype;
		    res->pst_sym.pst_value.pst_s_rsdm.pst_ntargno =
			s1->pst_sym.pst_value.pst_s_rsdm.pst_ntargno;
		}
	    }

	    /* Finally, to assure UNION selects in procedures compile 
	    ** to proper RESDOM lists, resolve 'em all. */
	    if (yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_value.pst_s_root.pst_union.pst_next
				!= (PST_QNODE *) NULL)
	    {
		status = pst_union_resolve(cb, yacc_cb->yypvt[-2].psl_trtype, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	}

	/* 
	** All root nodes in the tree will have set the `pst_rtuser' flag to
	** FALSE to indicate that they are not the ROOT of the tree. Now is the
	** time to mark the topmost ROOT node. In any case (unions included)
	** there will be one and only one such root node per tree.
	*/
	yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_value.pst_s_root.pst_rtuser = TRUE;

	if (yacc_cb->yypvt[-1].psl_tytype != 0)
	{
	    /* no sortlist was provided */
	    yyvarsp->sort_list = (PST_QNODE *) NULL;
	}

	/*
	** Store the FOR clause info.
	*/
	if (yacc_cb->yypvt[-1].psl_tytype == 1)
	{
	    updtmode = PST_DEFER;
	}
	else if (yacc_cb->yypvt[-1].psl_tytype == 2)
	{
	    updtmode = PST_DIRECT;
	}
	else
	{
	    updtmode = PST_READONLY;
	}

	/*
	** Initialize result variable info in the session control block
	** for open cursor statement and prepare statement. The idea is
	** to identify range variables defined at the outermost scope
	** (qualdepth == 1). To a certain extent we follow algorithm
	** used in the `order_column' production.
	*/
	if (psq_cb->psq_mode == PSQ_DEFCURS || cb->pss_defqry == PSQ_PREPARE)
	{
	    i4		    scope = MAXI1 + 1;
	    PSS_RNGTAB	    *rngvar;
	    i4		    i;
	    bool	    found = FALSE;

	    /* Check each variable */
	    for (i = 0; i < PST_NUMVARS; i++)
	    {
		rngvar = &cb->pss_auxrng.pss_rngtab[i];
		/* skip unused entries */
		if (!rngvar->pss_used || rngvar->pss_rgno < 0)
		    continue;
		/* must be at our scope */
		if (rngvar->pss_rgparent == scope)
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (found)
	    {
		cb->pss_resrng = rngvar;

		/*
		** if the user has not specified FOR UPDATE or ORDER BY, at this
		** point we do not know the mode for the query: if the <query
		** expression> is updatable and its underlying table is also
		** updatable, then it will be DIRECT or DEFERRED UPDATE;
		** otherwise, it will be left marked READONLY.
		** 
		** If a user has specified FOR UPDATE without specifying <column
		** name list>, we will know the mode of the query but the list
		** of columns will still be empty.
		** 
		** In both cases if the query itself appears updatable, we will
		** build a RESDOM list representing all attributes of the table
		** or view
		*/
		if (   (   yacc_cb->yypvt[-1].psl_tytype == -1	    /* empty clause */
					    /* or FOR UPDATE w/o <col list> */
			|| cb->pss_stmt_flags & PSS_IMPL_COL_LIST_IN_DECL_CURS)
		    && !yyvarsp->nonupdt   /* query looks updatable so far */
		   )
		{
		    PST_RSDM_NODE       resdom;
		    DMT_ATT_ENTRY      **attribute;

		    /*
		    ** if FOR UPDATE has not been specified, reset updtmode to
		    ** PST_UNSPECIFIED.  This will serve as an indicator that a
		    ** user may be allowed to UPDATE through the cursor
		    ** provifing the cursor's underlying table is updatable
		    */
		    if (yacc_cb->yypvt[-1].psl_tytype == -1)
		    {
			updtmode = PST_UNSPECIFIED;
		    }

		    /* Start at first attribute */
		    for (i = 0, attribute = rngvar->pss_attdesc + 1;
			 i < rngvar->pss_tabdesc->tbl_attr_count;
			 i++, attribute++)
		    {
			if ((*attribute)->att_flags & DMT_F_HIDDEN)
			    continue;

			MEcopy((PTR) (*attribute)->att_name.db_att_name,
			    DB_MAXNAME,
			    (PTR) resdom.pst_rsname);

			resdom.pst_rsno = (i4) 1;
			resdom.pst_ntargno = (i4) 0;
			resdom.pst_ttargtype = (i4) PST_USER;
			resdom.pst_rsupdt = (i4) FALSE;
			resdom.pst_rsflags = PST_RS_PRINT;
	                resdom.pst_dmuflags = 0;
			status = pst_node(cb, &cb->pss_ostream, yyvarsp->updcollst,
			    (PST_QNODE *) NULL, PST_RESDOM, (char *) &resdom,
			    sizeof(PST_RSDM_NODE), DB_NODT, (i2) 0, (i4) 0,
			    (DB_ANYTYPE *) NULL, &yyvarsp->updcollst,
			    &psq_cb->psq_error, (i4) 0);
			if (status != E_DB_OK)
			{
			    return (status);
			}
		    }
		}
	    }

	    if (yyvarsp->updcollst != (PST_QNODE *) NULL)
	    {
		/* FOR UPDATE clause must have been specified.
		** We need to validate column names. We will also
		** generate VAR nodes and connect them to resdom nodes.
		** This mini target-list will be connected to the main one
		** so that qrymod executed from within cursor_open tells us
		** what attribute numbers in the underlying base relation(s)
		** these update columns map to; we need these att. nos.
		** for proper initialization of psc_iupdmap and consequently
		** pst_updmap in the tree header passed to OPF.
		*/
		DMT_ATT_ENTRY	*coldesc;
		PST_QNODE	*rsdm, *newnode;
		char		*name;
		DB_DATA_VALUE	*dv;
		PST_VAR_NODE	varnode;

		for (rsdm = yyvarsp->updcollst;
		     rsdm && rsdm->pst_sym.pst_type == PST_RESDOM;
		     rsdm = rsdm->pst_left
		    )
		{
		    name = rsdm->pst_sym.pst_value.pst_s_rsdm.pst_rsname;

		    /* Get the column description */
		    coldesc = pst_coldesc(cb->pss_resrng, 
			(DB_ATT_NAME *) name);

		    if (coldesc == (DMT_ATT_ENTRY *) NULL)
		    {
			(VOID) psf_error(2102L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 2,
			    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
			    (i4) psf_trmwhite(DB_MAXNAME, name), name);
			return (E_DB_ERROR);
		    }

		    dv = &rsdm->pst_sym.pst_dataval;

		    dv->db_data =   (PTR) NULL;
		    dv->db_length = coldesc->att_width;
		    dv->db_datatype = coldesc->att_type;
		    dv->db_prec = coldesc->att_prec;
		    dv->db_collID = coldesc->att_collID;

		    /* Set up var node. */
		    varnode.pst_vno = cb->pss_resrng->pss_rgno;
		    varnode.pst_atno.db_att_id = coldesc->att_number;

		    /* Create the node */
		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
			sizeof(varnode), (DB_DT_ID) coldesc->att_type,
			(i2) coldesc->att_prec, (i4) coldesc->att_width,
			(DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
			(i4) 0);
		    if (DB_FAILURE_MACRO(status))
			return (status);

		    rsdm->pst_right = newnode;
		    newnode->pst_sym.pst_dataval.db_collID = dv->db_collID;
		}
	    }
	}

	/* For repeat queries we must determine if the query is shareable.
	** We already know that this is an SQL query, so the only criterion
	** to be checked out is whether all relations/views are DBA owned or
	** are catalogs.
	*/
	if (cb->pss_defqry == PSQ_DEFQRY || cb->pss_defqry == PSQ_DEFCURS)
	{
	    status = psl_shareable(psq_cb, cb, &yyvarsp->qp_shareable, &yyvarsp->shr_qryinfo);
	    if (status != E_DB_OK)
		return (status);
	}

	/*
	** Apply the qrymod algorithm (views, permits, and integrities).
	** If this is an OPEN CURSOR statement we cannot run querymod yet,
	** even though we know what columns have been spec'd in FOR UPDATE
	** clause, if any, because FOR READONLY may have been spec'd and we
	** have not seen it yet. Same applies to PREPARE case. Execution
	** of qrymod at this steg may result in erronous behaviour of psyview
	** because cb->pss_resrng has been defined.
	*/
	if (psq_cb->psq_mode != PSQ_DEFCURS && cb->pss_defqry != PSQ_PREPARE)
	{
	    i4	    qrymod_resp_mask;

	    status = psy_qrymod(yacc_cb->yypvt[-2].psl_trtype, cb, psq_cb, &yyvarsp->join_id, &qrymod_resp_mask);
	    if (status != E_DB_OK)
		return (status);
	}

	/*
	** In case of FOR UPDATE clause  we need to check whether the stmnt
	** is updateble. However, for cursors this check is not performed here
	** because FOR READONLY may have been spec'd and we have not seen it
	** yet. Same applies to PREPARE SELECT statements.
	*/
	if (psq_cb->psq_mode != PSQ_DEFCURS && updtmode != PST_READONLY &&
	    cb->pss_defqry != PSQ_PREPARE)
	{
	    /*
	    ** Make sure the query has only one range variable at the outermost
	    ** scope. The idea is to identify range variables defined at the
	    ** outermost scope (qualdepth == 1). To a certain extent we follow
	    ** algorithm used in the `order_column' production.
	    */
	    i4		    scope = MAXI1 + 1;
	    PSS_RNGTAB	    *rngvar;
	    i4		    i, varcount = 0;

	    /* Check each variable */
	    for (i = 0, rngvar = cb->pss_auxrng.pss_rngtab;
		 i < PST_NUMVARS;
		 i++, rngvar++)
	    {
		
		if (rngvar->pss_used &&	    /* skip unused entries */
		    rngvar->pss_rgno >= 0 
		    &&
		    rngvar->pss_rgparent == scope   /* must be at our scope */
		   )
		{
		    if (++varcount > 1)
		    {
			/* this SELECT is non-updatable */
			(VOID) psf_error(2925L, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 0);
			return (E_DB_ERROR);
		    }
		}
	    }
	}

        /* Make and fill in the query tree header */
	status = pst_header(cb, psq_cb, updtmode, yyvarsp->sort_list, yacc_cb->yypvt[-2].psl_trtype,
	    &tree, &pnode, (yyvarsp->isdbp) ? 0 : PST_0FULL_HEADER, &yyvarsp->xlated_qry);
    	if (status != E_DB_OK)
        {
	    return (status);
        }

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = yyvarsp->join_id;

	/* Fill in "first n" & offset values. */
	tree->pst_firstn = yyvarsp->first_n;
/*
	if (tree->pst_firstn < 0)
	{
	    /* Parameterized first "n" - set flag and make positive. * 
	    tree->pst_mask1 |= PST_PARM_FIRSTN;
	    tree->pst_firstn = -tree->pst_firstn;
	}
*/

	tree->pst_offsetn = yyvarsp->offset_n;
/*
	if (tree->pst_offsetn < 0)
	{
	    /* Parameterized offset "n" - set flag and make positive. * 
	    tree->pst_mask1 |= PST_PARM_OFFSETN;
	    tree->pst_offsetn = -tree->pst_offsetn;
	}
*/

	if (yyvarsp->first_n != (PST_QNODE *) NULL && cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* No "select first n ..." allowed in Star queries. */
	    (VOID) psf_error(E_PS091F_STAR_NO_FIRSTN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Make sure the statement header gets updated later for cursor.*/
	if (psq_cb->psq_mode != PSQ_DEFCURS && cb->pss_defqry != PSQ_PREPARE)
	{
	    psq_cb->psq_pnode = (PTR) NULL;
	}
	else
	    psq_cb->psq_pnode = (PTR) pnode;

	/* Fix the root in QSF */
	if (pnode != (PST_PROCEDURE *) NULL)
	{
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}

        yacc_cb->yyval.psl_qttype = tree;
    } break;

case 1317:
if (!((*yyvarspp)->bypass_actions))
/* # line 26953 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	yyvarsp->save_pss_rsdmno = cb->pss_rsdmno;
	yyvarsp->save_psq_mode = psq_cb->psq_mode;
	status = psl_push_yyvars(psq_cb, cb, yyvarspp);
	if (DB_FAILURE_MACRO(status))
		return(status);
	yyvarsp = *yyvarspp;
    } break;

case 1318:
if (!((*yyvarspp)->bypass_actions))
/* # line 26964 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_J_MASK	*mask;
	DB_STATUS	status;
	PSS_RNGTAB	*resrange;

	/* Add with list element to range table. Note scope is 
	** pss_qualdepth+1, because the "subselect" production decrements
	** it before we can add with list element to the range table. */
	status = psl_drngent(&cb->pss_auxrng, cb->pss_qualdepth+1,
		yacc_cb->yypvt[-6].psl_strtype, cb, &resrange, yacc_cb->yypvt[-1].psl_trtype, PST_WETREE, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_ses_flag |= PSS_WITHELEM_INQ;	/* note WITH clause in qry */

	/* And now restore the outer yyvarsp, since recursion is done. 
	**
	** This is done ahead of the dcol_list analysis, since the dcol_list
	** (if any) was built before we pushed the previous YYVARS ptr. */
	
	yyvarsp->prev_yyvarsp->join_id = yyvarsp->join_id;	/* join_id persists */

	if (yyvarsp->nonupdt)
	{
	    /* Propagate non-updateability to containing query. */
	    yyvarsp->prev_yyvarsp->nonupdt = TRUE;
	    yyvarsp->prev_yyvarsp->nonupdt_reason |= yyvarsp->nonupdt_reason;
	}

	yyvarsp = *yyvarspp = yyvarsp->prev_yyvarsp;
	cb->pss_rsdmno = yyvarsp->save_pss_rsdmno;	/* restore */
	psq_cb->psq_mode = yyvarsp->save_psq_mode;	/* ditto */

	/* If there was an override column list, check here that the 
	** count is right, and replace the column names. */
	if (yyvarsp->dcol_list.queue.q_next != (QUEUE *)&yyvarsp->dcol_list)
	{
	    PSY_COL	*psy_col;
	    i4		i, err_code;

	    for (i = 1, psy_col = (PSY_COL *)yyvarsp->dcol_list.queue.q_prev;
		i <= resrange->pss_tabdesc->tbl_attr_count && 
				psy_col != (PSY_COL *)&yyvarsp->dcol_list;
		i++, psy_col = (PSY_COL *)psy_col->queue.q_prev)
	    {
		MEcopy((char *)psy_col->psy_colnm.db_att_name, 
		    sizeof(DB_ATT_NAME), 
		    (char *)resrange->pss_attdesc[i]->att_name.db_att_name);
	    }

	    if (resrange->pss_tabdesc->tbl_attr_count >= i ||
		psy_col != (PSY_COL *)&yyvarsp->dcol_list)
	    {
		/* Count of override column names is incorrect - error. */
		(VOID) psf_error(2157L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    sizeof(DB_TAB_NAME),
		    resrange->pss_rgname);
		return (E_DB_ERROR);
	    }
	}

	/*
	** Correlation name was explicitly specified, set a bit in
	** resrange->pss_var_mask
	*/
	resrange->pss_var_mask |= PSS_EXPLICIT_CORR_NAME;

	BTset(resrange->pss_rgno, (char*) &yyvarsp->flists[cb->pss_qualdepth]);

        if (cb->pss_qualdepth == 1)
        {
            if (BTcount((char *)&yyvarsp->flists[cb->pss_qualdepth], PST_NUMVARS) > 1)
            {
                /*
                ** FROM-list in the outermost subselect involves more than one
                ** relation - query will not be updateable
                */
                yyvarsp->nonupdt = TRUE;
                yyvarsp->nonupdt_reason |= PSS_MULT_VAR_IN_OUTERMOST_SUBSEL;
            }
            else if (psq_cb->psq_mode == PSQ_VIEW && !yyvarsp->nonupdt)
            {
                /*
                ** remember address of the range variable representing the new
                ** view's simply underlying table
                */
                yyvarsp->underlying_rel = resrange;
            }
        }

	/*
	** save the address for future dereferencing.  Now, given range number,
	** I will get the pointer to a range variable without having to scan the
	** entire table
	*/
	yyvarsp->rng_vars[resrange->pss_rgno] = resrange;

	/*
	** productions such as integtbl may need to know thr value of
	** rngvar_info
	*/
	yyvarsp->rngvar_info = PSS_USR_OBJ;
	
	/* Allocate PST_J_MASK to define this table to rest of parse. */
        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEfill(sizeof(PST_J_MASK), '\0', (PTR)mask);
	BTset(resrange->pss_rgno, (char *) mask);

	/*
	** we keep track of the tables in the FROM list to make sure that there
	** are no correlated queries appearing in the join_search condition of
	** the FROM list which involve tables from the same FROM list
	*/
	BTor(PST_NUMVARS, (char *)mask, (char *)&yyvarsp->join_tbls);
    } break;

case 1319:
if (!((*yyvarspp)->bypass_actions))
/* # line 27090 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-2].psl_tytype;
	/* $$ = ($1 != -1) ? $1 : ($2 != -1) ? $2 : $3;
					/* first value != -1, else -1 */
    } break;

case 1320:
if (!((*yyvarspp)->bypass_actions))
/* # line 27105 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* updcollst point to the root of RESDOM tree with
	** names of columns named in the FOR UPDATE clause.
	*/
	yyvarsp->updcollst = yacc_cb->yypvt[-0].psl_trtype;

	/* FOR UPDATE + SCROLL = KEYSET */
	if (cb->pss_stmt_flags & PSS_SCROLL)
	{
	    if (yacc_cb->yypvt[-3].psl_tytype == 1)
	    {
		i4	err_code;
		/* Explicitly declared DEFERRED KEYSET cur not supported. */
		(VOID) psf_error(2230L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    cb->pss_stmt_flags |= PSS_KEYSET;
	    yacc_cb->yyval.psl_tytype = 2;			/* KEYSET ==> DIRECT */
	}
	else yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-3].psl_tytype;
    } break;

case 1321:
if (!((*yyvarspp)->bypass_actions))
/* # line 27130 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* FOR UPDATE + SCROLL = KEYSET */
	if (cb->pss_stmt_flags & PSS_SCROLL)
	{
	    if (yacc_cb->yypvt[-1].psl_tytype == 1)
	    {
		i4	err_code;
		/* Explicitly declared DEFERRED KEYSET cur not supported. */
		(VOID) psf_error(2230L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    cb->pss_stmt_flags |= PSS_KEYSET;
	    yacc_cb->yyval.psl_tytype = 2;			/* KEYSET ==> DIRECT */
	}
	else yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-1].psl_tytype;

	/*
	** remember that FOR [DIRECT|DEFERRED] UPDATE without <column name list>
	** has been specified.
	*/

	cb->pss_stmt_flags |= PSS_IMPL_COL_LIST_IN_DECL_CURS;
	yyvarsp->updcollst = (PST_QNODE *) NULL;

    } break;

case 1322:
if (!((*yyvarspp)->bypass_actions))
/* # line 27161 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = 1;
    } break;

case 1323:
if (!((*yyvarspp)->bypass_actions))
/* # line 27165 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = 2;
    } break;

case 1324:
if (!((*yyvarspp)->bypass_actions))
/* # line 27169 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	extern PSF_SERVBLK	*Psf_srvblk;
	
	/*
	** Ordinarilym DEFERRED UPDATE  is the default.  However, at server
	** startup we could be told that the default mode of an updatable cursor
	** is DIRECT, in which case we must act as if DIRECT was specified
	*/
	yacc_cb->yyval.psl_tytype = (Psf_srvblk->psf_flags & PSF_DEFAULT_DIRECT_CURSOR) ? 2 : 1;

	if (cb->pss_stmt_flags & PSS_SCROLL)
	    yacc_cb->yyval.psl_tytype = 2;			/* scrollable trumps deferred */
    } break;

case 1325:
if (!((*yyvarspp)->bypass_actions))
/* # line 27185 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Same trick is used as with group by to save range table scope
	** around order by analysis. */
	yyvarsp->ordby_qd = cb->pss_qualdepth;
	cb->pss_qualdepth += (MAXI1 + 1);
	yyvarsp->in_orderby = TRUE;
	psq_cb->psq_ret_flag |= PSQ_PARSING_ORDER_BY;	/* needed for FIRST */
    } break;

case 1326:
if (!((*yyvarspp)->bypass_actions))
/* # line 27194 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** Mark this SELECT stmnt as non-updatable
	** Note that ORDER BY can only occur in the outermost SUBSELECT, if at
	** all.
	*/
	yyvarsp->nonupdt = TRUE;
	yyvarsp->nonupdt_reason |= PSS_ORDER_BY_IN_OUTERMOST_SUBSEL;
	yyvarsp->in_orderby = FALSE;
	psq_cb->psq_ret_flag &= ~PSQ_PARSING_ORDER_BY;	/* needed for FIRST */
	cb->pss_qualdepth = yyvarsp->ordby_qd;
	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 1327:
if (!((*yyvarspp)->bypass_actions))
/* # line 27208 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = -1;
    } break;
	}
	return(0);
}

i4
psls26iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1328:
if (!((*yyvarspp)->bypass_actions))
/* # line 27214 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	ilen, ival;
	PTR	cptr;
	i4	err_code;

	/* Check for "first n" in wrong place (can only be in first select
	** of a query and NOT in create view). */
	if (cb->pss_qualdepth > 1 || psq_cb->psq_mode == PSQ_VIEW ||
		(yyvarsp->nonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL))
	{
	    (VOID) psf_error(2156L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* No "select first n ..." allowed in Star queries. */
	    (VOID) psf_error(E_PS091F_STAR_NO_FIRSTN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Now verify constant type, or that the offset value is a 
	** procedure parameter or repeat query host variable. */
	if (abs(yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE ||
		(ilen = yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_length) > 5 ||
		ilen < 2)
	{
	    (VOID) psf_error(2158L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}

	/* ... and that the value is in range, if it's a constant. */
	if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_cnst.pst_tparmtype == PST_USER)
	{
	    ival = (ilen == 2) ? *((i2 *)yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_data) :
			*((i4 *)yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_data);
	    if (ival < 0)
	    {
		(VOID) psf_error(2165L, 0L, PSF_USERERR, &err_code, 
		    &psq_cb->psq_error);
		return(E_DB_ERROR);
	    }
	}

	yyvarsp->offset_n = yacc_cb->yypvt[-0].psl_trtype;
	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 1329:
if (!((*yyvarspp)->bypass_actions))
/* # line 27266 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = -1;
    } break;

case 1330:
if (!((*yyvarspp)->bypass_actions))
/* # line 27272 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	ilen, ival;
	PTR	cptr;
	i4	err_code;

	/* Make sure he hasn't already coded "select first n ...". */
	if (yyvarsp->first_n != (PST_QNODE *) NULL)
	{
	    (VOID) psf_error(2159L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}

	/* Check for "first n" in wrong place (can only be in first select
	** of a query and NOT in create view). */
	if (cb->pss_qualdepth > 1 || psq_cb->psq_mode == PSQ_VIEW ||
		(yyvarsp->nonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL))
	{
	    (VOID) psf_error(2156L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* No "select first n ..." allowed in Star queries. */
	    (VOID) psf_error(E_PS091F_STAR_NO_FIRSTN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Now verify constant type, or that the first n value is a 
	** procedure parameter or repeat query host variable. */
	if (abs(yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE ||
		(ilen = yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_dataval.db_length) > 5 ||
		ilen < 2)
	{
	    (VOID) psf_error(2158L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}

	/* ... and that the value is in range, if it's a constant. */
	if (yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_value.pst_s_cnst.pst_tparmtype == PST_USER)
	{
	    ival = (ilen == 2) ? *((i2 *)yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_dataval.db_data) :
			*((i4 *)yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_dataval.db_data);
	    if (ival <= 0)
	    {
		(VOID) psf_error(2164L, 0L, PSF_USERERR, &err_code, 
		    &psq_cb->psq_error);
		return(E_DB_ERROR);
	    }
	}

	yyvarsp->first_n = yacc_cb->yypvt[-2].psl_trtype;
	yacc_cb->yyval.psl_tytype = 0;
    } break;

case 1331:
if (!((*yyvarspp)->bypass_actions))
/* # line 27333 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = -1;
    } break;

case 1332:
if (!((*yyvarspp)->bypass_actions))
/* # line 27339 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "first") != 0)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    } break;

case 1336:
if (!((*yyvarspp)->bypass_actions))
/* # line 27353 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype; } break;

case 1337:
if (!((*yyvarspp)->bypass_actions))
/* # line 27355 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype; } break;

case 1342:
if (!((*yyvarspp)->bypass_actions))
/* # line 27367 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;
	bool	conflict = FALSE;

	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "flatten") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOFLATTEN)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_FLATTEN;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "noflatten") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_FLATTEN)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOFLATTEN;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "ojflatten") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOOJFLATTEN)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_OJFLATTEN;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "noojflatten") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_OJFLATTEN)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOOJFLATTEN;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "greedy") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOGREEDY)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_GREEDY;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "nogreedy") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_GREEDY)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOGREEDY;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "hash") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOHASH)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_HASH;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "nohash") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_HASH)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOHASH;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "keyj") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOKEYJ)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_KEYJ;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "nokeyj") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_KEYJ)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOKEYJ;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "parallel") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOPARALLEL)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_PARALLEL;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "noparallel") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_PARALLEL)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOPARALLEL;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "qep") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOQEP)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_QEP;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "noqep") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_QEP)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOQEP;
	}
	else
	{
	    (VOID) psf_error(5989L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}

	if (conflict)
	{
	    (VOID) psf_error(5990L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}
    } break;

case 1343:
if (!((*yyvarspp)->bypass_actions))
/* # line 27475 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Forces the FROM clause order on the join tree. */
	cb->pss_hint_mask |= PST_HINT_ORDER;
    } break;

case 1345:
if (!((*yyvarspp)->bypass_actions))
/* # line 27481 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_HINTENT	*hintp;

	/* Forces the use of a specific index to access a base table. */
	if (cb->pss_hintcount < PST_NUMVARS)
	{
	    hintp = &cb->pss_tabhint[cb->pss_hintcount++];
	    hintp->pss_hintcode = PST_THINT_INDEX;
	    STmove(yacc_cb->yypvt[-3].psl_strtype, ' ', sizeof(DB_TAB_NAME), 
				(char *)&hintp->pss_tabname1.db_tab_name);
	    STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', sizeof(DB_TAB_NAME), 
				(char *)&hintp->pss_tabname2.db_tab_name);
	}
    } break;

case 1346:
if (!((*yyvarspp)->bypass_actions))
/* # line 27496 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_HINTENT	*hintp;

	/* Forces specific join techniques on a pair of tables. Address
	** next hint table entry, copy the table names and look for the 
	** keyword. */
	if (cb->pss_hintcount < PST_NUMVARS)
	{
	    hintp = &cb->pss_tabhint[cb->pss_hintcount++];
	    STmove(yacc_cb->yypvt[-3].psl_strtype, ' ', sizeof(DB_TAB_NAME), 
				(char *)&hintp->pss_tabname1.db_tab_name);
	    STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', sizeof(DB_TAB_NAME), 
				(char *)&hintp->pss_tabname2.db_tab_name);
	    if (STcompare(yacc_cb->yypvt[-5].psl_strtype, "fsmj") == 0)
		hintp->pss_hintcode = PST_THINT_FSMJ;
	    else if (STcompare(yacc_cb->yypvt[-5].psl_strtype, "hashj") == 0)
		hintp->pss_hintcode = PST_THINT_HASHJ;
	    else if (STcompare(yacc_cb->yypvt[-5].psl_strtype, "keyj") == 0)
		hintp->pss_hintcode = PST_THINT_KEYJ;
	    else if (STcompare(yacc_cb->yypvt[-5].psl_strtype, "psmj") == 0)
		hintp->pss_hintcode = PST_THINT_PSMJ;
	    else cb->pss_hintcount--;
	}
    } break;

case 1347:
if (!((*yyvarspp)->bypass_actions))
/* # line 27523 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE   *ss, *res, *thead;
	i4	    err_code;
	bool	    first = TRUE;

	/* Update target list in the session ctrl block for
	** ORDER BY clause processing.
	*/
	cb->pss_tlist = yacc_cb->yypvt[-0].psl_trtype->pst_left;

	/* If in DB procedure, check all target lists to make sure that
	** the leftmost query term references only local vars and
	** target lists of other terms do not reference local vars.
	** If the INTO clause has been used, for the first subselect
	** check the target list corresponding to the clause rather
	** than the target list.
	*/
	if (yyvarsp->isdbp == TRUE)
	{
	    /* For every query term */
	    for (ss = yacc_cb->yypvt[-0].psl_trtype; ss != (PST_QNODE *) NULL;
		 ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		)
	    {
		thead = ss->pst_left;

		if (first && yyvarsp->dbpinfo->pss_into_clause != (PST_QNODE *) NULL)
		{
		    thead = yyvarsp->dbpinfo->pss_into_clause;
		}

		/* Check the target list */
		for (res = thead;
		     res != (PST_QNODE *) NULL;
		     res = res->pst_left)
		{
		    /* See if end of the target list. */
		    if (res->pst_sym.pst_type == PST_TREE)
			break;

		    if (first && 
			res->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
			    != PST_LOCALVARNO &&
			!(cb->pss_stmt_flags & PSS_PARSING_INSERT_SUBSEL)
		       )
		    {
			/* Illegal resdom found */
			(VOID) psf_error(2412L, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 2,
			    sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(DB_MAXNAME,
				res->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			    res->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
			return (E_DB_ERROR);
		    }

		    if (!first &&
			res->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
			    == PST_LOCALVARNO
			)
		    {
			/* Illegal resdom found */
			(VOID) psf_error(2430L, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 2,
			    sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(DB_MAXNAME,
				res->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			    res->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
			return (E_DB_ERROR);
		    }
		}

		if (first)
		{
		    first = FALSE;
		}
	    }
	}
    } break;

case 1348:
if (!((*yyvarspp)->bypass_actions))
/* # line 27605 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* For the INTO clause processing remember
	** that we have already seen the first subselect.
	*/
	if (yyvarsp->isdbp == TRUE)
	{
	    yyvarsp->dbpinfo->pss_flags |= PSS_1SUB_SEEN;
	}

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1349:
if (!((*yyvarspp)->bypass_actions))
/* # line 27617 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*ss;
	i4		err_code;

	if (yyvarsp->seq_ops)
	{
	    /* No use of sequences in union selects. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/*
	** We will allow mixing of UNION and UNION ALL in a query expression.
	** UNION found in an expresion will result in duplicates being
	** eliminated in all terms of the expression, evenm if the user
	** specified UNION ALL in some of query terms comprising the expression
	*/

	/*
	** Find last subselect node in the union linked list.
	** If UNION was specified, we need to change PST_ALLDUPS to PST_NODUPS
	** in all elements of the union list
	*/
	if (yacc_cb->yypvt[-1].psl_tytype == PST_NODUPS)
	{
	    for (ss = yacc_cb->yypvt[-2].psl_trtype;
		 ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next;
		 ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		)
	    {
		ss->pst_sym.pst_value.pst_s_root.pst_union.pst_dups =
		    PST_NODUPS;
	    }
	}
	else
	{
	    for (ss = yacc_cb->yypvt[-2].psl_trtype;
		 ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next;
		 ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		)
	    ;
	}

	ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next = yacc_cb->yypvt[-0].psl_trtype;
	ss->pst_sym.pst_value.pst_s_root.pst_union.pst_dups = yacc_cb->yypvt[-1].psl_tytype;

	/*
	** If UNION was specified, we need to change PST_ALLDUPS to PST_NODUPS
	** in all elements of the list being appended to the union list;
	** remember, that we do not set pst_dups in the last element of the list
	*/
	if (yacc_cb->yypvt[-1].psl_tytype == PST_NODUPS)
	{
	    for (ss = yacc_cb->yypvt[-0].psl_trtype;
		 ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next;
		 ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		)
	    {
		ss->pst_sym.pst_value.pst_s_root.pst_union.pst_dups =
		    PST_NODUPS;
	    }
	}

	/* Only try to resolve the union if we have not seen any parameters. */
	if (cb->pss_highparm == -1 || cb->pss_defqry != PSQ_PREPARE)
	{
	    status = pst_union_resolve(cb, yacc_cb->yypvt[-2].psl_trtype, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-2].psl_trtype;
    } break;

case 1350:
if (!((*yyvarspp)->bypass_actions))
/* # line 27695 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	register PST_QNODE  *t;
	i4		    err_code;

	/* check for illegal use of VLUPs */
	if (yyvarsp->check_for_vlups)
	{
	    for (t = yacc_cb->yypvt[-0].psl_trtype->pst_left;
	         (t != (PST_QNODE *) NULL && t->pst_sym.pst_type == PST_RESDOM);
		 t = t->pst_left)
	    {
		if (t->pst_sym.pst_dataval.db_length == ADE_LEN_UNKNOWN)
		{
		    /*
		    ** We are in the outermost subselect.
		    ** If db_length of PST_RESDOM node is ADE_LEN_UNKNOWN,
		    ** we must be dealing with illegal usage of VLUPs.
		    */
		    (VOID) psf_error(2218L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
		    return(E_DB_ERROR);
		}
	    }
	}

	yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type = PST_ROOT;
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1351:
if (!((*yyvarspp)->bypass_actions))
/* # line 27724 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 1352:
if (!((*yyvarspp)->bypass_actions))
/* # line 27730 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        /* Mark this SELECT stmnt as non-updatable */
        if (cb->pss_qualdepth == 0 ||
		cb->pss_qualdepth == 1 && yyvarsp->prev_yyvarsp)
        {
            yyvarsp->nonupdt = TRUE;
            yyvarsp->nonupdt_reason |= PSS_UNION_IN_OUTERMOST_SUBSEL;
        }

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1353:
if (!((*yyvarspp)->bypass_actions))
/* # line 27744 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PST_NODUPS;
    } break;

case 1354:
if (!((*yyvarspp)->bypass_actions))
/* # line 27748 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PST_NODUPS;
    } break;

case 1355:
if (!((*yyvarspp)->bypass_actions))
/* # line 27752 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PST_ALLDUPS;
    } break;

case 1356:
if (!((*yyvarspp)->bypass_actions))
/* # line 27758 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_SYMBOL	    *sym;
	PST_QNODE	    *rsdm;
	i4		    tuple_width = 0;
	bool		    check_num_attrs;
	bool		    check_tuple_width;
	DB_STATUS	    status;
	i4		    err_code;

	/*
	** if we are processing the outermost subselect of SELECT, 
	** CREATE TABLE AS SELECT, CREATE VIEW, or DGTT AS SELECT, we need to
	** verify that the width of the tuple represented by the target list
	** does not exceed DB_MAXTUP.  For TABLE AS SELECT, CREATE VIEW, or 
	** DGTT AS SELECT we also need to verify that the number of attributes 
	** does not exceed DB_MAX_COLS
	*/
	if (   cb->pss_qualdepth == 1
	    && (   psq_cb->psq_mode == PSQ_RETRIEVE
		   /* 
		   ** for CREATE TABLE/DGTT AS SELECT, query mode gets reset to
		   ** PSQ_RETINTO/PSQ_DGTT_AS_SELECT AFTER we are done 
		   ** processing the <query_expr>
		   */
		|| psq_cb->psq_mode == PSQ_CREATE 
		|| psq_cb->psq_mode == PSQ_DGTT
		|| psq_cb->psq_mode == PSQ_VIEW
	       )
	    && !(cb->pss_stmt_flags & PSS_PARSING_INSERT_SUBSEL)
	   )
	{
	    check_tuple_width = TRUE;

	    check_num_attrs = (psq_cb->psq_mode != PSQ_RETRIEVE);
	}
	else
	{
	    check_tuple_width = check_num_attrs = FALSE;
	}

	if (yyvarsp->seq_ops && yacc_cb->yypvt[-3].psl_inttype)
	{
	    /* No use of sequences in distinct selects. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* If "first n" was specified, assure that this is the outermost
	** select, both subselect-wise and union-wise, and that we're not
	** creating a view. 
	*/
	if (cb->pss_qualdepth == 1 && 
		!(yyvarsp->nonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL)) 
	    yyvarsp->first_n = yacc_cb->yypvt[-4].psl_trtype;

	/*
	** Now that we are done parsing the from list, complete building the
	** tree representing the target list
	*/

	sym = &yacc_cb->yypvt[-2].psl_trtype->pst_right->pst_sym;	/* symbol for RESDOM's right child */

	{
	    status = psl_p_tlist(&yacc_cb->yypvt[-2].psl_trtype, yyvarsp, cb, psq_cb);
	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }

	    if (check_tuple_width)
	    {
		/*
		** walk down the RESDOM nodes representing elements of the 
		** target spec and compute the width of the tuple represented 
		** by the target spec if we need to verify that the width of 
		** the tuple is within valid limits
		*/
	        for (rsdm = yacc_cb->yypvt[-2].psl_trtype; 
	             (rsdm && rsdm->pst_sym.pst_type != PST_TREE);
	             tuple_width += rsdm->pst_sym.pst_dataval.db_length,
	             rsdm = rsdm->pst_left)
	        ;
	    }
	}

	if (check_num_attrs && cb->pss_rsdmno > DB_MAX_COLS)
	{
	    char	command[PSL_MAX_COMM_STRING];
	    i4 	len;
	    i4		max_cols = DB_MAX_COLS;

	    psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, &len);

	    (VOID) psf_error(E_PS0BE0_TOO_MANY_COLS, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 3,
		len, (PTR) command,
		(i4) sizeof(cb->pss_rsdmno), (PTR) &cb->pss_rsdmno,
		(i4) sizeof(max_cols), (PTR) &max_cols);
	    return(E_DB_ERROR);
	}

	/*
	** We donot need to check the tuple_width here.
	** Leave it for opf, qef and dmf to decide.
	** This change is required for supporting increasing tuple size.
	*/
	/*
	if (check_tuple_width && tuple_width > DB_MAXTUP)
	{
	    char	command[PSL_MAX_COMM_STRING];
	    i4 	len;
	    i4		max_width = DB_MAXTUP;

	    psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, &len);

	    (VOID) psf_error(E_PS0BE1_TUPLE_TOO_WIDE, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 3,
		len, (PTR) command,
		(i4) sizeof(tuple_width), (PTR) &tuple_width,
		(i4) sizeof(max_width), (PTR) &max_width);
	    return(E_DB_ERROR);
	}
	*/
	if (status = pst_trfix(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_trtype, &psq_cb->psq_error))
	{
	    return (status);
	}

    } break;

case 1357:
if (!((*yyvarspp)->bypass_actions))
/* # line 27889 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PST_QNODE	    *rootnode;
	PST_QNODE	    *nodeptr;
	PST_QNODE	    *resdomnode;
	PST_QNODE	    *wherenode;
	PST_QNODE	    *byhead;
	PST_QNODE	    *bylist;
	PST_QNODE	    *agopnode;
	PST_QNODE	    *treenode;
	PST_QNODE	    *qual;
	PST_RT_NODE	    root;
	i4		    err_code;
	char		    emptycol[DB_MAXNAME];
	char		    colname[DB_MAXNAME + 2];
	i4		    tcount, hcount;
	YYAGG_NODE_PTR	    *agg_node,
			    *cur_agg_list =
				yyvarsp->agg_list_stack[cb->pss_qualdepth];
	bool		    empty_gb = TRUE;

	/* Process the INTO clause if present. */
	if (yacc_cb->yypvt[-5].psl_trtype != (PST_QNODE *) NULL)
	{
	    register PST_QNODE	*t, *h;

	    /* First we will verify whether number of resdoms is identical.
	    ** Both trees are PST_TREE terminated.
	    */
	    for (t = yacc_cb->yypvt[-6].psl_trtype, tcount = 0; t != (PST_QNODE *) NULL; t = t->pst_left)
	    {
		if (t->pst_sym.pst_type == PST_RESDOM)
		{
		    tcount++;
		}
	    }

	    for (h = yacc_cb->yypvt[-5].psl_trtype, hcount = 0; h != (PST_QNODE *) NULL; h = h->pst_left)
	    {
		if (h->pst_sym.pst_type == PST_RESDOM)
		{
		    hcount++;
		}
	    }

	    if (tcount != hcount)
	    {	/* not equal number of nodes */
		(VOID) psf_error(2427L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    /* Real processing for the node pairs.
	    ** Since both lists are of equal length, the for loop can be 
	    ** terminated when the end of any of the two lists is found.
	    */
	    for (t = yacc_cb->yypvt[-6].psl_trtype, h= yacc_cb->yypvt[-5].psl_trtype;
		 t != (PST_QNODE *) NULL;
		 t = t->pst_left, h = h->pst_left
		)
	    {
		if (t->pst_sym.pst_type == PST_RESDOM &&
		    h->pst_sym.pst_type == PST_RESDOM
		   )
		{
		    /* Process the pair */

		    /* `Move' pst_right trees to the local var resdom
		    ** tree.
		    */
		    h->pst_right = t->pst_right;

		    /* Patch resdom no. */
		    h->pst_sym.pst_value.pst_s_rsdm.pst_rsno =
			t->pst_sym.pst_value.pst_s_rsdm.pst_rsno;

		    /* Resolve data types for local vars. */
		    status = pst_parm_resolve(cb, psq_cb, h);
		    if (DB_FAILURE_MACRO(status))
			return(status);
		}
	    }

	    /* Remember the ptr to the true target list, do not update
	    ** the tree yet as we have to process the ORDER BY clause first.
	    */
	    yyvarsp->dbpinfo->pss_into_clause = yacc_cb->yypvt[-5].psl_trtype;
	}

	/*
	** Make sure that all resdoms have a name.
	*/
	(VOID) MEfill(DB_MAXNAME, ' ', (PTR) emptycol);

	for (resdomnode = yacc_cb->yypvt[-6].psl_trtype;
	     (resdomnode != (PST_QNODE *) NULL) &&
	     (resdomnode->pst_sym.pst_type != PST_TREE);
	     resdomnode = resdomnode->pst_left
	    )
	{
	    if(MEcmp((PTR)(resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
		(PTR) emptycol, DB_MAXNAME) == 0)
	    {
		STprintf(colname, "col%d",
		    resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_rsno);
		MEmove(STlength(colname), (PTR)colname, ' ',
		    DB_MAXNAME,
		    (PTR) resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname); 
	    }
	}

	/* other semantic checking. */

	/* Search group list for ordinals (like order by). Corresponding 
	** expressions must then be copied to group list. */
	if (yacc_cb->yypvt[-1].psl_trtype)
	{
	    PST_QNODE	*gptr, **lptr;
	    i4		dt_status;

	    status = E_DB_OK;

	    if (!((gptr = yacc_cb->yypvt[-1].psl_trtype)->pst_sym.pst_type == PST_GCL &&
		gptr->pst_right == (PST_QNODE *) NULL &&
		(gptr->pst_left == (PST_QNODE *) NULL ||
		    gptr->pst_left->pst_sym.pst_type == PST_TREE)))
		empty_gb = FALSE;

	    if (!empty_gb)
	     for (gptr = yacc_cb->yypvt[-1].psl_trtype; gptr && gptr->pst_sym.pst_type == PST_RESDOM;
						gptr = gptr->pst_left)
	    {
		if (gptr->pst_right->pst_sym.pst_type == PST_CONST)
		{
		    status = psl_ordGroup(cb, psq_cb, gptr, yacc_cb->yypvt[-6].psl_trtype);
		    if (status != E_DB_OK)
		    {
                        if ( psq_cb->psq_error.err_code !=
                                   E_PS03AB_AGGR_IN_GROUP_BY )
                        {
                            (VOID) psf_error(2932L, 0L, PSF_USERERR, &err_code,
                                   &psq_cb->psq_error, 1, (i4)sizeof(cb->pss_lineno),
                                   &cb->pss_lineno);
                        }
                        else
                        {
                            /* b109012 */
                            (VOID) psf_error(E_PS03AB_AGGR_IN_GROUP_BY, 0L, PSF_USERERR,
                                   &err_code, &psq_cb->psq_error, 0);
                        }
                        return (E_DB_ERROR);

		    }
		}

		/* Then, assure groupby elements are groupable types. */
		status = adi_dtinfo((ADF_CB *)cb->pss_adfcb, 
		    gptr->pst_sym.pst_dataval.db_datatype,
		    &dt_status);
		if (status != E_DB_OK) return(status);
		if (dt_status & AD_NOSORT)
		{
		    char	name[33];
		    i4		err_code;
		    /* Copy column name (if any) and issue message. */
		    name[0] = name[32] = 0x0;
		    if (gptr->pst_right->pst_sym.pst_type == PST_VAR)
	        	MEcopy((PTR)&gptr->pst_right->pst_sym.pst_value.
			    pst_s_var.pst_atname,
	                    DB_MAXNAME, (PTR)&name);
	            (VOID) psf_error(2181L, 0L, PSF_USERERR, &err_code,
	                &psq_cb->psq_error, 1,(i4) STtrmwhite(name), name);
	            return (E_DB_ERROR);
        	}
	    }
	    /* Having replaced all the group-by ordinals with real variables
	    ** and expressions, any constants remaining are simply values,
	    ** which should be removed.  They're a waste of time trying to 
	    ** group by (since they're constant) and they confuse the opa_suck
	    ** routines.  (kibro01) b119299 (also see bug 114883)
	    */
	    if (!empty_gb)
	    {
		i4 cnt = 0;
		gptr = yacc_cb->yypvt[-1].psl_trtype;
		lptr = &yacc_cb->yypvt[-1].psl_trtype;
		while (gptr)
		{
		    if (gptr->pst_sym.pst_type != PST_RESDOM)
			break;
		    if (gptr->pst_right->pst_sym.pst_type == PST_CONST)
		    {
			*lptr=gptr->pst_left;
		    } else
		    {
			lptr=&gptr->pst_left;
			cnt++;
		    }
		    gptr=gptr->pst_left;
		}
		for (gptr = yacc_cb->yypvt[-1].psl_trtype; gptr; gptr=gptr->pst_left)
		{
		    if (gptr->pst_sym.pst_type != PST_RESDOM)
			break;
		    gptr->pst_sym.pst_value.pst_s_rsdm.pst_rsno = cnt--;
		}
	    }
	}

	/* If there is a group by clause,
	** check that the columns or expressions in the target list exactly
	** match columns or expressions in the group list or are in an aggregate 
	** function.
	*/
	/* if group by or having or aggs, select can only include set functions
	** and grouping columns
	*/
	if (yacc_cb->yypvt[-1].psl_trtype || yacc_cb->yypvt[-0].psl_trtype || cur_agg_list != (YYAGG_NODE_PTR *) NULL)
	{
	    if (status = psl_ting(yacc_cb->yypvt[-6].psl_trtype, yacc_cb->yypvt[-1].psl_trtype))
	    {
		(VOID) psf_error(2915L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	}

	/*
	** If the FROM list contained any joins, merge the join_search quals
	** with the qualification of the subselect
	*/

	if (yyvarsp->j_qual->pss_qual != (PST_QNODE *) NULL)
	{
	    if (!yacc_cb->yypvt[-2].psl_trtype || yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_type == PST_QLEND)
	    {
		qual = yyvarsp->j_qual->pss_qual;
	    }
	    else
	    {
		status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_trtype, yyvarsp->j_qual->pss_qual,
		    PST_AND, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0,
		    (i4) 0, (DB_ANYTYPE *) NULL, &qual, &psq_cb->psq_error,
		    (i4) 0);
		if (status != E_DB_OK)
		    return (status);
	    }
	}
	else
	{
	    qual = yacc_cb->yypvt[-2].psl_trtype;
	}
	
	/* if group by, build agg function, attach having */
	if ((yacc_cb->yypvt[-1].psl_trtype) && !empty_gb && cur_agg_list != (YYAGG_NODE_PTR *) NULL)
	{
	    for (agg_node = cur_agg_list;
	         agg_node;
		 agg_node = agg_node->agg_next)
	    {
		/* copy where clause and add to aghead */
		if (agg_node->agg_next)
		{
		    yyvarsp->dup_rb.pss_tree = qual;
		    yyvarsp->dup_rb.pss_dup  = &wherenode;
		    status = pst_treedup(cb, &yyvarsp->dup_rb);

		    if (status != E_DB_OK)
			return (status);
		    agg_node->agg_node->pst_right = wherenode;
		}
		else
		    agg_node->agg_node->pst_right = qual;
		/* create the bylist */
		if (agg_node->agg_next)
		{
		    yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-1].psl_trtype;
		    yyvarsp->dup_rb.pss_dup  = &bylist;
		    status = pst_treedup(cb, &yyvarsp->dup_rb);

		    if (status != E_DB_OK)
			return (status);
		}
		else
		    bylist = yacc_cb->yypvt[-1].psl_trtype;
		
		/* Create the byhead node */
		agopnode = agg_node->agg_node->pst_left;

		/* But first, if aggop's parm is not null and it is NOT an
		** OLAP binary aggregate function, change aggop
		** result (and BYHEAD and AGHEAD) to not null, too. This
		** improves ADF buffer alignment during code generation. */
		/* STDDEV_SAMP allows a null return even if a single row
		** is returned, so this optimisation must be removed for
		** that one case (kibro01) b119374
		*/
		if (agopnode->pst_left && 
		    agopnode->pst_left->pst_sym.pst_dataval.db_datatype > 0 &&
		    agopnode->pst_sym.pst_dataval.db_datatype < 0 &&
		    agopnode->pst_right == NULL &&
		    agopnode->pst_sym.pst_value.pst_s_op.pst_opinst !=
			ADFI_845_STDDEV_SAMP_FLT)
		{
		    agopnode->pst_sym.pst_dataval.db_datatype =
			abs(agopnode->pst_sym.pst_dataval.db_datatype);
		    agopnode->pst_sym.pst_dataval.db_length--;
		    agg_node->agg_node->pst_sym.pst_dataval.db_datatype =
			agopnode->pst_sym.pst_dataval.db_datatype;
		    agg_node->agg_node->pst_sym.pst_dataval.db_length--;
		}
		status = pst_node(cb, &cb->pss_ostream, bylist, agopnode, 
		    PST_BYHEAD, (PTR) NULL, sizeof(PST_RSDM_NODE), 
		    agopnode->pst_sym.pst_dataval.db_datatype,
		    agopnode->pst_sym.pst_dataval.db_prec, 
		    agopnode->pst_sym.pst_dataval.db_length, 
		    (DB_ANYTYPE *) NULL,
		    &byhead, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);
		}

		/* attach byhead to aghead */
		agg_node->agg_node->pst_left = byhead;

		/* Create the tree, PST_TREE, node */
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, 
		    (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &treenode,
		    &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);
		}

		/* Prepend the tree node to the aggregate result domain list */
		byhead = pst_tlprpnd(treenode, byhead);
	    }
	    /* since where clause has been added to aghead nodes, don't
	    ** add to bulk of query.
	    */

	    /* Create a QLEND node. */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &(qual), &psq_cb->psq_error,
		(i4) 0);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }
	}
	/* move where clause to simple aggregates */
	else if (cur_agg_list != (YYAGG_NODE_PTR *) NULL)
	{
	    for (agg_node = cur_agg_list;
		 agg_node; 
		 agg_node = agg_node->agg_next)
	    {
		/* copy where clause and add to aghead */
		if (agg_node->agg_next)
		{
		    yyvarsp->dup_rb.pss_tree = qual;
		    yyvarsp->dup_rb.pss_dup  = &wherenode;
		    status = pst_treedup(cb, &yyvarsp->dup_rb);

		    if (status != E_DB_OK)
			return (status);
		    agg_node->agg_node->pst_right = wherenode;
		}
		else
		    agg_node->agg_node->pst_right = qual;
	    }

	    /* Create a QLEND node. */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &(qual), &psq_cb->psq_error,
		(i4) 0);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }
	}

	/* Make the subselect node */
	root.pst_rtuser = FALSE;
	root.pst_union.pst_next  = 0;
	/* Tell whether retrieve unique. If explicit or if
	** group by and no aggregate functions.
	*/
	if (yacc_cb->yypvt[-7].psl_inttype ||
	    ((cur_agg_list == (YYAGG_NODE_PTR *) NULL)
	     && (yacc_cb->yypvt[-1].psl_trtype != (PST_QNODE*) NULL)))
	{
	    root.pst_dups = PST_NODUPS;
	}
	else
	    root.pst_dups = PST_ALLDUPS;

	MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&yyvarsp->from_list);
	/* if no from list, better not find where, groupby or having */
	if (BTcount((char *)&yyvarsp->from_list, PST_NUMVARS) == 0 &&
	    ((qual && qual->pst_sym.pst_type != PST_QLEND)
	    || yacc_cb->yypvt[-1].psl_trtype || yacc_cb->yypvt[-0].psl_trtype))
	{
	    (VOID) psf_error(2922L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);

	}
	MEcopy((char *)&yyvarsp->from_list, sizeof(PST_J_MASK),
					(char *)&root.pst_tvrm);
	root.pst_tvrc = 
	    BTcount((char*) &yyvarsp->from_list, BITS_IN(yyvarsp->from_list));
	/* set from list in aghead nodes */
	for (agg_node = cur_agg_list; agg_node; agg_node = agg_node->agg_next)
	{
	    MEcopy((char *)&root.pst_tvrm, sizeof(PST_J_MASK),
		(char *)&agg_node->agg_node->pst_sym.pst_value.
						pst_s_root.pst_tvrm);
	    agg_node->agg_node->pst_sym.pst_value.pst_s_root.pst_tvrc =
		root.pst_tvrc;
	}

	if (yyvarsp->in_update_set_clause || yyvarsp->in_target_clause || 
		yyvarsp->in_groupby_clause)
	{
	    /* As yet unsupported scalar subselect. */
	    i4		err_code;

	    (VOID) psf_error(5121L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** Make the data value of the subselect node identical to that
	** of the first resdom.
	*/

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-6].psl_trtype, qual,
	    PST_SUBSEL, (PTR) &root, sizeof(PST_RT_NODE),
	    yacc_cb->yypvt[-6].psl_trtype->pst_sym.pst_dataval.db_datatype,
	    yacc_cb->yypvt[-6].psl_trtype->pst_sym.pst_dataval.db_prec, yacc_cb->yypvt[-6].psl_trtype->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/*
	** provide OPF with indication of whether correlated variables were used
	** in this subselect
	*/
	if (BTtest(cb->pss_qualdepth, (char *) yyvarsp->correlation_mask))
	{
	    rootnode->pst_sym.pst_value.pst_s_root.pst_mask1 =
		PST_1CORR_VAR_FLAG_VALID | PST_2CORR_VARS_FOUND;
	}
	else
	{
	    rootnode->pst_sym.pst_value.pst_s_root.pst_mask1 =
		PST_1CORR_VAR_FLAG_VALID;
	}

	if (yyvarsp->mult_corr_attrs.depth == cb->pss_qualdepth)
	{
	    /*
	    ** if we were looking for multiple correlated relation references
	    ** because we have encountered COUNT in the target list of a nested
	    ** subselect, check if we did and reset depth
	    */
	    if (yyvarsp->mult_corr_attrs.found)
	    {
		cb->pss_flattening_flags |= PSS_MULT_CORR_ATTRS;
	    }

	    yyvarsp->mult_corr_attrs.depth = -1;
	}

	if (yyvarsp->corr_aggr.depth == cb->pss_qualdepth)
	{
	    /*
	    ** if we were looking for correlated references because we have
	    ** encountered an aggregate in the target list of this subselect,
	    ** check if we found any and reset depth
	    */
	    if (yyvarsp->corr_aggr.found)
	    {
		cb->pss_flattening_flags |= PSS_CORR_AGGR;
	    }

	    yyvarsp->corr_aggr.depth = -1;
	}

	cb->pss_qualdepth--;
	/* if no set function and a group by clause, add the group by clause
	** to the target list as non-printing resdoms (for sorting).
	*/
	if (cur_agg_list == (YYAGG_NODE_PTR *) NULL && yacc_cb->yypvt[-1].psl_trtype != (PST_QNODE *) NULL)
	{
	    i4		cur_resno;

	    yyvarsp->sort_list = (PST_QNODE*) NULL;
	    cur_resno =	yacc_cb->yypvt[-6].psl_trtype->pst_sym.pst_value.pst_s_rsdm.pst_rsno;
	    /* append the resdoms to the target list */
	    yacc_cb->yypvt[-6].psl_trtype = pst_tlprpnd(yacc_cb->yypvt[-6].psl_trtype, yacc_cb->yypvt[-1].psl_trtype);

	    /* make the recently added nodes non-printing.
	    ** add sort nodes for them.
	    */
	    for (nodeptr = yacc_cb->yypvt[-6].psl_trtype;
		 nodeptr->pst_sym.pst_value.pst_s_rsdm.pst_rsno > cur_resno;
		 nodeptr = nodeptr->pst_left)
	    {
		nodeptr->pst_sym.pst_value.pst_s_rsdm.pst_rsflags &= ~PST_RS_PRINT;
	    }
	}
	/* go down target list,having list if agg in tree, build aggregate */
	/* attach having clause to where clause */
	if (yacc_cb->yypvt[-0].psl_trtype != (PST_QNODE*) NULL)
	{
	    ADI_OP_ID	opno;
	    ADI_OP_ID	left_opno = (ADI_OP_ID) 0;

	    opno = yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_op.pst_opno;
	    if (yacc_cb->yypvt[-0].psl_trtype->pst_left && (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_NOT))
		left_opno = yacc_cb->yypvt[-0].psl_trtype->pst_left->pst_sym.pst_value.pst_s_op.pst_opno;

	    if (opno == ADI_EXIST_OP)
		yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_root.pst_mask1 |= PST_5HAVING;
	    if (left_opno == ADI_EXIST_OP)
		yacc_cb->yypvt[-0].psl_trtype->pst_left->pst_sym.pst_value.pst_s_root.pst_mask1 |= PST_5HAVING;

            /* b116202 */
            if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_BOP &&
                yacc_cb->yypvt[-0].psl_trtype->pst_left &&
                yacc_cb->yypvt[-0].psl_trtype->pst_left->pst_sym.pst_type == PST_AGHEAD &&
                yacc_cb->yypvt[-0].psl_trtype->pst_right &&
                yacc_cb->yypvt[-0].psl_trtype->pst_right->pst_sym.pst_type == PST_AGHEAD)
            {
                yacc_cb->yypvt[-0].psl_trtype->pst_left->pst_sym.pst_value.pst_s_root.pst_mask1 |= PST_6HAVING;
                yacc_cb->yypvt[-0].psl_trtype->pst_right->pst_sym.pst_value.pst_s_root.pst_mask1 |= PST_6HAVING;
            }

	    if (psl_hcheck(cb, yacc_cb->yypvt[-0].psl_trtype, yacc_cb->yypvt[-1].psl_trtype, &yyvarsp->from_list))
	    {
		i4		err_code;

		(VOID) psf_error(2920L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, sizeof(cb->pss_lineno), 
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	    status = psy_apql(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_trtype, rootnode,
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	/*
	** Move j_qual to the qualification (if any) of the outer subselect
	** (if any)
	*/
	yyvarsp->j_qual = yyvarsp->j_qual->pss_next;
	
	/* mark each element in the from list as 'out of current scope' */
	(VOID) pst_snscope(&cb->pss_auxrng, &yyvarsp->from_list);

	/*
	** return to the previous context (this is not useful now since we
	** disallow subselects inside the ON clause, but who knows, it may
	** become useful.)
	*/
	yyvarsp->qual_depth--;

	yacc_cb->yyval.psl_trtype = rootnode;
    } break;

case 1358:
if (!((*yyvarspp)->bypass_actions))
/* # line 28475 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = (PST_QNODE *) NULL;		/* default */
    } break;

case 1359:
if (!((*yyvarspp)->bypass_actions))
/* # line 28479 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;
	i4	err_code;

	/* Check for "first n" in wrong place (can only be in first select
	** of a query and NOT in create view). */
	if (cb->pss_qualdepth != 1 || psq_cb->psq_mode == PSQ_VIEW ||
		(yyvarsp->nonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL))
	{
	    (VOID) psf_error(2156L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* No "select first n ..." allowed in Star queries. */
	    (VOID) psf_error(E_PS091F_STAR_NO_FIRSTN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Simple integer constant node required. */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    DB_INT_TYPE, (i2) 0, (i4) 4, (DB_ANYTYPE *) &yacc_cb->yypvt[-0].psl_inttype,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1360:
if (!((*yyvarspp)->bypass_actions))
/* # line 28523 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;

	status = pst_trfix(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_trtype, 
		&psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Store the final target list ptr for
	** leftmost subselect
	*/
	yyvarsp->dbpinfo->pss_into_clause = yacc_cb->yypvt[-0].psl_trtype;

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1361:
if (!((*yyvarspp)->bypass_actions))
/* # line 28539 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = (PST_QNODE *) NULL;
    } break;

case 1362:
if (!((*yyvarspp)->bypass_actions))
/* # line 28545 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1363:
if (!((*yyvarspp)->bypass_actions))
/* # line 28549 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Looks like ANSI nad DB/2 allow duplicates, so we
	** will not check for them.
	*/

	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	yacc_cb->yyval.psl_trtype = pst_tlprpnd(yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype);
    } break;

case 1364:
if (!((*yyvarspp)->bypass_actions))
/* # line 28562 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*resdomnode;
	PST_RSDM_NODE	resdom;
	DB_STATUS       status;
	DB_PARM_NAME	varname;
	bool		found = FALSE;
	i4		err_code;
	register PSS_DECVAR *var;

	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, varname.db_parm_name);

	/* Find local var/parm by the specified name. */
	for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Unknown local variable or parm spec'd. */
	    (VOID) psf_error(2403L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Normalize the attribute name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(resdom.pst_rsname),
	    (char *) resdom.pst_rsname);

	/* Generate a resdom node */
	resdom.pst_rsno = (i4) 0;	/* To be patched later */
	resdom.pst_ntargno = var->pss_no;
	resdom.pst_ttargtype = (i4) PST_LOCALVARNO;
	resdom.pst_rsupdt = (i4) FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_RESDOM, (char *) &resdom,
	    sizeof(PST_RSDM_NODE), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &resdomnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomnode->pst_sym.pst_dataval);

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1367:
if (!((*yyvarspp)->bypass_actions))
/* # line 28630 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_J_QUAL	       *join_qual;
	DB_STATUS              status;

	/*
	** If we were processing a join_search condition, subselects are
	** presently disallowed
	*/
	if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	{
	    i4	err_code;
	    (VOID) psf_error(E_PS03A0_SUBSEL_IN_JQUAL, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}
	
	/* Open memory stream for allocating query tree, if not already
	** open
	*/
	if (!cb->pss_ostream.psf_mstream.qso_handle &&
	    (status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);    /* non-zero return means error */
	}

	cb->pss_qualdepth++;

	/*
	** clear the bit that would indicate to us that correlated variables
	** were being used
	*/
	BTclear(cb->pss_qualdepth, (char *) yyvarsp->correlation_mask);

	yyvarsp->agg_list_stack[cb->pss_qualdepth] = (YYAGG_NODE_PTR *) NULL;
	yyvarsp->in_target_clause = TRUE;
	/*
	** Reset the resdom count for each subselect.
	*/
	cb->pss_rsdmno = 0;
	cb->pss_tlist = (PST_QNODE*) NULL;

	/* note that we are processing append for tuple width check later */
	if (psq_cb->psq_mode == PSQ_APPEND)
	    cb->pss_stmt_flags |= PSS_PARSING_INSERT_SUBSEL;

	/*
	** Initialize psq_mode if uninitialized. Required by psl_yerror.
	** Also, if this is an insert or an update, we need to change the mode
	** so that pst_adresdom works correctly. The mode will be restored in
	** the final production for "insert/update..where..subselect.." case.
	*/
	switch (psq_cb->psq_mode)
	{
	    case 0:
	    case PSQ_APPEND:
	    case PSQ_REPLACE:
	    case PSQ_PROT:
	    case PSQ_DEFQRY:
	    case PSQ_CREDBP:
	    case PSQ_IF:
	    case PSQ_RETURN:
	    case PSQ_MESSAGE:
	    case PSQ_VAR:
	    case PSQ_WHILE:
	    case PSQ_FOR:
	    case PSQ_REPEAT:
		{ 
		    psq_cb->psq_mode = PSQ_RETRIEVE;
		    break;
		}
	    default:
		/* Do not change it. */
		break;
	}

	/*
	** allocate a header for join_search qualification for this
	** subselect
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_J_QUAL), 
		 (PTR *) &join_qual, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** Note that we "grow" the list upward.  Once the entire subselect
	** is processed, we will shed the PSS_J_QUAL node we just allocated
	*/
	join_qual->pss_qual = (PST_QNODE *) NULL;
	join_qual->pss_next = yyvarsp->j_qual;
	yyvarsp->j_qual = join_qual;

	/* indicate that we are NOT processing join_search condition */
	BTclear(++yyvarsp->qual_depth, yyvarsp->qual_type);
    } break;
	}
	return(0);
}

i4
psls27iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1368:
if (!((*yyvarspp)->bypass_actions))
/* # line 28731 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Mark this SELECT stmnt as non-updatable */
	if (cb->pss_qualdepth == 1)
	{
	    yyvarsp->nonupdt = TRUE;
	    yyvarsp->nonupdt_reason |= PSS_DISTINCT_IN_OUTERMOST_SUBSEL;
	}

	yacc_cb->yyval.psl_inttype = TRUE;
    } break;

case 1369:
if (!((*yyvarspp)->bypass_actions))
/* # line 28742 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = FALSE;
    } break;

case 1370:
if (!((*yyvarspp)->bypass_actions))
/* # line 28746 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = FALSE;
    } break;

case 1371:
if (!((*yyvarspp)->bypass_actions))
/* # line 28752 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	/* Into clause is only allowed in DB procedures. */
	if (yyvarsp->isdbp == FALSE)
	{
	    (VOID) psf_error(2419L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Into clause is only allowed at the outermost scope. */
	if (cb->pss_qualdepth != 1)
	{
	    (VOID) psf_error(2418L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Into clause must appear only once and must be
	** in the leftmost query term.
	*/
	if (yyvarsp->dbpinfo->pss_into_clause != (PST_QNODE *) NULL ||
	    yyvarsp->dbpinfo->pss_flags & PSS_1SUB_SEEN
	   )
	{
	    (VOID) psf_error(2428L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Into clause must not be mixed with other forms
	** of local var assignment statement.
	*/
	if (yyvarsp->dbpinfo->pss_flags & PSS_LVAR_SEEN)
	{
	    (VOID) psf_error(2429L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}
    } break;

case 1372:
if (!((*yyvarspp)->bypass_actions))
/* # line 28797 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->in_target_clause = FALSE;

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1374:
if (!((*yyvarspp)->bypass_actions))
/* # line 28806 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{

	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	yacc_cb->yyval.psl_trtype = pst_tlprpnd(yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype);
    } break;

case 1375:
if (!((*yyvarspp)->bypass_actions))
/* # line 28816 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* list all attributes */
	PST_VAR_NODE	       var;
	PST_QNODE	       *varnode;
	PST_QNODE	       *rsdmnode;
	DB_STATUS	       status;

	/*
	** when we encounter "*" when processing the target list, we are yet to
	** process the FROM list, so for now we just create a dummy VAR and
	** RESDOM nodes to indicate that the target list consists of "*".  Real
	** VAR and RESDOM nodes will be put together later
	** (in the "subselect:" production as soon as we are done processing the
	** from_list)
	*/

	/* Blank out the attribute name */
	MEfill(sizeof(DB_ATT_NAME), ' ', var.pst_atname.db_att_name);
	var.pst_atno.db_att_id = PST_STAR_SEEN;
	
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
	    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &varnode,
	    &psq_cb->psq_error, (i4) 0);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	/* Create the corresponding result domain node */
	status = pst_adresdom((char *) &var.pst_atname, (PST_QNODE *) NULL,
	    varnode, cb, psq_cb, &rsdmnode);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_trtype = rsdmnode;

    } break;

case 1376:
if (!((*yyvarspp)->bypass_actions))
/* # line 28859 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	PST_QNODE	    *resdomnode;
	char		    *name;
	char		    atname[sizeof(DB_ATT_NAME)];

	if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_VAR)
	{
	    name = (char *)&yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_var.pst_atname;
	}
	else
	{
	    (VOID) MEfill(sizeof(DB_ATT_NAME), (u_char) ' ', (PTR) atname);
	    name = (char *) atname;
	}
	status = pst_adresdom(name, (PST_QNODE *) NULL, yacc_cb->yypvt[-0].psl_trtype,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1377:
if (!((*yyvarspp)->bypass_actions))
/* # line 28882 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	PST_QNODE	    *resdomnode;
        DB_ATT_NAME	    colname;
	i4		    err_code;
	bool		    found = FALSE;
	PSS_DECVAR	    *var;
	char		    *name = (char *) &colname;

	/* normalize the attribute name */
	STmove((char *) yacc_cb->yypvt[-2].psl_strtype, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&colname);

	if (yyvarsp->isdbp == TRUE && ~yyvarsp->dbpinfo->pss_flags & PSS_1SUB_SEEN)
	{
	    /* If the outermost scope, treat as local variable. */
	    if (cb->pss_qualdepth == 1)
	    {
		/* Search for the variable; innermost scope first. */
		for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
		     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
		     var = (PSS_DECVAR *) var->pss_queue.q_next
		    )
		{
		    if (var->pss_out)
			continue;

		    if (MEcmp((PTR) &colname, (PTR) &var->pss_varname,
			sizeof(var->pss_varname)) == 0
		       )
		    {
			found = TRUE;
			break;
		    }
		}

		if (found == TRUE)
		{
		    /* The resdom name needs to be the same
		    ** as of select_expr.
		    */
		    if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_VAR)
		    {
		     name = (char *)&yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_var.pst_atname;
		    }
		    else
		    {
			(VOID) MEfill(sizeof(DB_ATT_NAME), (u_char) ' ',
				(PTR) &colname);
		    }

		    /*
		    ** Remember that local var related target list element was
		    ** seen
		    */
		    yyvarsp->dbpinfo->pss_flags |= PSS_LVAR_SEEN;
		}
		else
		{
		    /* Var unknown */
		    (VOID) psf_error(2413L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
		    return (E_DB_ERROR);
		}
	    }
	}

	status = pst_adresdom(name, (PST_QNODE *) NULL, yacc_cb->yypvt[-0].psl_trtype,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (found == TRUE)
	{
	    resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = var->pss_no;
	    resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_LOCALVARNO;
	    STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomnode->pst_sym.pst_dataval);
	}
	else
	{
	    /* indicate that RESDOM name has been assigned explicitly */
	    resdomnode->pst_sym.pst_type = PSS_2RESDOM;
	}

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1378:
if (!((*yyvarspp)->bypass_actions))
/* # line 28968 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	PST_QNODE	    *resdomnode;
        DB_ATT_NAME	    colname;
	i4		    err_code;
	bool		    found = FALSE;
	PSS_DECVAR	    *var;
	char		    *name = (char *) &colname;

	if (yyvarsp->isdbp == FALSE)
	{
	    /* Only allowed in DB procedures */
	    (VOID) psf_error(2414L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
	    return (E_DB_ERROR);	    
	}

	/* Assignment clause only allowed at the outermost scope. */
	if (yyvarsp->dbpinfo->pss_flags & PSS_1SUB_SEEN || cb->pss_qualdepth != 1)
	{
	    (VOID) psf_error(2431L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}

	/* Remember that local var related targ. list element seen. */
	yyvarsp->dbpinfo->pss_flags |= PSS_LVAR_SEEN;

	/* normalize the attribute name */
	STmove((char *) yacc_cb->yypvt[-2].psl_strtype, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&colname);

	/* Search for the variable; innermost scope first. */
	for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;

	    if (MEcmp((PTR) &colname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == FALSE)
	{
	    /* Var unknown */
	    (VOID) psf_error(2413L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* The resdom name needs to be the same
	** as of select_expr.
	*/
	if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_VAR)
	{
	    name = (char *)&yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_value.pst_s_var.pst_atname;
	}
	else
	{
	    (VOID) MEfill(sizeof(DB_ATT_NAME), (u_char) ' ', (PTR) &colname);
	}

	status = pst_adresdom(name, (PST_QNODE *) NULL, yacc_cb->yypvt[-0].psl_trtype,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = var->pss_no;
	resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_LOCALVARNO;
	STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomnode->pst_sym.pst_dataval);

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1379:
if (!((*yyvarspp)->bypass_actions))
/* # line 29050 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS           status;
	PST_QNODE	    *resdomnode;
        DB_ATT_NAME	    colname;

	/* normalize the attribute name */
	STmove((char *)yacc_cb->yypvt[-0].psl_strtype, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&colname);

	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL, yacc_cb->yypvt[-2].psl_trtype,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* indicate that RESDOM name has been assigned explicitly */
	resdomnode->pst_sym.pst_type = PSS_2RESDOM;

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1380:
if (!((*yyvarspp)->bypass_actions))
/* # line 29069 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_VAR_NODE	       var;
	PST_QNODE	       *varnode;
	PST_QNODE	       *rsdmnode;
	DB_STATUS	       status;
	PSS_RNGTAB             *rngvar;

        status = psl_tbl_ref(psq_cb, cb, yacc_cb->yypvt[-0].psl_col_ref, yyvarsp->in_target_clause,
	    yyvarsp->in_groupby_clause, &yyvarsp->tbl_refs, &rngvar);
        if (DB_FAILURE_MACRO(status))
	    return(status);

	/* Blank out the attribute name */
	MEfill(sizeof(DB_ATT_NAME), ' ', var.pst_atname.db_att_name);
	var.pst_atno.db_att_id = PST_STAR_SEEN;
	
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
	    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &varnode,
	    &psq_cb->psq_error, (i4) 0);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	varnode->pst_sym.pst_dataval.db_data = (PTR) rngvar;

	/* Create the corresponding result domain node */
	status = pst_adresdom((char *) &var.pst_atname, (PST_QNODE *) NULL,
	    varnode, cb, psq_cb, &rsdmnode);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_trtype = rsdmnode;
    } break;

case 1383:
if (!((*yyvarspp)->bypass_actions))
/* # line 29118 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_J_MASK	mask;

	MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK), 
					(char *)&mask);
	/*
	** we have to remove vars appearing in this FROM list from the
	** $Yjoin_tbls to allow for correlated queries.
	*/
	BTnot(BITS_IN(mask), (char *) &mask);
	BTand(BITS_IN(mask), (char *) &mask, (char *) &yyvarsp->join_tbls);

	cb->pss_stmt_flags |= PSS_XTABLE_UPDATE;

    } break;

case 1385:
if (!((*yyvarspp)->bypass_actions))
/* # line 29137 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_J_MASK	mask;

	MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK), 
					(char *)&mask);
	/*
	** we have to remove vars appearing in this FROM list from the
	** $Yjoin_tbls to allow for correlated queries.
	*/
	BTnot(BITS_IN(mask), (char *) &mask);
	BTand(BITS_IN(mask), (char *) &mask, (char *) &yyvarsp->join_tbls);
	yyvarsp->in_from_clause = FALSE;
    } break;

case 1386:
if (!((*yyvarspp)->bypass_actions))
/* # line 29151 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	MEfill(sizeof(PST_J_MASK), 0, (char *)&yyvarsp->flists[cb->pss_qualdepth]);
    } break;

case 1387:
if (!((*yyvarspp)->bypass_actions))
/* # line 29157 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->in_from_clause = TRUE;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&yyvarsp->flists[cb->pss_qualdepth]);
    } break;

case 1390:
if (!((*yyvarspp)->bypass_actions))
/* # line 29168 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1391:
if (!((*yyvarspp)->bypass_actions))
/* # line 29172 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1392:
if (!((*yyvarspp)->bypass_actions))
/* # line 29176 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = (char *) NULL;
    } break;

case 1393:
if (!((*yyvarspp)->bypass_actions))
/* # line 29183 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1394:
if (!((*yyvarspp)->bypass_actions))
/* # line 29187 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1395:
if (!((*yyvarspp)->bypass_actions))
/* # line 29193 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_J_MASK	*mask;
	DB_STATUS	status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	char		*corr_name = (yacc_cb->yypvt[-0].psl_strtype == (char *) NULL)
						? yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name
						: yacc_cb->yypvt[-0].psl_strtype;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    return(psl_cs06s_obj_spec(cb, psq_cb, &(yyvarsp->deplist), yacc_cb->yypvt[-1].psl_objspec,
				      (u_i4)0));
	}

	/* if schema.object construct was used */
	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)	    
	{
	    status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth, corr_name,
		&yacc_cb->yypvt[-1].psl_objspec->pss_owner, &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, cb->pss_qualdepth, 
		corr_name, &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if a correlation name was explicitly specified, set a bit in
	** resrange->pss_var_mask
	*/
	if (yacc_cb->yypvt[-0].psl_strtype)
	    resrange->pss_var_mask |= PSS_EXPLICIT_CORR_NAME;

	/*
	** In case of DB procedures table name needs to be qualified
	** by the owner name. 
	** But don't qualify name if it's a set-input parameter.
	*/
	if (yyvarsp->isdbp 
	    && (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    && ~yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
	    && (resrange->pss_rgtype != PST_SETINPUT))
	{
	    u_char 	    *owner;

	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		/*
		** special care must be exercised when dealing with synonyms:
		** if the object referenced by the user was a synonym, name of
		** its owner must be determined by consulting rngvar_info.
		*/
		if (rngvar_info & PSS_USR_OBJ)
		{
		    owner = (u_char *) &cb->pss_user;
		}
		else if (rngvar_info & PSS_DBA_OBJ)
		{
		    owner = (u_char *) &cb->pss_dba;
		}
		else if (rngvar_info & PSS_SYS_OBJ)
		{
		    owner = (u_char *) cb->pss_cat_owner;
		}
		else	    /* user name was explicitly specified */
		{
		    owner = (u_char *) &yacc_cb->yypvt[-1].psl_objspec->pss_owner;
		}
	    }
	    else
	    {
		owner = (u_char *) &resrange->pss_ownname;
	    }

	    status = psl_prepend_schemaname(cb->pss_tchain, 
					    yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, 
					    owner, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
	/*
	** As a result of the SYNONYM project, we also may have to do some extra
	** work when processing CREATE VIEW/INTEGRITY/PERMIT.
	**
	** if (object is a SYNONYM)
	** {
	**	replace reference to a synonym with a name of the actual object
	**	qualified by the name of the owner;
	**	if was not correlated, use synonym name as a corelation name;
	** }
	**
	** In addition to that, we will ensure that names of objects used in
	** view definition as it is stored in IIQRYTEXT are qualified with owner
	** name
	*/
	else if (!yyvarsp->isdbp)
	{
	    u_char	*actual_obj_owner = (u_char *) &resrange->pss_ownname;

	    if (   yyvarsp->qry_mask & PSS_PREFIX_WITH_OWNER 
		&& ~yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
		/*
		** if object name was NOT prefixed with owner name, insert name
		** of the owner of the ACTUAL object (i.e. not of a synonym
		** which may have been used.)
		*/
		status = psl_prepend_schemaname(cb->pss_tchain, 
						yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, 
						actual_obj_owner, 
						&psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }

	    if (rngvar_info & PSS_BY_SYNONYM &&
	        yyvarsp->qry_mask & PSS_REPL_SYN_WITH_ACTUAL)
	    {
		PTR	*obj_name_ptr;
		PTR	newpiece;
		i4 	name_len;
		u_char	delim_id[DB_MAX_DELIMID];
#ifdef BYTE_ALIGN
		PTR	align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*obj_name_ptr)
#endif

		/* The piece ptr is stored after the null terminated string */
		obj_name_ptr = (PTR *) ((char *) yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name +
					STlength(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name) + 1);
#ifdef BYTE_ALIGN
		MECOPY_CONST_MACRO((PTR)obj_name_ptr, sizeof(PTR),
				   (PTR)&align_ptr);
#endif
		/*
		** if synonym name was qualified with owner name, and the owner
		** of the synonym is different from the owner of the actual
		** object, we will replace name of the owner of the synonym with
		** that of the actual object
		*/
		if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
		    MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_owner, (PTR) actual_obj_owner,
			sizeof(DB_OWN_NAME)))
		{
		    PTR	    syn_owner = psq_tbacktrack(align_ptr, 2);

		    /*
		    ** psq_tsubs() may replace a name with preceding blank(s)
		    ** with one without them.  This is undesirable, e.g.
		    ** 
		    **	    create synonym andre.x for $ingres.iirelation;
		    **	    create view v as select * from andre.x;
		    **
		    ** would result in text
		    **
		    **	    create view v as select * from$ingres.iirelation 
		    **
		    ** Therefore, we must add a speca before the actual object
		    ** owner name.
		    */

		    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			sizeof(" ") - 1, &newpiece, syn_owner,
			&psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return (status);

		    /* convert owner name to a delimited identifier
		    ** (obj_owner pointer gets overwritten)
		    */
		    name_len = psf_trmwhite(DB_MAXNAME, 
			(char *) actual_obj_owner);

		    status = psl_norm_id_2_delim_id(&actual_obj_owner,
						    &name_len, delim_id,
						    &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			    return(status);

		    status = psq_tsubs(cb->pss_tchain, syn_owner,
				       actual_obj_owner, name_len,
				       &newpiece, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		}

		/*
		** if (synonym name was different from the actual object name)
		** {
		**     if (user did not supply a corelation name)
		**     {
		**         insert actual object name before the synonym name
		**	   which will be used as corelation name;
		**     }
		**     else
		**     {
		**         replace synonym name with actual object name;
		**     }
		** }
		*/
		if (MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, (PTR) &resrange->pss_tabname,
			  sizeof(DB_TAB_NAME)))
		{
		    u_char	*actual_tbl = (u_char *) &resrange->pss_tabname;

		    /* convert table name to a delimited identifier
		    ** (actual_tbl pointer gets overwritten)
		    */
		    name_len = psf_trmwhite(DB_MAXNAME, (char *) actual_tbl);

		    status = psl_norm_id_2_delim_id(&actual_tbl, 
						    &name_len, delim_id,
						    &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			    return(status);

		    if (yacc_cb->yypvt[-0].psl_strtype == (char *) NULL)
		    {
			/* no corelation name was supplied */

			/*
			** if synonym name was not prefixed with owner name and
			** the actual table owner name has not been already
			** inserted, we need to insert a blank before the actual
			** table name to separate it from the previous keyword.
			*/
			if (   ~yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			    && ~yyvarsp->qry_mask & PSS_PREFIX_WITH_OWNER)
			{
			    /* Add a blank */
			    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
				sizeof(" ") - 1, &newpiece, align_ptr,
				&psq_cb->psq_error);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}

			status = psq_tinsert(cb->pss_tchain, actual_tbl, 
					     name_len, &newpiece,
					     align_ptr, &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);

			/*
			** if the table name was not prefixed with the owner
			** name, we don't need to add a blank between the actual
			** table name and the synonym name which will be used as
			** a corelation name because there had to be at least
			** one white char preceding the synonym name
			**
			** This is not quite correct, since the synonym name may
			** have immediately followed some non-blank separator,
			** e.g. comma in a from list:
			**
			**	create synonym andre.s for t;
			**	create view z as select 1 from s,s;
			**
			** will result in text
			**
			**    create view z as select 1 from andre.t s, andre.ts
			**
			** which is not very desirable.
			*/

			/* Add a blank */
			status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			    sizeof(" ") - 1, &newpiece, align_ptr,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }
		    else
		    {
			/*
			** psq_tsubs() strikes again; it may substitute a string
			** for a string preceeded by at least one blank and
			** screw things up as in
			**
			**	create synonym s for t;
			**	create permit select on s x to greg;
			**
			** becomes
			**
			**	create permit select ont x to greg.
			*/

			/* Add a blank */
			status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			    sizeof(" ") - 1, &newpiece, align_ptr,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);

			status = psq_tsubs(cb->pss_tchain, align_ptr,
					   actual_tbl, name_len,
					   &newpiece, &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return(status);
		    }
		}
	    }
	}

	BTset(resrange->pss_rgno, (char*) &yyvarsp->flists[cb->pss_qualdepth]);

        if (cb->pss_qualdepth == 1)
        {
            if (BTcount((char *)&yyvarsp->flists[cb->pss_qualdepth], PST_NUMVARS) > 1)
            {
                /*
                ** FROM-list in the outermost subselect involves more than one
                ** relation - query will not be updateable
                */
                yyvarsp->nonupdt = TRUE;
                yyvarsp->nonupdt_reason |= PSS_MULT_VAR_IN_OUTERMOST_SUBSEL;
            }
            else if (psq_cb->psq_mode == PSQ_VIEW && !yyvarsp->nonupdt)
            {
                /*
                ** remember address of the range variable representing the new
                ** view's simply underlying table
                */
                yyvarsp->underlying_rel = resrange;
            }
        }

	/*
	** save the address for future dereferencing.  Now, given range number,
	** I will get the pointer to a range variable without having to scan the
	** entire table
	*/
	yyvarsp->rng_vars[resrange->pss_rgno] = resrange;

	/*
	** productions such as integtbl may need to know thr value of
	** rngvar_info
	*/
	yyvarsp->rngvar_info = rngvar_info;
	
	/* Allocate PST_J_MASK to define this table to rest of parse. */
        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEfill(sizeof(PST_J_MASK), '\0', (PTR)mask);
	BTset(resrange->pss_rgno, (char *) mask);

	/*
	** we keep track of the tables in the FROM list to make sure that there
	** are no correlated queries appearing in the join_search condition of
	** the FROM list which involve tables from the same FROM list
	*/
	BTor(PST_NUMVARS, (char *)mask, (char *)&yyvarsp->join_tbls);

	yacc_cb->yyval.psl_varmap = mask;
    } break;

case 1396:
if (!((*yyvarspp)->bypass_actions))
/* # line 29574 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	yyvarsp->save_pss_rsdmno = cb->pss_rsdmno;
	yyvarsp->save_psq_mode = psq_cb->psq_mode;
	status = psl_push_yyvars(psq_cb, cb, yyvarspp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
	yyvarsp = *yyvarspp;
    } break;

case 1397:
if (!((*yyvarspp)->bypass_actions))
/* # line 29585 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_J_MASK	*mask;
	DB_STATUS	status;
	PSS_RNGTAB	*resrange;

	status = psl_drngent(&cb->pss_auxrng, cb->pss_qualdepth, 
		yacc_cb->yypvt[-1].psl_strtype, cb, &resrange, yacc_cb->yypvt[-3].psl_trtype, PST_DRTREE, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_ses_flag |= PSS_DERTAB_INQ;	/* note derived table in qry */

	/* If there was an override column list, check here that the 
	** count is right, and replace the column names. */
	if (yyvarsp->dcol_list.queue.q_next != (QUEUE *)&yyvarsp->dcol_list)
	{
	    PSY_COL	*psy_col;
	    i4		i, err_code;

	    for (i = 1, psy_col = (PSY_COL *)yyvarsp->dcol_list.queue.q_prev;
		i <= resrange->pss_tabdesc->tbl_attr_count && 
				psy_col != (PSY_COL *)&yyvarsp->dcol_list;
		i++, psy_col = (PSY_COL *)psy_col->queue.q_prev)
	    {
		MEcopy((char *)psy_col->psy_colnm.db_att_name, 
		    sizeof(DB_ATT_NAME), 
		    (char *)resrange->pss_attdesc[i]->att_name.db_att_name);
	    }

	    if (resrange->pss_tabdesc->tbl_attr_count >= i ||
		psy_col != (PSY_COL *)&yyvarsp->dcol_list)
	    {
		/* Count of override column names is incorrect - error. */
		(VOID) psf_error(2157L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    sizeof(DB_TAB_NAME),
		    resrange->pss_rgname);
		return (E_DB_ERROR);
	    }
	}

	/* And now restore the outer yyvarsp, since recursion is done. */
	yyvarsp->prev_yyvarsp->join_id = yyvarsp->join_id;	/* join_id persists */

	if (yyvarsp->nonupdt)
	{
	    /* Propagate non-updateability to containing query. */
	    yyvarsp->prev_yyvarsp->nonupdt = TRUE;
	    yyvarsp->prev_yyvarsp->nonupdt_reason |= yyvarsp->nonupdt_reason;
	}

	yyvarsp = *yyvarspp = yyvarsp->prev_yyvarsp;
	cb->pss_rsdmno = yyvarsp->save_pss_rsdmno;	/* restore */
	psq_cb->psq_mode = yyvarsp->save_psq_mode;	/* ditto */

	/*
	** Correlation name was explicitly specified, set a bit in
	** resrange->pss_var_mask
	*/
	resrange->pss_var_mask |= PSS_EXPLICIT_CORR_NAME;

	BTset(resrange->pss_rgno, (char*) &yyvarsp->flists[cb->pss_qualdepth]);

        if (cb->pss_qualdepth == 1)
        {
            if (BTcount((char *)&yyvarsp->flists[cb->pss_qualdepth], PST_NUMVARS) > 1)
            {
                /*
                ** FROM-list in the outermost subselect involves more than one
                ** relation - query will not be updateable
                */
                yyvarsp->nonupdt = TRUE;
                yyvarsp->nonupdt_reason |= PSS_MULT_VAR_IN_OUTERMOST_SUBSEL;
            }
            else if (psq_cb->psq_mode == PSQ_VIEW && !yyvarsp->nonupdt)
            {
                /*
                ** remember address of the range variable representing the new
                ** view's simply underlying table
                */
                yyvarsp->underlying_rel = resrange;
            }
        }

	/*
	** save the address for future dereferencing.  Now, given range number,
	** I will get the pointer to a range variable without having to scan the
	** entire table
	*/
	yyvarsp->rng_vars[resrange->pss_rgno] = resrange;

	/*
	** productions such as integtbl may need to know thr value of
	** rngvar_info
	*/
	yyvarsp->rngvar_info = PSS_USR_OBJ;
	
	/* Allocate PST_J_MASK to define this table to rest of parse. */
        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEfill(sizeof(PST_J_MASK), '\0', (PTR)mask);
	BTset(resrange->pss_rgno, (char *) mask);

	/*
	** we keep track of the tables in the FROM list to make sure that there
	** are no correlated queries appearing in the join_search condition of
	** the FROM list which involve tables from the same FROM list
	*/
	BTor(PST_NUMVARS, (char *)mask, (char *)&yyvarsp->join_tbls);

	yacc_cb->yyval.psl_varmap = mask;
    } break;

case 1398:
if (!((*yyvarspp)->bypass_actions))
/* # line 29704 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_varmap = yacc_cb->yypvt[-0].psl_varmap;
    } break;

case 1401:
if (!((*yyvarspp)->bypass_actions))
/* # line 29714 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;
	PSY_COL     *psy_col;

	/* Open memory stream for allocating query tree, if not already
	** open. This may be necessary if the query includes with clause
	** elements (common query expressions).
	*/
	if (!cb->pss_ostream.psf_mstream.qso_handle &&
	    (status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);    /* non-zero return means error */
	}

	/* Allocate memory for a column entry
	 */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_COL),
			    (PTR *) &psy_col, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy update column name to column entry.
	*/
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_ATT_NAME),
		psy_col->psy_colnm.db_att_name);

	/*
	** Attach element to the list.
	*/
	QUinsert((QUEUE *) psy_col, (QUEUE *) &yyvarsp->dcol_list);
    } break;

case 1402:
if (!((*yyvarspp)->bypass_actions))
/* # line 29750 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;
	PSY_COL     *psy_col;

	/* Allocate memory for a column entry
	 */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_COL),
			    (PTR *) &psy_col, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy update column name to column entry.
	*/
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_ATT_NAME),
		psy_col->psy_colnm.db_att_name);

	/*
	** Attach element to the list.
	*/
	QUinsert((QUEUE *) psy_col, (QUEUE *) &yyvarsp->dcol_list);
    } break;

case 1403:
if (TRUE)	/* NOBYPASS */
/* # line 29777 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	char		*corr_name = (yacc_cb->yypvt[-0].psl_strtype == (char *) NULL)
						? yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name
						: yacc_cb->yypvt[-0].psl_strtype;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    return(psl_cs06s_obj_spec(cb, psq_cb, &(yyvarsp->deplist), yacc_cb->yypvt[-1].psl_objspec,
				      (u_i4)0));
	}

	/* if schema.object construct was used */
	if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)	    
	{
	    status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth, corr_name,
		&yacc_cb->yypvt[-1].psl_objspec->pss_owner, &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, cb->pss_qualdepth, 
		corr_name, &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, cb, FALSE, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if a correlation name was explicitly specified, set a bit in
	** resrange->pss_var_mask
	*/
	if (yacc_cb->yypvt[-0].psl_strtype)
	    resrange->pss_var_mask |= PSS_EXPLICIT_CORR_NAME;

	/*
	** In case of DB procedures table name needs to be qualified
	** by the owner name. 
	** But don't qualify name if it's a set-input parameter.
	*/
	if (yyvarsp->isdbp 
	    && (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    && ~yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
	    && (resrange->pss_rgtype != PST_SETINPUT))
	{
	    u_char 	    *owner;

	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		/*
		** special care must be exercised when dealing with synonyms:
		** if the object referenced by the user was a synonym, name of
		** its owner must be determined by consulting rngvar_info.
		*/
		if (rngvar_info & PSS_USR_OBJ)
		{
		    owner = (u_char *) &cb->pss_user;
		}
		else if (rngvar_info & PSS_DBA_OBJ)
		{
		    owner = (u_char *) &cb->pss_dba;
		}
		else if (rngvar_info & PSS_SYS_OBJ)
		{
		    owner = (u_char *) cb->pss_cat_owner;
		}
		else	    /* user name was explicitly specified */
		{
		    owner = (u_char *) &yacc_cb->yypvt[-1].psl_objspec->pss_owner;
		}
	    }
	    else
	    {
		owner = (u_char *) &resrange->pss_ownname;
	    }

	    status = psl_prepend_schemaname(cb->pss_tchain, 
					    yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, 
					    owner, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
	/*
	** As a result of the SYNONYM project, we also may have to do some extra
	** work when processing CREATE VIEW/INTEGRITY/PERMIT.
	**
	** if (object is a SYNONYM)
	** {
	**	replace reference to a synonym with a name of the actual object
	**	qualified by the name of the owner;
	**	if was not correlated, use synonym name as a corelation name;
	** }
	**
	** In addition to that, we will ensure that names of objects used in
	** view definition as it is stored in IIQRYTEXT are qualified with owner
	** name
	*/
	else if (!yyvarsp->isdbp)
	{
	    u_char	*actual_obj_owner = (u_char *) &resrange->pss_ownname;

	    if (   yyvarsp->qry_mask & PSS_PREFIX_WITH_OWNER 
		&& ~yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
		/*
		** if object name was NOT prefixed with owner name, insert name
		** of the owner of the ACTUAL object (i.e. not of a synonym
		** which may have been used.)
		*/
		status = psl_prepend_schemaname(cb->pss_tchain, 
						yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name, 
						actual_obj_owner, 
						&psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }

	    if (rngvar_info & PSS_BY_SYNONYM &&
	        yyvarsp->qry_mask & PSS_REPL_SYN_WITH_ACTUAL)
	    {
		PTR	*obj_name_ptr;
		PTR	newpiece;
		i4 	name_len;
		u_char	delim_id[DB_MAX_DELIMID];
#ifdef BYTE_ALIGN
		PTR	align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*obj_name_ptr)
#endif

		/* The piece ptr is stored after the null terminated string */
		obj_name_ptr = (PTR *) ((char *) yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name +
					STlength(yacc_cb->yypvt[-1].psl_objspec->pss_orig_obj_name) + 1);
#ifdef BYTE_ALIGN
		MECOPY_CONST_MACRO((PTR)obj_name_ptr, sizeof(PTR),
				   (PTR)&align_ptr);
#endif
		/*
		** if synonym name was qualified with owner name, and the owner
		** of the synonym is different from the owner of the actual
		** object, we will replace name of the owner of the synonym with
		** that of the actual object
		*/
		if (yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
		    MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_owner, (PTR) actual_obj_owner,
			sizeof(DB_OWN_NAME)))
		{
		    PTR	    syn_owner = psq_tbacktrack(align_ptr, 2);

		    /*
		    ** psq_tsubs() may replace a name with preceding blank(s)
		    ** with one without them.  This is undesirable, e.g.
		    ** 
		    **	    create synonym andre.x for $ingres.iirelation;
		    **	    create view v as select * from andre.x;
		    **
		    ** would result in text
		    **
		    **	    create view v as select * from$ingres.iirelation 
		    **
		    ** Therefore, we must add a speca before the actual object
		    ** owner name.
		    */

		    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			sizeof(" ") - 1, &newpiece, syn_owner,
			&psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return (status);

		    /* convert owner name to a delimited identifier
		    ** (obj_owner pointer gets overwritten)
		    */
		    name_len = psf_trmwhite(DB_MAXNAME, 
			(char *) actual_obj_owner);

		    status = psl_norm_id_2_delim_id(&actual_obj_owner,
						    &name_len, delim_id,
						    &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			    return(status);

		    status = psq_tsubs(cb->pss_tchain, syn_owner,
				       actual_obj_owner, name_len,
				       &newpiece, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		}

		/*
		** if (synonym name was different from the actual object name)
		** {
		**     if (user did not supply a corelation name)
		**     {
		**         insert actual object name before the synonym name
		**	   which will be used as corelation name;
		**     }
		**     else
		**     {
		**         replace synonym name with actual object name;
		**     }
		** }
		*/
		if (MEcmp((PTR) &yacc_cb->yypvt[-1].psl_objspec->pss_obj_name, (PTR) &resrange->pss_tabname,
			  sizeof(DB_TAB_NAME)))
		{
		    u_char	*actual_tbl = (u_char *) &resrange->pss_tabname;

		    /* convert table name to a delimited identifier
		    ** (actual_tbl pointer gets overwritten)
		    */
		    name_len = psf_trmwhite(DB_MAXNAME, (char *) actual_tbl);

		    status = psl_norm_id_2_delim_id(&actual_tbl, 
						    &name_len, delim_id,
						    &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			    return(status);

		    if (yacc_cb->yypvt[-0].psl_strtype == (char *) NULL)
		    {
			/* no corelation name was supplied */

			/*
			** if synonym name was not prefixed with owner name and
			** the actual table owner name has not been already
			** inserted, we need to insert a blank before the actual
			** table name to separate it from the previous keyword.
			*/
			if (   ~yacc_cb->yypvt[-1].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			    && ~yyvarsp->qry_mask & PSS_PREFIX_WITH_OWNER)
			{
			    /* Add a blank */
			    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
				sizeof(" ") - 1, &newpiece, align_ptr,
				&psq_cb->psq_error);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}

			status = psq_tinsert(cb->pss_tchain, actual_tbl, 
					     name_len, &newpiece,
					     align_ptr, &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);

			/*
			** if the table name was not prefixed with the owner
			** name, we don't need to add a blank between the actual
			** table name and the synonym name which will be used as
			** a corelation name because there had to be at least
			** one white char preceding the synonym name
			**
			** This is not quite correct, since the synonym name may
			** have immediately followed some non-blank separator,
			** e.g. comma in a from list:
			**
			**	create synonym andre.s for t;
			**	create view z as select 1 from s,s;
			**
			** will result in text
			**
			**    create view z as select 1 from andre.t s, andre.ts
			**
			** which is not very desirable.
			*/

			/* Add a blank */
			status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			    sizeof(" ") - 1, &newpiece, align_ptr,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }
		    else
		    {
			/*
			** psq_tsubs() strikes again; it may substitute a string
			** for a string preceeded by at least one blank and
			** screw things up as in
			**
			**	create synonym s for t;
			**	create permit select on s x to greg;
			**
			** becomes
			**
			**	create permit select ont x to greg.
			*/

			/* Add a blank */
			status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			    sizeof(" ") - 1, &newpiece, align_ptr,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);

			status = psq_tsubs(cb->pss_tchain, align_ptr,
					   actual_tbl, name_len,
					   &newpiece, &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return(status);
		    }
		}
	    }
	}

	BTset(resrange->pss_rgno, (char*) &yyvarsp->flists[cb->pss_qualdepth]);

        if (cb->pss_qualdepth == 1)
        {
            if (BTcount((char *)&yyvarsp->flists[cb->pss_qualdepth], PST_NUMVARS) > 1)
            {
                /*
                ** FROM-list in the outermost subselect involves more than one
                ** relation - query will not be updateable
                */
                yyvarsp->nonupdt = TRUE;
                yyvarsp->nonupdt_reason |= PSS_MULT_VAR_IN_OUTERMOST_SUBSEL;
            }
            else if (psq_cb->psq_mode == PSQ_VIEW && !yyvarsp->nonupdt)
            {
                /*
                ** remember address of the range variable representing the new
                ** view's simply underlying table
                */
                yyvarsp->underlying_rel = resrange;
            }
        }

	/*
	** save the address for future dereferencing.  Now, given range number,
	** I will get the pointer to a range variable without having to scan the
	** entire table
	*/
	yyvarsp->rng_vars[resrange->pss_rgno] = resrange;

	/*
	** productions such as integtbl may need to know thr value of
	** rngvar_info
	*/
	yyvarsp->rngvar_info = rngvar_info;
	
	yacc_cb->yyval.psl_rngtype = resrange;	
    } break;

case 1404:
if (!((*yyvarspp)->bypass_actions))
/* # line 30142 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_varmap = yacc_cb->yypvt[-0].psl_varmap;
    } break;

case 1405:
if (!((*yyvarspp)->bypass_actions))
/* # line 30146 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_varmap = yacc_cb->yypvt[-0].psl_varmap;
    } break;
	}
	return(0);
}

i4
psls28iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1406:
if (!((*yyvarspp)->bypass_actions))
/* # line 30150 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_varmap = yacc_cb->yypvt[-0].psl_varmap;
    } break;

case 1407:
if (!((*yyvarspp)->bypass_actions))
/* # line 30154 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_varmap = yacc_cb->yypvt[-1].psl_varmap;
    } break;

case 1408:
if (!((*yyvarspp)->bypass_actions))
/* # line 30160 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PSS_1JOIN	    *join_info;
	PST_J_MASK	    mask;

	if (cb->pss_distrib & DB_3_DDB_SESS &&
	    cb->pss_stmt_flags & PSS_OUTER_OJ)
	{
	    i4	err_code;

	    (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		sizeof("OUTER JOIN syntax") - 1, "OUTER JOIN syntax");
	    return (E_DB_ERROR);
	}

	/* indicate that we will be processing join_search clause */
	BTset(++yyvarsp->qual_depth, yyvarsp->qual_type);

	/* Set the outer_relation masks for relations in this join */

	join_info = yyvarsp->pss_join_info.pss_join + yyvarsp->pss_join_info.depth;

	MEcopy((char *)yacc_cb->yypvt[-2].psl_varmap, sizeof(PST_J_MASK), (char *)&mask);
	BTor(PST_NUMVARS, (char *)yacc_cb->yypvt[-0].psl_varmap, (char *)&mask);

	if ((join_info->join_type & DB_FULL_JOIN) == DB_FULL_JOIN)
	{
	    /*
	    ** For FULL joins left AND right relations are marked as both inner
	    ** and outer
	    */
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, &mask, &mask, 
	                 (i4) join_info->join_id, yyvarsp->rng_vars, DB_FULL_JOIN);
	}
	else if (join_info->join_type & DB_LEFT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, yacc_cb->yypvt[-0].psl_varmap, yacc_cb->yypvt[-2].psl_varmap,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_LEFT_JOIN);
	}
	else if (join_info->join_type & DB_RIGHT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, yacc_cb->yypvt[-2].psl_varmap, yacc_cb->yypvt[-0].psl_varmap,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_RIGHT_JOIN);
	}
	else if (join_info->join_type & DB_INNER_JOIN)
	{
	    PST_J_MASK	mask1;
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&mask1);
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, &mask, &mask1,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_INNER_JOIN);
	}

	/* save masks representing left and right relations of this join */
	MEcopy((char *)yacc_cb->yypvt[-2].psl_varmap, sizeof(PST_J_MASK), 
				(char *)&join_info->left_rels);
	MEcopy((char *)yacc_cb->yypvt[-0].psl_varmap, sizeof(PST_J_MASK), 
				(char *)&join_info->right_rels);
    } break;

case 1409:
if (!((*yyvarspp)->bypass_actions))
/* # line 30220 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_J_MASK	*mask;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEcopy((char *)yacc_cb->yypvt[-4].psl_varmap, sizeof(PST_J_MASK), (char *)mask);
	BTor(PST_NUMVARS, (char *)yacc_cb->yypvt[-2].psl_varmap, (char *)mask);

	yyvarsp->qual_depth--;		    /* done with this qualification */

	yyvarsp->pss_join_info.depth--;    /* done with this join */
	yacc_cb->yyval.psl_varmap = mask;
    } break;

case 1410:
if (!((*yyvarspp)->bypass_actions))
/* # line 30241 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PSS_1JOIN	    *join_info;
	PST_J_MASK	    *mask;

	/* Set the outer_relation masks for relations in this join */

	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type = 0x00;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	join_info = yyvarsp->pss_join_info.pss_join + yyvarsp->pss_join_info.depth;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEcopy((char *)yacc_cb->yypvt[-2].psl_varmap, sizeof(PST_J_MASK), (char *)mask);
	BTor(PST_NUMVARS, (char *)yacc_cb->yypvt[-0].psl_varmap, (char *)mask);

	/* Cross joins are inner joins with no ON clause. */
	join_info->join_type |= DB_INNER_JOIN;
	cb->pss_stmt_flags |= PSS_INNER_OJ;
	psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, (PST_J_MASK *) NULL, 
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_INNER_JOIN);
	yyvarsp->pss_join_info.depth--;    /* done with this join */

	/* save masks representing left and right relations of this join */
	MEcopy((char *)yacc_cb->yypvt[-2].psl_varmap, sizeof(PST_J_MASK), 
				(char *)&join_info->left_rels);
	MEcopy((char *)yacc_cb->yypvt[-0].psl_varmap, sizeof(PST_J_MASK), 
				(char *)&join_info->right_rels);
	yacc_cb->yyval.psl_varmap = mask;
    } break;

case 1411:
if (!((*yyvarspp)->bypass_actions))
/* # line 30286 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_1JOIN	*join_info;
	PST_J_MASK	*mask;
	PST_QNODE	*qual = (PST_QNODE *) NULL;
	i4		left, right;
	PSS_RNGTAB	*left_rel, *right_rel;
	i4		left1, right1;
	PSS_RNGTAB	*left_rel1, *right_rel1;
	i4		cols;
	DMT_ATT_ENTRY	**left_attr, *right_attr;
	PST_QNODE	*var1, *var2, *oper;
	PST_VAR_NODE	var_node;
	PST_OP_NODE	op_node;
	DB_STATUS	status;
	i4		err_code;
	i4		rmask;
	bool		duperr;
	
	/* Not supported yet - just issue error. */
	(VOID) psf_error(5120L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 10);
	if (TRUE)	/* to eliminate compiler warning */
	    return(E_DB_ERROR);

	if (cb->pss_distrib & DB_3_DDB_SESS && 
	    cb->pss_stmt_flags & PSS_OUTER_OJ)
	{
	    (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		sizeof("OUTER JOIN syntax") - 1, "OUTER JOIN syntax");
	    return (E_DB_ERROR);
	}

	/* Set the outer_relation masks for relations in this join */

	join_info = yyvarsp->pss_join_info.pss_join + yyvarsp->pss_join_info.depth;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEcopy((char *)yacc_cb->yypvt[-3].psl_varmap, sizeof(PST_J_MASK), (char *)mask);
	BTor(PST_NUMVARS, (char *)yacc_cb->yypvt[-0].psl_varmap, (char *)mask);

	if ((join_info->join_type & DB_FULL_JOIN) == DB_FULL_JOIN)
	{
	    /*
	    ** For FULL joins left AND right relations are marked as both inner
	    ** and outer
	    */
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, mask,
	                 (i4) join_info->join_id, yyvarsp->rng_vars, DB_FULL_JOIN);
	}
	else if (join_info->join_type & DB_LEFT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, yacc_cb->yypvt[-0].psl_varmap, yacc_cb->yypvt[-3].psl_varmap,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_LEFT_JOIN);
	}
	else if (join_info->join_type & DB_RIGHT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, yacc_cb->yypvt[-3].psl_varmap, yacc_cb->yypvt[-0].psl_varmap,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_RIGHT_JOIN);
	}
	else if (join_info->join_type & DB_INNER_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, (PST_J_MASK *) NULL,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_INNER_JOIN);
	}

	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_type |=
								    DB_NAT_JOIN;
	/* save masks representing left and right relations of this join */
	MEcopy((char *)yacc_cb->yypvt[-3].psl_varmap, sizeof(PST_J_MASK), 
				(char *)&join_info->left_rels);
	MEcopy((char *)yacc_cb->yypvt[-0].psl_varmap, sizeof(PST_J_MASK), 
				(char *)&join_info->right_rels);


	/* Originally, there are no nodes to be reused */
	var1 = var2 = oper = (PST_QNODE *) NULL;

	/*
	** Initialize fields in op_node so we don't have to do it repeatedly
	** inside the loop
	*/
	op_node.pst_opno = ADI_EQ_OP;
	op_node.pst_opmeta = PST_NOMETA;
	op_node.pst_isescape = PST_DOESNT_APPLY;
	
	/* For natural joins we have to generate the join_search condition */
	for (left = -1;
	     (left = BTnext(left, (char *) &join_info->left_rels,
	                    PST_NUMVARS)) >= 0;
	    )
	{
	    left_rel = yyvarsp->rng_vars[left];
	    for (cols = 0, left_attr = left_rel->pss_attdesc + 1;
	         cols < left_rel->pss_tabdesc->tbl_attr_count;
		 cols++, left_attr++)
	    {
		for (right = -1;
		     (right = BTnext(right, (char *) &join_info->right_rels,
				     PST_NUMVARS)) >= 0;
		    )
		{
		    right_rel = yyvarsp->rng_vars[right];

		    /*
		    ** Check for like-named attributes.  If there are no
		    ** like-named attributes, go to next right relation
		    */
		    right_attr = pst_coldesc(right_rel,&(*left_attr)->att_name);
		    if (right_attr == (DMT_ATT_ENTRY *) NULL)
		    {
			continue;
		    }

		    /* See if the common column appears elsewhere in left or 
		    ** right join sources. This is NOT permitted. */
		    duperr = FALSE;
		    for (left1 = left; 
			(left1 = BTnext(left1, (char *) &join_info->left_rels,
	                    PST_NUMVARS)) >= 0 && !duperr; )
		    {
			/* Check for dup in rest of left rels. */
			left_rel1 = yyvarsp->rng_vars[left1];
			if (pst_coldesc(left_rel1, &(*left_attr)->att_name))
			    duperr = TRUE;	/* same col in another left rel */
		    }
		    if (!duperr)
		     for (right1 = right;
			(right1 = BTnext(right1, (char *) &join_info->right_rels,
	                    PST_NUMVARS)) >= 0 && !duperr; )
		    {
			/* Check for dup in rest of right rels. */
			right_rel1 = yyvarsp->rng_vars[right1];
			if (pst_coldesc(right_rel1, &(*left_attr)->att_name))
			    duperr = TRUE;	/* same col in another right rel */
		    }
		    if (duperr)
		    {
			i4		err_code;

			(VOID) psf_error(E_PS03A5_MULT_COMMON_COLS, 0L, PSF_USERERR,
	        	    &err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
			    &cb->pss_lineno, psf_trmwhite(DB_MAXNAME, 
			    (char *)&(*left_attr)->att_name),
			    (char *)&(*left_attr)->att_name);
			return (E_DB_ERROR);
		    }


		    /*
		    ** We may have a preallocated node representing a column in
		    ** the left relation.  If so, just reinitialize the fileds
		    ** in the node; otherwise, allocate AND initialize the
		    ** fields now.
		    */
		    STRUCT_ASSIGN_MACRO((*left_attr)->att_name,
					var_node.pst_atname);

		    var_node.pst_vno            = left;
		    var_node.pst_atno.db_att_id = (*left_attr)->att_number;

		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var_node,
			sizeof(var_node), (DB_DT_ID) (*left_attr)->att_type,
			(i2) (*left_attr)->att_prec,
			(i4) (*left_attr)->att_width, (DB_ANYTYPE *) NULL,
			&var1, &psq_cb->psq_error,
			(var1 == (PST_QNODE *) NULL) ? 0 : PSS_NOALLOC);

		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		    var1->pst_sym.pst_dataval.db_collID =
						(*left_attr)->att_collID;

		    /*
		    ** We may have a preallocated node representing a column in
		    ** the right relation.  If so, just reinitialize the fileds
		    ** in the node; otherwise, allocate AND initialize the
		    ** fields now.
		    */

		    var_node.pst_vno            = right;
		    var_node.pst_atno.db_att_id = right_attr->att_number;

		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var_node,
			sizeof(var_node), (DB_DT_ID) right_attr->att_type,
			(i2) right_attr->att_prec, (i4) right_attr->att_width,
			(DB_ANYTYPE *) NULL, &var2, &psq_cb->psq_error,
			(var2 == (PST_QNODE *) NULL) ? 0 : PSS_NOALLOC);

		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		    var2->pst_sym.pst_dataval.db_collID =
						right_attr->att_collID;

		    /*
		    ** We may have a preallocated node representing comparison.
		    ** If so, just reinitialize the fileds in the node;
		    ** otherwise, allocate AND initialize the fields now.
		    ** Also, since we are not sure if a comparison would be
		    ** legal, and the user should not see the results of out
		    ** vain attempts
		    */

		    rmask = PSS_NOTYPERES_ERR;
		    if (oper != (PST_QNODE *) NULL)
		    {
			/*
			** If oper node has already been allocated, we will make
			** var1 and var2 its children, and indicate to
			** pst_node() that only type resolution need to be
			** performed.
			*/
			oper->pst_left  = var1;
			oper->pst_right = var2;
			rmask |= PSS_TYPERES_ONLY;
		    }
			
		    status = pst_node(cb, &cb->pss_ostream, var1, var2,
			PST_BOP, (char *) &op_node, sizeof(op_node), DB_NODT,
			(i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &oper,
			&psq_cb->psq_error, rmask);

		    /*
		    ** If the error resulted from an invalid comparison as would
		    ** be indicated by the PSS_NOTYPERES_ERR bit being reset,
		    ** continue; otherwise return to the caller
		    */
		    if (DB_FAILURE_MACRO(status))
		    {
			if (~rmask & PSS_NOTYPERES_ERR)
			{
			    continue;
			}
			
			return(status);
		    }

		    /*
		    ** If this is the first qualification, do not create AND
		    ** node, just make qual point at the PST_BOP we just created
		    */
		    if (qual == (PST_QNODE *) NULL)
		    {
			qual = oper;
		    }
		    else
		    {
			/*
			** The columns can indeed be compared.  Add the comparison
			** to our qualification
			*/
			
			status = pst_node(cb, &cb->pss_ostream, oper, qual,
			    PST_AND, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT,
			    (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &qual,
			    &psq_cb->psq_error, (i4) 0);

			if (DB_FAILURE_MACRO(status))
			{
			    return(status);
			}
		    }
		    /* store join_id in the EQUAL node and in the AND node */
		    qual->pst_sym.pst_value.pst_s_op.pst_joinid =
			oper->pst_sym.pst_value.pst_s_op.pst_joinid =
			    join_info->join_id;

		    /*
		    ** Nodes pointed to by var1, var2, and oper have been used.
		    ** We will reset these ptrs to NULL to indicate that new
		    ** nodes need to be allocated
		    */
		    var1 = var2 = oper = (PST_QNODE *) NULL;
		}
	    }
	}

	/*
	** If this is the first join_search qualification, just make
	** j_qual->pss_qual point at it; otherwise build a new PST_AND
	** node with new qual and all the previously collected quals as
	** left and right children, respectively
	*/
	if (yyvarsp->j_qual->pss_qual == (PST_QNODE *) NULL)
	{
	    yyvarsp->j_qual->pss_qual = qual;
	}
	else
	{
	    status = pst_node(cb, &cb->pss_ostream, qual, yyvarsp->j_qual->pss_qual,
		PST_AND, (char *) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &yyvarsp->j_qual->pss_qual,
		&psq_cb->psq_error, (i4) 0);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }

	    /* Note that pst_joinid was set to PST_NOJOIN in pst_node() */
	}

	/* indicate that we will be processing join_search clause */
	BTset(++yyvarsp->qual_depth, yyvarsp->qual_type);

	/* Set the outer_relation masks for relations in this join */

	join_info = yyvarsp->pss_join_info.pss_join + yyvarsp->pss_join_info.depth;

	if ((join_info->join_type & DB_FULL_JOIN) == DB_FULL_JOIN)
	{
	    /*
	    ** For FULL joins left AND right relations are marked as both inner
	    ** and outer
	    */
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, mask,
	                 (i4) join_info->join_id, yyvarsp->rng_vars, DB_FULL_JOIN);
	}
	else if (join_info->join_type & DB_LEFT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, yacc_cb->yypvt[-0].psl_varmap, yacc_cb->yypvt[-3].psl_varmap,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_LEFT_JOIN);
	}
	else if (join_info->join_type & DB_RIGHT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, yacc_cb->yypvt[-3].psl_varmap, yacc_cb->yypvt[-0].psl_varmap,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_RIGHT_JOIN);
	}
	else if (join_info->join_type & DB_INNER_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, (PST_J_MASK *) NULL,
			 (i4) join_info->join_id, yyvarsp->rng_vars, DB_INNER_JOIN);
	}

	yyvarsp->qual_depth--;		    /* done with this qualification */
	yyvarsp->pss_join_info.depth--;    /* done with this join */
	yacc_cb->yyval.psl_varmap = mask;
    } break;

case 1412:
if (!((*yyvarspp)->bypass_actions))
/* # line 30638 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_INNER_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_INNER_OJ;
    } break;

case 1413:
if (!((*yyvarspp)->bypass_actions))
/* # line 30645 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_INNER_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_INNER_OJ;
    } break;

case 1414:
if (!((*yyvarspp)->bypass_actions))
/* # line 30652 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
							  DB_INTERSECT_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_INNER_OJ;
    } break;

case 1415:
if (!((*yyvarspp)->bypass_actions))
/* # line 30659 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_LANTI_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1416:
if (!((*yyvarspp)->bypass_actions))
/* # line 30666 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_LANTI_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1417:
if (!((*yyvarspp)->bypass_actions))
/* # line 30673 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_LEFT_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1418:
if (!((*yyvarspp)->bypass_actions))
/* # line 30680 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_LEFT_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1419:
if (!((*yyvarspp)->bypass_actions))
/* # line 30687 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_RANTI_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1420:
if (!((*yyvarspp)->bypass_actions))
/* # line 30694 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_RANTI_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1421:
if (!((*yyvarspp)->bypass_actions))
/* # line 30701 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_RIGHT_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1422:
if (!((*yyvarspp)->bypass_actions))
/* # line 30708 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_RIGHT_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1423:
if (!((*yyvarspp)->bypass_actions))
/* # line 30715 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_FANTI_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1424:
if (!((*yyvarspp)->bypass_actions))
/* # line 30722 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_FANTI_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1425:
if (!((*yyvarspp)->bypass_actions))
/* # line 30729 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_FULL_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1426:
if (!((*yyvarspp)->bypass_actions))
/* # line 30736 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->pss_join_info.pss_join[++yyvarsp->pss_join_info.depth].join_type =
								  DB_FULL_JOIN;
	yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id  = ++yyvarsp->join_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    } break;

case 1429:
if (!((*yyvarspp)->bypass_actions))
/* # line 30749 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	/*
	** If this is the first join_search qualification, just make
	** j_qual->pss_qual point at it; otherwise build a new PST_AND
	** node with new qual and all the previously collected quals as
	** left and right children, respectively
	*/
	if (yyvarsp->j_qual->pss_qual == (PST_QNODE *) NULL)
	{
	    yyvarsp->j_qual->pss_qual = yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree;
	}
	else
	{
	    status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree,
		yyvarsp->j_qual->pss_qual, PST_AND, (char *) NULL, sizeof(PST_OP_NODE),
		DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
		&yyvarsp->j_qual->pss_qual, &psq_cb->psq_error, (i4) 0);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }

	    /* Note that pst_joinid was set to PST_NOJOIN in pst_node() */
	}
    } break;

case 1433:
if (!((*yyvarspp)->bypass_actions))
/* # line 30787 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_1JOIN	*join_info;
	i4		left, right;
	PSS_RNGTAB	*left_rel, *right_rel;
	i4		cols;
	DMT_ATT_ENTRY	*left_attr, *right_attr;
	DB_ATT_NAME	colname;
	PST_QNODE	*var1, *var2, *oper;
	PST_VAR_NODE	var_node;
	PST_OP_NODE	op_node;
	DB_STATUS	status;
	i4		mask;
	bool		found = FALSE;
	
	join_info = yyvarsp->pss_join_info.pss_join + yyvarsp->pss_join_info.depth;

	/* Originally, there are no nodes to be reused */
	var1 = var2 = oper = (PST_QNODE *) NULL;

	/*
	** Initialize fields in op_node so we don't have to do it repreatedly
	** inside the loop
	*/
	op_node.pst_opno = ADI_EQ_OP;
	op_node.pst_opmeta = PST_NOMETA;
	op_node.pst_isescape = PST_DOESNT_APPLY;
	
	/* For named column joins we have to generate the join_search condition */
	for (left = -1;
	     (left = BTnext(left, (char *) &join_info->left_rels,
	                    PST_NUMVARS)) >= 0;
	    )
	{
	    /* First, look for the column in the left join source. */
	    left_rel = yyvarsp->rng_vars[left];
	    STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, (char *)&colname);
	    left_attr = pst_coldesc(left_rel, &colname);
	    if (left_attr == NULL)
		continue;

	    for (right = -1;
		 (right = BTnext(right, (char *) &join_info->right_rels,
				     PST_NUMVARS)) >= 0;
		    )
	    {
		/* Now look for the column in the right join source. */
		right_rel = yyvarsp->rng_vars[right];
		right_attr = pst_coldesc(right_rel,&left_attr->att_name);
		if (right_attr == (DMT_ATT_ENTRY *) NULL)
			continue;
		found = TRUE;	/* found it in both */

		/* Allocate the PST_VAR for the column in left source. */
		STRUCT_ASSIGN_MACRO(left_attr->att_name,
					var_node.pst_atname);

		var_node.pst_vno            = left;
		var_node.pst_atno.db_att_id = left_attr->att_number;

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var_node,
			sizeof(var_node), (DB_DT_ID) left_attr->att_type,
			(i2) left_attr->att_prec,
			(i4) left_attr->att_width, (DB_ANYTYPE *) NULL,
			&var1, &psq_cb->psq_error, 0);

		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
		var1->pst_sym.pst_dataval.db_collID = left_attr->att_collID;

		/* Allocate the PST_VAR for the column in right source. */

		var_node.pst_vno            = right;
		var_node.pst_atno.db_att_id = right_attr->att_number;

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var_node,
			sizeof(var_node), (DB_DT_ID) right_attr->att_type,
			(i2) right_attr->att_prec, (i4) right_attr->att_width,
			(DB_ANYTYPE *) NULL, &var2, &psq_cb->psq_error, 0);

		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
		var2->pst_sym.pst_dataval.db_collID = right_attr->att_collID;

		/* Allocate the PST_BOP node to perform the "=" comparison. */

		status = pst_node(cb, &cb->pss_ostream, var1, var2,
			PST_BOP, (char *) &op_node, sizeof(op_node), DB_NODT,
			(i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &oper,
			&psq_cb->psq_error, 0);

		/*
		** If the error resulted from an invalid comparison as would
		** be indicated by the PSS_NOTYPERES_ERR bit being reset,
		** continue; otherwise return to the caller
		*/
		if (DB_FAILURE_MACRO(status))
		{
/*
		    if (~mask & PSS_NOTYPERES_ERR)
		    {
			continue;
		    }
*/
			
		    return(status);
		}

		/*
		** If this is the first join_search qualification, just make
		** j_qual->pss_qual point at it; otherwise build a new PST_AND
		** node with new qual and all the previously collected quals as
		** left and right children, respectively */

		if (yyvarsp->j_qual->pss_qual == (PST_QNODE *) NULL)
		{
		    yyvarsp->j_qual->pss_qual = oper;
		}
		else
		{
		    status = pst_node(cb, &cb->pss_ostream, oper, 
			    yyvarsp->j_qual->pss_qual, PST_AND, (char *) NULL, 
			    sizeof(PST_OP_NODE), DB_NODT, (i2) 0,
			    (i4) 0, (DB_ANYTYPE *) NULL, &yyvarsp->j_qual->pss_qual,
			    &psq_cb->psq_error, (i4) 0);

		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		}
		/* Store join_id in the EQUAL node. */
		oper->pst_sym.pst_value.pst_s_op.pst_joinid =
			    join_info->join_id;
	    }
	}

	/* If the column wasn't found in both left and right join sources,
	** report the error. */
	if (!found)
	{
	    i4		err_code;

	    (VOID) psf_error(E_PS03AC_MISSING_COLUMN, 0L, PSF_USERERR,
	        &err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, psf_trmwhite(DB_MAXNAME, (char *)&colname),
		&colname);
	    return (E_DB_ERROR);
	}

    } break;

case 1434:
if (!((*yyvarspp)->bypass_actions))
/* # line 30946 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** if there is an aggregate function anywhere in the where_clause, it is
	** illegal for it to be correlated to any range vars from the subselect
	** at this depth.
	*/
	BTor(BITS_IN(yyvarsp->illegal_agg_relmask),
	     (char *) &yyvarsp->flists[cb->pss_qualdepth],
	     (char *) &yyvarsp->illegal_agg_relmask);
	yyvarsp->in_where_clause++;		/* level of where nesting */
    } break;

case 1435:
if (!((*yyvarspp)->bypass_actions))
/* # line 30958 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** Since we are done with this where_clause, remove relations which
	** appeared at this level from $Yillegal_agg_relmask
	*/
	BTnot(  BITS_IN(yyvarsp->flists[cb->pss_qualdepth]),
		(char *) &yyvarsp->flists[cb->pss_qualdepth]);
	BTand(  BITS_IN(yyvarsp->illegal_agg_relmask),
		(char *) &yyvarsp->flists[cb->pss_qualdepth],
		(char *) &yyvarsp->illegal_agg_relmask);
	BTnot(  BITS_IN(yyvarsp->flists[cb->pss_qualdepth]),
		(char *) &yyvarsp->flists[cb->pss_qualdepth]);

	yyvarsp->in_where_clause--;
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree;
    } break;

case 1436:
if (!((*yyvarspp)->bypass_actions))
/* # line 30975 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*nonode;

	/* Create a QLEND node. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &nonode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = nonode;
    } break;

case 1438:
if (!((*yyvarspp)->bypass_actions))
/* # line 30996 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	if (yyvarsp->seq_ops)
	{
	    /* No use of sequences in grouped selects. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	yyvarsp->in_groupby_clause = FALSE;
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1439:
if (!((*yyvarspp)->bypass_actions))
/* # line 31011 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;
    } break;

case 1440:
if (!((*yyvarspp)->bypass_actions))
/* # line 31017 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** set in_groupby_clause so that we don't get correlated columns in the
	** group by list.
	*/
	yyvarsp->in_groupby_clause = TRUE;

	/* Mark this SELECT stmnt as non-updatable */
	if (cb->pss_qualdepth == 1 || 
		cb->pss_qualdepth == 2 && yyvarsp->prev_yyvarsp)
	{
	    yyvarsp->nonupdt = TRUE;
	    yyvarsp->nonupdt_reason |= PSS_GROUP_BY_IN_OUTERMOST_SUBSEL;
	}

    } break;

case 1441:
if (!((*yyvarspp)->bypass_actions))
/* # line 31036 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	    yyvarsp->inhaving++;
    } break;
	}
	return(0);
}

i4
psls29iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1442:
if (!((*yyvarspp)->bypass_actions))
/* # line 31040 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Mark this SELECT stmnt as non-updatable */
	if (cb->pss_qualdepth == 1 ||
		cb->pss_qualdepth == 2 && yyvarsp->prev_yyvarsp)
	{
	    yyvarsp->nonupdt = TRUE;
	    yyvarsp->nonupdt_reason |= PSS_HAVING_IN_OUTERMOST_SUBSEL;
	}

	yyvarsp->inhaving--;
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree;
    } break;

case 1443:
if (!((*yyvarspp)->bypass_actions))
/* # line 31053 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;
    } break;

case 1445:
if (!((*yyvarspp)->bypass_actions))
/* # line 31062 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE              *newnode;
	DB_STATUS	       status;
	PST_RSDM_NODE	       resdom;

	/* Make RESDOM for grouping column/expression. */
	resdom.pst_ntargno = (i4) 0;
	resdom.pst_ttargtype = (i4) PST_ATTNO;
	resdom.pst_rsupdt = FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;  /* was |= ... */
	resdom.pst_dmuflags = 0;
	/* GROUP BY list element must be numbered */
	resdom.pst_rsno = yyvarsp->bylist_elem_no = 1;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, yacc_cb->yypvt[-0].psl_trtype,
	    PST_RESDOM, (PTR) &resdom, sizeof(PST_RSDM_NODE),
	    yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_datatype, 
	    yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_prec, yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1446:
if (!((*yyvarspp)->bypass_actions))
/* # line 31089 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE              *newnode;
	DB_STATUS	       status;
	PST_RSDM_NODE	       resdom;

	/* Make RESDOM for grouping column/expression. */

	resdom.pst_ntargno = (i4) 0;
	resdom.pst_ttargtype = (i4) PST_ATTNO;
	resdom.pst_rsupdt = FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;  /* was |= ... */
	resdom.pst_dmuflags = TRUE;
	resdom.pst_rsno = ++yyvarsp->bylist_elem_no;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, yacc_cb->yypvt[-0].psl_trtype, 
	    PST_RESDOM, (PTR) &resdom, sizeof(PST_RSDM_NODE),
	    yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_datatype, 
	    yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_prec, yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* link the values of the left side */
	yacc_cb->yyval.psl_trtype = pst_tlprpnd(yacc_cb->yypvt[-2].psl_trtype, newnode);
    } break;

case 1447:
if (!((*yyvarspp)->bypass_actions))
/* # line 31119 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	i4		err_code;
	PSS_RNGTAB      *rngvar;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; bypass parsing */
	    yacc_cb->yyval.psl_trtype = NULL;
	    break;
	}

	if (!(yacc_cb->yypvt[-0].psl_col_ref->pss_flags &
	          (PSS_TBL_OR_CORR_NAME_SPECIFIED | PSS_TBL_SPECIFIED)))
	{
	    /* column was specified */
	    
	    DB_ATT_NAME	    colname;
            bool            found_resdom = FALSE;
            bool            found_var = FALSE;
	    PSS_DECVAR	    *var;

	    if (yyvarsp->in_rule == TRUE)
	    {
		/* If in rule MUST be qualified */
		_VOID_ psf_error(E_US189F_6303_RULE_COL, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    STlength(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name), yacc_cb->yypvt[-0].psl_col_ref->pss_col_name);
		return (E_DB_ERROR);
	    }

	    STmove(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name, ' ', sizeof(DB_ATT_NAME),
		(char *) &colname);

	    if (yyvarsp->isdbp == TRUE)
	    {
		/* Search for the variable; innermost scope first. */
		for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
		     var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
		     var = (PSS_DECVAR *) var->pss_queue.q_next
		    )
		{
		    if (var->pss_out)
			continue;

		    if (MEcmp((PTR) &colname, (PTR) &var->pss_varname,
			sizeof(var->pss_varname)) == 0
		       )
		    {
			found_var = TRUE;
			break;
		    }
		}
	    }

	    /* If CALLPROC and either not a local var or simple column name */
	    if (psq_cb->psq_mode == PSQ_CALLPROC && !found_var)
	    {
		/* Unknown local variable or isolated column specified */
		(VOID) psf_error(yyvarsp->isdbp ? 2403L : E_US0986_2438_EXEC_COL, 0L,
		    PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
		    STlength(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name), yacc_cb->yypvt[-0].psl_col_ref->pss_col_name);
		return (E_DB_ERROR);
	    }

	    /* if parsing a check constraint, we are collecting text
	    ** in 2 separate chains, and the 2nd chain must contain the 
	    ** correlation name NEW (for later use in creating a rule).
	    ** So add "NEW." to the chain.
	    */
	    if (cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
	    {
		PTR	oldpiece, newpiece;
		
		/* get a pointer to the column name (which is the
		** next-to-last text piece, as the scanner/grammar
		** has to lookahead to get to this token)
		*/
		oldpiece = psq_tbackfromlast(cb->pss_tchain2, 1);
		if (oldpiece == (PTR) NULL)
		{
		    psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
			      &err_code, &psq_cb->psq_error, 0);
		    return(E_DB_OK);
		}

		status = psq_tinsert(cb->pss_tchain2, 
				     (u_char *) ERx(" NEW."),
				     sizeof(ERx(" NEW."))-1,
				     &newpiece, oldpiece,
				     &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

	    }  /* end if PSS_PARSING_CHECK_CONS */

	    /*
	    ** Since we will no longer expect to see the from_list before we see
	    ** target list, we can do very little when we see a name which may
	    ** or may not turn out to be a column name.  If we are in the
	    ** process of parsing the target clause, simply generate a VAR node,
	    ** and do all the necessary checking later.
	    ** (rjb) Do same thing when parsing a check constraint specified as
	    ** a part of CREATE TABLE statement, since a user can define a check
	    ** constraint before defining the columns in the table.
	    */
	    if (yyvarsp->in_target_clause
		|| (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		    && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		         ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	    {
		PST_VAR_NODE	varnode;

		MEfill(sizeof(PST_VAR_NODE), '\0', (PTR)&varnode);
		STRUCT_ASSIGN_MACRO(colname, varnode.pst_atname);

		/*
		** If local var was found, allocate enough space to accomodate
		** it in case no attribute will be found
		*/
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
		    (found_var) ? max(sizeof(PST_VAR_NODE), 
                    sizeof(PST_CNST_NODE)) : sizeof(varnode),
		    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &newnode,
		    &psq_cb->psq_error, (i4) 0);

		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
	    }
	    else
	    {
		/*
		** For each range entry look for attribute in relation in the
		** FROM list.  If there is no FROM list, do not bother to call
		** psl_fatt
		*/
		if (yyvarsp->in_groupby_clause && 
		    BTcount((char *)&yyvarsp->flists[cb->pss_qualdepth], 
				PST_NUMVARS) == 0)
		{
		    /* If column was not found but there is a var */
		    if (yyvarsp->isdbp && found_var)
		    {
			/* Create a CNST node for the var. */
			PST_CNST_NODE	cconst;

			/* Parm or local variable */
			cconst.pst_tparmtype = PST_LOCALVARNO;
			cconst.pst_parm_no = var->pss_no;
			cconst.pst_pmspec  = PST_PMNOTUSED;
			cconst.pst_cqlang = DB_SQL;
			cconst.pst_origtxt = (char *) NULL;
			status = pst_node(cb, &cb->pss_ostream,
			    (PST_QNODE *) NULL, (PST_QNODE *) NULL,
			    PST_CONST, (char *) &cconst, sizeof(cconst),
			    var->pss_dbdata.db_datatype,
			    (i2) var->pss_dbdata.db_prec,
			    (i4) var->pss_dbdata.db_length, 
			    (DB_ANYTYPE *) var->pss_dbdata.db_data,
			    &newnode, &psq_cb->psq_error, (i4) 0);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }
		    else
		    {
			(VOID) psf_error(2103L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 2,
			    (i4) sizeof(cb->pss_lineno),
			    &cb->pss_lineno,
			    (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name),
			    yacc_cb->yypvt[-0].psl_col_ref->pss_col_name);
			return (E_DB_ERROR);
		    }
		}
		else
		{
		    PSS_1JOIN   *join_info;
		    PST_J_MASK    join_rels;
		    i4	    mask;

		    if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
		    {
			join_info = yyvarsp->pss_join_info.pss_join +
			    yyvarsp->pss_join_info.depth;
			mask = JOINREL_MASK;
			MEcopy((char *)&join_info->left_rels,
			    sizeof(PST_J_MASK), (char *)&join_rels);
			BTor(PST_NUMVARS, (char *) &join_info->right_rels,
			     (char *) &join_rels);
		    }
		    else
		    {
			mask = 0;
			MEfill(sizeof(PST_J_MASK), 0, (char *)&join_rels);
		    }
			
                    /* found_var (previously found) may be true but
                    ** if we are in an ORDER BY the host variable would
                    ** not be valid anyway so we should over-ride the
                    ** 'find' if we have a matching resdom and we're in
                    ** an ORDER BY. We should then ensure we do not enter
                    ** the var logic in the follow IF statement.
                    */

                    if (yyvarsp->in_orderby)
                    {
                        PST_QNODE	*resdomp;
                    
                        for (resdomp = cb->pss_tlist; resdomp &&
                            resdomp->pst_sym.pst_type == PST_RESDOM;
                            resdomp = resdomp->pst_left)
                        if (!MEcmp((char *)&colname, 
                            (char *)&resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
                            DB_MAXNAME))
                        {
                            found_resdom = TRUE;  /* got matching RESDOM */
                            newnode = resdomp;
                            break;
                        }
                    }
		    
		    if (!found_var || found_resdom)
		    {
			if (!found_var && !found_resdom) /* there must be a column */
			{
			    /* find attribute */
			    status = psl_fatt(cb, psq_cb, 
				yyvarsp->in_orderby | yyvarsp->in_groupby_clause, 
				&colname, &newnode, &rngvar, mask | ALLOC_NODE,
				&join_rels);
			    if (DB_FAILURE_MACRO(status))
				return (status);

			    if (rngvar->pss_rgparent != cb->pss_qualdepth)
			    {
				register i4	i;
				/*
				** pss_rgparent MUST be < pss_qualdepth; we set
				** the bit in the correlation for all levels
				** starting with pss_rgparent+1 to pss_qualdepth
				*/
				for (i = rngvar->pss_rgparent +1;
				     i <= cb->pss_qualdepth; i++)
				{
				    BTset(i, (char *) yyvarsp->correlation_mask);
				}

				if (yyvarsp->mult_corr_attrs.depth != -1 &&
				    !yyvarsp->mult_corr_attrs.found)
				{
				    if (yyvarsp->mult_corr_attrs.rgno == -1)
				    {
					yyvarsp->mult_corr_attrs.rgno =
					    rngvar->pss_rgno;
				    }
				    else if (yyvarsp->mult_corr_attrs.rgno !=
					 rngvar->pss_rgno)
				    {
					yyvarsp->mult_corr_attrs.found = TRUE;
				    }
				}

				if (yyvarsp->corr_aggr.depth != -1)
				{
				    yyvarsp->corr_aggr.found = TRUE;
				}
			    }
			}
		    }    
		    else			/* there is a var */
		    {
			/* There is a local var and we do not want any error
			** messages to be send to user yet.
			*/

			/*
			** find if there is also an attribute (check only)
			*/
			status = psl_fatt(cb, psq_cb, 
			    yyvarsp->in_orderby | yyvarsp->in_groupby_clause, 
			    &colname, &newnode, &rngvar, mask | FIND_ONLY,
			    &join_rels);
			if (DB_FAILURE_MACRO(status))
			{
			    /* Column was not found, therefore
			    ** create a CNST node for the var.
			    */
			    PST_CNST_NODE	cconst;

			    /* Parm or local variable */
			    cconst.pst_tparmtype = PST_LOCALVARNO;
			    cconst.pst_parm_no = var->pss_no;
			    cconst.pst_pmspec  = PST_PMNOTUSED;
			    cconst.pst_cqlang = DB_SQL;
			    cconst.pst_origtxt = (char *) NULL;
			    status = pst_node(cb, &cb->pss_ostream,
				(PST_QNODE *) NULL, (PST_QNODE *) NULL,
				PST_CONST, (char *) &cconst, sizeof(cconst),
				var->pss_dbdata.db_datatype,
				(i2) var->pss_dbdata.db_prec,
				(i4) var->pss_dbdata.db_length, 
				(DB_ANYTYPE *) var->pss_dbdata.db_data,
				&newnode, &psq_cb->psq_error, (i4) 0);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}
			else
			{
			    /* Column was found, reexecute call to psl_fatt,
			    ** this time create a var node for the column.
			    */
			    status = psl_fatt(cb, psq_cb,
				yyvarsp->in_orderby | yyvarsp->in_groupby_clause, 
				&colname, &newnode,
				&rngvar, mask | ALLOC_NODE, &join_rels);
			    if (DB_FAILURE_MACRO(status))
				return (status);

			    if (rngvar->pss_rgparent != cb->pss_qualdepth)
			    {
				register i4	i;
				/*
				** pss_rgparent MUST be < pss_qualdepth;
				** we set the bit in the correlation for
				** all levels starting with pss_rgparent+1
				** to pss_qualdepth
				*/
				for (i = rngvar->pss_rgparent +1;
				     i <= cb->pss_qualdepth; i++)
				{
				    BTset(i, (char *) yyvarsp->correlation_mask);
				}

				if (yyvarsp->mult_corr_attrs.depth != -1 &&
				    !yyvarsp->mult_corr_attrs.found)
				{
				    if (yyvarsp->mult_corr_attrs.rgno == -1)
				    {
					yyvarsp->mult_corr_attrs.rgno =
					    rngvar->pss_rgno;
				    }
				    else if (yyvarsp->mult_corr_attrs.rgno !=
					     rngvar->pss_rgno)
				    {
					yyvarsp->mult_corr_attrs.found = TRUE;
				    }
				}

				if (yyvarsp->corr_aggr.depth != -1)
				{
				    yyvarsp->corr_aggr.found = TRUE;
				}
			    }
			}
		    }
		}
	    }
	}
	else
	{
	    /* [schema.]table.column was specified */
	    
	    DMT_ATT_ENTRY       *attribute;
	    PST_VAR_NODE	varnode;
	    PST_RL_NODE		rulenode;

	    /* 
	    ** first find a range var referred in this <column reference>
	    ** or, if we are processing an element of a target list, get an
	    ** address of a <table reference> description which we'll be
	    ** able to dereference once the FROM list has been parsed
	    */
	    status = psl_tbl_ref(psq_cb, cb, yacc_cb->yypvt[-0].psl_col_ref, yyvarsp->in_target_clause,
		yyvarsp->in_groupby_clause, &yyvarsp->tbl_refs, &rngvar);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    MEfill(sizeof(PST_VAR_NODE), '\0', (PTR)&varnode);

	    /* Normalize the attribute name */
	    STmove(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name, ' ', sizeof(DB_ATT_NAME), 
		(char *) &varnode.pst_atname);

	    /* if parsing a check constraint, we are collecting text
	    ** in 2 separate chains, and the 2nd chain must use the 
	    ** correlation name NEW (for later use in creating a rule).
	    ** So delete the pieces containing <schema name> and "." (if
	    ** schema name was specified) and replace existing correlation name
	    ** with " NEW"
	    */
	    if (cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
	    {
		PTR	    oldpiece, corr_piece;
		
		/*
		** backtrack past the column name and period
		** if schema name was specified, the last piece in the chain
		** will contain column name; otherwise, YACC would look ahead
		** one token
		*/
		oldpiece = psq_tbackfromlast(cb->pss_tchain2,
		    (yacc_cb->yypvt[-0].psl_col_ref->pss_flags & PSS_SCHEMA_SPECIFIED) ? 2 : 3);
		if (oldpiece == (PTR) NULL)
		{
		    psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
			      &err_code, &psq_cb->psq_error, 0);
		    return(E_DB_OK);
		}

		/* replace correlation name with NEW */
		status = psq_tsubs(cb->pss_tchain2, oldpiece,
				   (u_char *) ERx(" NEW"),
				   sizeof(ERx(" NEW"))-1,
				   &corr_piece, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		/*
		** if have a schema name, delete pieces containing <schema name>
		** and period
		*/
		if (yacc_cb->yypvt[-0].psl_col_ref->pss_flags & PSS_SCHEMA_SPECIFIED)
		{
		    /*
		    ** backtrack from the piece containing " NEW", and delete
		    ** piece containing period
		    */
		    oldpiece = psq_tbacktrack(corr_piece, 1);
		    if (oldpiece == (PTR) NULL)
		    {
			psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
				  &err_code, &psq_cb->psq_error, 0);
			return(E_DB_OK);
		    }

		    psq_tdelete(cb->pss_tchain2, oldpiece);

		    /*
		    ** backtrack from the piece containing " NEW",and delete the
		    ** piece containing schema name
		    */
		    oldpiece = psq_tbacktrack(corr_piece, 1);
		    if (oldpiece == (PTR) NULL)
		    {
			psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
				  &err_code, &psq_cb->psq_error, 0);
			return(E_DB_OK);
		    }

		    psq_tdelete(cb->pss_tchain2, oldpiece);
		}  /* end if PSS_SCHEMA_SPECIFIED) */
	    }  /* end if PSS_PARSING_CHECK_CONS */

	    if (yyvarsp->in_target_clause
		|| (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		    && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		         ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	    {
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode, 
		    sizeof(varnode), DB_NODT, (i2) 0, (i4) 0, 
		    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);

		if (DB_FAILURE_MACRO(status))
		    return(status);

		newnode->pst_sym.pst_dataval.db_data = (PTR) rngvar;
	    }
	    else
	    {
		DMT_ATT_ENTRY	    tid_att;
		
		/*
		** If processing join_search condition, only relations involved
		** in the join may appear in the join_search condition
		*/
		if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
		{
		    PSS_1JOIN	    *join_info = yyvarsp->pss_join_info.pss_join +
						 yyvarsp->pss_join_info.depth;

		    if (!BTtest((i4) rngvar->pss_rgno,
				(char *) &join_info->left_rels)
			&&
			!BTtest((i4) rngvar->pss_rgno,
				(char *) &join_info->right_rels)
		       )
		    {
			/*
			** we ARE processing join_search condition and the user
			** tried to refer to a relation which is nether a left
			** nor a right relation for this join.
			*/
			(VOID) psf_error(E_PS03A4_NOT_A_JREL, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 2,
			    sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(DB_MAXNAME, rngvar->pss_rgname),
			    rngvar->pss_rgname);
			return(E_DB_ERROR);
		    }
		}

		/* Look up the attribute */
		attribute = pst_coldesc(rngvar, &varnode.pst_atname);

		/* Check for attribute not found */
		if (attribute == (DMT_ATT_ENTRY *) NULL)
		{
		    /*
		    ** if rngvar represents a view V and column name was TID, we
		    ** will fabricate an attribute entry for V.TID and remember
		    ** that TID attribute of V was referenced;
		    ** at qrymod time, if the V is updatable, we will translate
		    ** the reference to V.TID to the the reference to TID of V's
		    ** underlying base table, otherwise, an error will be issued
		    */
		    if (   rngvar->pss_tabdesc->tbl_status_mask & DMT_VIEW
			&& !STcompare(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name, 
				      ((*cb->pss_dbxlate & CUI_ID_REG_U) ?
				       "TID" : "tid")))
		    {
			rngvar->pss_var_mask |= PSS_TID_REFERENCE;
			
			attribute = &tid_att;
			psl_bld_tid_descr(attribute, cb);
		    }
		    else
		    {
			if (cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
			{
			    char        command[PSL_MAX_COMM_STRING];
			    i4     length;

			    psl_command_string(psq_cb->psq_mode, DB_SQL,
				command, &length);

			    _VOID_ psf_error(E_PS0483_CONS_NO_COL, 0L,
				PSF_USERERR, &err_code, &psq_cb->psq_error, 3,
				length, command,
				(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name),
				yacc_cb->yypvt[-0].psl_col_ref->pss_col_name,
				sizeof(ERx("CHECK")) - 1, ERx("CHECK"));
			}
			else
			{
			    (VOID) psf_error(2100L, 0L, PSF_USERERR, 
				&err_code, &psq_cb->psq_error, 4,
				(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
				psf_trmwhite(sizeof(DB_TAB_NAME), 
				    (char *) &rngvar->pss_tabname),
				&rngvar->pss_tabname,
				psf_trmwhite(sizeof(DB_OWN_NAME), 
				    (char *) &rngvar->pss_ownname),
				&rngvar->pss_ownname, 
				(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name), 
				yacc_cb->yypvt[-0].psl_col_ref->pss_col_name);
			}
			return (E_DB_ERROR);
		    }
		}

		/* 
		** If processing a CREATE RULE statement then create a RULEVAR 
		** node, otherwise create a VAR node.
		*/
		if (yyvarsp->in_rule == TRUE)
		{
							/* PST_BEFORE/AFTER */
		    rulenode.pst_rltype     = rngvar->pss_image;  

		    /* Check if the OLD version of a LOB is being used in an
		    ** AFTER rule - it will have been destroyed by this stage
		    ** so cannot be referenced (kibro01) b119726
		    */
		    if (psq_cb->psq_mode == PSQ_RULE &&
			(attribute->att_flags & ATT_PERIPHERAL))
		    {
		        PSY_CB		*psy_cb = (PSY_CB *)cb->pss_object;
			DB_IIRULE	*rule_tup = &(psy_cb->psy_tuple.psy_rule);
			if ((rule_tup->dbr_flags & DBR_F_AFTER) &&
			    (rngvar->pss_image == PST_BEFORE))
			{
			    (VOID) psf_error(2194L, 0L, PSF_USERERR, 
				&err_code, &psq_cb->psq_error, 4,
				(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
				psf_trmwhite(sizeof(DB_OWN_NAME), 
				    (char *) &rngvar->pss_ownname),
				&rngvar->pss_ownname, 
				psf_trmwhite(sizeof(DB_TAB_NAME), 
				    (char *) &rngvar->pss_tabname),
				&rngvar->pss_tabname,
				(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_col_ref->pss_col_name), 
				yacc_cb->yypvt[-0].psl_col_ref->pss_col_name);
			}
		    }

		    rulenode.pst_rltargtype = PST_ATTNO;
		    rulenode.pst_rltno	    = attribute->att_number;
		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL,
			(PST_QNODE *)NULL, PST_RULEVAR, (char *)&rulenode,
			sizeof(rulenode), (DB_DT_ID)attribute->att_type,
			(i2)attribute->att_prec, (i4)attribute->att_width,
			(DB_ANYTYPE *)NULL, &newnode, &psq_cb->psq_error, 
			(i4) 0);
		}
		else
		{
		    varnode.pst_vno 	       = rngvar->pss_rgno;
		    varnode.pst_atno.db_att_id = attribute->att_number;
		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
			sizeof(varnode), (DB_DT_ID) attribute->att_type,
			(i2) attribute->att_prec, (i4) attribute->att_width,
			(DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, 
			(i4) 0);
		    newnode->pst_sym.pst_dataval.db_collID =
						attribute->att_collID;

		    if (rngvar->pss_rgparent != cb->pss_qualdepth)
		    {
			register i4	i;
			/*
			** pss_rgparent MUST be < pss_qualdepth; we set the
			** bit in the correlation for all levels starting with
			** pss_rgparent+1 to pss_qualdepth
			*/
			for (i = rngvar->pss_rgparent + 1;
			     i <= cb->pss_qualdepth; i++)
			{
			    BTset(i, (char *) yyvarsp->correlation_mask);
			}

			if (yyvarsp->mult_corr_attrs.depth != -1 &&
			    !yyvarsp->mult_corr_attrs.found)
			{
			    if (yyvarsp->mult_corr_attrs.rgno == -1)
			    {
				yyvarsp->mult_corr_attrs.rgno = rngvar->pss_rgno;
			    }
			    else if (yyvarsp->mult_corr_attrs.rgno != rngvar->pss_rgno)
			    {
				yyvarsp->mult_corr_attrs.found = TRUE;
			    }
			}

			if (yyvarsp->corr_aggr.depth != -1)
			{
			    yyvarsp->corr_aggr.found = TRUE;
			}
		    }
		}

		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }
	}

	/*
	** if processing a CHECK constraint defined using ALTER TABLE statement
	** and we have created a PST_VAR node (i.e. we found an attribute
	** described by the <col_ref>), set a bit corresponding to the attribute
	** number in $Ycheck_cons_cols.
	*/
	if (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	    && ( (psq_cb->psq_mode == PSQ_ALTERTABLE) ||
		 (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) )
	    && newnode->pst_sym.pst_type == PST_VAR
	   )
	{
	    BTset((i4) newnode->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id,
		(char *) &yyvarsp->check_cons_cols);
	}
	
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1451:
if (!((*yyvarspp)->bypass_actions))
/* # line 31806 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** if this attribute has been previously seen in the order_by list, we
	** will avoid adding it this time, in which case order_column will
	** return NULL
	*/
	if (yacc_cb->yypvt[-1].psl_trtype != (PST_QNODE *) NULL)
	{
	    yacc_cb->yypvt[-1].psl_trtype->pst_sym.pst_value.pst_s_sort.pst_srasc = TRUE;
	}
    } break;

case 1452:
if (!((*yyvarspp)->bypass_actions))
/* # line 31818 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "desc"))
	{
	    i4	    err_code;

	    /*
	    ** NOTE: this production is curently used only by SELECT.
	    ** Should you change it, make sure that the correct message gets
	    ** displayed.
	    ** (andre 4/26/90)
	    */
	    (VOID) psf_error(2501L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/*
	** if this attribute has been previously seen in the order_by list, we
	** will avoid adding it this time, in which case order_column will
	** return NULL
	*/
	if (yacc_cb->yypvt[-1].psl_trtype != (PST_QNODE *) NULL)
	{
	    yacc_cb->yypvt[-1].psl_trtype->pst_sym.pst_value.pst_s_sort.pst_srasc = FALSE;
	}
    } break;

case 1453:
if (!((*yyvarspp)->bypass_actions))
/* # line 31848 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*sortnode;

	if (yyvarsp->isdbp == TRUE)
	{
	    status = pst_sqlsort(cb, &cb->pss_ostream, cb->pss_tlist,
		yyvarsp->dbpinfo->pss_into_clause,
		&yyvarsp->sort_list, yacc_cb->yypvt[-0].psl_trtype, &sortnode, psq_cb);
	}
	else
	{
	    status = pst_sqlsort(cb, &cb->pss_ostream, cb->pss_tlist,
		(PST_QNODE *) NULL,
		&yyvarsp->sort_list, yacc_cb->yypvt[-0].psl_trtype, &sortnode, psq_cb);
	}
	if (status != E_DB_OK)
	{
	    return(status);
	}
	yacc_cb->yyval.psl_trtype = sortnode;
    } break;

case 1454:
if (!((*yyvarspp)->bypass_actions))
/* # line 31873 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-0].psl_treeinfo_type;
    } break;

case 1455:
if (!((*yyvarspp)->bypass_actions))
/* # line 31877 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;

	/* will reuse the first PSS_TREEINFO passed from below */
	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_treeinfo_type->pss_tree, yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree,
	    PST_OR, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &yacc_cb->yypvt[-2].psl_treeinfo_type->pss_tree, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    yacc_cb->yypvt[-2].psl_treeinfo_type->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	}

	if ((yacc_cb->yypvt[-2].psl_treeinfo_type->pss_mask |= yacc_cb->yypvt[-0].psl_treeinfo_type->pss_mask) & PSS_SUBSEL_IN_TREE)
	{
	    cb->pss_flattening_flags |= PSS_SUBSEL_IN_OR_TREE;
	}

	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-2].psl_treeinfo_type;
    } break;

case 1456:
if (!((*yyvarspp)->bypass_actions))
/* # line 31910 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-0].psl_treeinfo_type;
    } break;

case 1457:
if (!((*yyvarspp)->bypass_actions))
/* # line 31914 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;

	/* will reuse the first PSS_TREEINFO passed from below */
	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_treeinfo_type->pss_tree, yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree,
	    PST_AND, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &yacc_cb->yypvt[-2].psl_treeinfo_type->pss_tree, &psq_cb->psq_error, (i4) 0);

	if (status != E_DB_OK)
	{
	    return (status);
	}

	if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    yacc_cb->yypvt[-2].psl_treeinfo_type->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	}

	yacc_cb->yypvt[-2].psl_treeinfo_type->pss_mask |= yacc_cb->yypvt[-0].psl_treeinfo_type->pss_mask;

	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-2].psl_treeinfo_type;
    } break;

case 1458:
if (!((*yyvarspp)->bypass_actions))
/* # line 31945 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-0].psl_treeinfo_type;
    } break;

case 1459:
if (!((*yyvarspp)->bypass_actions))
/* # line 31949 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;

	/* reuse PSS_TREEINFO passed from below */
	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree,
	    (PST_QNODE *) NULL, PST_NOT, (PTR) NULL, 0, DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &yacc_cb->yypvt[-0].psl_treeinfo_type->pss_tree, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** if multiple correlated relation references occurred in the tree
	** rooted in NOT EXISTS we need to indicate to OPF that no flattening is
	** to take place
	*/
	if (yacc_cb->yypvt[-0].psl_treeinfo_type->pss_mask & PSS_0MULT_CORR_ATTR_IN_EXIST)
	{
	    cb->pss_flattening_flags |= PSS_MULT_CORR_ATTRS;
	    yacc_cb->yypvt[-0].psl_treeinfo_type->pss_mask &= ~PSS_0MULT_CORR_ATTR_IN_EXIST;
	}

	/*
	** if we were looking for and found a correlated attribute reference in
	** the tree rooted in NOT EXISTS, we set PSS_CORR_AGGR in 
	** cb->pss_flattening_flags to remind us to set PST_CORR_AGGR in 
	** pst_mask1 of the query tree header
	*/
	if (yacc_cb->yypvt[-0].psl_treeinfo_type->pss_mask & PSS_CORR_ATTR_IN_EXIST)
	{
	    cb->pss_flattening_flags |= PSS_CORR_AGGR;
	    yacc_cb->yypvt[-0].psl_treeinfo_type->pss_mask &= ~PSS_CORR_ATTR_IN_EXIST;
	}

	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-0].psl_treeinfo_type;
    } break;

case 1460:
if (!((*yyvarspp)->bypass_actions))
/* # line 31989 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-0].psl_treeinfo_type;
    } break;

case 1461:
if (!((*yyvarspp)->bypass_actions))
/* # line 31993 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_treeinfo_type = yacc_cb->yypvt[-1].psl_treeinfo_type;
    } break;

case 1462:
if (!((*yyvarspp)->bypass_actions))
/* # line 31999 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = TRUE;
    } break;

case 1463:
if (!((*yyvarspp)->bypass_actions))
/* # line 32003 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = FALSE;
    } break;

case 1464:
if (!((*yyvarspp)->bypass_actions))
/* # line 32009 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = FALSE;
    } break;

case 1465:
if (!((*yyvarspp)->bypass_actions))
/* # line 32013 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = FALSE;
    } break;

case 1466:
if (!((*yyvarspp)->bypass_actions))
/* # line 32017 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = TRUE;
    } break;

case 1467:
if (!((*yyvarspp)->bypass_actions))
/* # line 32023 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = TRUE;
    } break;

case 1468:
if (!((*yyvarspp)->bypass_actions))
/* # line 32027 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** If NOT IN was specified then
	**     if $Ycorr_aggr.depth has not been previously set, 
	**	   we will set it to -1 * (pss_qualdepth + 1) (setting it to a 
	** 	   negative number enables us to distinguish cases when we set 
	**	   out to search for correlated aggregates after seeing an 
	**	   aggregate in target list vs. cases when we do it after 
	**	   seeing NOT IN, != ALL, or EXISTS) and start looking for 
	**	   correlated attributes.  If we find a correlated attribute in
	**	   the right subtree of NOT IN, we will indicate to OPF that 
	**	   the query contained a correlated aggregate.
	**
	**     if $Ymult_corr_attrs.depth has not been previously set, we will 
	**         set it to -1 * (pss_qualdepth + 1) and start looking for 
	**	   correlated attributes.  If we find correlated attributes from
	**	   at least 2 different relations within that subselect, and the
	**	   parent of EXISTS node is a NOT node, we will indicate to OPF
	**	   that the query should not be flattened.  Of course, if have 
	**	   previously found an instance of multiple correlated 
	**	   attributes in a tree rooted in NOT EXISTS or in a tree of a 
	**	   subselect whose target list involves count() or count(*),
	** 	   there is no point in looking for any more instances of the 
	**	   same.
	**
	** NOTE!!!!: we are only interested in correlated references and 
	**	     multiple correlated attributes in the right subtree of 
	**	     NOT IN (<subselect>), but in order to avoid additional 
	**	     shift/reduce conflicts, we may set $Ycorr_aggr.depth 
	**	     and $Ymult_corr_attrs.depth here and reset them to -1 in 
	**		predicate: select_expr in select_expr 
	**	     and 
	**		predicate: select_expr in LPAREN sel_expr_list RPAREN
	**	     productions.  
	**	     THEREFORE, if you are planning to use this production in 
	**	                some new context, be sure to at least reset 
	**	      		$Ycorr_aggr.depth and $Ymult_corr_attrs.depth
	**			to -1
	*/
	if (   ~cb->pss_flattening_flags & PSS_CORR_AGGR 
	    && yyvarsp->corr_aggr.depth == -1
	    && cb->pss_qualdepth > 0)
	{
	    yyvarsp->corr_aggr.depth = -cb->pss_qualdepth - 1;
	    yyvarsp->corr_aggr.found = FALSE;
	}

        if (   ~cb->pss_flattening_flags & PSS_MULT_CORR_ATTRS 
	    && yyvarsp->mult_corr_attrs.depth == -1     
	    && cb->pss_qualdepth > 0)
        {
            yyvarsp->mult_corr_attrs.depth = -cb->pss_qualdepth - 1;
            yyvarsp->mult_corr_attrs.found = FALSE;
            yyvarsp->mult_corr_attrs.rgno = -1;
        }

	yacc_cb->yyval.psl_tytype = FALSE;
    } break;

case 1469:
if (!((*yyvarspp)->bypass_actions))
/* # line 32088 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_opinfo = yacc_cb->yypvt[-0].psl_opinfo;
    } break;

case 1470:
if (!((*yyvarspp)->bypass_actions))
/* # line 32092 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_opinfo = yacc_cb->yypvt[-1].psl_opinfo;
    } break;

case 1471:
if (!((*yyvarspp)->bypass_actions))
/* # line 32096 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_opinfo = yacc_cb->yypvt[-0].psl_opinfo;
    } break;

case 1472:
if (!((*yyvarspp)->bypass_actions))
/* # line 32100 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_opinfo = yacc_cb->yypvt[-1].psl_opinfo;
    } break;

case 1473:
if (!((*yyvarspp)->bypass_actions))
/* # line 32106 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADI_OP_NAME	       funcname;
	ADI_OP_ID	       opid;
	ADI_OPINFO	       *opinfo;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_STATUS	       status;
	i4		       err_code;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(ADI_OPINFO),
	         (PTR *) &opinfo, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

        STlpolycat(2, sizeof(ADI_OP_NAME), "is ", yacc_cb->yypvt[-0].psl_strtype, funcname.adi_opname);
	if ((status = adi_opid(adf_scb, &funcname, &opid)) != E_DB_OK ||
	    (status = adi_op_info(adf_scb, opid, opinfo)) != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite(funcname.adi_opname), funcname.adi_opname);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_opinfo = opinfo;
    } break;

case 1474:
if (!((*yyvarspp)->bypass_actions))
/* # line 32134 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADI_OP_NAME	       funcname;
	ADI_OP_ID	       opid;
	ADI_OPINFO	       *opinfo;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_STATUS	       status;
	i4		       err_code;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(ADI_OPINFO), 
	         (PTR *) &opinfo, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

        STlpolycat(2, sizeof(ADI_OP_NAME), "is not ", yacc_cb->yypvt[-0].psl_strtype, funcname.adi_opname);
	if ((status = adi_opid(adf_scb, &funcname, &opid)) != E_DB_OK ||
	    (status = adi_op_info(adf_scb, opid, opinfo)) != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite(funcname.adi_opname), funcname.adi_opname);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_opinfo = opinfo;
    } break;

case 1475:
if (!((*yyvarspp)->bypass_actions))
/* # line 32162 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = TRUE;
    } break;
	}
	return(0);
}

i4
psls30iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1476:
if (!((*yyvarspp)->bypass_actions))
/* # line 32166 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = FALSE;
    } break;

case 1477:
if (!((*yyvarspp)->bypass_actions))
/* # line 32172 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = ALL_SUBSEL;
    } break;

case 1478:
if (!((*yyvarspp)->bypass_actions))
/* # line 32176 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = SOME_SUBSEL;
    } break;

case 1479:
if (!((*yyvarspp)->bypass_actions))
/* # line 32190 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_TREEINFO	    *treeinfo;
	DB_STATUS	    status;

	if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_SUBSEL)
	{
	    if (yyvarsp->in_case_function)
	    {
		/* CASE statement with subselect not implemented yet */
		i4          err_code;

		_VOID_ psf_error(E_PS03AD_CASE_NOT_SUPPORTED_WITH_SUBSELECT, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    /* "select_expr compop (subselect)" */
	    status = psl_subsel_compare(cb, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype, (ADI_OP_ID) yacc_cb->yypvt[-1].psl_tytype,
		(i4) PST_ONE_SUBSELECT, &treeinfo,
		(bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
		(bool)((yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INCOND &&
		!(yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)) || yyvarsp->in_rule),
		yyvarsp->in_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);
	}
	else if (yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_type == PST_SUBSEL)
	{
	    if (yyvarsp->in_case_function)
	    {
		/* CASE statement with subselect not implemented yet */
		i4          err_code;

		_VOID_ psf_error(E_PS03AD_CASE_NOT_SUPPORTED_WITH_SUBSELECT, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    /* "(subselect) compop select_expr" - transformed to 
	    ** "select_expr reverse_compop (subselect)" */
	    status = psl_subsel_compare(cb, yacc_cb->yypvt[-0].psl_trtype, yacc_cb->yypvt[-2].psl_trtype, (ADI_OP_ID) revops[yacc_cb->yypvt[-1].psl_tytype],
		(i4) PST_ONE_SUBSELECT, &treeinfo,
		(bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
		(bool)((yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INCOND &&
		!(yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)) || yyvarsp->in_rule),
		yyvarsp->in_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);
	}
	else
	{
	    /* No subselects. */
	    status = psl_simple_compare(cb, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype, (ADI_OP_ID) yacc_cb->yypvt[-1].psl_tytype,
		(i4) PST_DOESNT_APPLY, (char) 0, &treeinfo,
		(bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), 
		(bool)yyvarsp->in_target_clause, &yyvarsp->pss_join_info, psq_cb);
	}

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1480:
if (!((*yyvarspp)->bypass_actions))
/* # line 32252 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_TREEINFO	*treeinfo;
	DB_STATUS	status;
	i4		meta_op;

	if (yyvarsp->in_case_function)
	{
	    /* CASE statement with subselect not implemented yet */
	    i4          err_code;

	    _VOID_ psf_error(E_PS03AD_CASE_NOT_SUPPORTED_WITH_SUBSELECT, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	meta_op = PST_ANY_SUBSELECT;

	status = psl_subsel_compare(cb, yacc_cb->yypvt[-5].psl_trtype, yacc_cb->yypvt[-1].psl_trtype, (ADI_OP_ID) yacc_cb->yypvt[-4].psl_tytype, meta_op,
	    &treeinfo, (bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type),
	    &yyvarsp->pss_join_info,
	    (bool)((yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INCOND &&
	    !(yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)) || yyvarsp->in_rule),
	    yyvarsp->in_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1481:
if (!((*yyvarspp)->bypass_actions))
/* # line 32284 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** If != ALL was specified then
	**     if $Ycorr_aggr.depth has not been previously set, 
	**	   we will set it to -1 * (pss_qualdepth + 1) (setting it to a 
	**         negative number enables us to distinguish cases when we set 
	**	   out to search for correlated aggregates after seeing an 
	**	   aggregate in target list vs. cases when we do it after seeing
	**	   NOT IN, != ALL, or EXISTS) and start looking for correlated 
	**	   attributes.  If we find a correlated attribute in the right 
	**	   subtree of != ALL, we will indicate to OPF that the query 
	**	   contained a correlated aggregate.
	**     if $Ymult_corr_attrs.depth has not been previously set, we will 
	**         set it to -1 * (pss_qualdepth + 1) and start looking for 
	**	   correlated attributes.  If we find correlated attributes from
	**	   at least 2 different relations within that subselect, and the
	**	   parent of EXISTS node is a NOT node, we will indicate to OPF
	**	   that the query should not be flattened.  Of course, if have 
	**	   previously found an instance of multiple correlated 
	**	   attributes in a tree rooted in NOT EXISTS or in a tree of a 
	**	   subselect whose target list involves count() or count(*),
	** 	   there is no point in looking for any more instances of the 
	**	   same.
	*/

	if (yyvarsp->in_case_function)
	{
	    /* CASE statement with subselect not implemented yet */
	    i4          err_code;

	    _VOID_ psf_error(E_PS03AD_CASE_NOT_SUPPORTED_WITH_SUBSELECT, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if (yacc_cb->yypvt[-1].psl_tytype == ADI_NE_OP && yacc_cb->yypvt[-0].psl_tytype == ALL_SUBSEL)
	{
	    if (   ~cb->pss_flattening_flags & PSS_CORR_AGGR 
	        && yyvarsp->corr_aggr.depth == -1
	        && cb->pss_qualdepth > 0)
	    {
	        yyvarsp->corr_aggr.depth = -cb->pss_qualdepth - 1;
	        yyvarsp->corr_aggr.found = FALSE;
	    }

	    if (   ~cb->pss_flattening_flags & PSS_MULT_CORR_ATTRS 
		&& yyvarsp->mult_corr_attrs.depth == -1     
		&& cb->pss_qualdepth > 0)
	    {
	        yyvarsp->mult_corr_attrs.depth = -cb->pss_qualdepth - 1;
	        yyvarsp->mult_corr_attrs.found = FALSE;
	        yyvarsp->mult_corr_attrs.rgno = -1;
	    }
	}
    } break;

case 1482:
if (!((*yyvarspp)->bypass_actions))
/* # line 32340 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_TREEINFO	*treeinfo;
	DB_STATUS	status;
	i4		meta_op;

        if (yacc_cb->yypvt[-5].psl_tytype == ADI_NE_OP && yacc_cb->yypvt[-4].psl_tytype == ALL_SUBSEL)
	{
            /* 
	    ** When processing != ALL, OPF will fold the left subtree into the
	    ** subtree representing the subselect; this means that variables 
	    ** referenced in the left subtree will, in essence, be involved in 
	    ** correlated references.  Therefore, if we were looking for and 
	    ** failed to find a single or multiple correlated references in the
	    ** subtree representing the subselect, we must take into 
	    ** consideration variables referenced in the left subtree.  
	    ** In particular, we will build a map of variables referenced in 
	    ** the left subtree, OR into it a map (consisting of at most one 
	    ** bit - otherwise we would not even get here) of variables involved
	    ** in correlated references in the right subtree and use the 
	    ** resulting map to determine whether to claim that we found one or
	    ** more correlated references.
	    */
	    if (   (yyvarsp->corr_aggr.depth != -1 && !yyvarsp->corr_aggr.found)
		|| (yyvarsp->mult_corr_attrs.depth != -1 && !yyvarsp->mult_corr_attrs.found))
	    {
		i4		num_corr_vars;
		PST_VRMAP	var_map;

		psy_vcount(yacc_cb->yypvt[-6].psl_trtype, &var_map);

		/* 
		** if we found one variable involved in correlated references 
		** in the tree representing the subselect, we need to set a 
		** bit representing that variable in var_map - this will
		** make it easier for us to avoid counting the same variable 
		** twice
		*/
		if (   yyvarsp->mult_corr_attrs.depth != -1
		    && yyvarsp->mult_corr_attrs.rgno != -1)
		{
		    BTset(yyvarsp->mult_corr_attrs.rgno, (char *) &var_map);
		}

		/* 
		** now count the number of variables involved in correlated 
		** references
		*/
		num_corr_vars = BTcount((char *) &var_map, PST_NUMVARS);

		if (num_corr_vars > 0)
		{
		    if (yyvarsp->corr_aggr.depth != -1 && !yyvarsp->corr_aggr.found)
		    {
			yyvarsp->corr_aggr.found = TRUE;
		    }

		    if (   yyvarsp->mult_corr_attrs.depth != -1 
			&& !yyvarsp->mult_corr_attrs.found
			&& num_corr_vars > 1)
		    {
			yyvarsp->mult_corr_attrs.found = TRUE;
		    } 
		} 
	    } 
	    
	    /*
            ** if we looked for and found a correlated attribute reference 
	    ** because we hit != ALL, we need to set PSS_CORR_AGGR in 
	    ** pss_flattening_flags and reset depth to indicate that we are 
	    ** done with our search; 
	    **
	    ** similarly, if we looked for and found multiple correlated 
	    ** references because we hit != ALL, we need to set 
	    ** PSS_MULT_CORR_ATTRS in pss_flattening_flags and reset depth to 
	    ** indicate that we are done with our search
            */
	    if (yyvarsp->corr_aggr.depth == -cb->pss_qualdepth - 1)
            {
                if (yyvarsp->corr_aggr.found)
                {
	            cb->pss_flattening_flags |= PSS_CORR_AGGR;
                }
 
                yyvarsp->corr_aggr.depth = -1;
	    }

	    if (yyvarsp->mult_corr_attrs.depth == -cb->pss_qualdepth - 1)
	    {
		if (yyvarsp->mult_corr_attrs.found)
		{
		    cb->pss_flattening_flags |= PSS_MULT_CORR_ATTRS;
		}

		yyvarsp->mult_corr_attrs.depth = -1;
	    }
        }

	meta_op = (yacc_cb->yypvt[-4].psl_tytype == ALL_SUBSEL) ? PST_ALL_SUBSELECT : PST_ANY_SUBSELECT;

	status = psl_subsel_compare(cb, yacc_cb->yypvt[-6].psl_trtype, yacc_cb->yypvt[-1].psl_trtype, (ADI_OP_ID) yacc_cb->yypvt[-5].psl_tytype, meta_op,
	    &treeinfo, (bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type),
	    &yyvarsp->pss_join_info,
	    (bool)((yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INCOND &&
	    !(yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)) || yyvarsp->in_rule),
	    yyvarsp->in_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1483:
if (!((*yyvarspp)->bypass_actions))
/* # line 32454 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_TREEINFO	    *treeinfo;
	PST_QNODE           *lnode1, *lnode2;
	PST_QNODE           *rnode1, *rnode2;
	PST_QNODE	    *ornode1, *ornode2;
	PST_QNODE           *xnode2, *xnode3, *xnode4, *ynode2, *znode2;
	YYAGG_NODE_PTR	    *agg_node_list = (YYAGG_NODE_PTR *) NULL;
	PST_OP_NODE	    opnode;
	DB_STATUS	    status;
	i4		    nores_flag;

	/* "between" predicates are transformed here into the corresponding
	** ">="/"<=" parse tree nodes. 
	** "x between [asymmetric] y and z" becomes "x >= y and x <= z". 
	** "x between symmetric y and z" becomes
	** "(x >= y or x >= z) and (x <= z or x <= y)", which is the CNF
	** form for "(x >= y and x <= z) or (x >= z and x <= y)". 
	** "not between [asymmetric]" simply inserts a NOT operator and lets 
	** OPF perform the corresponding transform.
	** "x not between symmetric y and z" is done here because of the
	** greater complexity (that OPF doesn't handle as well) and becomes
	** "(x < y or x > z) and (x < z or x > y)". */

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE TABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/* Verify collation compatibility between 1st and 2nd/3rd exprs. */
	if (!(psl_validate_collation_mix(yacc_cb->yypvt[-5].psl_trtype->pst_sym.pst_dataval.db_collID,
	    yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_dataval.db_collID)))
	{
	    /* Collation conflict. */
	    i4	err_code;
	    (VOID) psf_error(6427L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	else if (!(psl_validate_collation_mix(yacc_cb->yypvt[-5].psl_trtype->pst_sym.pst_dataval.db_collID,
	    yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_dataval.db_collID)))
	{
	    /* Collation conflict. */
	    i4	err_code;
	    (VOID) psf_error(6427L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_TREEINFO), 
	         (PTR *) &treeinfo, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* "x >= y" or "x < y" (NOT BETWEEN SYMMETRIC) */
	opnode.pst_opno = ADI_GE_OP;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;
	if (!yacc_cb->yypvt[-4].psl_tytype && yacc_cb->yypvt[-3].psl_tytype)
	    opnode.pst_opno = ADI_LT_OP;	/* not between symm. */

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-5].psl_trtype, yacc_cb->yypvt[-2].psl_trtype, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &lnode1, &psq_cb->psq_error, nores_flag);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* Make copy of x operand for second comparison. */

	/*
	** when copying a subtree, add newly created PST_AGHEAD nodes to the
	** list of AGHEAD nodes.  This is done to fix bug 20499
	*/
	yyvarsp->dup_rb.pss_op_mask |= PSS_5DUP_ATTACH_AGHEAD;
	yyvarsp->dup_rb.pss_1ptr     = (PTR) &agg_node_list;  

	yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-5].psl_trtype;
	yyvarsp->dup_rb.pss_dup  = &xnode2;
	status = pst_treedup(cb, &yyvarsp->dup_rb);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (agg_node_list != (YYAGG_NODE_PTR *) NULL)
	{
	    /*
	    ** tree copy contains some AGGHEAD nodes which must be inserted into
	    ** appropriate AGGHEAD list
	    */
	    YYAGG_NODE_PTR	*agg_list_elem, *next_elem = agg_node_list;

	    while ((agg_list_elem = next_elem) != (YYAGG_NODE_PTR *) NULL)
	    {
		/*
		** must remember agg_list_elem->agg_next as it will ALWAYS get
		** changed when psl_insert_into_agg_list() inserts agg_list_elem
		** into appropriate list
		*/
		next_elem = agg_list_elem->agg_next;

		/* insert it into approprite AGGHEAD list */
		psl_insert_into_agg_list(
		    psl_find_node(agg_list_elem->agg_node, PST_VAR),
		    agg_list_elem, yyvarsp->agg_list_stack, cb->pss_qualdepth,
		    &yyvarsp->flists[0]);
	    }
	}

	/*
	** since $Ydup_rb may be used throughout the grammar, reset pss_op_mask
	** and pss_1ptr to their old values.
	*/
	yyvarsp->dup_rb.pss_op_mask &= ~PSS_5DUP_ATTACH_AGHEAD;
	yyvarsp->dup_rb.pss_1ptr     = NULL;

	/* "x <= z" or "x > z" (NOT BETWEEN SYMMETRIC) */
	opnode.pst_opno = ADI_LE_OP;
	if (!yacc_cb->yypvt[-4].psl_tytype && yacc_cb->yypvt[-3].psl_tytype)
	    opnode.pst_opno = ADI_GT_OP;	/* not between symm. */

	status = pst_node(cb, &cb->pss_ostream, xnode2, yacc_cb->yypvt[-0].psl_trtype, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rnode1, &psq_cb->psq_error, nores_flag);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* If not SYMMETRIC, compose final AND here. */
	if (!yacc_cb->yypvt[-3].psl_tytype)
	{
	    /* note that treeinfo->pss_tree will point at the resulting tree */
	    status = pst_node(cb, &cb->pss_ostream, lnode1, rnode1, PST_AND,
		(PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &treeinfo->pss_tree, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN
		** in pst_node().
		*/
		treeinfo->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		    lnode1->pst_sym.pst_value.pst_s_op.pst_joinid =
		    rnode1->pst_sym.pst_value.pst_s_op.pst_joinid =
			yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	    }

	    /* [asymmetric] with NOT - just plunk NOT in front for OPF
	    ** to normalize. For NOT BETWEEN SYMMETRIC the transform is 
	    ** done here because it is more complex and we're smarter. */
	    if (!yacc_cb->yypvt[-4].psl_tytype)
	    {
		status = pst_node(cb, &cb->pss_ostream, treeinfo->pss_tree, 
		    (PST_QNODE *) NULL, PST_NOT, (PTR) NULL, 0, DB_NODT, (i2) 0,
		    (i4) 0, (DB_ANYTYPE *) NULL, &treeinfo->pss_tree,
		    &psq_cb->psq_error, nores_flag);

		if (DB_FAILURE_MACRO(status))
		{
		    return (status);
		}
	    }
	}
	else
	{
	    /* SYMMETRIC - do the rest in here. */

	    /* First, allocate 2 more copies of x operand and 1 each
	    ** of y and z operands. */
	    yyvarsp->dup_rb.pss_op_mask |= PSS_5DUP_ATTACH_AGHEAD;
	    yyvarsp->dup_rb.pss_1ptr     = (PTR) &agg_node_list;  

	    yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-5].psl_trtype;
	    yyvarsp->dup_rb.pss_dup  = &xnode3;
	    status = pst_treedup(cb, &yyvarsp->dup_rb);

	    if (DB_FAILURE_MACRO(status))
		return (status);

	    yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-5].psl_trtype;
	    yyvarsp->dup_rb.pss_dup  = &xnode4;
	    status = pst_treedup(cb, &yyvarsp->dup_rb);

	    if (DB_FAILURE_MACRO(status))
		return (status);

	    yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-2].psl_trtype;
	    yyvarsp->dup_rb.pss_dup  = &ynode2;
	    status = pst_treedup(cb, &yyvarsp->dup_rb);

	    if (DB_FAILURE_MACRO(status))
		return (status);

	    yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-0].psl_trtype;
	    yyvarsp->dup_rb.pss_dup  = &znode2;
	    status = pst_treedup(cb, &yyvarsp->dup_rb);

	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /* Do the agg_node thing for all of them. */

	    if (agg_node_list != (YYAGG_NODE_PTR *) NULL)
	    {
		/*
		** tree copy contains some AGGHEAD nodes which must be inserted
		** into appropriate AGGHEAD list
		*/
		YYAGG_NODE_PTR	*agg_list_elem, *next_elem = agg_node_list;

		while ((agg_list_elem = next_elem) != (YYAGG_NODE_PTR *) NULL)
		{
		    /*
		    ** must remember agg_list_elem->agg_next as it will ALWAYS
		    ** get changed when psl_insert_into_agg_list() inserts 
		    ** agg_list_elem into appropriate list
		    */
		    next_elem = agg_list_elem->agg_next;

		    /* insert it into approprite AGGHEAD list */
		    psl_insert_into_agg_list(
			psl_find_node(agg_list_elem->agg_node, PST_VAR),
			agg_list_elem, yyvarsp->agg_list_stack, cb->pss_qualdepth,
			&yyvarsp->flists[0]);
		}
	    }

	    /*
	    ** since $Ydup_rb may be used throughout the grammar, reset 
	    ** pss_op_mask and pss_1ptr to their old values.
	    */
	    yyvarsp->dup_rb.pss_op_mask &= ~PSS_5DUP_ATTACH_AGHEAD;
	    yyvarsp->dup_rb.pss_1ptr     = NULL;

	    /* "x >= z" or "x < z" (NOT) */
	    if (!yacc_cb->yypvt[-4].psl_tytype)
		opnode.pst_opno = ADI_LT_OP;
	    else opnode.pst_opno = ADI_GE_OP;

	    status = pst_node(cb, &cb->pss_ostream, xnode3, znode2, PST_BOP,
		(char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &lnode2, &psq_cb->psq_error, nores_flag);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    /* "x <= y" or "x > y" (NOT) */
	    if (!yacc_cb->yypvt[-4].psl_tytype)
		opnode.pst_opno = ADI_GT_OP;
	    else opnode.pst_opno = ADI_LE_OP;

	    status = pst_node(cb, &cb->pss_ostream, xnode4, ynode2, PST_BOP,
		(char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &rnode2, &psq_cb->psq_error, nores_flag);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    /* "x >= y or x >= z" or "x < y or x > z" (NOT) */
	    status = pst_node(cb, &cb->pss_ostream, lnode1, 
		(yacc_cb->yypvt[-4].psl_tytype) ? lnode2 : rnode1, PST_OR,
		(PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &ornode1, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN
		** in pst_node().
		*/
		ornode1->pst_sym.pst_value.pst_s_op.pst_joinid =
		    lnode1->pst_sym.pst_value.pst_s_op.pst_joinid =
		    lnode2->pst_sym.pst_value.pst_s_op.pst_joinid =
			yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	    }

	    /* "x <= z or x <= y" or "x < z or x > y" (NOT) */
	    status = pst_node(cb, &cb->pss_ostream, (yacc_cb->yypvt[-4].psl_tytype) ? rnode1 : lnode2, 
		rnode2, PST_OR,
		(PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &ornode2, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN
		** in pst_node().
		*/
		ornode2->pst_sym.pst_value.pst_s_op.pst_joinid =
		    rnode1->pst_sym.pst_value.pst_s_op.pst_joinid =
		    rnode2->pst_sym.pst_value.pst_s_op.pst_joinid =
			yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	    }

	    /* Finally, AND the ORs together. */

	    /* note that treeinfo->pss_tree will point at the resulting tree */
	    status = pst_node(cb, &cb->pss_ostream, ornode1, ornode2, PST_AND,
		(PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &treeinfo->pss_tree, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN
		** in pst_node().
		*/
		treeinfo->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
			yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	    }
	}

	treeinfo->pss_mask = (i4) 0;

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1484:
if (!((*yyvarspp)->bypass_actions))
/* # line 32819 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_TREEINFO	    *treeinfo;
	DB_STATUS	    status;
	ADI_OP_ID	operator;
	i4		meta_op;

	if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_SUBSEL)
	{
	    /* "select_expr in (subselect)" */

	    if (yyvarsp->in_case_function)
	    {
		/* CASE statement with subselect not implemented yet */
		i4          err_code;

		_VOID_ psf_error(E_PS03AD_CASE_NOT_SUPPORTED_WITH_SUBSELECT, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    if (yacc_cb->yypvt[-1].psl_tytype)
	    {
		operator = (ADI_OP_ID) ADI_EQ_OP;
		meta_op = (i4) PST_ANY_SUBSELECT;
	    }
	    else
	    {
		/*
		** a tree for NOT IN subselect will be the same as the one for
		** != ALL subselect.  This fixes bug 34433
		*/
		operator = (ADI_OP_ID) ADI_NE_OP;
		meta_op  = (i4) PST_ALL_SUBSELECT;

        	/* 
		** When processing NOT IN, OPF will fold the left subtree into
		** the subtree representing the subselect; this means that
		** variables referenced in the left subtree will, in essence, 
		** be involved in correlated references.  Therefore, if we were
		** looking for and failed to find a single or multiple 
		** multiple correlated references in the subtree representing 
		** the subselect, we must take into consideration variables 
		** referenced in the left subtree. In particular, we will build 
		** a map of variables referenced in the left subtree, OR into 
		** it a map (consisting of at most one bit - otherwise we would 
		** not even get here) of variables involved in correlated 
		** references in the right subtree and use the resulting 
		** map to determine whether to claim that we found one or
		** more correlated references.
		*/
		if (   (yyvarsp->corr_aggr.depth != -1 && !yyvarsp->corr_aggr.found)
	            || (yyvarsp->mult_corr_attrs.depth != -1 && !yyvarsp->mult_corr_attrs.found))
		{
	            i4		num_corr_vars;
	            PST_VRMAP	var_map;
    
	            psy_vcount(yacc_cb->yypvt[-2].psl_trtype, &var_map);
    
	            /* 
	            ** if we found one variable involved in correlated 
		    ** references in the tree representing the subselect, 
		    ** we need to set a bit representing that variable in 
		    ** var_map - this will make it easier for us to avoid 
		    ** counting the same variable twice
	            /*
	            if (   $Ymult_corr_attrs.depth != -1
	        	&& $Ymult_corr_attrs.rgno != -1)
	            {
	        	BTset($Ymult_corr_attrs.rgno, (char *) &var_map);
	            }
    
	            /* 
	            ** now count the number of variables involved in correlated 
	            ** references
	            */
	            num_corr_vars = BTcount((char *) &var_map, PST_NUMVARS);
    
	            if (num_corr_vars > 0)
	            {
	        	if (yyvarsp->corr_aggr.depth != -1 && !yyvarsp->corr_aggr.found)
	        	{
		            yyvarsp->corr_aggr.found = TRUE;
	        	}
    
	        	if (   yyvarsp->mult_corr_attrs.depth != -1 
		            && !yyvarsp->mult_corr_attrs.found
		            && num_corr_vars > 1)
	        	{
		            yyvarsp->mult_corr_attrs.found = TRUE;
	        	} 
	            } 
        	}
	        
        	/*
        	** if we looked for and found a correlated attribute reference 
		** because we hit NOT IN, we need to set PSS_CORR_AGGR in 
		** pss_flattening_flags and reset depth to indicate that we are 
		** done with our search; 
		**
		** similarly, if we looked for and found multiple correlated 
		** references because we hit NOT IN, we need to set 
		** PSS_MULT_CORR_ATTRS in pss_flattening_flags and reset depth
		** to indicate that we are done with our search
        	*/
        	if (yyvarsp->corr_aggr.depth == -cb->pss_qualdepth - 1)
        	{
                    if (yyvarsp->corr_aggr.found)
                    {
	        	cb->pss_flattening_flags |= PSS_CORR_AGGR;
                    }
     
                    yyvarsp->corr_aggr.depth = -1;
        	}
    
        	if (yyvarsp->mult_corr_attrs.depth == -cb->pss_qualdepth - 1)
        	{
	            if (yyvarsp->mult_corr_attrs.found)
		    {
			cb->pss_flattening_flags |= PSS_MULT_CORR_ATTRS;
		    }
    
		    yyvarsp->mult_corr_attrs.depth = -1;
        	}
	    }
	
	    status = psl_subsel_compare(cb, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype, operator, meta_op,
		&treeinfo, (bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type),
		&yyvarsp->pss_join_info,
		(bool)((yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INCOND &&
		!(yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)) || yyvarsp->in_rule),
		yyvarsp->in_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);

	}
	else
	{
	    /* "select_expr in non-subselect-expr" */

	    /* 
	    ** when we have encountered NOT IN, we may have set $Ycorr_aggr.
	    ** depth and/or $Ymult_corr_attrs.depth to -cb->pss_qualdepth - 1.
	    ** However, unless NOT IN were followed by a (SUBSELECT), we are 
	    ** not interested in checking whether the <select_expr> involved 
	    ** correlated references; therefore here we simply reset 
	    ** $Ycorr_aggr.depth and $Ymult_corr_attrs.depth to -1
	    */
	    if (!yacc_cb->yypvt[-1].psl_tytype)
	    {
        	if (yyvarsp->corr_aggr.depth == -cb->pss_qualdepth - 1)
        	{
	            yyvarsp->corr_aggr.depth = -1;
        	}
    
        	if (yyvarsp->mult_corr_attrs.depth == -cb->pss_qualdepth - 1)
        	{
	            yyvarsp->mult_corr_attrs.depth = -1;
        	}
	    }

	    status = psl_simple_compare(cb, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype,
		(ADI_OP_ID) ((yacc_cb->yypvt[-1].psl_tytype) ? ADI_EQ_OP : ADI_NE_OP),
		(i4) PST_DOESNT_APPLY, (char) 0, &treeinfo,
		(bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), 
		(bool)yyvarsp->in_target_clause, &yyvarsp->pss_join_info, psq_cb);

	}

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1485:
if (!((*yyvarspp)->bypass_actions))
/* # line 32993 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE           *resultnode;
	PST_QNODE           *newnode;
	PST_QNODE           *copynode;
	PST_QNODE	    *ineq = (PST_QNODE *)NULL;
	PSS_EXLIST          *valnode;
	PST_QNODE           *ornode;
	YYAGG_NODE_PTR	    *agg_node_list = (YYAGG_NODE_PTR *) NULL;
	PSS_TREEINFO	    *treeinfo;
	PST_OP_NODE	    opnode;
	DB_STATUS	    status;
	PST_J_ID	    join_id;
	i4		    nores_flag;

	/* 
	** when we have encountered NOT IN, we may have set $Ycorr_aggr.depth
	** and/or $Ymult_corr_attrs.depth to -cb->pss_qualdepth - 1.  
	** However, unless NOT IN were followed by a (SUBSELECT), we are not 
	** interested in checking whether the <select_expr> involved correlated
	** references; therefore here we simply reset $Ycorr_aggr.depth and
	** $Ymult_corr_attrs.depth to -1
	*/
	if (!yacc_cb->yypvt[-3].psl_tytype)
	{
            if (yyvarsp->corr_aggr.depth == -cb->pss_qualdepth - 1)
            {
                yyvarsp->corr_aggr.depth = -1;
            }
    
            if (yyvarsp->mult_corr_attrs.depth == -cb->pss_qualdepth - 1)
            {
                yyvarsp->mult_corr_attrs.depth = -1;
            }
	}

	/*
	** don't do type resolution if parsing a check constraint specified
	** inside CREATE TABLE statement, as we may not know the type of the
	** column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_TREEINFO), 
	         (PTR *) &treeinfo, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	resultnode = (PST_QNODE *) NULL;
	opnode.pst_opno = ADI_EQ_OP;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	/*
	** determine join id based on whether we are processing a join_search
	** condition
	*/
	join_id = (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
		    ? yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id
		    : PST_NOJOIN;

	/*
	** if expression list contains more than 1 value, we will need to make
	** copies of select_expr
	*/

	if (yyvarsp->exprlist->pss_next != (PSS_EXLIST *) NULL)
	{
	    /*
	    ** when copying a subtree, add newly created PST_AGHEAD nodes to the
	    ** list of AGHEAD nodes.  This is done to fix bug 20499
	    */
	    yyvarsp->dup_rb.pss_op_mask |= PSS_5DUP_ATTACH_AGHEAD;
	    yyvarsp->dup_rb.pss_1ptr     = (PTR) &agg_node_list;
	}

	/*			    
	** Predicate x [NOT] IN (l1, l2, ..., ln) is equivalent to
	** [NOT] ((x = l1) OR (x = l2) OR ... OR (x = ln)) and the generated
	** tree will reflect that.
	** Note that the trees representing l1,l2,...,ln hang off nodes
	** in a singly linked list with $Yexprlist pointing to the first node
	** in the list.
	** (Trees were linked in reverse order, but here the order will
	** be reversed again.)
	*/
	
	for (valnode = yyvarsp->exprlist;
	     valnode != (PSS_EXLIST *) NULL;
	     valnode = valnode->pss_next)
	{
	    /* First check for collation conflicts. */
	    if (!(psl_validate_collation_mix(yacc_cb->yypvt[-4].psl_trtype->pst_sym.pst_dataval.db_collID,
		valnode->pss_expr->pst_sym.pst_dataval.db_collID)))
	    {
		i4	err_code;
		(VOID) psf_error(6427L, 0L, PSF_USERERR, &err_code, 
		    &psq_cb->psq_error, 0);
	    }

	    /* Then new code to pack constant IN-lists into a single "=" BOP. 
	    ** NOTE - not done for "not in" lists. */
	    if (valnode->pss_expr->pst_sym.pst_type == PST_CONST && ineq && yacc_cb->yypvt[-3].psl_tytype
		&& ~cb->pss_distrib & DB_3_DDB_SESS)
	    {
		ineq->pst_sym.pst_value.pst_s_op.pst_flags |= PST_INLIST;
					/* flag it to be sure */
		valnode->pss_expr->pst_left = ineq->pst_right;
		ineq->pst_right = valnode->pss_expr;
					/* link 'em together */
		continue;
	    }

	    /* if not the last value node, copy the select expr */
	    if (valnode->pss_next != NULL)
	    {
		yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-4].psl_trtype;
		yyvarsp->dup_rb.pss_dup  = &copynode;
		status = pst_treedup(cb, &yyvarsp->dup_rb);

		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }	    
	    else
		copynode = yacc_cb->yypvt[-4].psl_trtype;

	    status = pst_node(cb, &cb->pss_ostream, copynode, valnode->pss_expr,
		PST_BOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid = join_id;
	    if (valnode->pss_expr->pst_sym.pst_type == PST_CONST)
		ineq = newnode;
	    
	    /* no result, make the op a result, else create an OR node */
	    if (resultnode)
	    {	
		status = pst_node(cb, &cb->pss_ostream, newnode, resultnode, 
		    PST_OR, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0,
		    (i4) 0, (DB_ANYTYPE *) NULL, &ornode, &psq_cb->psq_error,
		    nores_flag);
		if (DB_FAILURE_MACRO(status))
		{
		    return (status);
		}

		/* in pst_node() pst_joinid was set to PST_NOJOIN */
		ornode->pst_sym.pst_value.pst_s_op.pst_joinid = join_id;
		
		resultnode = ornode;
	    }
	    else
		resultnode = newnode;
	}

	if (!yacc_cb->yypvt[-3].psl_tytype)    /* NOT IN was specified: will negate the qualification */
	{
	    /* negate the qualification */
	    status = pst_node(cb, &cb->pss_ostream, resultnode,
		(PST_QNODE *) NULL, PST_NOT, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &resultnode, &psq_cb->psq_error,
		nores_flag);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }
	}

	if (agg_node_list != (YYAGG_NODE_PTR *) NULL)
	{
	    /*
	    ** tree copy contains some AGGHEAD nodes which must be inserted into
	    ** appropriate AGGHEAD list
	    */
	    YYAGG_NODE_PTR	*agg_list_elem, *next_elem = agg_node_list;

	    while ((agg_list_elem = next_elem) != (YYAGG_NODE_PTR *) NULL)
	    {
		/*
		** must remember agg_list_elem->agg_next as it will ALWAYS get
		** changed when psl_insert_into_agg_list() inserts agg_list_elem
		** into appropriate list
		*/
		next_elem = agg_list_elem->agg_next;

		/* insert it into approprite AGGHEAD list */
		psl_insert_into_agg_list(
		    psl_find_node(agg_list_elem->agg_node, PST_VAR),
		    agg_list_elem, yyvarsp->agg_list_stack, cb->pss_qualdepth,
		    &yyvarsp->flists[0]);
	    }
	}

	if (yyvarsp->exprlist->pss_next != (PSS_EXLIST *) NULL)
	{
	    /*
	    ** since $Ydup_rb may be used throughout the grammar, reset
	    ** pss_op_mask and pss_1ptr to their old values.
	    */
	    yyvarsp->dup_rb.pss_op_mask &= ~PSS_5DUP_ATTACH_AGHEAD;
	    yyvarsp->dup_rb.pss_1ptr     = NULL;
	}

	/* Reset for nested subqueries. */	
	yyvarsp->exprlist = (PSS_EXLIST *) NULL;

	treeinfo->pss_mask = (i4) 0;
	treeinfo->pss_tree = resultnode;

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1486:
if (!((*yyvarspp)->bypass_actions))
/* # line 33222 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** If $Ymult_corr_attrs.depth has not been previously set, we will set
	** it to -1 * (pss_qualdepth + 1) and start looking for correlated
	** attributes.  If we find correlated attributes from at least 2
	** different relations within that subselect, and some ancestor of
	** EXISTS node is a NOT node, we will indicate to OPF that the query
	** should not be flattened.  Of course, if we have previously found an
	** instance of multiple correlated attributes in a tree rooted in
	** NOT EXISTS or in a tree of a subselect whose target list involves
	** count() or count(*), there is no point in looking for any more
	** instances of the same.
	*/
	if (~cb->pss_flattening_flags & PSS_MULT_CORR_ATTRS &&
	    yyvarsp->mult_corr_attrs.depth == -1     &&
	    cb->pss_qualdepth > 0)
	{
	    yyvarsp->mult_corr_attrs.depth = -cb->pss_qualdepth - 1;
	    yyvarsp->mult_corr_attrs.found = FALSE;
	    yyvarsp->mult_corr_attrs.rgno = -1;
	}

	/*
	** If $Ycorr_aggr.depth has not been previously set, we will set
	** it to -1 * (pss_qualdepth + 1) (setting it to a negative number 
	** enables us to distinguish cases when we set out to search for 
	** correlated aggregates after seeing an aggregate in target list vs. 
	** cases when we do it after seeing NOT IN, != ALL, or EXISTS) and 
	** start looking for correlated attributes.  If we find a correlated 
	** attribute within that subselect, and some ancestor of EXISTS node is
	** a NOT node, we will indicate to OPF that the query contained a 
	** correlated aggregate.
	*/

	if (yyvarsp->in_case_function)
	{
	    /* CASE statement with subselect not implemented yet */
	    i4          err_code;

	    _VOID_ psf_error(E_PS03AD_CASE_NOT_SUPPORTED_WITH_SUBSELECT, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if (   ~cb->pss_flattening_flags & PSS_CORR_AGGR 
	    && yyvarsp->corr_aggr.depth == -1
	    && cb->pss_qualdepth > 0)
	{
	    yyvarsp->corr_aggr.depth = -cb->pss_qualdepth - 1;
	    yyvarsp->corr_aggr.found = FALSE;
	}
    } break;

case 1487:
if (!((*yyvarspp)->bypass_actions))
/* # line 33275 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_TREEINFO	*treeinfo;
	DB_STATUS	status;

	status = psl_subsel_compare(cb, (PST_QNODE *) NULL, yacc_cb->yypvt[-1].psl_trtype,
	    (ADI_OP_ID) ADI_EXIST_OP, (i4) PST_ANY_SUBSELECT, &treeinfo,
	    (bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    (bool)((yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INCOND &&
	    !(yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)) || yyvarsp->in_rule),
	    yyvarsp->in_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** Indicate presence of a subselect. Do not call psl_subsel
	** which returns error for more than 1 resdom.
	*/
	cb->pss_stmt_flags |= PSS_SUBINTREE; /* pss_subintree = TRUE */

	if (yyvarsp->mult_corr_attrs.depth == -cb->pss_qualdepth - 1)
	{
	    /*
	    ** if we were looking for multiple correlated relation references
	    ** because we hit EXISTS, check if we did and reset depth to avoid
	    ** confusion in the future.
	    */
	    if (yyvarsp->mult_corr_attrs.found)
	    {
		/*
		** Now if we come across NOT and its child has
		** PSS_0MULT_CORR_ATTR_IN_EXIST in its pss_mask, we will be
		** able to conclude that there were multiple correlated relation
		** references in the tree rooted in NOT EXISTS, so we should
		** indicate to OPF that no flattening should take place
		*/
		treeinfo->pss_mask |= PSS_0MULT_CORR_ATTR_IN_EXIST;
	    }

	    /*
	    ** we reset depth since otherwise it would be very messy to
	    ** determine if the multiple correlated relation references occurred
	    ** in the tree rooted in the given NOT EXISTS.
	    */
	    yyvarsp->mult_corr_attrs.depth = -1;
	}

	if (yyvarsp->corr_aggr.depth == -cb->pss_qualdepth - 1)
	{
	    /*
	    ** if we were looking for correlated attribute reference because 
	    ** we hit EXISTS, check if we did and reset depth to avoid confusion
	    ** in the future.
	    */
	    if (yyvarsp->corr_aggr.found)
	    {
		/*
		** Now if we come across NOT and its child has
		** PSS_CORR_ATTR_IN_EXIST in its pss_mask, we will know to set
		** PSS_CORR_AGGR bit in pss_flattening_flags which will 
		** eventually result in PST_CORR_AGGR being set if 
		** PST_QTREE.pst_mask1 where OPF expects to find it
		*/
		treeinfo->pss_mask |= PSS_CORR_ATTR_IN_EXIST;
	    }

	    yyvarsp->corr_aggr.depth = -1;
	}

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1488:
if (!((*yyvarspp)->bypass_actions))
/* # line 33349 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	PSS_TREEINFO        *treeinfo;

	if (yacc_cb->yypvt[-0].psl_opinfo->adi_optype != ADI_COMPARISON ||
	       yacc_cb->yypvt[-0].psl_opinfo->adi_use != ADI_POSTFIX)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	status = psl_simple_compare(cb, yacc_cb->yypvt[-1].psl_trtype, (PST_QNODE *) NULL,
	    yacc_cb->yypvt[-0].psl_opinfo->adi_opid,
	    (i4) PST_DOESNT_APPLY, (char) 0, &treeinfo,
	    (bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), 
	    (bool)yyvarsp->in_target_clause, &yyvarsp->pss_join_info, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1489:
if (!((*yyvarspp)->bypass_actions))
/* # line 33374 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_TREEINFO        *treeinfo;
	DB_STATUS	    status;

	status = psl_simple_compare(cb, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype,
	    (ADI_OP_ID) ((yacc_cb->yypvt[-1].psl_tytype) ? ADI_LIKE_OP : ADI_NLIKE_OP),
	    (i4) PST_NO_ESCAPE, (char) 0, &treeinfo,
	    (bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), 
	    (bool)yyvarsp->in_target_clause, &yyvarsp->pss_join_info, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1490:
if (!((*yyvarspp)->bypass_actions))
/* # line 33392 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_TREEINFO	*treeinfo;
	DB_STATUS	status;

	if (STlength(yacc_cb->yypvt[-0].psl_strtype) != 1)
	{
	    i4         err_code;

	    (VOID) psf_error(2713L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	status = psl_simple_compare(cb, yacc_cb->yypvt[-4].psl_trtype, yacc_cb->yypvt[-2].psl_trtype,
	    (ADI_OP_ID) ((yacc_cb->yypvt[-3].psl_tytype) ? ADI_LIKE_OP : ADI_NLIKE_OP),
	    (i4) PST_HAS_ESCAPE, *yacc_cb->yypvt[-0].psl_strtype, &treeinfo,
	    (bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), 
	    (bool)yyvarsp->in_target_clause, &yyvarsp->pss_join_info, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_treeinfo_type = treeinfo;
    } break;

case 1491:
if (!((*yyvarspp)->bypass_actions))
/* # line 33423 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1492:
if (!((*yyvarspp)->bypass_actions))
/* # line 33427 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;
	i4		       nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	opnode.pst_opno = yacc_cb->yypvt[-1].psl_tytype;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype,
	    PST_BOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK)
	{
	    return (status);
	}
	else if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1493:
if (!((*yyvarspp)->bypass_actions))
/* # line 33478 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1494:
if (!((*yyvarspp)->bypass_actions))
/* # line 33482 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;
	i4		       nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	opnode.pst_opno = yacc_cb->yypvt[-1].psl_tytype;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	if (yacc_cb->yypvt[-2].psl_trtype->pst_sym.pst_type == PST_SUBSEL ||
	    yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_SUBSEL)
	    opnode.pst_opmeta = PST_ONE_SUBSELECT;

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype,
	    PST_BOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK)
	{
	    return (status);
	}
	else if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1495:
if (!((*yyvarspp)->bypass_actions))
/* # line 33537 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;
	i4		       nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	opnode.pst_opno = yacc_cb->yypvt[-1].psl_tytype;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype,
	    PST_BOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK)
	{
	    return (status);
	}
	else if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1496:
if (!((*yyvarspp)->bypass_actions))
/* # line 33586 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1497:
if (!((*yyvarspp)->bypass_actions))
/* # line 33592 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1498:
if (!((*yyvarspp)->bypass_actions))
/* # line 33596 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1499:
if (!((*yyvarspp)->bypass_actions))
/* # line 33602 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1500:
if (!((*yyvarspp)->bypass_actions))
/* # line 33606 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;
	i4		       nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/*
	** The scanner is unable to distinguish between unary and binary +,
	** and unary and binary -.  Therefore, translate the binary operator
	** ids to unary ones here.
	*/
	if (yacc_cb->yypvt[-1].psl_tytype == ADI_ADD_OP)
	    opnode.pst_opno = ADI_PLUS_OP;
	else if (yacc_cb->yypvt[-1].psl_tytype == ADI_SUB_OP)
	    opnode.pst_opno = ADI_MINUS_OP;

	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_trtype, (PST_QNODE *) NULL,
	    PST_UOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK)
	{
	    return (status);
	}
        else if ((newnode->pst_sym.pst_type != PST_CONST) && 
                   (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type)))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1501:
if (!((*yyvarspp)->bypass_actions))
/* # line 33667 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1502:
if (!((*yyvarspp)->bypass_actions))
/* # line 33671 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;

	if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_AGHEAD ||
	    yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_BOP && yacc_cb->yypvt[-0].psl_trtype->pst_left &&
	    yacc_cb->yypvt[-0].psl_trtype->pst_left->pst_sym.pst_type == PST_UOP &&
	    yacc_cb->yypvt[-0].psl_trtype->pst_left->pst_left &&
	    yacc_cb->yypvt[-0].psl_trtype->pst_left->pst_left->pst_sym.pst_type == PST_AGHEAD)
	{
	    PST_QNODE	*a1 = yacc_cb->yypvt[-0].psl_trtype;
	    PST_QNODE	*a2 = NULL;

	    if (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_BOP)
	    {
		/* avg(x) => sum(x) / count(x) */
		a1 = yacc_cb->yypvt[-0].psl_trtype->pst_left->pst_left;
		a2 = yacc_cb->yypvt[-0].psl_trtype->pst_right;
	    }
	    if (   (yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INCOND) &&
		  !(yyvarsp->isdbp && yyvarsp->dbpinfo->pss_flags & PSS_INFORQ)
		|| (yyvarsp->in_rule == TRUE))
	    {
		/* Not allowed in conditions in DB proc
		** control statements or CREATE RULE statments.
		*/
		(VOID) psf_error(yyvarsp->in_rule ? E_US189E_6302_RULE_QUAL : 2415L,
		    0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	    {
		/* use of AGGREGATES in join_search condition is illegal */
		(VOID) psf_error(E_PS03A6_AGGR_IN_JOIN_COND, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    if (yyvarsp->in_orderby)
	    {
		/* Not allowed in order by expressions. */
		(VOID) psf_error(E_PS03AA_AGGR_IN_ORDER_BY, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }
	    if (yyvarsp->in_groupby_clause)
	    {
		/* Not allowed in group by expressions. */
		(VOID) psf_error(E_PS03AB_AGGR_IN_GROUP_BY, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }
	    /*
	    ** for flattening we care if we have one or multiple aggregates,
	    ** so use two flags as a two-bit counter indicating that we have
	    ** none, one, or more than one
	    */
	    if (cb->pss_flattening_flags & PSS_AGHEAD || 
		yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_BOP)
		cb->pss_flattening_flags |= PSS_AGHEAD_MULTI;
	    cb->pss_flattening_flags |= PSS_AGHEAD;

	    /*
	    ** if we are processing elements of a target list, wait until the from
	    ** list is processed before checking for illegal use of aggregates in
	    ** where_clause and appending AGGHEAD to the appropriate AGGHEAD list
	    */
	    if (!yyvarsp->in_target_clause)
	    {
		PST_QNODE		*var_node;
		YYAGG_NODE_PTR      *agg_list_elem;
		DB_STATUS		status;

		if ((var_node = psl_find_node(yacc_cb->yypvt[-0].psl_trtype, PST_VAR)) != (PST_QNODE *) NULL &&
		    BTtest(var_node->pst_sym.pst_value.pst_s_var.pst_vno,
		       (char *) &yyvarsp->illegal_agg_relmask) ||
		    var_node == NULL && yyvarsp->inhaving == 0 && BTnext((i4)-1, 
			(char *) &yyvarsp->illegal_agg_relmask, PST_NUMVARS) != -1)
				/* 2nd test clumsily looks for count(*) 
				** in where, but NOT in having cl subselect */
		{
		    (VOID) psf_error(2930L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
			&cb->pss_lineno);
		    return (E_DB_ERROR);
		}

		/* save location of new agg head */
		status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(YYAGG_NODE_PTR), 
		    (PTR *) &agg_list_elem, &psq_cb->psq_error);
		if (status != E_DB_OK)
		return (status);
		agg_list_elem->agg_node = a1;

		/* insert it into approprite AGGHEAD list */
		psl_insert_into_agg_list(var_node, agg_list_elem, yyvarsp->agg_list_stack,
				     cb->pss_qualdepth, &yyvarsp->flists[0]);
		if (a2 != NULL)
		{
		    /* save location of 2nd AGHEAD for xformed avg(x). */
		    status = psf_malloc(cb, &cb->pss_ostream, 
			(i4) sizeof(YYAGG_NODE_PTR), (PTR *) &agg_list_elem, 
			&psq_cb->psq_error);
		    if (status != E_DB_OK)
			return (status);
		    agg_list_elem->agg_node = a2;

		    /* insert it into appropriate AGHEAD list */
		    psl_insert_into_agg_list(var_node, agg_list_elem, 
			yyvarsp->agg_list_stack, cb->pss_qualdepth, &yyvarsp->flists[0]);
		}
	    }
	    /*
	    ** we may want to know if a subselect with aggregate(s) in its target
	    ** list involved any correlated references; if we are in the target list
	    ** of a subselect other than an outermost one, and $Ycorr_aggr.depth
	    ** has not been previously set, we set it to the current pss_qualdepth
	    ** and start looking for correlated references.  If such reference(s)
	    ** is(are) found, PSS_CORR_AGGR will be set in cb->pss_flattening_flags,
	    ** and after the query tree header is built, PST_CORR_AGGR will be set 
	    ** in the header flag field.  We will not be looking for correlated 
	    ** references if cb->pss_flattening_flags indicates that we have already
	    ** found an occurrence
	    */
	    else if (cb->pss_qualdepth > 1		&&
	         ~cb->pss_flattening_flags & PSS_CORR_AGGR	&&
		 yyvarsp->corr_aggr.depth == -1)
	    {
		yyvarsp->corr_aggr.depth = cb->pss_qualdepth;
		yyvarsp->corr_aggr.found = FALSE;
	    }

	    /*
	    ** If aggregate occurred in the target list of the outermost subselect
	    ** of a SELECT, mark it as non-updatable
	    */
	    if (cb->pss_qualdepth == 1 && yyvarsp->in_target_clause)
	    {
		yyvarsp->nonupdt = TRUE;
		yyvarsp->nonupdt_reason |= PSS_SET_FUNC_IN_OUTERMOST_SUBSEL;
	    }

	     	cb->pss_stmt_flags |= PSS_AGINTREE;	/* pss_agintree = TRUE */
	}   /* end of aggregate function stuff */

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1503:
if (!((*yyvarspp)->bypass_actions))
/* # line 33820 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	if (psl_seqop_search(yacc_cb->yypvt[-0].psl_trtype))
	{
	    /* No sequence operators in case expressions. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* decrement our flag now that we've successfully parsed a case_function */
	yyvarsp->in_case_function--;

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1504:
if (!((*yyvarspp)->bypass_actions))
/* # line 33837 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	if (psl_seqop_search(yacc_cb->yypvt[-0].psl_trtype))
	{
	    /* No sequence operators in cast expressions. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1505:
if (!((*yyvarspp)->bypass_actions))
/* # line 33851 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	if (yyvarsp->in_where_clause || yyvarsp->inhaving || yyvarsp->in_orderby)
	{
	    /* No use of sequences in where, having or order by clauses. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;
	}
	return(0);
}

i4
psls31iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1506:
if (!((*yyvarspp)->bypass_actions))
/* # line 33865 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1507:
if (!((*yyvarspp)->bypass_actions))
/* # line 33869 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 1508:
if (!((*yyvarspp)->bypass_actions))
/* # line 33873 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1511:
if (!((*yyvarspp)->bypass_actions))
/* # line 33883 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1512:
if (!((*yyvarspp)->bypass_actions))
/* # line 33887 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1513:
if (!((*yyvarspp)->bypass_actions))
/* # line 33891 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1514:
if (!((*yyvarspp)->bypass_actions))
/* # line 33895 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADI_OP_NAME	opname;
	ADI_OP_ID	opid;
	ADI_OPINFO	opinfo;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_STATUS	status;
	i4		err_code;

	/* Allow user-defined predicate function names to be used in
	** infix notation. Originally used for OME spatial functions:
	** inside, intesects and overlaps. 
	*/
	STmove(yacc_cb->yypvt[-0].psl_strtype, '\0', sizeof(ADI_OP_NAME), (char *)&opname);
					/* copy operator name */
	status = adi_opid(adf_scb, &opname, &opid);
	if (status == E_DB_OK) status = adi_op_info(adf_scb, opid, &opinfo);
					/* get operator ID, then info */
	if (status != E_DB_OK || opinfo.adi_optype != ADI_PRED_FUNC)
	{	/* is this a valid infix?? */
	    (VOID) psf_error(2931L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
	yacc_cb->yyval.psl_tytype = opid;
    } break;

case 1515:
if (!((*yyvarspp)->bypass_actions))
/* # line 33924 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        PSS_EXLIST *exlist_ptr;	    
        DB_STATUS   status;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_EXLIST), 
	         (PTR *) &exlist_ptr, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

        /*								    
	** The node corresponding to a select_expr will be placed into a linked
	** list to be processed later
	*/							    
        exlist_ptr->pss_expr = yacc_cb->yypvt[-0].psl_trtype;
        exlist_ptr->pss_next = yyvarsp->exprlist;
        yyvarsp->exprlist           = exlist_ptr;
    } break;

case 1516:
if (!((*yyvarspp)->bypass_actions))
/* # line 33944 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        PSS_EXLIST *exlist_ptr;	    
        DB_STATUS   status;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_EXLIST), 
	         (PTR *) &exlist_ptr, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

        /*								    
	** The node corresponding to a select_expr will be placed into a linked
	** list to be processed later
	*/							    
        exlist_ptr->pss_expr = yacc_cb->yypvt[-0].psl_trtype;
        exlist_ptr->pss_next = yyvarsp->exprlist;
        yyvarsp->exprlist           = exlist_ptr;
    } break;

case 1517:
if (!((*yyvarspp)->bypass_actions))
/* # line 33966 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* Non-parameter number constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    yacc_cb->yypvt[-0].psl_dbval->db_datatype, (i2) yacc_cb->yypvt[-0].psl_dbval->db_prec, (i4) yacc_cb->yypvt[-0].psl_dbval->db_length, 
	    (DB_ANYTYPE *) yacc_cb->yypvt[-0].psl_dbval->db_data, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1518:
if (!((*yyvarspp)->bypass_actions))
/* # line 33989 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;
	i4			constSize;

	/* Non-parameter text constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	constSize = yacc_cb->yypvt[-0].psl_textype->db_t_count + DB_CNTSIZE;
	/* STAR may need to create a global tempTbl and VARCHAR(0) is invalid */
	if (constSize == DB_CNTSIZE)
	    ++constSize;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    DB_VCH_TYPE, (i2) 0, constSize, 
	    (DB_ANYTYPE *) yacc_cb->yypvt[-0].psl_textype, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1519:
if (!((*yyvarspp)->bypass_actions))
/* # line 34017 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* hex constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    DB_VCH_TYPE, (i2) 0, (i4) (yacc_cb->yypvt[-0].psl_textype->db_t_count + DB_CNTSIZE),
	    (DB_ANYTYPE *) yacc_cb->yypvt[-0].psl_textype, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1520:
if (!((*yyvarspp)->bypass_actions))
/* # line 34040 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;
	i4			constSize;

	/* Non-parameter Unicode constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	constSize = yacc_cb->yypvt[-0].psl_utextype->count * sizeof(UCS2) + DB_CNTSIZE;
	/* STAR may need to create a global tempTbl and VARCHAR(0) is invalid */
	if (constSize == DB_CNTSIZE)
	    constSize += sizeof(UCS2);
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    DB_NVCHR_TYPE, (i2) 0, constSize, 
	    (DB_ANYTYPE *) yacc_cb->yypvt[-0].psl_utextype, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1521:
if (!((*yyvarspp)->bypass_actions))
/* # line 34068 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	       *newnode;

	status = psl_ansi_strtodt(cb, psq_cb, DB_ADTE_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, &newnode, 
			(DB_DATA_VALUE *) NULL, 0);

	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1522:
if (!((*yyvarspp)->bypass_actions))
/* # line 34084 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TMWO_TYPE, 0,
		       (DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, &yacc_cb->yyval.psl_trtype, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    } break;

case 1523:
if (!((*yyvarspp)->bypass_actions))
/* # line 34096 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TMW_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, &yacc_cb->yyval.psl_trtype, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    } break;

case 1524:
if (!((*yyvarspp)->bypass_actions))
/* # line 34108 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TME_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, &yacc_cb->yyval.psl_trtype, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    } break;

case 1525:
if (!((*yyvarspp)->bypass_actions))
/* # line 34120 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TSWO_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, &yacc_cb->yyval.psl_trtype, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    } break;

case 1526:
if (!((*yyvarspp)->bypass_actions))
/* # line 34132 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TSW_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, &yacc_cb->yyval.psl_trtype,
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    } break;

case 1527:
if (!((*yyvarspp)->bypass_actions))
/* # line 34144 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TSTMP_TYPE, 0,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-0].psl_textype, &yacc_cb->yyval.psl_trtype, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    } break;

case 1528:
if (!((*yyvarspp)->bypass_actions))
/* # line 34156 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1529:
if (!((*yyvarspp)->bypass_actions))
/* # line 34160 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;
	DB_DATA_VALUE	       *dbval;

	dbval = (DB_DATA_VALUE*) yacc_cb->yypvt[-0].psl_dbval;
	/* Non-parameter arbitrary constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	/* we set this because we don't know the type */
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    dbval->db_datatype, (i2) (dbval->db_prec), (i4) (dbval->db_length),
	    (DB_ANYTYPE *) dbval->db_data, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1530:
if (!((*yyvarspp)->bypass_actions))
/* # line 34187 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PST_QNODE	       *parmnode;
	DB_STATUS	       status;

	/* parameters not allowed in non-repeat queries */
	if ((cb->pss_defqry != PSQ_DEFQRY) &&
	    (cb->pss_defqry != PSQ_DEFCURS))
	{
	    (VOID) psf_error(2110L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a constant node with a parameter number */
	status = pst_2adparm(cb, psq_cb, &cb->pss_ostream, *yacc_cb->yypvt[-2].psl_i2type, yacc_cb->yypvt[-0].psl_dbval,
	    &parmnode, &cb->pss_highparm);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = parmnode;
    } break;

case 1531:
if (!((*yyvarspp)->bypass_actions))
/* # line 34213 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode;
	DB_STATUS	status;
	PST_CNST_NODE	const_node;
	i4		err_code;
	i4		psq_mode;

	/* parameter markers allowed only in PREPARE statements.
	** We also won't allow parameters in certain DSQL statements.
	** The ones allowed are the ones that actually return a query
	** tree from pst_execute, with the exception of create rule,
	** integrity, and permit;  those seem too ddl-ish and weren't
	** allowed historically anyway.
	** SET SESSION AUTHORIZATION is special-cased in execute, so
	** I guess it's OK here, as bizarre as that may seem.
	*/

	psq_mode = psq_cb->psq_mode;
	if (cb->pss_defqry != PSQ_PREPARE ||
	  !(psq_mode == PSQ_APPEND ||
	    psq_mode == PSQ_DELETE ||
	    psq_mode == PSQ_REPLACE ||
	    psq_mode == PSQ_RETRIEVE ||
	    psq_mode == PSQ_RETINTO ||
	    psq_mode == PSQ_DGTT_AS_SELECT ||
	    psq_mode == PSQ_DELCURS ||
	    psq_mode == PSQ_REPCURS ||
	    psq_mode == PSQ_VIEW ||
	    psq_mode == PSQ_SET_SESS_AUTH_ID) )
	{
	    (VOID) psf_error(2306L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR); 
	}

	/* Allocate a constant node with a parameter number */

	++cb->pss_highparm;
	if (yyvarsp->in_target_clause)
	   ++cb->pss_targparm;
	const_node.pst_tparmtype = PST_USER;
	if (yyvarsp->repeat_dyn && psq_mode == PSQ_RETRIEVE)
	    const_node.pst_tparmtype = PST_RQPARAMNO;
	const_node.pst_parm_no = cb->pss_highparm + 1;
	const_node.pst_pmspec = PST_PMNOTUSED;
	const_node.pst_cqlang = DB_SQL;
	const_node.pst_origtxt = (char *) NULL;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, 
	    (PST_QNODE *) NULL, PST_CONST, (PTR) &const_node,
	    sizeof(const_node), (DB_DT_ID)DB_NODT, (i2) 0, (i4)0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);

	if (status != E_DB_OK)
	    return (status);

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1532:
if (!((*yyvarspp)->bypass_actions))
/* # line 34273 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("user", cb, BTtest(yyvarsp->qual_depth, yyvarsp->qual_type),
	    &yyvarsp->pss_join_info, &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1533:
if (!((*yyvarspp)->bypass_actions))
/* # line 34282 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("current_date", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1534:
if (!((*yyvarspp)->bypass_actions))
/* # line 34292 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("current_time", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1535:
if (!((*yyvarspp)->bypass_actions))
/* # line 34302 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("current_time", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1536:
if (!((*yyvarspp)->bypass_actions))
/* # line 34312 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("current_timestamp", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1537:
if (!((*yyvarspp)->bypass_actions))
/* # line 34322 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("current_timestamp", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;
	}
	return(0);
}

i4
psls32iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1538:
if (!((*yyvarspp)->bypass_actions))
/* # line 34332 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("local_time", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1539:
if (!((*yyvarspp)->bypass_actions))
/* # line 34342 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("local_time", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1540:
if (!((*yyvarspp)->bypass_actions))
/* # line 34352 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("local_timestamp", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1541:
if (!((*yyvarspp)->bypass_actions))
/* # line 34362 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("local_timestamp", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1542:
if (!((*yyvarspp)->bypass_actions))
/* # line 34372 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("current_user", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1543:
if (!((*yyvarspp)->bypass_actions))
/* # line 34382 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("session_user", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1544:
if (!((*yyvarspp)->bypass_actions))
/* # line 34392 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("system_user", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1545:
if (!((*yyvarspp)->bypass_actions))
/* # line 34402 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;

	status = psl_usr_func("initial_user", cb,
	    BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), &yyvarsp->pss_join_info,
	    &yacc_cb->yyval.psl_trtype, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1546:
if (!((*yyvarspp)->bypass_actions))
/* # line 34412 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADI_OP_ID	       opid;
	DB_STATUS	       status;

	/* first get function id */
	{
	    ADI_OP_NAME	    funcname;
	    ADF_CB	    *adf_scb = (ADF_CB*) cb->pss_adfcb;
	    i4	    err_code;
	    /*
	    ** ADF didn't want to do any work, so we act as if the user entered
	    ** _dba()
	    */
	    STmove("_dba", '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	    
	    status = adi_opid(adf_scb, &funcname, &opid);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_error(2906L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		    &cb->pss_lineno, (i4) (sizeof("$DBA") - 1), "$DBA");
		return (E_DB_ERROR);
	    }
	}

	/* now create a node representing the function */
	{
	    PST_OP_NODE	       opnode;
	    PST_QNODE	       *newnode;
	    
	    opnode.pst_opno = opid;
	    opnode.pst_opmeta = PST_NOMETA;
	    opnode.pst_isescape = PST_DOESNT_APPLY;
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_COP, (char *) &opnode, sizeof(opnode),
		DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &newnode,
		&psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    else if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN in
		** pst_node().
		*/
		newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
			yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	    }
	    
	    yacc_cb->yyval.psl_trtype = newnode;
	}
    } break;

case 1547:
if (!((*yyvarspp)->bypass_actions))
/* # line 34468 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_CNST_NODE	    cconst;

	/* buffer to store $ingres as a string constant */
	DEFINE_DB_TEXT_STRING(ingres,"ingres")
	PST_QNODE	    *newnode;
	DB_STATUS           status;

	/*@FIX_ME@ I don't like this -- what if cat owner not "$ingres"? */
	MEcopy(cb->pss_cat_owner->db_own_name, 
	       ingres.db_t_count, (char *) &(ingres.db_t_text[0]));

	/* Non-parameter text constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_VCH_TYPE, (i2) 0,
	    (i4) (ingres.db_t_count + DB_CNTSIZE),
	    (DB_ANYTYPE *) &ingres, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1548:
if (!((*yyvarspp)->bypass_actions))
/* # line 34501 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*nodep;
	DB_DT_ID	int_type;

	if (yacc_cb->yypvt[-0].psl_inttype >= INT_DAY * 8)
	    int_type = DB_INDS_TYPE;
	else int_type = DB_INYM_TYPE;

	status = psl_ansi_strtodt(cb, psq_cb, int_type, yacc_cb->yypvt[-0].psl_inttype,
			(DB_TEXT_STRING *)yacc_cb->yypvt[-1].psl_textype, &nodep, 
			(DB_DATA_VALUE *) NULL, yyvarsp->interval_frac);
	if (status != E_DB_OK)
	{
	    return (status);
	}
	yacc_cb->yyval.psl_trtype = nodep;
    } break;

case 1549:
if (!((*yyvarspp)->bypass_actions))
/* # line 34522 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	ij2;
	bool	badword = FALSE;

	if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "year") == 0)
	    yacc_cb->yyval.psl_inttype = INT_YEAR;
	else if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "month") == 0)
	    yacc_cb->yyval.psl_inttype = INT_MONTH;
	else if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "day") == 0)
	    yacc_cb->yyval.psl_inttype = INT_DAY;
	else if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "hour") == 0)
	    yacc_cb->yyval.psl_inttype = INT_HOUR;
	else if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "minute") == 0)
	    yacc_cb->yyval.psl_inttype = INT_MINUTE;
	else if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "second") == 0)
	    yacc_cb->yyval.psl_inttype = INT_SECOND;
	else
	{
	    badword = TRUE;
	    yacc_cb->yyval.psl_inttype = 0;
	}

	/* Validate field range and encode for conversion. */
	if (badword || yacc_cb->yypvt[-0].psl_inttype && yacc_cb->yyval.psl_inttype >= yacc_cb->yypvt[-0].psl_inttype ||
	    (yacc_cb->yyval.psl_inttype <= INT_MONTH && yacc_cb->yypvt[-0].psl_inttype >= INT_DAY))
	{
	    /* Syntax error in literal. */
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_OK);
	}

	/* Set 2nd field of range. */
	ij2 = yacc_cb->yypvt[-0].psl_inttype;
	if (ij2 == 0)
	    ij2 = yacc_cb->yyval.psl_inttype;

	yacc_cb->yyval.psl_inttype = yacc_cb->yyval.psl_inttype*8 + ij2;		/* encode field range */
    } break;

case 1550:
if (!((*yyvarspp)->bypass_actions))
/* # line 34562 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->interval_frac = 6;		/* default fracs of seconds */
    } break;

case 1551:
if (!((*yyvarspp)->bypass_actions))
/* # line 34566 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->interval_frac = *yacc_cb->yypvt[-1].psl_i2type;
    } break;

case 1552:
if (!((*yyvarspp)->bypass_actions))
/* # line 34570 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->interval_frac = *yacc_cb->yypvt[-1].psl_i2type;
    } break;

case 1553:
if (!((*yyvarspp)->bypass_actions))
/* # line 34576 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = 0;
    } break;

case 1554:
if (!((*yyvarspp)->bypass_actions))
/* # line 34580 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (STcompare(yacc_cb->yypvt[-3].psl_strtype, "second") != 0)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	yyvarsp->interval_frac = *yacc_cb->yypvt[-1].psl_i2type;
	yacc_cb->yyval.psl_inttype = INT_SECOND;
    } break;

case 1555:
if (!((*yyvarspp)->bypass_actions))
/* # line 34590 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "month") == 0)
	    yacc_cb->yyval.psl_inttype = INT_MONTH;
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "hour") == 0)
	    yacc_cb->yyval.psl_inttype = INT_HOUR;
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "minute") == 0)
	    yacc_cb->yyval.psl_inttype = INT_MINUTE;
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "second") == 0)
	{
	    yacc_cb->yyval.psl_inttype = INT_SECOND;
	    yyvarsp->interval_frac = 6;		/* default fracs of seconds */
	}
	else
	{
	    /* Everything else is a syntax error - including year
	    ** and day, since they can't be the low end field. */
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    } break;

case 1556:
if (!((*yyvarspp)->bypass_actions))
/* # line 34613 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->db_pdata.db_datatype	= DB_INT_TYPE;
	yyvarsp->db_pdata.db_prec  	= 0;
	yyvarsp->db_pdata.db_length	= 2;
	yyvarsp->db_pdata.db_data	= (PTR) &yyvarsp->db_vdata;
	yyvarsp->db_vdata.db_i2type	= *yacc_cb->yypvt[-0].psl_i2type;
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1557:
if (!((*yyvarspp)->bypass_actions))
/* # line 34622 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->db_pdata.db_datatype	= DB_INT_TYPE;
	yyvarsp->db_pdata.db_prec  	= 0;
	yyvarsp->db_pdata.db_length	= 4;
	yyvarsp->db_pdata.db_data	= (PTR) &yyvarsp->db_vdata;
	yyvarsp->db_vdata.db_i4type	= *yacc_cb->yypvt[-0].psl_i4type;
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1558:
if (!((*yyvarspp)->bypass_actions))
/* # line 34631 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->db_pdata.db_datatype	= DB_INT_TYPE;
	yyvarsp->db_pdata.db_prec  	= 0;
	yyvarsp->db_pdata.db_length	= 8;
	yyvarsp->db_pdata.db_data	= (PTR) &yyvarsp->db_vdata;
	yyvarsp->db_vdata.db_i8type	= *yacc_cb->yypvt[-0].psl_i8type;
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1559:
if (!((*yyvarspp)->bypass_actions))
/* # line 34641 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i2		prec;

	I2ASSIGN_MACRO(*yacc_cb->yypvt[-0].psl_dectype, prec);
	yyvarsp->db_pdata.db_datatype	= DB_DEC_TYPE;
	yyvarsp->db_pdata.db_prec  	= prec;
	yyvarsp->db_pdata.db_length	= DB_PREC_TO_LEN_MACRO(DB_P_DECODE_MACRO(prec));
	yyvarsp->db_pdata.db_data	= (PTR)((u_char *)yacc_cb->yypvt[-0].psl_dectype + sizeof(i2));
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1560:
if (!((*yyvarspp)->bypass_actions))
/* # line 34652 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->db_pdata.db_datatype	= DB_FLT_TYPE;
	yyvarsp->db_pdata.db_prec  	= 0;
	yyvarsp->db_pdata.db_length	= 4;
	yyvarsp->db_pdata.db_data	= (PTR) &yyvarsp->db_vdata;
	yyvarsp->db_vdata.db_f4type	= *yacc_cb->yypvt[-0].psl_f4type;
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1561:
if (!((*yyvarspp)->bypass_actions))
/* # line 34661 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->db_pdata.db_datatype	= DB_FLT_TYPE;
	yyvarsp->db_pdata.db_prec  	= 0;
	yyvarsp->db_pdata.db_length	= 8;
	yyvarsp->db_pdata.db_data	= (PTR) &yyvarsp->db_vdata;
	yyvarsp->db_vdata.db_f8type	= *yacc_cb->yypvt[-0].psl_f8type;
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1562:
if (!((*yyvarspp)->bypass_actions))
/* # line 34672 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = AGGR_AVG;
    } break;

case 1563:
if (!((*yyvarspp)->bypass_actions))
/* # line 34676 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = AGGR_MIN;
    } break;

case 1564:
if (!((*yyvarspp)->bypass_actions))
/* # line 34680 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = AGGR_MAX;
    } break;

case 1565:
if (!((*yyvarspp)->bypass_actions))
/* # line 34684 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = AGGR_SUM;
    } break;

case 1566:
if (!((*yyvarspp)->bypass_actions))
/* # line 34690 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  ERx("count(*)"), PST_NDISTINCT, 
				  TRUE, (PST_QNODE *) NULL, 
				  (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = aghdnode;
    } break;

case 1567:
if (!((*yyvarspp)->bypass_actions))
/* # line 34704 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  ERx("count"), yacc_cb->yypvt[-2].psl_tytype, TRUE, yacc_cb->yypvt[-1].psl_trtype, 
				  (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = aghdnode;
    } break;
	}
	return(0);
}

i4
psls33iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1568:
if (!((*yyvarspp)->bypass_actions))
/* # line 34717 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	if (!(yyvarsp->aggr_allowed & PSS_AGG_ALLOWED))
	{
	    (VOID) psf_error(2928L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		sizeof(ERx("any")) - 1, ERx("any"));
	    return (E_DB_ERROR);
	}
	else
	{
	    yyvarsp->aggr_allowed &= ~PSS_AGG_ALLOWED;
	}
    } break;

case 1569:
if (!((*yyvarspp)->bypass_actions))
/* # line 34734 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	/* for ANY, we don't care about distinct values 
	 */
	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  ERx("any"), PST_DONTCARE, TRUE, 
				  yacc_cb->yypvt[-1].psl_trtype, (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = aghdnode;
    } break;

case 1570:
if (!((*yyvarspp)->bypass_actions))
/* # line 34749 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	if (!(yyvarsp->aggr_allowed & PSS_AGG_ALLOWED))
	{
	    (VOID) psf_error(2928L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		STlength(aggr_func_names[yacc_cb->yypvt[-0].psl_tytype]), aggr_func_names[yacc_cb->yypvt[-0].psl_tytype]);
	    return (E_DB_ERROR);
	}
	else
	{
	    yyvarsp->aggr_allowed &= ~PSS_AGG_ALLOWED;
	}
    } break;

case 1571:
if (!((*yyvarspp)->bypass_actions))
/* # line 34766 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	/* for MIN and MAX we don't care about distinct values */
	if (yacc_cb->yypvt[-5].psl_tytype == AGGR_MIN || yacc_cb->yypvt[-5].psl_tytype == AGGR_MAX)
	{
	    yacc_cb->yypvt[-2].psl_tytype = PST_DONTCARE;
	}

	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  aggr_func_names[yacc_cb->yypvt[-5].psl_tytype], yacc_cb->yypvt[-2].psl_tytype, FALSE,
				  yacc_cb->yypvt[-1].psl_trtype, (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = aghdnode;
    } break;

case 1572:
if (!((*yyvarspp)->bypass_actions))
/* # line 34785 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1573:
if (!((*yyvarspp)->bypass_actions))
/* # line 34791 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	if (!(yyvarsp->aggr_allowed & PSS_AGG_ALLOWED))
	{
	    (VOID) psf_error(2928L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		sizeof(ERx("count")) - 1, ERx("count"));
	    return (E_DB_ERROR);
	}
	else
	{
	    yyvarsp->aggr_allowed &= ~PSS_AGG_ALLOWED;
	}
    } break;

case 1574:
if (!((*yyvarspp)->bypass_actions))
/* # line 34810 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PST_BDISTINCT;
    } break;

case 1575:
if (!((*yyvarspp)->bypass_actions))
/* # line 34814 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PST_NDISTINCT;
    } break;

case 1576:
if (!((*yyvarspp)->bypass_actions))
/* # line 34818 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PST_DISTINCT;
    } break;

case 1577:
if (!((*yyvarspp)->bypass_actions))
/* # line 34824 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PST_DISTINCT;
    } break;

case 1578:
if (!((*yyvarspp)->bypass_actions))
/* # line 34828 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = PST_NDISTINCT;
    } break;

case 1579:
if (!((*yyvarspp)->bypass_actions))
/* # line 34834 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	       *newnode;
	DB_STATUS	       status;

	status = psl_nary_func(cb, psq_cb, yyvarsp, yacc_cb->yypvt[-2].psl_opinfo, &newnode);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1580:
if (!((*yyvarspp)->bypass_actions))
/* # line 34844 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	if (yacc_cb->yypvt[-4].psl_opinfo->adi_optype != ADI_AGG_FUNC)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	/* Not going to use the func-args mechanism, pop what func pushed */
	yyvarsp->arg_ix = yyvarsp->arg_base;
	yyvarsp->arg_base = yyvarsp->arg_stack[--yyvarsp->arg_stack_ix];

	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  (char *)&yacc_cb->yypvt[-4].psl_opinfo->adi_opname, yacc_cb->yypvt[-2].psl_tytype, FALSE, 
				  yacc_cb->yypvt[-1].psl_trtype, (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = aghdnode;
    } break;

case 1581:
if (!((*yyvarspp)->bypass_actions))
/* # line 34867 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADI_OPINFO	func;
	DB_STATUS	status;
	i4		err_code;
	PST_QNODE	*newnode;

	/* ANSI style substring.
	** "func" production not used, do its work here.
	** Find substring opinfo and do 2-operand function.
	*/
	status = adi_op_info(cb->pss_adfcb, ADI_SUBSTRING_OP, &func);
	if (status != E_DB_OK)
	    return (status);
	/* Stack current arglist base, reset to current arglist position */
	if (yyvarsp->arg_stack_ix >= PSS_YYMAXDEPTH)
	{
	    (void) psf_error(2800L, 0, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	yyvarsp->arg_stack[yyvarsp->arg_stack_ix++] = yyvarsp->arg_base;
	yyvarsp->arg_base = yyvarsp->arg_ix;

	/* Put string and from args where they belong */
	status = psl_arg_room(cb, psq_cb, yyvarsp, 2);
	if (status != E_DB_OK)
	    return (status);
	yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-3].psl_trtype;
	yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-1].psl_trtype;
	status = psl_nary_func(cb, psq_cb, yyvarsp, &func, &newnode);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1582:
if (!((*yyvarspp)->bypass_actions))
/* # line 34903 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		err_code;
	PST_QNODE	*newnode;

	/* This is the ANSI POSITION function - func MUST be "position". */

	if (yacc_cb->yypvt[-5].psl_opinfo->adi_opid != ADI_POS_OP)
	{
	    (void)psf_error(2934L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite((char *)&(yacc_cb->yypvt[-5].psl_opinfo->adi_opname)), 
		yacc_cb->yypvt[-5].psl_opinfo->adi_opname);
	    return (E_DB_ERROR);
	}
	status = psl_arg_room(cb, psq_cb, yyvarsp, 2);
	if (status != E_DB_OK)
	    return (status);
	yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-3].psl_trtype;
	yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-1].psl_trtype;
	status = psl_nary_func(cb, psq_cb, yyvarsp, yacc_cb->yypvt[-5].psl_opinfo, &newnode);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = newnode;

    } break;

case 1583:
if (!((*yyvarspp)->bypass_actions))
/* # line 34930 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		err_code;
	PST_QNODE	*newnode;
	ADI_OPINFO	*opinfo;
	bool		extract = FALSE;

	/* This is ANSI syntax for the TRIM or EXTRACT functions - funcname
	** must be either TRIM or EXTRACT. */

	/* Determine if this is TRIM or EXTRACT. TRIMs always have 3 byte
	** constant for $3. EXTRACT only has 3 bytes if it is DAY. */
	if (yacc_cb->yypvt[-3].psl_trtype->pst_sym.pst_dataval.db_length != 3 ||
	    MEcmp(yacc_cb->yypvt[-3].psl_trtype->pst_sym.pst_dataval.db_data, "day", 3) == 0)
	    extract = TRUE;

	if ((yacc_cb->yypvt[-5].psl_opinfo->adi_opid != ADI_TRIM_OP && yacc_cb->yypvt[-5].psl_opinfo->adi_opid != ADI_DPART_OP) ||
	    (yacc_cb->yypvt[-5].psl_opinfo->adi_opid == ADI_TRIM_OP && extract) ||
	    (yacc_cb->yypvt[-5].psl_opinfo->adi_opid == ADI_DPART_OP && !extract))
	{
	    /* Plain old syntax error. */
	    psl_yerror(3, cb, psq_cb);
	    return (E_DB_ERROR);
	}

	/* Change trim() to atrim(). */
	if (yacc_cb->yypvt[-5].psl_opinfo->adi_opid == ADI_TRIM_OP)
	{
            status = psf_malloc(cb, &cb->pss_ostream, sizeof(ADI_OPINFO), 
	         (PTR *) &opinfo, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return(status);

	    status = adi_op_info((ADF_CB *)cb->pss_adfcb, ADI_ATRIM_OP, opinfo);
	    if (status != E_DB_OK)
		return(status);
	}
	else opinfo = yacc_cb->yypvt[-5].psl_opinfo;

	status = psl_arg_room(cb, psq_cb, yyvarsp, 2);
	if (status != E_DB_OK)
	    return (status);

	/* If this is EXTRACT, parms are in sequence. If TRIM, they're
	** backwards. */
	if (extract)
	{
	    yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-3].psl_trtype;
	    yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-1].psl_trtype;
	}
	else
	{
	    yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-1].psl_trtype;
	    yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-3].psl_trtype;
	}

	status = psl_nary_func(cb, psq_cb, yyvarsp, opinfo, &newnode);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1584:
if (!((*yyvarspp)->bypass_actions))
/* # line 34993 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADI_OPINFO	func;
	DB_STATUS	status;
	i4		err_code;
	PST_QNODE	*newnode;

	/* ANSI style substring.
	** "func" production not used, do its work here.
	** Find substring opinfo and do 3-operand function.
	*/
	status = adi_op_info(cb->pss_adfcb, ADI_SUBSTRING_OP, &func);
	if (status != E_DB_OK)
	    return (status);
	/* Stack current arglist base, reset to current arglist position */
	if (yyvarsp->arg_stack_ix >= PSS_YYMAXDEPTH)
	{
	    (void) psf_error(2800L, 0, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	yyvarsp->arg_stack[yyvarsp->arg_stack_ix++] = yyvarsp->arg_base;
	yyvarsp->arg_base = yyvarsp->arg_ix;

	status = psl_arg_room(cb, psq_cb, yyvarsp, 3);
	if (status != E_DB_OK)
	    return (status);
	yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-5].psl_trtype;
	yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-3].psl_trtype;
	yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-1].psl_trtype;
	status = psl_nary_func(cb, psq_cb, yyvarsp, &func, &newnode);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1585:
if (!((*yyvarspp)->bypass_actions))
/* # line 35029 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	       *newnode;
	DB_STATUS	       status;

	status = psl_nary_func(cb, psq_cb, yyvarsp, yacc_cb->yypvt[-3].psl_opinfo, &newnode);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1592:
if (!((*yyvarspp)->bypass_actions))
/* # line 35056 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;

	status = psl_arg_room(cb, psq_cb, yyvarsp, 1);
	if (status != E_DB_OK)
	    return (status);
	if ((yyvarsp->arg_ix - yyvarsp->arg_base) == ADI_MAX_OPERANDS)
	{
	    i4 err_code;
	    i4 maxops = ADI_MAX_OPERANDS;

	    (void)psf_error(2423, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(maxops), &maxops);
	    return (E_DB_ERROR);
	}
	yyvarsp->func_args[yyvarsp->arg_ix++] = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1593:
if (!((*yyvarspp)->bypass_actions))
/* # line 35078 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	ADI_OP_NAME	       funcname;
	ADI_OP_ID	       opid;
	ADI_OPINFO	       *opinfo;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_STATUS	       status;
	i4		       err_code;

	STmove(yacc_cb->yypvt[-0].psl_strtype, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	status = adi_opid(adf_scb, &funcname, &opid);
	if (status != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(ADI_OPINFO), 
	         (PTR *) &opinfo, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	status = adi_op_info(adf_scb, opid, opinfo);
	if (status != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Stack current arglist base, reset to current arglist position */
	if (yyvarsp->arg_stack_ix >= PSS_YYMAXDEPTH)
	{
	    (void) psf_error(2800L, 0, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	yyvarsp->arg_stack[yyvarsp->arg_stack_ix++] = yyvarsp->arg_base;
	yyvarsp->arg_base = yyvarsp->arg_ix;
	yacc_cb->yyval.psl_opinfo = opinfo;
    } break;

case 1594:
if (!((*yyvarspp)->bypass_actions))
/* # line 35126 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1595:
if (!((*yyvarspp)->bypass_actions))
/* # line 35130 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = "interval";
    } break;

case 1596:
if (!((*yyvarspp)->bypass_actions))
/* # line 35136 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode;
	PST_CNST_NODE	cconst;
	DB_STATUS	status;
	i1		trimcode;
	i4		err_code, copylen;
	char		trimval[3];

	/* Validate trim specifier value. */
	if (STbcompare(yacc_cb->yypvt[-1].psl_strtype, 0, "trailing", 0, TRUE) == 0)
	    trimcode = ADF_TRIM_TRAILING;
	else if (STbcompare(yacc_cb->yypvt[-1].psl_strtype, 0, "leading", 0, TRUE) == 0)
	    trimcode = ADF_TRIM_LEADING;
	else if (STbcompare(yacc_cb->yypvt[-1].psl_strtype, 0, "both", 0, TRUE) == 0)
	    trimcode = ADF_TRIM_BOTH;
	else
	{
	    /* Bad value for trim code. */
	    psf_error(2936L, 0L, PSF_USERERR,
		      &err_code, &psq_cb->psq_error, 2,
		      sizeof(cb->pss_lineno), &cb->pss_lineno,
		      STlength(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
	    return(E_DB_ERROR);
	}

	trimval[0] = (i1)trimcode;

	/* Now add trim character. */
	trimval[1] = trimval[2] = 0;
	copylen = STlength(yacc_cb->yypvt[-0].psl_strtype);
	if (copylen > 2)
	    copylen = 2;
	if (copylen == 0)
	    trimval[1] = ' ';
	else MEcopy(yacc_cb->yypvt[-0].psl_strtype, copylen, &trimval[1]);
	if (copylen <= 1)
	    trimval[2] = 0;

	/* Now make a PST_CONST with this stuff in it and return. */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_CHA_TYPE, (i2) 0, (i4) 3,
	    (DB_ANYTYPE *) &trimval, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1597:
if (!((*yyvarspp)->bypass_actions))
/* # line 35191 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode;
	PST_CNST_NODE	cconst;
	DB_STATUS	status;
	i4		err_code;
	i2		i, constlen;
	char		trimval[3];
	char		*cptr;
	bool		found = TRUE;

	/* Validate specifier - trim field or extract field. */

	/* Trim character defaults to ' '. */
	constlen = 3;
	cptr = &trimval[0];
	trimval[1] = ' ';
	trimval[2] = 0;
	if (STbcompare(yacc_cb->yypvt[-0].psl_strtype, 0, "trailing", 0, TRUE) == 0)
	    trimval[0] = ADF_TRIM_TRAILING;
	else if (STbcompare(yacc_cb->yypvt[-0].psl_strtype, 0, "leading", 0, TRUE) == 0)
	    trimval[0] = ADF_TRIM_LEADING;
	else if (STbcompare(yacc_cb->yypvt[-0].psl_strtype, 0, "both", 0, TRUE) == 0)
	    trimval[0] = ADF_TRIM_BOTH;
	else
	{
	    for (i = 0; i < EXTRACT_FIELDS_COUNT; i++)
	     if (STbcompare(yacc_cb->yypvt[-0].psl_strtype, 0, extract_fields[i], 0, TRUE) == 0)
		break;

	    if (i >= EXTRACT_FIELDS_COUNT)
		found = FALSE;
	    else 
	    {
		constlen = STlength(extract_fields[i]);
		cptr = extract_fields[i];
	    }
	}

	if (!found)
	{
	    /* Plain old syntax error. */
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	/* Now make a PST_CONST with this stuff in it and return. */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_CHA_TYPE, (i2) 0, (i4) constlen,
	    (DB_ANYTYPE *) cptr, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1598:
if (!((*yyvarspp)->bypass_actions))
/* # line 35253 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode;
	PST_CNST_NODE	cconst;
	DB_STATUS	status;
	i1		trimcode;
	i4		copylen;
	char		trimval[3];

	/* Trim code defaults to 2 (both). */
	trimval[0] = (i1)ADF_TRIM_BOTH;

	/* Now add trim character. */
	trimval[1] = trimval[2] = 0;
	copylen = STlength(yacc_cb->yypvt[-0].psl_strtype);
	if (copylen > 2)
	    copylen = 2;
	if (copylen == 0)
	    trimval[1] = ' ';
	else MEcopy(yacc_cb->yypvt[-0].psl_strtype, copylen, &trimval[1]);
	if (copylen == 1)
	{
	    trimval[2] = 0;
	}

	/* Now make a PST_CONST with this stuff in it and return. */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_CHA_TYPE, (i2) 0, (i4) 3,
	    (DB_ANYTYPE *) &trimval, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1599:
if (!((*yyvarspp)->bypass_actions))
/* # line 35296 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 1600:
if (!((*yyvarspp)->bypass_actions))
/* # line 35300 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* This is a bit drawn out. NULLIF is literally defined as 
	** "case when v1 = v2 then NULL else v1 end", and the entire parse
	** tree structure is built here. */

	DB_STATUS	status;
	PST_QNODE	*casep, *whlistp, *whopp, *constp;
	PST_QNODE	*srcecopy;
	PSS_TREEINFO	*treeinfo;
	PST_OP_NODE	eqnode;
	PST_CNST_NODE	constnode;
	PST_CASE_NODE	casenode;
	DB_DATA_VALUE	db_data;
	i4	        nores_flag;
	char		buf[DB_CNTSIZE + 1];

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/* Build WHOP, WHLIST to represent NULLIF's else case. */
	status = pst_node(cb, &cb->pss_ostream, NULL, yacc_cb->yypvt[-3].psl_trtype,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Build "v1 = v2" comparison, then NULL constant value to attach
	** to upper WHLIST. */

	/* Copy the v1 source expression. */
	yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-3].psl_trtype;
	yyvarsp->dup_rb.pss_dup  = &srcecopy;;
	status = pst_treedup(cb, &yyvarsp->dup_rb);

	if (status != E_DB_OK) return (status);

	/* Set up "=" comparison between v1 and v2. */
	status = psl_simple_compare(cb, srcecopy, yacc_cb->yypvt[-1].psl_trtype,
		ADI_EQ_OP, (i4)PST_DOESNT_APPLY, (char)0, &treeinfo, 
		(bool)BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), (bool)yyvarsp->in_target_clause,
		&yyvarsp->pss_join_info, psq_cb);

	if (status != E_DB_OK) return (status);

	/* NULL constant node */
	db_data.db_datatype = -DB_LTXT_TYPE;
	db_data.db_prec     = 0;
	db_data.db_length   = DB_CNTSIZE + 1;
	db_data.db_data	    = (PTR) buf;

	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, &db_data);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	constnode.pst_tparmtype = PST_USER;
	constnode.pst_parm_no = 0;
	constnode.pst_pmspec  = PST_PMNOTUSED;
	constnode.pst_cqlang = DB_SQL;
	constnode.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &constnode,
	    sizeof(constnode), -DB_LTXT_TYPE, (i2) 0, (i4) (1 + DB_CNTSIZE),
	    (DB_ANYTYPE *) db_data.db_data, &constp, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Build WHOP, WHLIST to contain NULLIF's "when v1 = v2 then NULL". */
	status = pst_node(cb, &cb->pss_ostream, treeinfo->pss_tree, constp,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, whlistp, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Finally init case node, then allocate PST_CASEOP node and attach 
	** NULLIF "when list". */
	casenode.pst_caselen = 0;
	casenode.pst_casedt = (DB_DT_ID) DB_NODT;
	casenode.pst_caseprec = 0;
	casenode.pst_casetype = PST_SEARCHED_CASE;

	status = pst_node(cb, &cb->pss_ostream, whlistp, (PST_QNODE *)NULL, 
		PST_CASEOP, (char *)&casenode, (i4)sizeof(PST_CASE_NODE), 
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &casep, 
		&psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	yacc_cb->yyval.psl_trtype = casep;
    } break;

case 1601:
if (!((*yyvarspp)->bypass_actions))
/* # line 35419 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*casep, *whlistp;
	PST_CASE_NODE	casenode;
	DB_DATA_VALUE	db_data;
	i4	        nores_flag;

	/* COALESCE(v1, v2, ..., vn) compiles to "CASE WHEN v1 IS NOT NULL THEN v1
	** ELSE WHEN v2 IS NOT NULL THEN v2 ... ELSE vn". Once we return here,
	** all we need to do is allocate the case node and attach whlist from
	** below. */

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/* Build case node and attach WHLIST chain to it. */
	casenode.pst_caselen = 0;
	casenode.pst_casedt = (DB_DT_ID) DB_NODT;
	casenode.pst_caseprec = 0;
	casenode.pst_casetype = PST_SEARCHED_CASE;

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-1].psl_trtype, (PST_QNODE *)NULL, 
		PST_CASEOP, (char *)&casenode, (i4)sizeof(PST_CASE_NODE), 
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &casep, 
		&psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Final step is to find last WHLIST and make it into "ELSE vn"
	** by removing "vn IS NOT NULL" from corresponding WHOP node. */
	for (whlistp = yacc_cb->yypvt[-1].psl_trtype; whlistp->pst_left != NULL; 
		whlistp = whlistp->pst_left);	/* loop ends when we're at
						** last WHLIST */
	whlistp->pst_right->pst_left = (PST_QNODE *) NULL;

	yacc_cb->yyval.psl_trtype = casep;
    } break;

case 1602:
if (!((*yyvarspp)->bypass_actions))
/* # line 35473 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
      /*
      ** Start parsing a case_function. This could be embedded in another
      ** case_function so we use an increment rather than just set to TRUE.
      */
      yyvarsp->in_case_function++;
    } break;

case 1603:
if (!((*yyvarspp)->bypass_actions))
/* # line 35483 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*casep;
	PST_CASE_NODE	casenode;
	i4	        nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Init case node, then allocate PST_CASEOP node and attach "when list". */
	casenode.pst_caselen = 0;
	casenode.pst_casedt = (DB_DT_ID) DB_NODT;
	casenode.pst_caseprec = 0;
	casenode.pst_casetype = PST_SEARCHED_CASE;

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_trtype, (PST_QNODE *)NULL, 
		PST_CASEOP, (char *)&casenode, (i4)sizeof(PST_CASE_NODE), 
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &casep, 
		&psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	yacc_cb->yyval.psl_trtype = casep;
    } break;
	}
	return(0);
}

i4
psls34iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1604:
if (!((*yyvarspp)->bypass_actions))
/* # line 35523 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*casep, *whlistp;
	PST_CASE_NODE	casenode;
	i4 		nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Init case node, then allocate PST_CASEOP node and attach "when list" 
	** and source value expression. */
	casenode.pst_caselen = 0;
	casenode.pst_casedt = (DB_DT_ID) DB_NODT;
	casenode.pst_caseprec = 0;
	casenode.pst_casetype = PST_SIMPLE_CASE;

	/* Now loop over "when" list, creating search expressions for each. */
	for (whlistp = yacc_cb->yypvt[-0].psl_trtype; whlistp && whlistp->pst_right->pst_left;
		whlistp = whlistp->pst_left)
	{
	    PST_QNODE	*srcecopy;
	    PSS_TREEINFO *treeinfo;

	    /* Copy the source expression. */
	    yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-1].psl_trtype;
	    yyvarsp->dup_rb.pss_dup  = &srcecopy;;
	    status = pst_treedup(cb, &yyvarsp->dup_rb);

	    if (status != E_DB_OK) return (status);

	    /* Set up "=" comparison between source and "when" clause 
	    ** comparand expression. */
	    status = psl_simple_compare(cb, srcecopy, whlistp->pst_right->pst_left,
		ADI_EQ_OP, (i4)PST_DOESNT_APPLY, (char)0, &treeinfo, 
		(bool)BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), (bool)yyvarsp->in_target_clause,
		&yyvarsp->pss_join_info, psq_cb);

	    if (status != E_DB_OK) return (status);

	    /* Finally, replace comparand expression of "when" clause by new
	    ** "=" comparison. */
	    whlistp->pst_right->pst_left = treeinfo->pss_tree;
	}

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-0].psl_trtype, yacc_cb->yypvt[-1].psl_trtype,
		PST_CASEOP, (char *)&casenode, (i4)sizeof(PST_CASE_NODE), 
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &casep, 
		&psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	yacc_cb->yyval.psl_trtype = casep;
    } break;

case 1605:
if (!((*yyvarspp)->bypass_actions))
/* # line 35594 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*nodep;

	/* Just loop down left side of "when list" and attach case_else to end. */
	for (nodep = yacc_cb->yypvt[-1].psl_trtype; nodep->pst_left && 
		nodep->pst_left->pst_sym.pst_type == PST_WHLIST;
		nodep= nodep->pst_left);
	nodep->pst_left = yacc_cb->yypvt[-0].psl_trtype;

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 1606:
if (!((*yyvarspp)->bypass_actions))
/* # line 35608 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1607:
if (!((*yyvarspp)->bypass_actions))
/* # line 35612 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*nodep;

	/* Attach "when item" to list. */
	for (nodep = yacc_cb->yypvt[-1].psl_trtype; nodep->pst_left && 
		nodep->pst_left->pst_sym.pst_type == PST_WHLIST;
		nodep= nodep->pst_left);
	nodep->pst_left = yacc_cb->yypvt[-0].psl_trtype;

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 1608:
if (!((*yyvarspp)->bypass_actions))
/* # line 35626 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	i4 		nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Allocate PST_WHOP node and attach search and result expressions. */
	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_treeinfo_type->pss_tree, yacc_cb->yypvt[-0].psl_trtype,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	yacc_cb->yyval.psl_trtype = whlistp;
    } break;

case 1609:
if (!((*yyvarspp)->bypass_actions))
/* # line 35668 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*nodep;

	/* Just loop down left side of "when list" and attach case_else to end. */
	for (nodep = yacc_cb->yypvt[-1].psl_trtype; nodep->pst_left && 
		nodep->pst_left->pst_sym.pst_type == PST_WHLIST;
		nodep= nodep->pst_left);
	nodep->pst_left = yacc_cb->yypvt[-0].psl_trtype;

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 1610:
if (!((*yyvarspp)->bypass_actions))
/* # line 35682 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1611:
if (!((*yyvarspp)->bypass_actions))
/* # line 35686 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*nodep;

	/* Attach "when item" to list. */
	for (nodep = yacc_cb->yypvt[-1].psl_trtype; nodep->pst_left && 
		nodep->pst_left->pst_sym.pst_type == PST_WHLIST;
		nodep= nodep->pst_left);
	nodep->pst_left = yacc_cb->yypvt[-0].psl_trtype;

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-1].psl_trtype;
    } break;

case 1612:
if (!((*yyvarspp)->bypass_actions))
/* # line 35700 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	i4 		nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Allocate PST_WHOP node and attach search and result expressions. */
	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	yacc_cb->yyval.psl_trtype = whlistp;
    } break;

case 1613:
if (!((*yyvarspp)->bypass_actions))
/* # line 35742 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	PST_CNST_NODE	cconst;
	DB_DATA_VALUE	db_data;
	char		buf[DB_CNTSIZE + 1];
	i4		nores_flag;

	/*
	** Just allocate NULL constant and attach to WHOP to WHLIST.
	*/

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	db_data.db_datatype = -DB_LTXT_TYPE;
	db_data.db_prec     = 0;
	db_data.db_length   = DB_CNTSIZE + 1;
	db_data.db_data	    = (PTR) buf;

	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, &db_data);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* NULL constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), -DB_LTXT_TYPE, (i2) 0, (i4) (1 + DB_CNTSIZE),
	    (DB_ANYTYPE *) db_data.db_data, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Allocate PST_WHOP node and attach NULL as "else" result expression. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, newnode,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	yacc_cb->yyval.psl_trtype = whlistp;

    } break;

case 1614:
if (!((*yyvarspp)->bypass_actions))
/* # line 35813 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	i4		nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Allocate PST_WHOP node and attach "else" result expression. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, yacc_cb->yypvt[-0].psl_trtype,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	yacc_cb->yyval.psl_trtype = whlistp;
    } break;

case 1615:
if (!((*yyvarspp)->bypass_actions))
/* # line 35855 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1616:
if (!((*yyvarspp)->bypass_actions))
/* # line 35859 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*cp;

	/* Hook the WHLISTs together. */
	for (cp = yacc_cb->yypvt[-2].psl_trtype; cp->pst_left; cp = cp->pst_left);
				/* find end of current list */
	cp->pst_left = yacc_cb->yypvt[-0].psl_trtype;	/* add the latest to end */
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-2].psl_trtype;
    } break;

case 1617:
if (!((*yyvarspp)->bypass_actions))
/* # line 35871 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	PST_QNODE	*srcecopy;
	PSS_TREEINFO	*treeinfo;
	i4	        nores_flag;

	/* Each coalesce_list_item represents a parameter and generates a
	** "when vj is not null then vj" entry in the big case. */

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   yyvarsp->in_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/* Copy the vj source expression. */
	yyvarsp->dup_rb.pss_tree = yacc_cb->yypvt[-0].psl_trtype;
	yyvarsp->dup_rb.pss_dup  = &srcecopy;;
	status = pst_treedup(cb, &yyvarsp->dup_rb);

	if (status != E_DB_OK) return (status);

	/* Build "vj is not null" comparison. */

	status = psl_simple_compare(cb, srcecopy, (PST_QNODE *) NULL,
	    ADI_NONUL_OP, (i4) PST_DOESNT_APPLY, (char) 0, &treeinfo,
	    (bool) BTtest(yyvarsp->qual_depth, yyvarsp->qual_type), 
	    (bool)yyvarsp->in_target_clause, &yyvarsp->pss_join_info, psq_cb);
	if (status != E_DB_OK) return (status);

	/* Build WHOP, WHLIST to contain COALESCE "when vj is not null then vj". */
	status = pst_node(cb, &cb->pss_ostream, treeinfo->pss_tree, yacc_cb->yypvt[-0].psl_trtype,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	yacc_cb->yyval.psl_trtype = whlistp;
    } break;

case 1618:
if (!((*yyvarspp)->bypass_actions))
/* # line 35932 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_OP_NODE	       opnode;
	PST_QNODE	       *newnode;
	PST_QNODE	       *dec_node = NULL;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	ADI_OP_ID	       opid;
	DB_STATUS	       status;
	bool		       delay_type_resolution;

	{
	    status = adi_castid(adf_scb, &opid, yacc_cb->yypvt[-1].psl_dbval);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** delay type resolution if processing target list or a CHECK constraint
	    ** specified as a part of CREATE TABLE statement until we have type info
	    ** on attributes that may be involved in expressions passed to the
	    ** function
	    */
	    if (   yyvarsp->in_target_clause 
		|| (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	    {
		delay_type_resolution = TRUE;
	    }
	    else
	    {
		delay_type_resolution = FALSE;
	    }

	    if (!delay_type_resolution)
	    {
		/*
		** additional processing for unary functions.  For the time
		** being, it will consist of setting default precision and scale
		** for specified argument to decimal() function
		*/
		status = psl_1ary_func_extra_proc(cb, opid, yacc_cb->yypvt[-3].psl_trtype, &dec_node,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		return(status);
	    }
	    
	    opnode.pst_opno = opid;
	    opnode.pst_opmeta = PST_NOMETA;
	    opnode.pst_isescape = PST_DOESNT_APPLY;

	    status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-3].psl_trtype, dec_node,
		(dec_node == NULL) ? PST_UOP : PST_BOP,
		(char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
		(delay_type_resolution) ? PSS_NORES : 0);

	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    else if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN in
		** pst_node().
		*/
		newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
	    }

	    yyvarsp->db_pdata.db_data = NULL;		/* Ensure no junk here */
	    if (yyvarsp->db_pdata.db_length == 0)
		yyvarsp->db_pdata.db_datatype = 0;	/* length is set later */
	    STRUCT_ASSIGN_MACRO(yyvarsp->db_pdata, newnode->pst_sym.pst_dataval);

	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/* Dbmsinfo() & some constant funcs are evaluated to constants */
		status = psl_proc_func(cb, opid, yacc_cb->yypvt[-3].psl_trtype, &newnode, 
		    &psq_cb->psq_error);
		if (status != E_DB_OK)
		{
		    return (status);
		}
	    }
	    yacc_cb->yyval.psl_trtype = newnode;
	    
	}
    } break;

case 1619:
if (!((*yyvarspp)->bypass_actions))
/* # line 36026 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = adi_encode_colspec(cb->pss_adfcb, yacc_cb->yypvt[-1].psl_strtype, 0, (i4 *)NULL, 
			(i4)ADI_F4_CAST, &yyvarsp->db_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	if (yacc_cb->yypvt[-0].psl_inttype >= 0)
	{
	    status = psl_collation_check(psq_cb, cb, &yyvarsp->db_pdata, yacc_cb->yypvt[-0].psl_inttype);
	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}

	yyvarsp->db_pdata.db_collID = yacc_cb->yypvt[-0].psl_inttype;
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1620:
if (!((*yyvarspp)->bypass_actions))
/* # line 36050 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		len = yacc_cb->yypvt[-2].psl_inttype;

	status = adi_encode_colspec(cb->pss_adfcb, yacc_cb->yypvt[-4].psl_strtype, 1, &len,
			(i4) 0, &yyvarsp->db_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	if (yacc_cb->yypvt[-0].psl_inttype >= 0)
	{
	    status = psl_collation_check(psq_cb, cb, &yyvarsp->db_pdata, yacc_cb->yypvt[-0].psl_inttype);
	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}

	yyvarsp->db_pdata.db_collID = yacc_cb->yypvt[-0].psl_inttype;
	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1621:
if (!((*yyvarspp)->bypass_actions))
/* # line 36075 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		lenvec[2];

	lenvec[0] = yacc_cb->yypvt[-3].psl_inttype;
	lenvec[1] = yacc_cb->yypvt[-1].psl_inttype;
	status = adi_encode_colspec(cb->pss_adfcb, yacc_cb->yypvt[-5].psl_strtype, 2, lenvec,
			(i4) 0, &yyvarsp->db_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1622:
if (!((*yyvarspp)->bypass_actions))
/* # line 36092 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	char		*value;

	/* INTERVAL X TO Y(n) */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-2].psl_strtype, "to", yacc_cb->yypvt[-0].psl_strtype, 
						&value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = adi_encode_colspec(cb->pss_adfcb, value, 0, (i4 *)NULL,
			(i4) 0, &yyvarsp->db_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1623:
if (!((*yyvarspp)->bypass_actions))
/* # line 36115 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		len;
	char		*value;

	/* INTERVAL X TO Y(n) */
	status = psl_ct11_tname_name_name(cb, psq_cb, yacc_cb->yypvt[-5].psl_strtype, "to", yacc_cb->yypvt[-3].psl_strtype, 
						&value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	len = yacc_cb->yypvt[-1].psl_inttype;
	status = adi_encode_colspec(cb->pss_adfcb, value, 1, &len,
			(i4) 0, &yyvarsp->db_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	yacc_cb->yyval.psl_dbval = &yyvarsp->db_pdata;
    } break;

case 1624:
if (!((*yyvarspp)->bypass_actions))
/* # line 36142 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1625:
if (!((*yyvarspp)->bypass_actions))
/* # line 36146 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1626:
if (!((*yyvarspp)->bypass_actions))
/* # line 36152 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	i4		err_code;
	PST_SEQOP_NODE	seqop;
	PSS_SEQINFO	seqinfo;
	i4		privs = DB_NEXT;
	i4		seq_mask = 0;
	i4		gseq_flags;

	/* Verify it's ok to issue next/current value. */
	if (yyvarsp->in_groupby_clause || yyvarsp->inhaving || (yyvarsp->nonupdt &&
	    (yyvarsp->nonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL)) ||
	    yyvarsp->in_where_clause)
	{
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Fill in SEQOP node */
	STmove(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&seqop.pst_seqname);
	/* If name was qualified, copy schema qualifier. 
	** Otherwise use session userid as default qualifier. */
	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    STmove((char *)&yacc_cb->yypvt[-0].psl_objspec->pss_owner, ' ', sizeof(DB_OWN_NAME),
	       (char *)&seqop.pst_owner);
	else STRUCT_ASSIGN_MACRO(cb->pss_user, seqop.pst_owner);

	seq_mask |= ((yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_SEQ_BY_OWNER
	    : PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ);

	/* Find the sequence first. */
	status = psy_gsequence(cb, &seqop.pst_owner, 
		&seqop.pst_seqname, seq_mask, &seqinfo, NULL,
		&gseq_flags, &privs, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}

	STRUCT_ASSIGN_MACRO(seqinfo.pss_seqid, seqop.pst_seqid);
	seqop.pst_seqflag = yacc_cb->yypvt[-1].psl_inttype;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_SEQOP, (char *) &seqop,
	    sizeof(seqop), seqinfo.pss_dt, 
	    DB_PS_ENCODE_MACRO(seqinfo.pss_prec, 0), seqinfo.pss_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yyvarsp->seq_ops = TRUE;
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1627:
if (!((*yyvarspp)->bypass_actions))
/* # line 36218 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PST_SEQOP_NEXT;
    } break;

case 1628:
if (!((*yyvarspp)->bypass_actions))
/* # line 36222 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PST_SEQOP_CURR;
    } break;

case 1629:
if (!((*yyvarspp)->bypass_actions))
/* # line 36228 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	i4		err_code;
	PST_SEQOP_NODE	seqop;
	PSS_SEQINFO	seqinfo;
	i4		privs = DB_NEXT;
	i4		gseq_flags;

	/* Verify it's ok to issue next/current value. */
	if (yyvarsp->in_groupby_clause || yyvarsp->inhaving || (yyvarsp->nonupdt &&
	    (yyvarsp->nonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL)) ||
	    yyvarsp->in_where_clause)
	{
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Fill in SEQOP node */
	STmove(yacc_cb->yypvt[-4].psl_strtype, ' ', sizeof(DB_OWN_NAME), (char *) &seqop.pst_owner);
	STmove(yacc_cb->yypvt[-2].psl_strtype, ' ', sizeof(DB_NAME), (char *) &seqop.pst_seqname);
	/* STRUCT_ASSIGN_MACRO(cb->pss_user, seqop.pst_owner); */

	/* Find the sequence first. */
	status = psy_gsequence(cb, &seqop.pst_owner, 
		&seqop.pst_seqname, (i4)PSS_SEQ_BY_OWNER, &seqinfo, NULL,
		&gseq_flags, &privs, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}

	STRUCT_ASSIGN_MACRO(seqinfo.pss_seqid, seqop.pst_seqid);
	seqop.pst_seqflag = yacc_cb->yypvt[-0].psl_inttype;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_SEQOP, (char *) &seqop,
	    sizeof(seqop), seqinfo.pss_dt, 
	    DB_PS_ENCODE_MACRO(seqinfo.pss_prec, 0), seqinfo.pss_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yyvarsp->seq_ops = TRUE;
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1630:
if (!((*yyvarspp)->bypass_actions))
/* # line 36282 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	i4		err_code;
	PST_SEQOP_NODE	seqop;
	PSS_SEQINFO	seqinfo;
	i4		privs = DB_NEXT;
	i4		seq_mask = 0;
	i4		gseq_flags;

	/* Verify it's ok to issue next/current value. */
	if (yyvarsp->in_groupby_clause || yyvarsp->inhaving || (yyvarsp->nonupdt &&
	    (yyvarsp->nonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL)) ||
	    yyvarsp->in_where_clause)
	{
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Fill in SEQOP node */
	STmove(yacc_cb->yypvt[-2].psl_strtype, ' ', sizeof(DB_NAME), (char *) &seqop.pst_seqname);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &yyvarsp->obj_spec.pss_owner);
	/* Name wasn't qualified, use session userid as default qualifier. */
	STRUCT_ASSIGN_MACRO(cb->pss_user, seqop.pst_owner);

	seq_mask = PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ;

	/* Find the sequence first. */
	status = psy_gsequence(cb, &seqop.pst_owner, 
		&seqop.pst_seqname, seq_mask, &seqinfo, NULL,
		&gseq_flags, &privs, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}

	STRUCT_ASSIGN_MACRO(seqinfo.pss_seqid, seqop.pst_seqid);
	seqop.pst_seqflag = yacc_cb->yypvt[-0].psl_inttype;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_SEQOP, (char *) &seqop,
	    sizeof(seqop), seqinfo.pss_dt, 
	    DB_PS_ENCODE_MACRO(seqinfo.pss_prec, 0), seqinfo.pss_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yyvarsp->seq_ops = TRUE;
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1631:
if (!((*yyvarspp)->bypass_actions))
/* # line 36342 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PST_SEQOP_NEXT;
    } break;

case 1632:
if (!((*yyvarspp)->bypass_actions))
/* # line 36346 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = PST_SEQOP_CURR;
    } break;

case 1633:
if (!((*yyvarspp)->bypass_actions))
/* # line 36352 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;
	}
	return(0);
}

i4
psls35iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1634:
if (!((*yyvarspp)->bypass_actions))
/* # line 36356 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1635:
if (!((*yyvarspp)->bypass_actions))
/* # line 36362 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	PST_CNST_NODE	cconst;
	DB_DATA_VALUE	db_data;
	char		buf[DB_CNTSIZE + 1];

	db_data.db_datatype = -DB_LTXT_TYPE;
	db_data.db_prec     = 0;
	db_data.db_length   = DB_CNTSIZE + 1;
	db_data.db_data	    = (PTR) buf;

	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, &db_data);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* NULL constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), -DB_LTXT_TYPE, (i2) 0, (i4) (1 + DB_CNTSIZE),
	    (DB_ANYTYPE *) db_data.db_data, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1636:
if (!((*yyvarspp)->bypass_actions))
/* # line 36397 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4             err_code, err_num = 0L;
	DB_STATUS	    status;
	i4		    rngvar_info;
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	PSS_RNGTAB	    *resrange;
	bool		    audit_err = FALSE;

	psq_cb->psq_mode = PSQ_RELOCATE;

	/* "relocate" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6206L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Look up the table to be relocated */
	if (yacc_cb->yypvt[-2].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-2].psl_objspec->pss_owner,
		&yacc_cb->yypvt[-2].psl_objspec->pss_obj_name, cb, FALSE, &resrange, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-2].psl_objspec->pss_obj_name,
		cb, FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-2].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* If table resides in multiple locations MODIFY RELOCATE
	** must be used.
	*/
	if (resrange->pss_tabdesc->tbl_status_mask & DMT_MULTIPLE_LOC)
	{
	    err_num = 6207L;
	}
	/* Don't allow relocation of views */
	else if (resrange->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	{
	    err_num = 6205L;
	}
	else if (MEcmp((PTR) &resrange->pss_ownname,
	    (PTR) &cb->pss_user, sizeof(DB_OWN_NAME)))
	{
	    err_num = 6204L;
	    audit_err = TRUE;
	}

	if (err_num != 0L)
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE && audit_err )
	    {
		/* Must audit RELOCATE failure. */
		DB_STATUS   local_status;
		DB_ERROR    e_error;

	        local_status = psy_secaudit(FALSE, cb,
	    		(char *)&resrange->pss_tabname,
			&resrange->pss_tabdesc->tbl_owner,
	    		sizeof(DB_TAB_NAME), SXF_E_TABLE,
	      		I_SX2026_TABLE_ACCESS, SXF_A_FAIL | SXF_A_RELOCATE,
	      		&e_error);
	    }

	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-2].psl_objspec, rngvar_info,
		    sizeof("RELOCATE") - 1, "RELOCATE", &psq_cb->psq_error);
	    }

	    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Allocate QEU_CB for RELOCATE and initialize its header */
	status = psl_qeucb(cb, DMU_RELOCATE_TABLE, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMU control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMU_CB),
		&dmu_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	MEfill(sizeof(DMU_CB), '\0', dmu_cb);
	qeu_cb->qeu_d_cb = dmu_cb;

	/* Fill in the DMU control block header */
	dmu_cb->type = DMU_UTILITY_CB;
	dmu_cb->length = sizeof(DMU_CB);
	dmu_cb->dmu_flags_mask = DMU_EXTTOO_MASK;
	dmu_cb->dmu_db_id = (char*) cb->pss_dbid;

	cb->pss_resrng = resrange;

	/* Put it in the control block */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid, dmu_cb->dmu_tbl_id);
	dmu_cb->dmu_nphys_parts = resrange->pss_tabdesc->tbl_nparts;

	/*
	** Allocate 1 location entry (`RELOCATE' is not supposed to handle
	** multiple locations - this is done by `MODIFY'.
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_LOC_NAME),
	    (PTR *) &dmu_cb->dmu_location.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Put the new location name in the control block */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_LOC_NAME),
	    (char *) dmu_cb->dmu_location.data_address);
	dmu_cb->dmu_location.data_in_size = sizeof(DB_LOC_NAME);

	/* Indicate no old locations. */
	dmu_cb->dmu_olocation.data_in_size = 0;

	/* Invalidate table info on RDF cache */
	{
	    RDF_CB		rdf_cb;

	    pst_rdfcb_init(&rdf_cb, cb);
	    STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid,
				rdf_cb.rdf_rb.rdr_tabid);
	    status = rdf_call(RDF_INVALIDATE, (PTR) &rdf_cb);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_rdf_error(RDF_INVALIDATE, &rdf_cb.rdf_error,
				&psq_cb->psq_error);
		return (status);
	    }
	}
    } break;

case 1637:
if (!((*yyvarspp)->bypass_actions))
/* # line 36558 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;

	psq_cb->psq_mode = PSQ_RLSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Give QEF pointer to name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;
    } break;

case 1638:
if (!((*yyvarspp)->bypass_actions))
/* # line 36577 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;
	char		       numbuf[25];

	psq_cb->psq_mode = PSQ_RLSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Give QEF pointer to name */
	CVla((i4) yacc_cb->yypvt[-0].psl_inttype, (PTR) numbuf);
	STmove(numbuf, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;
    } break;

case 1639:
if (!((*yyvarspp)->bypass_actions))
/* # line 36598 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_XA_ROLLBACK;
    } break;

case 1640:
if (!((*yyvarspp)->bypass_actions))
/* # line 36602 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB                *qef_rcb;

	psq_cb->psq_mode = PSQ_ROLLBACK;
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = (DB_SP_NAME *) NULL;
    } break;

case 1641:
if (!((*yyvarspp)->bypass_actions))
/* # line 36612 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	/* Create the QEF control block for abort */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    } break;

case 1642:
if (!((*yyvarspp)->bypass_actions))
/* # line 36640 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	i4                err_code;

	if (STcasecmp(yacc_cb->yypvt[-2].psl_strtype, "xa_xid") != 0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		(i4)STlength(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate memory for distributed transaction id */
	status = psf_malloc(cb, &cb->pss_ostream, (i4)(STlength(yacc_cb->yypvt[-0].psl_strtype) + 1),
		(PTR *) &psq_cb->psq_distranid, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	STcopy(yacc_cb->yypvt[-0].psl_strtype, psq_cb->psq_distranid);
    } break;

case 1643:
if (!((*yyvarspp)->bypass_actions))
/* # line 36673 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 1644:
if (!((*yyvarspp)->bypass_actions))
/* # line 36678 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* "register dbevent" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 1,
		(i4) sizeof("REGISTER DBEVENT") - 1, "REGISTER DBEVENT");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_EVREGISTER;

	if (yyvarsp->isdbp == FALSE)	/* Open memory stream for allocating objects */
	{
	    DB_STATUS	status;
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
				    &psq_cb->psq_error)) != E_DB_OK)
		return (status);
	}
    } break;

case 1645:
if (!((*yyvarspp)->bypass_actions))
/* # line 36702 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*evstmt;
	PST_EVENTSTMT   *ev;
	DB_STATUS	status;
	i4		ev_mask = 0;
	i4		ret_flags;
	PSS_EVINFO	ev_info;
	i4		stmt_type;
	i4		priv_to_check;
	i4		err_code;

	switch (psq_cb->psq_mode)
	{
	    case PSQ_EVREGISTER:
		stmt_type = PST_EVREG_TYPE;
		priv_to_check = (i4) DB_EVREGISTER;
		break;
	    case PSQ_EVDEREG:
		stmt_type = PST_EVDEREG_TYPE;
		priv_to_check = (i4) 0;
		break;
	    case PSQ_EVRAISE:
		stmt_type = PST_EVRAISE_TYPE;
		priv_to_check = (i4) DB_EVRAISE;
		break;
	    default:
		/* this is very bad */
		_VOID_ psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	}

	ev_mask |= ((yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_EV_BY_OWNER
	    : PSS_USREVENT | PSS_DBAEVENT | PSS_INGEVENT);

	status = psy_gevent(cb, &yacc_cb->yypvt[-0].psl_objspec->pss_owner, &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
	    (DB_TAB_ID *) NULL, ev_mask, &ev_info, &ret_flags, &priv_to_check,
	    psq_cb->psq_mode, (i4) FALSE, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (ret_flags & (PSS_MISSING_EVENT | PSS_INSUF_EV_PRIVS))
	{
	    /*
	    **    dbevent does not exist
	    ** or the current user lacks a required privilege on it
	    ** or we are reparsing a dbproc in order to determine if it is
	    **    grantable and the user does not posess a required privilege on
	    **    the dbevent WGO 
	    */
	    return(E_DB_ERROR);
	}

	/* Allocate statement node */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_STATEMENT),
			    (PTR *) &evstmt, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	MEfill(sizeof(PST_STATEMENT), (u_char) 0, (PTR) evstmt);

	evstmt->pst_type = stmt_type;
        evstmt->pst_mode = psq_cb->psq_mode;

	ev = &evstmt->pst_specific.pst_eventstmt;
	/*
	** copy alert name structure (event owner, name, and database) into the
	** statement description, plus security label.
	*/
	STRUCT_ASSIGN_MACRO(ev_info.pss_alert_name, ev->pst_event);

	/* if emitting query text, and the schema/owner name has not been
	** specified, add the event's schema name to the query
	*/
	if (   (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    && (~yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA))
	{
	    status = psl_prepend_schemaname(cb->pss_tchain, 
		yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, 
		(u_char *) ev_info.pss_alert_name.dba_owner.db_own_name,
		&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
	        return (status);
	}

	yyvarsp->tmp_stmt = evstmt;
    } break;

case 1646:
if (!((*yyvarspp)->bypass_actions))
/* # line 36793 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_STATEMENT	*evstmt;	/* DBEVENT statement */
	PST_PROCEDURE	*prnode;	/* DBP node may need to be created */
	DB_STATUS	status;

	evstmt = yyvarsp->tmp_stmt;	/* Was set by event_name production */
	yyvarsp->tmp_stmt = NULL;	/* Reset for safety */
	if (yyvarsp->isdbp)		/* Return statement to be patched in DBP */
	{
	    yacc_cb->yyval.psl_stmt = evstmt;
	}
	else			/* Not a DBP */
	{
           /* Create procedure (for OPC) and attach the DBEVENT statement */
            status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_PROCEDURE),
                                (PTR *)&prnode, &psq_cb->psq_error);
            if (status != E_DB_OK)
                return (status);
            prnode->pst_mode = 0;
            prnode->pst_vsn = PST_CUR_VSN;
            prnode->pst_isdbp = FALSE;
	    prnode->pst_flags = 0;
            prnode->pst_stmts = evstmt;
            prnode->pst_parms = (PST_DECVAR *)NULL;
            MEfill(sizeof(prnode->pst_dbpid), (u_char)0,
                   (PTR)&prnode->pst_dbpid);
            status = psf_mroot(cb, &cb->pss_ostream, (PTR)prnode,
                               &psq_cb->psq_error);
            if (status != E_DB_OK)
                return (status);
            yacc_cb->yyval.psl_stmt = NULL;          /* Unused outside of DBP */
        } 
    } break;

case 1647:
if (!((*yyvarspp)->bypass_actions))
/* # line 36839 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 1648:
if (!((*yyvarspp)->bypass_actions))
/* # line 36844 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* "remove dbevent" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("REMOVE DBEVENT") - 1, "REMOVE DBEVENT");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_EVDEREG;

	if (yyvarsp->isdbp == FALSE)	/* Open memory stream for allocating objects */
	{
	    DB_STATUS	status;
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
				    &psq_cb->psq_error)) != E_DB_OK)
		return (status);
	}
    } break;

case 1649:
if (!((*yyvarspp)->bypass_actions))
/* # line 36880 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_stmt = yacc_cb->yypvt[-0].psl_stmt;
    } break;

case 1650:
if (!((*yyvarspp)->bypass_actions))
/* # line 36885 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* "raise dbevent" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("RAISE DBEVENT") - 1, "RAISE DBEVENT");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_EVRAISE;

	if (yyvarsp->isdbp == FALSE)	/* Open memory stream for allocating objects */
	{
	    DB_STATUS	status;
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
				    &psq_cb->psq_error)) != E_DB_OK)
		return (status);
	}
    } break;

case 1651:
if (!((*yyvarspp)->bypass_actions))
/* # line 36909 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Ytmp_stmt was set by event_name production */
	yyvarsp->tmp_stmt->pst_specific.pst_eventstmt.pst_evvalue = yacc_cb->yypvt[-1].psl_trtype;
	yyvarsp->tmp_stmt->pst_specific.pst_eventstmt.pst_evflags |= yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1652:
if (!((*yyvarspp)->bypass_actions))
/* # line 36915 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_trtype = NULL;
    } break;

case 1653:
if (!((*yyvarspp)->bypass_actions))
/* # line 36919 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_CNST_NODE	constnd;
	PST_QNODE	*newnode;
	DB_PARM_NAME	varname;
	PSS_DECVAR 	*var;
	DB_DT_ID	dtype;
	bool		found = FALSE;
	i4		err_code;

	if (yyvarsp->isdbp == FALSE)
	{
	    _VOID_ psf_error(E_PS0D36_EVENT_TEXT_QUOTE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Find local var/parm by the specified name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, varname.db_parm_name);

	for (var = (PSS_DECVAR *)yyvarsp->dbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *)&yyvarsp->dbpinfo->pss_varq;
	     var = (PSS_DECVAR *)var->pss_queue.q_next)
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR)&varname, (PTR)&var->pss_varname,
		sizeof(var->pss_varname)) == 0)
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)	/* Unknown local var/parm specified */
	{
	    _VOID_ psf_error(2403L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Type of var must be non-nullable string */
	if (   ((dtype = var->pss_dbdata.db_datatype) < 0)
	    || (dtype != DB_CHR_TYPE && dtype != DB_TXT_TYPE &&
		dtype != DB_CHA_TYPE && dtype != DB_VCH_TYPE && 
	        dtype != DB_NCHR_TYPE && dtype != DB_NVCHR_TYPE)
	   )
	{
	    _VOID_ psf_error(E_PS0D37_EVENT_TEXT_TYPE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	/* Parm or local variable */
	constnd.pst_tparmtype = PST_LOCALVARNO;
	constnd.pst_parm_no = var->pss_no;
	constnd.pst_pmspec  = PST_PMNOTUSED;
	constnd.pst_cqlang = DB_SQL;
	constnd.pst_origtxt = NULL;
	status = pst_node(cb, &cb->pss_ostream,
			  (PST_QNODE *)NULL, (PST_QNODE *)NULL, PST_CONST,
			  (char *)&constnd, sizeof(constnd),
			  var->pss_dbdata.db_datatype,
			  (i2)var->pss_dbdata.db_prec, 
			  (i4)var->pss_dbdata.db_length, 
			  (DB_ANYTYPE *)var->pss_dbdata.db_data,
			  &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1654:
if (!((*yyvarspp)->bypass_actions))
/* # line 36993 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS       status;
	PST_CNST_NODE	constnd;
	PST_QNODE	*newnode;

	constnd.pst_tparmtype = PST_USER;
	constnd.pst_parm_no = 0;
	constnd.pst_pmspec  = PST_PMNOTUSED;
	constnd.pst_cqlang = DB_SQL;
	constnd.pst_origtxt = NULL;
	status = pst_node(cb, &cb->pss_ostream,
			  (PST_QNODE *)NULL, (PST_QNODE *)NULL, PST_CONST,
			  (char *)&constnd, sizeof(constnd),
			  DB_VCH_TYPE, (i2)0, (i4)(yacc_cb->yypvt[-0].psl_textype->db_t_count + DB_CNTSIZE),
			  (DB_ANYTYPE *)yacc_cb->yypvt[-0].psl_textype, &newnode, &psq_cb->psq_error,
			  (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	yacc_cb->yyval.psl_trtype = newnode;
    } break;

case 1655:
if (!((*yyvarspp)->bypass_actions))
/* # line 37015 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = 0;
    } break;

case 1656:
if (!((*yyvarspp)->bypass_actions))
/* # line 37019 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;

	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "noshare") == 0)
	{
	    yacc_cb->yyval.psl_inttype = PST_EVNOSHARE;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "share") == 0)
	{
	    yacc_cb->yyval.psl_inttype = 0;
	}
	else
	{
	    _VOID_ psf_error(E_PS0D38_EVENT_WITH, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 1657:
if (!((*yyvarspp)->bypass_actions))
/* # line 37041 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	i4			rngvar_info;
	PSS_RNGTAB		*rngvar;
	i4			err_code, err_num = 0L;
	i4			mask;
	i4			mask2;
	char			*duve_prefix;
	i4			duve_len;

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
		&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, TRUE, &rngvar, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name,
		cb, TRUE, &rngvar, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* User may issue SAVE only against his/her tables */
	if (MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_user,
		       sizeof(DB_OWN_NAME)))
	{
	    err_num = E_PS0424_ILLEGAL_TBL_REF;
	}
	else
	{
	    mask = rngvar->pss_tabdesc->tbl_status_mask;
	    mask2 = rngvar->pss_tabdesc->tbl_2_status_mask;

	    /* 
	    ** May not run SAVE against catalogs but allow for
	    ** special tables created by VERIFYDB since they aren't
	    ** really catalogs anyway.
	    */
	    duve_prefix = "iiqeflist";
	    duve_len = sizeof("iiqeflist") - 1;

	    if ((mask & DMT_CATALOG) && 
		(MEcmp(duve_prefix, (PTR)&rngvar->pss_tabname, duve_len)))
	    {
		err_num = 2126L;
	    }
	    /* SAVE may only be run against base tables */
	    else if (mask & DMT_VIEW
		     || mask & DMT_IDX
		     || mask2 & DMT_TEXTENSION)
	    {
		err_num = 2127L;
	    }
	}

	if (err_num != 0L)
	{
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, rngvar, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
		    sizeof("SAVE") - 1, "SAVE", &psq_cb->psq_error);
	    }

	    if (err_num == E_PS0424_ILLEGAL_TBL_REF)
	    {
		/*
		** Audit failure to save table.
		*/
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_ERROR	e_error;

		    (VOID) psy_secaudit(FALSE, cb, (char *) &rngvar->pss_tabname,
			(DB_OWN_NAME *)&rngvar->pss_ownname,
			sizeof(rngvar->pss_tabname),SXF_E_TABLE, 
			I_SX2719_TABLE_SAVE, SXF_A_FAIL | SXF_A_CONTROL,
			&e_error);
		}

		(VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 3,
		    sizeof("SAVE") - 1, "SAVE",
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &rngvar->pss_tabname),
		    &rngvar->pss_tabname,
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &rngvar->pss_ownname),
		    &rngvar->pss_ownname);
	    }
	    else
	    {
		(VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &rngvar->pss_tabname),
		    &rngvar->pss_tabname);
	    }

	    return (E_DB_ERROR);    /* non-zero return means error */
	}	    
	else
	{
	    RDF_CB		rdf_cb;
	    STRUCT_ASSIGN_MACRO(rngvar->pss_tabid,
		    ((DMT_CB *) ((QEU_CB *) cb->pss_object)->qeu_d_cb)->dmt_id);
	    /* invalidate RDF's cache */

	    pst_rdfcb_init(&rdf_cb, cb);
	    STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, rdf_cb.rdf_rb.rdr_tabid);

	    status = rdf_call(RDF_INVALIDATE, (PTR) &rdf_cb);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_rdf_error(RDF_INVALIDATE, &rdf_cb.rdf_error,
				&psq_cb->psq_error);
		return (status);
	    }
	}
    } break;

case 1660:
if (!((*yyvarspp)->bypass_actions))
/* # line 37186 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	QEU_CB		       *qeu_cb;
	DMT_CB		       *dmt_cb;
	DB_STATUS	       status;
	DMT_CHAR_ENTRY	       *chr;

	psq_cb->psq_mode = PSQ_SAVE;

	/* "save" is not allowed in distributed */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5605L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate QEU_CB for SAVE and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the save date */

	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id	= DMT_C_SAVEDATE;
	chr->char_value = 0;

    } break;

case 1661:
if (!((*yyvarspp)->bypass_actions))
/* # line 37240 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		       err_code;
	register i4	       i;
	register i4       date;
	i4		       value;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	QEU_CB		       *qeu_cb;
	DMT_CB		       *dmt_cb;
	DMT_CHAR_ENTRY	       *chr;

	/* Check out the year */
	if (yacc_cb->yypvt[-0].psl_inttype < 1970 || yacc_cb->yypvt[-0].psl_inttype > 2035)
	{
	    (VOID) psf_error(5603L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof(yacc_cb->yypvt[-0].psl_inttype), &(yacc_cb->yypvt[-0].psl_inttype));
	    return (E_DB_ERROR);
	}

	/* Check out the day */
	if (yacc_cb->yypvt[-1].psl_inttype < 1 || psq_monsize((i4) yacc_cb->yypvt[-2].psl_inttype, (i4) yacc_cb->yypvt[-0].psl_inttype) < yacc_cb->yypvt[-1].psl_inttype)
	{
	    (VOID) psf_error(5602L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof(yacc_cb->yypvt[-1].psl_inttype), &(yacc_cb->yypvt[-1].psl_inttype));
	    return (E_DB_ERROR);
	}

	/* Convert date */

	/* "date" will be number of days from 1970 for a while */
	date = 0;

	/* Do year conversion */
	date += (yacc_cb->yypvt[-0].psl_inttype - 1970) * 365;
	if (yacc_cb->yypvt[-0].psl_inttype > 1970)
	    date += (yacc_cb->yypvt[-0].psl_inttype - 1973) / 4 + 1;	    /* Add one day for each leap year */

	/* Do month conversion */
	for (i = 1; i < yacc_cb->yypvt[-2].psl_inttype; i++)
	    date += psq_monsize((i4)i, (i4)yacc_cb->yypvt[-0].psl_inttype);

	/* Do date conversion */
	date += yacc_cb->yypvt[-1].psl_inttype - 1;

	/* Convert the date to be the number of hours since 1970 */
	date *= 24;

	/* Convert to minutes */
	date *= 60;

	/* Convert to seconds */
	date *= 60;

	/* Adjust to GMT */

    	if( date > MAXI4)
    	    value = MAXI4;
    	else
    	    value = date;
    
    	date -=	TMtz_search(adf_scb->adf_tzcb, TM_TIMETYPE_LOCAL,
    	    	    	    value);

	/* Store number of seconds in control block */
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmt_cb = (DMT_CB *) qeu_cb->qeu_d_cb;
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_value = date;
    } break;

case 1662:
if (!((*yyvarspp)->bypass_actions))
/* # line 37311 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	i4		       monthno;
	
	/* Translate month name to month number */
	status = psq_month(yacc_cb->yypvt[-0].psl_strtype, &monthno, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	yacc_cb->yyval.psl_inttype = monthno;
    } break;

case 1663:
if (!((*yyvarspp)->bypass_actions))
/* # line 37324 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	char                   numbuf[25];
	i4		       err_code;

	if (yacc_cb->yypvt[-0].psl_inttype < 0 || yacc_cb->yypvt[-0].psl_inttype > 12)
	{
	    CVla((i4)yacc_cb->yypvt[-0].psl_inttype, numbuf);
	    (VOID) psf_error(5601L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite(numbuf), numbuf);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1665:
if (!((*yyvarspp)->bypass_actions))
/* # line 37344 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_SVEPOINT;

	/* Allocate QEF control block for savepoint */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_modifier = QEF_MSTRAN;
	qef_rcb->qef_flag   = DB_SQL;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_db_id  = cb->pss_dbid;

	/* Allocate the savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_SP_NAME),
	    (PTR *) &qef_rcb->qef_spoint, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 1666:
if (!((*yyvarspp)->bypass_actions))
/* # line 37383 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		       *qef_rcb;

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;

	/* Fill in the savepoint name */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_SP_NAME), (char *) qef_rcb->qef_spoint);

    } break;
	}
	return(0);
}

i4
psls36iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1667:
if (!((*yyvarspp)->bypass_actions))
/* # line 37394 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEF_RCB		       *qef_rcb;
	char		       numbuf[25];

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;

	/* Fill in the savepoint name */
	CVla((i4) yacc_cb->yypvt[-0].psl_inttype, numbuf);
	STmove(numbuf, ' ', sizeof(DB_SP_NAME), (char *) qef_rcb->qef_spoint);
    } break;

case 1668:
if (!((*yyvarspp)->bypass_actions))
/* # line 37408 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* "set aggregate [no]project" is no longer supported */
	    (VOID) psf_error(5979L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	}
    } break;

case 1669:
if (!((*yyvarspp)->bypass_actions))
/* # line 37423 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	/* Allocate QEF control block for autocommit */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_auto = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1670:
if (!((*yyvarspp)->bypass_actions))
/* # line 37452 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_AUTOCOMMIT;
    } break;

case 1671:
if (!((*yyvarspp)->bypass_actions))
/* # line 37458 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Freeze semaphore while we mess with PSF server control block. */

	CSp_semaphore(1, &Psf_srvblk->psf_sem); /* exclusive */
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	{
	    Psf_srvblk->psf_flags |= PSF_CACHEDYN;
	    psq_cb->psq_mode = PSQ_SCACHEDYN;
	}
	else 
	{
	    Psf_srvblk->psf_flags &= ~PSF_CACHEDYN;
	    psq_cb->psq_mode = PSQ_SNOCACHEDYN;
	}
	CSv_semaphore(&Psf_srvblk->psf_sem);

    } break;

case 1672:
if (!((*yyvarspp)->bypass_actions))
/* # line 37478 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SCPUFACT;

	/* "set cpufactor" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5945L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Create control block for setting cpu factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_alter = OPF_CPUFACTOR;
	opf_cb->opf_value = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1673:
if (!((*yyvarspp)->bypass_actions))
/* # line 37519 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4         err_code;
	i4	   date_fmt;

	psq_cb->psq_mode = PSQ_SDATEFMT;

	/*
	** Possible formats determined in adu (kibro01) b119318
	*/
	date_fmt = adu_date_format((char*)yacc_cb->yypvt[-0].psl_strtype);
	if (date_fmt == -1)
	{
	    (VOID) psf_error(5934L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite((char *) yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	psq_cb->psq_dtefmt = date_fmt;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    DB_STATUS       status;
	    char            buf[sizeof("set date_format 'multinational4'")];

	    STprintf(buf, "set date_format '%s' ", yacc_cb->yypvt[-0].psl_strtype);

	    status = psl_send_setqry(cb, buf, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    } break;

case 1674:
if (!((*yyvarspp)->bypass_actions))
/* # line 37552 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	QEF_RCB		*qef_rcb;

	/* Allocate QEF control block for autocommit */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_r3_ddb_req.qer_d12_ddl_concur_on_b = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1675:
if (!((*yyvarspp)->bypass_actions))
/* # line 37581 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;

	/* "set ddl_concurrency" is allowed only in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, sizeof("SET DDL_CONCURRENCY")-1,
			"SET DDL_CONCURRENCY");
	    return (E_DB_ERROR);

	}
	else
	{
	    psq_cb->psq_mode = PSQ_DDLCONCUR;
	}
    } break;

case 1676:
if (!((*yyvarspp)->bypass_actions))
/* # line 37601 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = QEF_ON;
    } break;

case 1677:
if (!((*yyvarspp)->bypass_actions))
/* # line 37605 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "off") == 0)
	    yacc_cb->yyval.psl_inttype = QEF_OFF;
	else  /* syntax error */
	{
	    err_code = (psq_cb->psq_mode == PSQ_DDLCONCUR) ? 5985L : 5983L;

	    (VOID) psf_error(err_code, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */

	}
    } break;

case 1678:
if (!((*yyvarspp)->bypass_actions))
/* # line 37623 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	char		*str;

	psq_cb->psq_mode = PSQ_SDECIMAL;

	/* Period and comma are only allowable decimal markers */
	if (!STcompare((char *) yacc_cb->yypvt[-0].psl_strtype, ","))
	{
	    str = "set decimal ',' ";
	}
	else if (!STcompare((char *) yacc_cb->yypvt[-0].psl_strtype, "."))
	{
	    str = "set decimal '.' ";
	}
	else
	{
	    (VOID) psf_error(5936L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 1,
		(i4) STtrmwhite((char *) yacc_cb->yypvt[-0].psl_strtype), (char *) yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Give new decimal character back to caller */
	psq_cb->psq_decimal.db_decspec = TRUE;
	psq_cb->psq_decimal.db_decimal = *((char *) yacc_cb->yypvt[-0].psl_strtype);

	/* Change decimal character in session control block */
	cb->pss_decimal = *((char *) yacc_cb->yypvt[-0].psl_strtype);

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    DB_STATUS       status;

	    status = psl_send_setqry(cb, str, psq_cb);

	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    } break;

case 1679:
if (!((*yyvarspp)->bypass_actions))
/* # line 37666 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    ret_val;
	DB_DEBUG_CB	    *debug_cb;

	/* "set [no]io_trace" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4		err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]IO_TRACE")-1, "SET [NO]IO_TRACE");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_trace_point = DM_IOTRACE;
	debug_cb->db_value_count = 0;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;
    } break;

case 1680:
if (!((*yyvarspp)->bypass_actions))
/* # line 37705 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* Set [no]joinop no longer supported */
	    (VOID) psf_error(5933L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	}
    } break;

case 1681:
if (!((*yyvarspp)->bypass_actions))
/* # line 37720 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	psq_cb->psq_mode = PSQ_ALLJOURNAL;

	/* "set journaling" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5951L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    cb->pss_ses_flag |= PSS_JOURNALING;     /* pss_journaling=TRUE */
	else
	    cb->pss_ses_flag &= ~PSS_JOURNALING;    /*pss_journaling = FALSE */
    } break;

case 1682:
if (!((*yyvarspp)->bypass_actions))
/* # line 37739 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_SJOURNAL;
    } break;

case 1683:
if (!((*yyvarspp)->bypass_actions))
/* # line 37743 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4             err_code, err_num = 0L;
	DB_STATUS	    status;
	i4		    rngvar_info;
	QEU_CB		    *qeu_cb;
	DMT_CB		    *dmt_cb;
	PSS_RNGTAB	    *rngvar;
	DMT_CHAR_ENTRY	    *chr;

	/* "set journaling" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5951L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
		&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, FALSE, &rngvar, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb,
		FALSE, &rngvar, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (	(rngvar->pss_tabdesc->tbl_status_mask &
	    	    (DMT_CATALOG|DMT_EXTENDED_CAT))
	    ||  (rngvar->pss_tabdesc->tbl_2_status_mask & DMT_TEXTENSION))
	{
	    /* Disallow SET JOURNALING on catalogs. */
	    err_num = 2762L;
	}
	else if (MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_user,
	               sizeof(DB_OWN_NAME)))
	{
	    /* disallow SET [NO]JOURNALING on someone else's tables */
	    err_num = 2753L;
	}
	else if (rngvar->pss_tabdesc->tbl_status_mask & DMT_IDX)
	{
	    /* Disallow SET JOURNALING on indices */
	    err_num = 2766L;
	}
	else
	{
	    i4		ref_cons_exists = FALSE;

	    /* 
	    ** one may not alter journaling status of a table involved in a
	    ** REFERENCES constraint
	    */
	    status = psl_find_cons(cb, rngvar, psl_qual_ref_cons, (PTR *) NULL,
		(DB_INTEGRITY *) NULL, &ref_cons_exists, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	
	    if (!ref_cons_exists)
	    {
		/*
		** table is not a REFERENCES constraint dependent object
		** need to check if table is a REFERENCES constraint
		** independent object
		*/
		status = psl_find_iobj_cons(cb, rngvar, &ref_cons_exists,
			   &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }

	    if (ref_cons_exists)
		err_num = E_PS04B1_SET_JOUR_ON_REF_TBL;
	}

	if (err_num != 0L)
	{
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, rngvar, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
		    sizeof("SET JOURNALING") - 1, "SET JOURNALING",
		    &psq_cb->psq_error);
	    }

	    if (err_num == 2753L)
	    {
		(VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2,
		    sizeof("SET [NO]JOURNALING") - 1, "SET [NO]JOURNALING",
		    psf_trmwhite(sizeof(rngvar->pss_tabname),
				 (char *) &rngvar->pss_tabname),
		    (char *) &rngvar->pss_tabname);
	    }
	    else if (err_num == E_PS04B1_SET_JOUR_ON_REF_TBL)
	    {
		(VOID) psf_error(E_PS04B1_SET_JOUR_ON_REF_TBL, 0L, PSF_USERERR, 
		    &err_code, &psq_cb->psq_error, 2,
		    psf_trmwhite(sizeof(rngvar->pss_tabname),
			(char *) &rngvar->pss_tabname),
		    (PTR) &rngvar->pss_tabname,
		    psf_trmwhite(sizeof(rngvar->pss_ownname),
			(char *) &rngvar->pss_ownname),
		    (PTR) &rngvar->pss_ownname);
	    }
	    else
	    {
		(VOID) psf_error(err_num, 0L, PSF_USERERR,&err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(rngvar->pss_tabname),
				 (char *) &rngvar->pss_tabname),
		    (char *) &rngvar->pss_tabname);
	    }

	    return (E_DB_ERROR);
	}

	/* Allocate QEU_CB for SET JOURNALING and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the journaled bit */
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id = DMT_C_JOURNALED;
	chr->char_value = (yacc_cb->yypvt[-3].psl_tytype == PSL_ONSET) ? DMT_C_ON : DMT_C_OFF;

	STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, dmt_cb->dmt_id);

	/* invalidate RDF's cache */
	{
	    RDF_CB              rdf_cb;

	    pst_rdfcb_init(&rdf_cb, cb);
	    STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, rdf_cb.rdf_rb.rdr_tabid);
	    status = rdf_call(RDF_INVALIDATE, (PTR) &rdf_cb);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_rdf_error(RDF_INVALIDATE, &rdf_cb.rdf_error,
					&psq_cb->psq_error);
		return (status);
	    }
	}
    } break;

case 1684:
if (!((*yyvarspp)->bypass_actions))
/* # line 37930 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;
	i4			flag;

	psq_cb->psq_mode = PSQ_JTIMEOUT;

	if (STcompare(yacc_cb->yypvt[-1].psl_strtype, "timeout") == 0)
	    flag = OPF_TIMEOUT;
	else if (STcompare(yacc_cb->yypvt[-1].psl_strtype, "timeoutabort") == 0)
	    flag = OPF_TIMEOUTABORT;
	else if (STcompare(yacc_cb->yypvt[-1].psl_strtype, "notimeout") == 0)
	    flag = OPF_NOTIMEOUT;
	else if ((STcompare(yacc_cb->yypvt[-1].psl_strtype, "newenum") == 0 ||
		STcompare(yacc_cb->yypvt[-1].psl_strtype, "greedy") == 0) && yacc_cb->yypvt[-0].psl_inttype == 0)
	    flag = OPF_NEWENUM;
	else if ((STcompare(yacc_cb->yypvt[-1].psl_strtype, "nonewenum") == 0 ||
		STcompare(yacc_cb->yypvt[-1].psl_strtype, "nogreedy") == 0) && yacc_cb->yypvt[-0].psl_inttype == 0)
	    flag = OPF_NONEWENUM;
	else
	{
	    i4	    err_code;

	    /* set joinop [no]timeout syntax error */
	    (VOID) psf_error(2582L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
		(i4) STlength(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
	    return (E_DB_ERROR);
	}
	if (flag == OPF_TIMEOUTABORT)
	{
            status = psy_ckdbpr(psq_cb, (u_i4)DBPR_TIMEOUT_ABORT);
            if (status)
            {
		i4         err_code;
                /*
                ** Audit failure to set TIMEOUTABORT 
                */
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_ERROR        e_error;
		    DB_STATUS       local_status;
		    local_status = psy_secaudit(FALSE, cb,
			     "TIMEOUT_ABORT", &cb->pss_user,
			     sizeof(DB_TAB_NAME), SXF_E_RESOURCE,
			     I_SX2754_SET_TIMEOUTABORT, SXF_A_FAIL,
			     &e_error);
		}

                (VOID) psf_error(9353L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
                return(status);
            }
       	}

	/* Create control block for setting cpu factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_alter = flag;
	opf_cb->opf_value = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1685:
if (!((*yyvarspp)->bypass_actions))
/* # line 38011 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;

case 1686:
if (!((*yyvarspp)->bypass_actions))
/* # line 38014 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = 0;
    } break;

case 1687:
if (!((*yyvarspp)->bypass_actions))
/* # line 38020 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_lm5_setlockmode_distr(cb, yyvarsp->scanbuf_ptr, &yyvarsp->xlated_qry,
			psq_cb);

	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    } break;

case 1688:
if (!((*yyvarspp)->bypass_actions))
/* # line 38035 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_lm1_setlockstmnt(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 1689:
if (!((*yyvarspp)->bypass_actions))
/* # line 38048 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DMC_CB			*dmc_cb;

	dmc_cb	= (DMC_CB *) cb->pss_object;
	dmc_cb->dmc_sl_scope = DMC_SL_SESSION;

	/* there is special distributed handling for SET LOCKMODE SESSION */
	cb->pss_stmt_flags |= PSS_SET_LOCKMODE_SESS; 

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    DB_STATUS		status;

	    status = psl_lm6_setlockscope_distr(cb, (PSS_RNGTAB *)NULL,
				&yyvarsp->xlated_qry, &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	/* keep track of text of set lockmode stmnt for QEF */
	yyvarsp->scanbuf_ptr = (PTR) cb->pss_nxtchar;
    } break;

case 1690:
if (!((*yyvarspp)->bypass_actions))
/* # line 38071 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	i4			rngvar_info;
	DMC_CB			*dmc_cb;
	PSS_RNGTAB	       *rngvar;

	dmc_cb	= (DMC_CB*) cb->pss_object;
	dmc_cb->dmc_sl_scope = DMC_SL_TABLE;

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
			&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, FALSE, &rngvar,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb,
		FALSE, &rngvar, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, dmc_cb->dmc_table_id);
	}
	else
	{
	    status = psl_lm6_setlockscope_distr(cb, rngvar, &yyvarsp->xlated_qry,
	    			&psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
		return(status);

	    /* keep track of text of set lockmode stmnt for QEF (distr) */
	    if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
		yyvarsp->scanbuf_ptr = (PTR) cb->pss_nxtchar;
	    else
		yyvarsp->scanbuf_ptr = (PTR) cb->pss_prvtok;
	}
    } break;

case 1693:
if (!((*yyvarspp)->bypass_actions))
/* # line 38131 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name(yacc_cb->yypvt[-2].psl_tytype, yacc_cb->yypvt[-0].psl_strtype, cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 1694:
if (!((*yyvarspp)->bypass_actions))
/* # line 38142 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name(yacc_cb->yypvt[-2].psl_tytype, "row", cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 1695:
if (!((*yyvarspp)->bypass_actions))
/* # line 38153 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name(yacc_cb->yypvt[-2].psl_tytype, "table", cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 1696:
if (!((*yyvarspp)->bypass_actions))
/* # line 38164 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name(yacc_cb->yypvt[-2].psl_tytype, "session", cb,
	    &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 1697:
if (!((*yyvarspp)->bypass_actions))
/* # line 38176 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_lm4_setlockparm_num(yacc_cb->yypvt[-2].psl_tytype, yacc_cb->yypvt[-0].psl_inttype, cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 1698:
if (!((*yyvarspp)->bypass_actions))
/* # line 38189 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4			lockkey_type;
	DB_STATUS		status;

	status = psl_lm2_setlockkey(cb, yacc_cb->yypvt[-0].psl_strtype, &lockkey_type, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	else
	{
	    yacc_cb->yyval.psl_tytype = lockkey_type;
	}
    } break;
	}
	return(0);
}

i4
psls37iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1699:
if (!((*yyvarspp)->bypass_actions))
/* # line 38206 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        i4                      lockkey_type;
        DB_STATUS               status;
 
        status = psl_lm2_setlockkey(cb, "level", &lockkey_type,
                                    &psq_cb->psq_error);
 
        if (DB_FAILURE_MACRO(status))
        {
            return(status);
        }
        else
        {
            yacc_cb->yyval.psl_tytype = lockkey_type;
        }
    } break;

case 1700:
if (!((*yyvarspp)->bypass_actions))
/* # line 38225 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS               status;
 
        status = psl_st0_settransaction(cb, psq_cb);
        if (DB_FAILURE_MACRO(status))
            return(status);
    } break;

case 1701:
if (!((*yyvarspp)->bypass_actions))
/* # line 38234 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS               status;
 
        status = psl_st1_settranstmnt(cb, psq_cb);
        if (DB_FAILURE_MACRO(status))
            return(status);
    } break;

case 1706:
if (!((*yyvarspp)->bypass_actions))
/* # line 38252 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS               status;
 
        status = psl_st2_settranisolation_level(cb, &psq_cb->psq_error, 
		(i4)yacc_cb->yypvt[-0].psl_inttype);
        if (DB_FAILURE_MACRO(status))
            return(status);
    } break;

case 1707:
if (!((*yyvarspp)->bypass_actions))
/* # line 38263 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = (i4)DMC_C_READ_COMMITTED;
    } break;

case 1708:
if (!((*yyvarspp)->bypass_actions))
/* # line 38267 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = (i4)DMC_C_READ_UNCOMMITTED;
    } break;

case 1709:
if (!((*yyvarspp)->bypass_actions))
/* # line 38271 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = (i4)DMC_C_REPEATABLE_READ;
    } break;

case 1710:
if (!((*yyvarspp)->bypass_actions))
/* # line 38275 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = (i4)DMC_C_SERIALIZABLE;
    } break;

case 1711:
if (!((*yyvarspp)->bypass_actions))
/* # line 38281 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS               status;
 
        status = psl_st3_accessmode(cb, &psq_cb->psq_error, yacc_cb->yypvt[-0].psl_inttype);
        if (DB_FAILURE_MACRO(status))
            return(status);
    } break;

case 1712:
if (!((*yyvarspp)->bypass_actions))
/* # line 38291 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = (i4)DMC_C_READ_ONLY;
    } break;

case 1713:
if (!((*yyvarspp)->bypass_actions))
/* # line 38295 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = (i4)DMC_C_READ_WRITE; 
    } break;

case 1714:
if (!((*yyvarspp)->bypass_actions))
/* # line 38301 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    ret_val;
	DB_DEBUG_CB	    *debug_cb;

	/* "set [no]lock_trace" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]LOCK_TRACE")-1, "SET [NO]LOCK_TRACE");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_trace_point = DM_LOCKTRACE;
	debug_cb->db_value_count = 0;
	debug_cb->db_trswitch = (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET) ? DB_TR_ON : DB_TR_OFF;
    } break;

case 1715:
if (!((*yyvarspp)->bypass_actions))
/* # line 38353 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    status;
	DMC_CB		    *dmc_cb;
	DMC_CHAR_ENTRY	    *dmc_char;
	i4		    err_code;

	/* "set [no]logging" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]LOGGING") - 1, "SET [NO]LOGGING");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_SLOGGING;

	/*
	** Check for priviledge to turn off logging.
	** User must be the DBA to enable or disable logging.
	*/
	if (MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
	      sizeof(DB_OWN_NAME)) != 0)
	{
	    _VOID_ psf_error(E_PS0F81_SETLG_PRIV_ERR, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** Create control block for DMC_ALTER call for Set [No]Logging
	*/
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CB), (PTR *) &dmc_cb,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) dmc_cb, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** Format Alter Control Block.
	*/
	cb->pss_object	    = (PTR) dmc_cb;
	dmc_cb->type	    = DMC_CONTROL_CB;
	dmc_cb->length	    = sizeof (DMC_CB);
	dmc_cb->dmc_op_type = DMC_SESSION_OP;
	dmc_cb->dmc_session_id	= (PTR)cb->pss_sessid;
	dmc_cb->dmc_db_id   = cb->pss_dbid;
	dmc_cb->dmc_flags_mask = 0;

	/*
	** Allocate characteristics array with entry for Set Logging.
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CHAR_ENTRY),
	     (PTR *) &dmc_char, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	dmc_cb->dmc_char_array.data_in_size = sizeof(DMC_CHAR_ENTRY);
	dmc_cb->dmc_char_array.data_address = (char *) dmc_char;
	dmc_char->char_id = DMC_C_LOGGING;
	dmc_char->char_value = ((yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET) ? DMC_C_ON: DMC_C_OFF);
    } break;

case 1716:
if (!((*yyvarspp)->bypass_actions))
/* # line 38425 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	    ret_val;
	DB_DEBUG_CB	    *debug_cb;

	/* "set [no]log_trace" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]LOG_TRACE") - 1, "SET [NO]LOG_TRACE");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_trace_point = DM_LOGTRACE;
	debug_cb->db_value_count = 0;
	debug_cb->db_trswitch = (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET) ? DB_TR_ON : DB_TR_OFF;
    } break;

case 1717:
if (!((*yyvarspp)->bypass_actions))
/* # line 38461 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	psq_cb->psq_mode = PSQ_SMNFMT;

	/* First character of parameter must specify leading or trailing */
	if (((char *) yacc_cb->yypvt[-0].psl_strtype)[0] == 't' || ((char *) yacc_cb->yypvt[-0].psl_strtype)[0] == 'T')
	{
	    /* Give trailing indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_TRAIL_MONY;
	}
	else if (((char *) yacc_cb->yypvt[-0].psl_strtype)[0] == 'l' || ((char *) yacc_cb->yypvt[-0].psl_strtype)[0] == 'L')
	{
	    /* Give leading indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_LEAD_MONY;
	}
	else if ( (((char *) yacc_cb->yypvt[-0].psl_strtype)[0] == 'n' || ((char *) yacc_cb->yypvt[-0].psl_strtype)[0] == 'N') &&
	          (((char *) yacc_cb->yypvt[-0].psl_strtype)[1] == 'o' || ((char *) yacc_cb->yypvt[-0].psl_strtype)[1] == 'O') &&
	          (((char *) yacc_cb->yypvt[-0].psl_strtype)[2] == 'n' || ((char *) yacc_cb->yypvt[-0].psl_strtype)[2] == 'N') &&
	          (((char *) yacc_cb->yypvt[-0].psl_strtype)[3] == 'e' || ((char *) yacc_cb->yypvt[-0].psl_strtype)[3] == 'E') )
	{
	    /* Give leading indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_NONE_MONY;
	    psq_cb->psq_mnyfmt.db_mny_sym[0] = EOS;
	}
	else
	{
	    (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite((char *) yacc_cb->yypvt[-0].psl_strtype), (char *) yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

 	if ( (psq_cb->psq_mnyfmt.db_mny_lort == DB_LEAD_MONY) ||
 	     (psq_cb->psq_mnyfmt.db_mny_lort == DB_TRAIL_MONY) )
	{
 	    /* Second character of parameter must be a colon */
	    if (((char *) yacc_cb->yypvt[-0].psl_strtype)[1] != ':')
	    {
	        (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, STtrmwhite((char *) yacc_cb->yypvt[-0].psl_strtype), (char *) yacc_cb->yypvt[-0].psl_strtype);
	        return (E_DB_ERROR);    /* non-zero return means error */
	    }

	    /* Next 0 - 4 characters is the currency symbol */
	    if (STlength(&((char *) yacc_cb->yypvt[-0].psl_strtype)[2]) > DB_MAXMONY)
	    {
	        (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
	          	&psq_cb->psq_error, 1, STtrmwhite((char *) yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	        return (E_DB_ERROR);
	    }

	    /* Give money symbol back to caller */
	    STcopy(&((char *) yacc_cb->yypvt[-0].psl_strtype)[2], psq_cb->psq_mnyfmt.db_mny_sym);
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    char	str[sizeof("set money_format '' ") + 2 + DB_MAXMONY];
	    DB_STATUS	status;

	    status = psl_send_setqry(cb,
			STpolycat(3, "set money_format '", yacc_cb->yypvt[-0].psl_strtype, "' ", str),
			psq_cb);

	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    } break;

case 1718:
if (!((*yyvarspp)->bypass_actions))
/* # line 38532 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	psq_cb->psq_mode = PSQ_SMNPREC;

	/* Specified precision must be between 0 and 2, inclusive */
	if (yacc_cb->yypvt[-0].psl_inttype < 0 || yacc_cb->yypvt[-0].psl_inttype > 2)
	{
	    (VOID) psf_error(5937L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof(yacc_cb->yypvt[-0].psl_inttype), &yacc_cb->yypvt[-0].psl_inttype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Give money precision back to caller */
	psq_cb->psq_mnyfmt.db_mny_prec = yacc_cb->yypvt[-0].psl_inttype;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    char	str[sizeof("set money_prec   ")];
	    char	num[1 + sizeof(EOS)];
	    DB_STATUS	status;

	    CVla(yacc_cb->yypvt[-0].psl_inttype, num);

	    status = psl_send_setqry(cb,
			STpolycat(3, "set money_prec ", num, " ", str),
			psq_cb);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}
    } break;

case 1719:
if (!((*yyvarspp)->bypass_actions))
/* # line 38569 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-1].psl_tytype != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QDIO_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QDIO_LIMIT;
	psy_cb->psy_qdio_limit  = yacc_cb->yypvt[-0].psl_inttype;

    } break;

case 1720:
if (!((*yyvarspp)->bypass_actions))
/* # line 38588 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-0].psl_tytype != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  = DBPR_QDIO_LIMIT;
    } break;

case 1721:
if (!((*yyvarspp)->bypass_actions))
/* # line 38606 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1722:
if (!((*yyvarspp)->bypass_actions))
/* # line 38628 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-1].psl_tytype != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QROW_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QROW_LIMIT;
	psy_cb->psy_qrow_limit  = yacc_cb->yypvt[-0].psl_inttype;

    } break;

case 1723:
if (!((*yyvarspp)->bypass_actions))
/* # line 38647 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-0].psl_tytype != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QROW_LIMIT;
    } break;

case 1724:
if (!((*yyvarspp)->bypass_actions))
/* # line 38665 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1725:
if (!((*yyvarspp)->bypass_actions))
/* # line 38687 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-1].psl_tytype != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QCPU_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QCPU_LIMIT;
	psy_cb->psy_qcpu_limit  = yacc_cb->yypvt[-0].psl_inttype;

    } break;

case 1726:
if (!((*yyvarspp)->bypass_actions))
/* # line 38706 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-0].psl_tytype != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QCPU_LIMIT;
    } break;

case 1727:
if (!((*yyvarspp)->bypass_actions))
/* # line 38724 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1728:
if (!((*yyvarspp)->bypass_actions))
/* # line 38746 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-1].psl_tytype != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_IDLE_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_IDLE_LIMIT;
	psy_cb->psy_idle_limit  = yacc_cb->yypvt[-0].psl_inttype;

    } break;

case 1729:
if (!((*yyvarspp)->bypass_actions))
/* # line 38765 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-0].psl_tytype != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_IDLE_LIMIT;
    } break;

case 1730:
if (!((*yyvarspp)->bypass_actions))
/* # line 38782 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXSESSION;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1731:
if (!((*yyvarspp)->bypass_actions))
/* # line 38796 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-1].psl_tytype != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_CONNECT_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_CONNECT_LIMIT;
	psy_cb->psy_connect_limit  = yacc_cb->yypvt[-0].psl_inttype;

    } break;

case 1732:
if (!((*yyvarspp)->bypass_actions))
/* # line 38815 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-0].psl_tytype != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_CONNECT_LIMIT;
    } break;
	}
	return(0);
}

i4
psls38iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1733:
if (!((*yyvarspp)->bypass_actions))
/* # line 38833 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXSESSION;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1734:
if (!((*yyvarspp)->bypass_actions))
/* # line 38846 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-1].psl_tytype != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QPAGE_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QPAGE_LIMIT;
	psy_cb->psy_qpage_limit = yacc_cb->yypvt[-0].psl_inttype;

    } break;

case 1735:
if (!((*yyvarspp)->bypass_actions))
/* # line 38865 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-0].psl_tytype != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QPAGE_LIMIT;
    } break;

case 1736:
if (!((*yyvarspp)->bypass_actions))
/* # line 38883 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1737:
if (!((*yyvarspp)->bypass_actions))
/* # line 38905 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-1].psl_tytype != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QCOST_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QCOST_LIMIT;
	psy_cb->psy_qcost_limit = yacc_cb->yypvt[-0].psl_inttype;

    } break;

case 1738:
if (!((*yyvarspp)->bypass_actions))
/* # line 38924 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (yacc_cb->yypvt[-0].psl_tytype != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QCOST_LIMIT;
    } break;

case 1739:
if (!((*yyvarspp)->bypass_actions))
/* # line 38942 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1740:
if (!((*yyvarspp)->bypass_actions))
/* # line 38964 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_DEBUG_CB	       *debug_cb;
	DB_STATUS	       ret_val;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_value_count = 0;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;

	debug_cb->db_trace_point = 129;	    /* 128 + 1 - first trace flag
					    ** of session trace flags.
					    */
	psq_cb->psq_mode = PSQ_PSFTRACE;
    } break;

case 1741:
if (!((*yyvarspp)->bypass_actions))
/* # line 39005 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_DEBUG_CB	       *debug_cb;
	DB_STATUS	       ret_val;

	/* "set [no]printrules" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]PRINTRULES")-1, "SET [NO]PRINTRULES");
	    return (E_DB_ERROR);
	}

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
			     (PTR *)&debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR)debug_cb,
			    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_value_count = 0;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;
	debug_cb->db_trace_point = QEF_T_RULES;		/* qea_callproc */
	psq_cb->psq_mode = PSQ_QEFTRACE;
    } break;

case 1742:
if (!((*yyvarspp)->bypass_actions))
/* # line 39050 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	DB_DEBUG_CB	*debug_cb;
	DB_STATUS	ret_val;

	/* "set [no]rules" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]RULES")-1, "SET [NO]RULES");
	    return (E_DB_ERROR);
	}

	/* Confirm that the DBA is turning rules off */
	if (MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
	      sizeof(DB_OWN_NAME)) != 0)
	{
	    _VOID_ psf_error(E_US18AA_6314_SET_NORULES, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
			     (PTR *)&debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream,(PTR)debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_value_count = 0;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)			/* Note reverse logic! */
	    debug_cb->db_trswitch = DB_TR_OFF;
	else
	    debug_cb->db_trswitch = DB_TR_ON;
	debug_cb->db_trace_point = QEF_T_NORULES;	/* qea_callproc */
	psq_cb->psq_mode = PSQ_QEFTRACE;
    } break;

case 1743:
if (!((*yyvarspp)->bypass_actions))
/* # line 39103 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_DEBUG_CB            *dbg_cb;
        DB_STATUS              ret_val;

	/* "set [no]printdbevents" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]PRINTDBEVENTS")-1,
		"SET [NO]PRINTDBEVENTS");
	    return (E_DB_ERROR);
	}

        /* Allocate the debug control block */
        ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
                             (PTR *)&dbg_cb, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR)dbg_cb, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        dbg_cb->db_value_count = 0;
        if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
            dbg_cb->db_trswitch = DB_TR_ON;
        else
            dbg_cb->db_trswitch = DB_TR_OFF;
        dbg_cb->db_trace_point = QEF_T_EVENTS;         /* qea_event */
        psq_cb->psq_mode = PSQ_QEFTRACE;
    } break;

case 1744:
if (!((*yyvarspp)->bypass_actions))
/* # line 39150 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_DEBUG_CB            *dbg_cb;
        DB_STATUS              ret_val;

	/* "set [no]logdbevents" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]LOGDBEVENTS")-1,
		"SET [NO]LOGDBEVENTS");
	    return (E_DB_ERROR);
	}

        /* Allocate the debug control block */
        ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
                             (PTR *)&dbg_cb, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR)dbg_cb, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        dbg_cb->db_value_count = 0;
        if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
            dbg_cb->db_trswitch = DB_TR_ON;
        else
            dbg_cb->db_trswitch = DB_TR_OFF;
        dbg_cb->db_trace_point = QEF_T_LGEVENTS;         /* qea_event */
        psq_cb->psq_mode = PSQ_QEFTRACE;
    } break;

case 1745:
if (!((*yyvarspp)->bypass_actions))
/* # line 39188 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** It has been decided to implement thsi statement by acting as if user
	** entered "set [no]trace point op160"
	*/

	OPF_CB		       *opf_cb;
	DB_STATUS	ret_val;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Allocate the OPF control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
			    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    opf_cb->opf_alter = OPF_OPTIMIZEONLY;
	else
	    opf_cb->opf_alter = OPF_NOOPTIMIZEONLY;
    } break;

case 1746:
if (!((*yyvarspp)->bypass_actions))
/* # line 39227 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting flattening indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    opf_cb->opf_alter = OPF_NOSUBSELECT;
	else
	    opf_cb->opf_alter = OPF_SUBSELECT;
    } break;

case 1747:
if (!((*yyvarspp)->bypass_actions))
/* # line 39261 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting hash operations indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    opf_cb->opf_alter = OPF_HASH;
	else
	    opf_cb->opf_alter = OPF_NOHASH;
    } break;

case 1748:
if (!((*yyvarspp)->bypass_actions))
/* # line 39295 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting OJ flattening indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    opf_cb->opf_alter = OPF_OJSUBSELECT;
	else
	    opf_cb->opf_alter = OPF_NOOJSUBSELECT;
    } break;

case 1749:
if (!((*yyvarspp)->bypass_actions))
/* # line 39329 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting parallel query indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_value = yacc_cb->yypvt[-0].psl_inttype;
	if (yacc_cb->yypvt[-1].psl_tytype == PSL_ONSET)
	    opf_cb->opf_alter = OPF_PARALLEL;
	else
	{
	    opf_cb->opf_alter = OPF_NOPARALLEL;
	    opf_cb->opf_value = -1;
	}
    } break;

case 1750:
if (!((*yyvarspp)->bypass_actions))
/* # line 39367 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
    } break;

case 1751:
if (!((*yyvarspp)->bypass_actions))
/* # line 39370 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = 4;
    } break;

case 1752:
if (!((*yyvarspp)->bypass_actions))
/* # line 39376 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;

	/* Create control block for setting qep factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if (yacc_cb->yypvt[-0].psl_tytype == PSL_ONSET)
	    opf_cb->opf_alter = OPF_QEP;
	else
	    opf_cb->opf_alter = OPF_NOQEP;
    } break;

case 1753:
if (!((*yyvarspp)->bypass_actions))
/* # line 39409 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_SETRANDOMSEED;
	psq_cb->psq_random_seed = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1754:
if (!((*yyvarspp)->bypass_actions))
/* # line 39414 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	u_i4	tmppid;
	u_i4	tmpnow = TMsecs();

	PCpid(&tmppid);
	psq_cb->psq_mode = PSQ_SETRANDOMSEED;
	psq_cb->psq_random_seed = tmppid * tmpnow; 
    } break;

case 1755:
if (!((*yyvarspp)->bypass_actions))
/* # line 39425 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* "set ret_into" no longer supported */
	    (VOID) psf_error(5978L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	}
    } break;

case 1756:
if (!((*yyvarspp)->bypass_actions))
/* # line 39440 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_TEXT_STRING	    *text_string;
	PSS_RNGTAB	    *rngvar;
	DB_STATUS           status;
	i4		    rngvar_info;
	DB_TAB_NAME         tabname;
	DB_DT_ID	    totype;

	/*
	** before we call qdata_cvt() to convert input value into longtext, make
	** sure that the input value is of "character type", i.e. c, char, text,
	** varchar, or longtext
	*/

	status = psl_must_be_string(cb, yacc_cb->yypvt[-0].psl_dbval, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = (yacc_cb->yypvt[-0].psl_dbval->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;

	if (qdata_cvt(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, totype, (PTR *) &text_string) != E_DB_OK)
	{
	    return (E_DB_ERROR);
	}

	STmove(sconvert(text_string), ' ', sizeof(DB_TAB_NAME), 
	    (char *) &tabname);

 	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb, FALSE, 
	   &rngvar, psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	if (status == E_DB_INFO)
	{
	    status = E_DB_OK;
	    if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		(char *)&tabname, &psq_cb->psq_error))
	    {
		return(E_DB_ERROR);
	    }
	}
	if (status != E_DB_OK)
	    return (status);

	yacc_cb->yyval.psl_rngtype = rngvar;
   } break;

case 1757:
if (!((*yyvarspp)->bypass_actions))
/* # line 39489 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSS_RNGTAB          *rngvar;
	DB_STATUS           status;
	i4		    rngvar_info;

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
		&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, FALSE, &rngvar, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb,
		FALSE, &rngvar, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_rngtype = rngvar;
    } break;

case 1759:
if (!((*yyvarspp)->bypass_actions))
/* # line 39540 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	QEF_RCB			*qef_rcb;

	/*
	** Doing a SET SESSION statement
	*/
	psq_cb->psq_mode = PSQ_SET_SESSION;
	psq_cb->psq_ret_flag=0;
	psq_cb->psq_privs=0;

	/* Open memory stream for statement */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

    } break;

case 1763:
if (!((*yyvarspp)->bypass_actions))
/* # line 39565 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ("setsessadp: ADD P L list R - calling psl_us10_usrpriv\n");
*/
	status=psl_us10_set_priv(psq_cb, cb,PSQ_SET_APRIV, yacc_cb->yypvt[-1].psl_inttype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1764:
if (!((*yyvarspp)->bypass_actions))
/* # line 39578 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ("setsessadp: DROP P L list R - calling psl_us10_usrpriv\n");
*/
	status=psl_us10_set_priv(psq_cb, cb, PSQ_SET_DPRIV, yacc_cb->yypvt[-1].psl_inttype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1765:
if (!((*yyvarspp)->bypass_actions))
/* # line 39591 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_ret_flag |= PSQ_SET_ISOLATION;
	psq_cb->psq_isolation = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1766:
if (!((*yyvarspp)->bypass_actions))
/* # line 39596 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (!STcompare(yacc_cb->yypvt[-0].psl_strtype, "system"))
	{
	    psq_cb->psq_ret_flag |= PSQ_SET_ISOLATION;
	    psq_cb->psq_isolation = DMC_C_SYSTEM;
	}
	else
	{
	    i4    err_code;

	    (VOID) psf_error(5923L, 0L, PSF_USERERR, &err_code, 
		    &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
    } break;
	}
	return(0);
}

i4
psls39iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1767:
if (!((*yyvarspp)->bypass_actions))
/* # line 39612 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_ret_flag |= PSQ_SET_ACCESSMODE;
	psq_cb->psq_accessmode = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1768:
if (!((*yyvarspp)->bypass_actions))
/* # line 39617 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (!STcompare(yacc_cb->yypvt[-0].psl_strtype, "nocache_dynamic"))
	{
	    cb->pss_ses_flag |= PSS_NO_CACHEDYN;
	    cb->pss_ses_flag &= ~PSS_CACHEDYN;
	}
	else if (!STcompare(yacc_cb->yypvt[-0].psl_strtype, "cache_dynamic"))
	{
	    cb->pss_ses_flag |= PSS_CACHEDYN;
	    cb->pss_ses_flag &= ~PSS_NO_CACHEDYN;
	}
	else
	{
	    /* syntax error */
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_SSCACHEDYN;	/* this is a no-op in sqncr */
    } break;

case 1773:
if (!((*yyvarspp)->bypass_actions))
/* # line 39648 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	status=psl_us9_set_nonkw_eq_nonkw(psq_cb, cb, yacc_cb->yypvt[-2].psl_strtype,yacc_cb->yypvt[-0].psl_strtype, TRUE);
	if(DB_FAILURE_MACRO(status))
			return status;
    } break;

case 1774:
if (!((*yyvarspp)->bypass_actions))
/* # line 39655 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	status=psl_us9_set_nonkw_eq_nonkw(psq_cb, cb, yacc_cb->yypvt[-2].psl_strtype,yacc_cb->yypvt[-0].psl_strtype, FALSE);
	if(DB_FAILURE_MACRO(status))
		return status;
	
    } break;

case 1775:
if (!((*yyvarspp)->bypass_actions))
/* # line 39663 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	status=psl_us14_set_nonkw_eq_int(psq_cb, cb, yacc_cb->yypvt[-2].psl_strtype,(i4)yacc_cb->yypvt[-0].psl_inttype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1776:
if (!((*yyvarspp)->bypass_actions))
/* # line 39670 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	status=psl_us11_set_nonkw_roll_svpt(psq_cb, cb, yacc_cb->yypvt[-4].psl_strtype,yacc_cb->yypvt[-0].psl_strtype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1777:
if (!((*yyvarspp)->bypass_actions))
/* # line 39677 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS status;
	status=psl_us12_set_nonkw_roll_nonkw(psq_cb, cb, yacc_cb->yypvt[-3].psl_strtype,yacc_cb->yypvt[-0].psl_strtype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1778:
if (!((*yyvarspp)->bypass_actions))
/* # line 39684 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;

/*
	TRdisplay("setsessparm: P L list R -  calling psl_us10_set_priv\n");
*/
	status=psl_us10_set_priv(psq_cb, cb, PSQ_SET_PRIV, yacc_cb->yypvt[-1].psl_inttype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1779:
if (!((*yyvarspp)->bypass_actions))
/* # line 39695 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;

/*
	TRdisplay("setsessparm: P EQUAL DEFAULT - calling psl_us10_set_priv\n" ) ;
*/
	status=psl_us10_set_priv(psq_cb, cb, PSQ_SET_DEFPRIV, 0);
	if(DB_FAILURE_MACRO(status))
		return status;
      } break;

case 1780:
if (!((*yyvarspp)->bypass_actions))
/* # line 39707 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;

/*
	TRdisplay ( "setsessparm: P EQUAL ALL -  calling psl_us10_usrpriv\n");
*/
	status=psl_us10_set_priv(psq_cb, cb, PSQ_SET_ALLPRIV, 0);
	if(DB_FAILURE_MACRO(status))
		return status;
      } break;

case 1781:
if (!((*yyvarspp)->bypass_actions))
/* # line 39718 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS   status;
	i4     err_code;

	status=psl_us15_set_nonkw(psq_cb, cb, yacc_cb->yypvt[-0].psl_strtype);
	if(DB_FAILURE_MACRO(status))
		return status;
    } break;

case 1782:
if (!((*yyvarspp)->bypass_actions))
/* # line 39729 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	       status;
	QEU_CB		       *qeu_cb;
	DMT_CB		       *dmt_cb;
	DMT_CHAR_ENTRY	       *chr;
        DB_ERROR		e_error;
	i4			err_code;

	status = psy_ckdbpr(psq_cb, (u_i4) DBPR_TABLE_STATS);

	if (DB_FAILURE_MACRO(status))
	{
	    /*
	    ** Not allowed to change table stats
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		status = psy_secaudit(FALSE, 
			cb, 
			yacc_cb->yypvt[-0].psl_rngtype->pss_tabname.db_tab_name,
			&yacc_cb->yypvt[-0].psl_rngtype->pss_ownname, 
			sizeof(yacc_cb->yypvt[-0].psl_rngtype->pss_tabname),
			SXF_E_TABLE, I_SX273C_TABLE_STATS,
			SXF_A_FAIL | SXF_A_CONTROL, 
			&e_error);
	    }

	     (VOID) psf_error(E_PS035B_CANT_ACCESS_TBL_STATS, 
			0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 0);
	    return E_DB_ERROR;
	}

	psq_cb->psq_mode = PSQ_SSTATS;

	/* Allocate QEU_CB for SET STATISTICS and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the journaled bit */
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id = DMT_C_ZOPTSTATS;
	if (yacc_cb->yypvt[-1].psl_tytype == PSL_ONSET)
	    chr->char_value = DMT_C_ON;
	else
	    chr->char_value = DMT_C_OFF;

	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_rngtype->pss_tabid, dmt_cb->dmt_id);

	/* Star requires table and owner for issuing query */
	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_rngtype->pss_tabname, dmt_cb->dmt_table);
	STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_rngtype->pss_ownname, dmt_cb->dmt_owner);

	/* invalidate RDF's cache */
	{
	    RDF_CB		rdf_cb;

	    pst_rdfcb_init(&rdf_cb, cb);
	    STRUCT_ASSIGN_MACRO(yacc_cb->yypvt[-0].psl_rngtype->pss_tabid, rdf_cb.rdf_rb.rdr_tabid);
	    status = rdf_call(RDF_INVALIDATE, (PTR) &rdf_cb);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_rdf_error(RDF_INVALIDATE, &rdf_cb.rdf_error,
				&psq_cb->psq_error);
		return (status);
	    }
	}
    } break;

case 1783:
if (!((*yyvarspp)->bypass_actions))
/* # line 39822 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	SCF_CB		       scf_cb;
	SCF_SCI		       sci_list;
	DB_TERM_NAME	       termname;
	CL_ERR_DESC	       cl_error;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** Possible single parameters are "terminal", "output", "input",
	** "point".  Error is anything else.
	*/
	if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "terminal"))
	{
	    if (yacc_cb->yypvt[-1].psl_tytype == PSL_ONSET)
	    {
		/* Get user's terminal name */
	        scf_cb.scf_length = sizeof(SCF_CB);
	        scf_cb.scf_type = SCF_CB_TYPE;
	        scf_cb.scf_facility = DB_PSF_ID;
	        scf_cb.scf_session = DB_NOSESSION;
		scf_cb.scf_len_union.scf_ilength = 1;
		/* may cause lint message */
		scf_cb.scf_ptr_union.scf_sci = (SCI_LIST*) &sci_list;
		sci_list.sci_code = SCI_UTTY;
		sci_list.sci_length = sizeof(termname);
		sci_list.sci_aresult = (PTR) &termname;
		sci_list.sci_rlength = NULL;
		status = scf_call(SCU_INFORMATION, &scf_cb);
		if (status == E_DB_OK)
		{
		    /* set trace terminal */
		    if (TRset_file(TR_T_OPEN, termname.db_term_name,
			sizeof(termname), &cl_error))
		    {
		        (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
		    		&psq_cb->psq_error, 1, 
				sizeof (termname.db_term_name),
				termname.db_term_name);
		    }
		}
		else
		{
		    (VOID) psf_error(E_PS0378_SCF_TERM_ERR,
			scf_cb.scf_error.err_code, PSF_INTERR,
			&err_code, &psq_cb->psq_error, 0);
		}
	    }
	    else
	    {
		/* set notrace terminal */
		TRset_file(TR_T_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "output"))
	{
	    /* "set trace output" without filename not allowed */
	    if (yacc_cb->yypvt[-1].psl_tytype == PSL_ONSET)
	    {
		(VOID) psf_error(5973L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set notrace output */
		TRset_file(TR_F_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "input"))
	{
	    /* "set trace input" without filename not allowed */
	    if (yacc_cb->yypvt[-1].psl_tytype == PSL_ONSET)
	    {
		(VOID) psf_error(5973L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set notrace input */
		TRset_file(TR_I_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "point"))
	{
	    /* "set trace point" without facility code not allowed */
	    (VOID) psf_error(5965L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	else
	{
	    (VOID) psf_error(5962L, 0L,  PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
    } break;

case 1784:
if (!((*yyvarspp)->bypass_actions))
/* # line 39924 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	CL_ERR_DESC	       cl_error;

	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** Valid parameters are "terminal", "output", "input", "point".
	** Error if none of these.
	*/
	if (!STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "terminal"))
	{
	    /* "set notrace terminal" must not have a second parm */
	    if (yacc_cb->yypvt[-2].psl_tytype == PSL_OFFSET)
	    {
		(VOID) psf_error(5963L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace terminal termname */
		if (TRset_file(TR_T_OPEN, yacc_cb->yypvt[-0].psl_strtype, STlength(yacc_cb->yypvt[-0].psl_strtype), &cl_error))
		{
		    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
		    	&psq_cb->psq_error, 1, 
			STlength (yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		}
	    }
	}
	else if (!STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "output"))
	{
	    /* "set notrace output" must not have a second parm */
	    if (yacc_cb->yypvt[-2].psl_tytype == PSL_OFFSET)
	    {
		(VOID) psf_error(5964L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace output filename */
		if (TRset_file(TR_F_SAFEOPEN, yacc_cb->yypvt[-0].psl_strtype, STlength(yacc_cb->yypvt[-0].psl_strtype), &cl_error))
		{
		    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
		    	&psq_cb->psq_error, 1, 
			STlength (yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		}
	    }
	}
	else if (!STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "input"))
	{
	    /* "set notrace input" must not have a second parm */
	    if (yacc_cb->yypvt[-2].psl_tytype == PSL_OFFSET)
	    {
		(VOID) psf_error(5964L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace input filename */
		if (TRset_file(TR_I_OPEN, yacc_cb->yypvt[-0].psl_strtype, STlength(yacc_cb->yypvt[-0].psl_strtype), &cl_error))
		{
		    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
		    	&psq_cb->psq_error, 1, 
			STlength (yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		}
	    }
	}
	else if (!STcasecmp(yacc_cb->yypvt[-1].psl_strtype, "point"))
	{
	    i4                 facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_DEBUG_CB	       *debug_cb;
	    DB_STATUS	       ret_val;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 0;
	    if (yacc_cb->yypvt[-2].psl_tytype == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code;  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    ** FIXME - facility code is not set */
	    if ((status = getfacil(yacc_cb->yypvt[-0].psl_strtype, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		debug_cb->db_trace_point = flagno;
		psq_cb->psq_mode = facility;

		if (facility == PSQ_QEFTRACE && flagno == QEF_T_NORULES &&
		    MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
			     sizeof(DB_OWN_NAME)) != 0
		   )
		{
		    _VOID_ psf_error(E_US18AA_6314_SET_NORULES, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1785:
if (!((*yyvarspp)->bypass_actions))
/* # line 40056 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	/*
	** This form of the "set [no]trace command makes sense only with
	** "set [no]trace point".
	*/
	if (!STcasecmp(yacc_cb->yypvt[-2].psl_strtype, "terminal") ||
	    !STcasecmp(yacc_cb->yypvt[-2].psl_strtype, "output")   ||
	    !STcasecmp(yacc_cb->yypvt[-2].psl_strtype, "input"))
	{
	    (VOID) psf_error(5968L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else if (!STcasecmp(yacc_cb->yypvt[-2].psl_strtype, "point"))
	{
	    i4		       facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_STATUS	       ret_val;
	    DB_DEBUG_CB	       *debug_cb;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 1;
	    debug_cb->db_vals[0] = yacc_cb->yypvt[-0].psl_inttype;
	    if (yacc_cb->yypvt[-3].psl_tytype == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code.  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    */
	    if ((status = getfacil(yacc_cb->yypvt[-1].psl_strtype, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
		return (E_DB_ERROR);
	    }
	    else
	    {
		psq_cb->psq_mode = facility;
		debug_cb->db_trace_point = flagno;
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1786:
if (!((*yyvarspp)->bypass_actions))
/* # line 40124 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;

	/*
	** This form of the "set [no]trace" command makes sense only with
	** "set [no]trace point".
	*/
	if (!STcasecmp(yacc_cb->yypvt[-3].psl_strtype, "terminal") ||
	    !STcasecmp(yacc_cb->yypvt[-3].psl_strtype, "output")   ||
	    !STcasecmp(yacc_cb->yypvt[-3].psl_strtype, "input"))
	{
	    (VOID) psf_error(5968L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else if (!STcasecmp(yacc_cb->yypvt[-3].psl_strtype, "point"))
	{
	    i4		       facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_STATUS	       ret_val;
	    DB_DEBUG_CB	       *debug_cb;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 2;
	    debug_cb->db_vals[0] = yacc_cb->yypvt[-1].psl_inttype;
	    debug_cb->db_vals[1] = yacc_cb->yypvt[-0].psl_inttype;
	    if (yacc_cb->yypvt[-4].psl_tytype == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code.  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    */
	    if ((status = getfacil(yacc_cb->yypvt[-2].psl_strtype, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
		return (E_DB_ERROR);
	    }
	    else
	    {
		psq_cb->psq_mode = facility;
		debug_cb->db_trace_point = flagno;
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-3].psl_strtype), yacc_cb->yypvt[-3].psl_strtype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    } break;

case 1787:
if (!((*yyvarspp)->bypass_actions))
/* # line 40194 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** "set trace" is allowed in distributed, even though the current
	** spec doesn't list it.
	*/
	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1788:
if (!((*yyvarspp)->bypass_actions))
/* # line 40206 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4            err_code;
	DB_STATUS	   status;
	OPF_CB		   *opf_cb;
	char		   *ch = yacc_cb->yypvt[-0].psl_strtype;
	bool		   not_distr = ((cb->pss_distrib & DB_3_DDB_SESS) == 0);
	i4		   *val, dummy;

	psq_cb->psq_mode = PSQ_SRINTO;

	if (not_distr)
	{
	    /* Allocate OPF control block for set result_structure command */
	    status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* Fill in OPF control block */
	    opf_cb->opf_length = sizeof(opf_cb);
	    opf_cb->opf_type = OPFCB_CB;
	    opf_cb->opf_owner = (PTR)DB_PSF_ID;
	    opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	    opf_cb->opf_level = OPF_SESSION;
	    opf_cb->opf_alter = OPF_RET_INTO;
	    opf_cb->opf_compressed = FALSE;
	    val = &opf_cb->opf_value;
	}
	else /* distributed */
	{
	    val = &dummy;
	}

	if (!CMcmpnocase(ch, "c"))
	{
	    ch = CMnext(ch);
	    if (not_distr)
	        opf_cb->opf_compressed = TRUE;
	}

	/* Decode storage structure.  Error if unknown. */
	*val = uld_struct_xlate(ch);
	if (*val == 0)
	{
	    (VOID) psf_error(5916L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* cheapsort is the longest option */
	    char	str[sizeof("set result_structure 'cheapsort' ")];
	    DB_STATUS	status;

	    status = psl_send_setqry(cb,
			STpolycat(3, "set result_structure '", yacc_cb->yypvt[-0].psl_strtype, "' ", str),
			psq_cb);
	    
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    } break;

case 1790:
if (!((*yyvarspp)->bypass_actions))
/* # line 40282 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	i4			err_code;
	DMC_CB			*dmc_cb;

	/* do this right away so that a syntax error will be generated if
	** anything goes wrong later on
	*/
	psq_cb->psq_mode = PSQ_SWORKLOC;

	/* "set work locations..." is not allowed in distributed */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(2767L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Create control block for DMC_ALTER call for set work locations */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CB), (PTR *) &dmc_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) dmc_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	cb->pss_object	       = (PTR) dmc_cb;
	dmc_cb->type	       = DMC_CONTROL_CB;
	dmc_cb->length	       = sizeof (DMC_CB);
	dmc_cb->dmc_op_type    = DMC_SESSION_OP;
	dmc_cb->dmc_session_id = (PTR)cb->pss_sessid;
	dmc_cb->dmc_flags_mask = DMC_LOC_MODE;
	dmc_cb->dmc_db_id      = cb->pss_dbid;
	dmc_cb->dmc_names_loc  = NULL;
    } break;

case 1791:
if (!((*yyvarspp)->bypass_actions))
/* # line 40325 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4			err_code;

	/* "locations" is the only word acceptable here */
	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "locations"))
	{
	    (VOID) psf_error(2551L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 1792:
if (!((*yyvarspp)->bypass_actions))
/* # line 40340 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	((DMC_CB *) cb->pss_object)->dmc_s_type = DMC_S_ADD_LOCS;
    } break;

case 1793:
if (!((*yyvarspp)->bypass_actions))
/* # line 40344 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{    
	((DMC_CB *) cb->pss_object)->dmc_s_type = DMC_S_DROP_LOCS;
    } break;

case 1794:
if (!((*yyvarspp)->bypass_actions))
/* # line 40348 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	
	/* "use" is the only other valid word here */
	if (STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "use"))
	{
	    (VOID) psf_error(2551L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}

	((DMC_CB*) cb->pss_object)->dmc_s_type = DMC_S_TRADE_LOCS;
    } break;

case 1797:
if (!((*yyvarspp)->bypass_actions))
/* # line 40370 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
	DMC_CB			*dmc_cb;
	DMC_LLIST_ITEM		*tmp;

	dmc_cb	= (DMC_CB*) cb->pss_object;
	tmp = dmc_cb->dmc_names_loc;

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_LLIST_ITEM),
	     (PTR *) &dmc_cb->dmc_names_loc, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	MEmove(STlength(yacc_cb->yypvt[-0].psl_strtype), (PTR)yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_LOC_NAME),
		(PTR)dmc_cb->dmc_names_loc->dmc_lname.db_loc_name);
	/* location names must be in lowercase */
	if (*cb->pss_dbxlate & CUI_ID_REG_U)
	    CVlower(dmc_cb->dmc_names_loc->dmc_lname.db_loc_name);
	dmc_cb->dmc_names_loc->dmc_llink = tmp;
    } break;

case 1798:
if (!((*yyvarspp)->bypass_actions))
/* # line 40393 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{ 
	DB_STATUS status;
	psq_cb->psq_ret_flag=0;
        psq_cb->psq_mode = PSQ_SETROLE;
	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);
    } break;

case 1799:
if (!((*yyvarspp)->bypass_actions))
/* # line 40401 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS               status;
	i4                 err_code;

	/*
	** SET ROLE not available in distributed yet
	*/
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET ROLE")-1,
		"SET ROLE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	/*
	** Check for magic NONE, need to check if delimeted or not
	*/
	if(!STcasecmp(yacc_cb->yypvt[-1].psl_strtype,"none"))
	{
		if(yyvarsp->id_type!=PSS_ID_DELIM)
		{
			psq_cb->psq_ret_flag|=PSQ_SET_NOROLE;
		}
	}
	/*
	** Save the role name
	*/
	STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', sizeof(psq_cb->psq_rolename), 
			(char*)&psq_cb->psq_rolename.db_own_name);
	
      } break;

case 1800:
if (!((*yyvarspp)->bypass_actions))
/* # line 40435 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		/* Fill password to empty */
		MEfill(sizeof(psq_cb->psq_password),' ',
			(PTR)&psq_cb->psq_password);
	  } break;

case 1801:
if (!((*yyvarspp)->bypass_actions))
/* # line 40441 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
		i4                 err_code;
		/*
		** Should be WITH PASSWORD = 'pwd'
		*/
		if(STcasecmp(yacc_cb->yypvt[-2].psl_strtype,"password")==0)
		{
			/* Blank pad full DB_PASSWORD */
			MEmove(STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype, ' ', 
				sizeof(psq_cb->psq_password),
				(char*)&psq_cb->psq_password);
			psq_cb->psq_ret_flag|=PSQ_SET_ROLE_PASSWORD;
		}
		else
		{
		    (void) psf_error(E_PS0F86_SET_ROLE_WITH, 0L, 
			PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, 
			(i4) STlength(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
		    return (E_DB_ERROR);    /* non-zero return means error */
		}
	  } break;

case 1802:
if (!((*yyvarspp)->bypass_actions))
/* # line 40466 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
     i4                 err_code;

        /* "set usub " is not allowed in distributed yet */
        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(5951L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }

        psq_cb->psq_mode = PSQ_SETUNICODESUB;

        if (yacc_cb->yypvt[-0].psl_tytype == PSL_GOVAL)    /* psq_usub_stat = FALSE */
          psq_cb->psq_usub_stat = AD_UNISUB_ON;
        else                     /* psq_usub_stat = TRUE */
          psq_cb->psq_usub_stat = AD_UNISUB_OFF;

        *psq_cb->psq_usub_char = '\0';

        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            DB_STATUS   status;
            status = psl_send_setqry(cb, "set usub", psq_cb);
            if (DB_FAILURE_MACRO(status))
                return (status);
        }
    } break;

case 1803:
if (!((*yyvarspp)->bypass_actions))
/* # line 40494 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        i4                 err_code;
        char               inchar[4] = {'\0'};
        i4                 inlength = 0;

        /* "set usub " is not allowed in distributed yet */
        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(5951L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }

        psq_cb->psq_mode = PSQ_SETUNICODESUB;

        if (yacc_cb->yypvt[-1].psl_tytype == PSL_GOVAL)    /* psq_usub_stat =TRUE */
          psq_cb->psq_usub_stat = AD_UNISUB_ON;
        else                     /* psq_usub_stat = FALSE */
          psq_cb->psq_usub_stat = AD_UNISUB_OFF;

       inlength = CMbytecnt(yacc_cb->yypvt[-0].psl_strtype);
       STmove(yacc_cb->yypvt[-0].psl_strtype, '\0', inlength, (char*)&psq_cb->psq_usub_char);
 
       if (cb->pss_distrib & DB_3_DDB_SESS)
       {
            char  str[sizeof("set unicode_substitution '' ") + 2 + 4];
            DB_STATUS   status;

            status = psl_send_setqry(cb,
                     STpolycat(3, "set unicode_substitution '", yacc_cb->yypvt[-0].psl_strtype, "' ", str),
                     psq_cb);

            if (DB_FAILURE_MACRO(status))
                return (status);
       }
    } break;
	}
	return(0);
}

i4
psls40iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1804:
if (!((*yyvarspp)->bypass_actions))
/* # line 40533 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        DB_STATUS               status;
        QEF_RCB                 *qef_rcb;
	i4                 err_code;
	bool                    not_distr=(cb->pss_distrib & DB_3_DDB_SESS) 
					== 0;
	i4			*val, dummy;

        psq_cb->psq_mode = PSQ_UPD_ROWCNT;

	if (not_distr)
	{
           /* Allocate QEF control bock for update_rowcount */
           status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
           if (status != E_DB_OK)
              return (status);
           status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB),
			&cb->pss_object, &psq_cb->psq_error);
           if (status != E_DB_OK)
              return (status);
           status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
                        &psq_cb->psq_error);
           if (status != E_DB_OK)
              return (status);

           /* Fill in the QEF control block */
           qef_rcb = (QEF_RCB *) cb->pss_object;
           qef_rcb->qef_length = sizeof(QEF_RCB);
           qef_rcb->qef_type = QEFRCB_CB;
           qef_rcb->qef_owner = (PTR)DB_PSF_ID;
           qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	   qef_rcb->qef_sess_id = cb->pss_sessid;
           val = &qef_rcb->qef_upd_rowcnt;
      }
      else /* distributed */
      {
           val = &dummy;
      }

      if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "changed") == 0)	
      {
	 *val = QEF_ROWCHGD;
      }

      else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "qualified") == 0)
      {
          *val = QEF_ROWQLFD;
      }

      else  /* syntax error */
      {
           /* set update_rowcount syntax error */
            (void) psf_error(E_PS0F85_SET_UPDATE_ROWCOUNT_STMT, 0L, 
		PSF_USERERR, &err_code,
                &psq_cb->psq_error, 1, (i4) STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
            return (E_DB_ERROR);    /* non-zero return means error */
      }

      if (cb->pss_distrib & DB_3_DDB_SESS)        
      {
         DB_STATUS       status;

         /* qualified is the longest option */
	 char            buf[sizeof("set update_rowcount qualified ")];

         status = psl_send_setqry(cb,
                        STpolycat(3, "set update_rowcount ", yacc_cb->yypvt[-0].psl_strtype, " ", buf),
                        psq_cb);

         if (DB_FAILURE_MACRO(status))
              return(status);
       }
      } break;

case 1805:
if (!((*yyvarspp)->bypass_actions))
/* # line 40609 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1806:
if (!((*yyvarspp)->bypass_actions))
/* # line 40613 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                     num;
	i4		       err_code;

	/*
	** If a string used in place of an integer can't be converted to an
	** integer, give an error.
	*/
	if (CVal(sconvert(yacc_cb->yypvt[-0].psl_textype), &num) != OK)
        {
	    (VOID) psf_error(5969L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite((char *) yacc_cb->yypvt[-0].psl_textype), (char *) yacc_cb->yypvt[-0].psl_textype);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	yacc_cb->yyval.psl_inttype = num;
    } break;

case 1807:
if (!((*yyvarspp)->bypass_actions))
/* # line 40633 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1808:
if (!((*yyvarspp)->bypass_actions))
/* # line 40637 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1809:
if (!((*yyvarspp)->bypass_actions))
/* # line 40643 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1810:
if (!((*yyvarspp)->bypass_actions))
/* # line 40647 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	(VOID) psl_sx_error(2722L, cb, psq_cb);
	YYABORT;
    } break;

case 1811:
if (!((*yyvarspp)->bypass_actions))
/* # line 40655 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1812:
if (!((*yyvarspp)->bypass_actions))
/* # line 40659 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		    value;
	ADF_CB		    adf_cb;
	ADF_CB		    *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_DATA_VALUE	    tdv;
	ADI_DT_NAME	    dt_fname;
	ADI_DT_NAME	    dt_tname;
	i4		    err_code;
	
	/* Copy the session ADF block into local one */
	STRUCT_ASSIGN_MACRO(*adf_scb, adf_cb);

	adf_cb.adf_errcb.ad_ebuflen = 0;
	adf_cb.adf_errcb.ad_errmsgp = 0;
	tdv.db_prec		    = 0;
	tdv.db_length		    = 4;
	tdv.db_datatype		    = DB_INT_TYPE;
	tdv.db_data		    = (PTR) &value;
	    
	if (adc_cvinto(&adf_cb, yacc_cb->yypvt[-0].psl_dbval, &tdv) != E_DB_OK)
	{
	    (VOID) adi_tyname(&adf_cb, yacc_cb->yypvt[-0].psl_dbval->db_datatype, &dt_fname);
	    (VOID) adi_tyname(&adf_cb, (DB_DT_ID) DB_INT_TYPE, &dt_tname);
	    (VOID) psf_error(2911L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof (cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof (dt_fname), (char *) &dt_fname), &dt_fname, 
		psf_trmwhite(sizeof (dt_tname), (char *) &dt_tname), &dt_tname);
	    return (E_DB_ERROR);
	}

	/* The values is expected to be 0 or positive. */
	if (value < 0)
	{
	    (VOID) adi_tyname(&adf_cb, yacc_cb->yypvt[-0].psl_dbval->db_datatype, &dt_fname);
	    (VOID) psf_error(2929L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		psf_trmwhite(sizeof (dt_fname), (char *) &dt_fname), &dt_fname);
	    return (E_DB_ERROR);
	}

	yacc_cb->yyval.psl_inttype = value;
    } break;

case 1813:
if (!((*yyvarspp)->bypass_actions))
/* # line 40705 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = *yacc_cb->yypvt[-0].psl_i4type;
    } break;

case 1814:
if (!((*yyvarspp)->bypass_actions))
/* # line 40709 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = *yacc_cb->yypvt[-0].psl_i2type;
    } break;

case 1815:
if (!((*yyvarspp)->bypass_actions))
/* # line 40715 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yacc_cb->yypvt[-1].psl_tytype == ADI_SUB_OP)
	    yacc_cb->yyval.psl_inttype = -yacc_cb->yypvt[-0].psl_inttype;
	else
	    yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1816:
if (!((*yyvarspp)->bypass_actions))
/* # line 40722 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_inttype = yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1817:
if (!((*yyvarspp)->bypass_actions))
/* # line 40728 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = sconvert(yacc_cb->yypvt[-0].psl_textype);
    } break;

case 1818:
if (!((*yyvarspp)->bypass_actions))
/* # line 40732 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_TEXT_STRING	    *value;
	DB_STATUS	    status;
	DB_DT_ID	    totype;

	/*
	** before we call qdata_cvt() to convert input value into longtext, make
	** sure that the input value is of "character type", i.e. c, char, text,
	** varchar, or longtext
	*/

	status = psl_must_be_string(cb, yacc_cb->yypvt[-0].psl_dbval, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = (yacc_cb->yypvt[-0].psl_dbval->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;
							   
	if (qdata_cvt(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, totype, (PTR *) &value) != E_DB_OK)
	    return (E_DB_ERROR);

	yacc_cb->yyval.psl_strtype = sconvert(value);
    } break;

case 1819:
if (!((*yyvarspp)->bypass_actions))
/* # line 40761 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = sconvert(yacc_cb->yypvt[-0].psl_textype);
    } break;

case 1820:
if (!((*yyvarspp)->bypass_actions))
/* # line 40765 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_TEXT_STRING	    *value;
	DB_STATUS	    status;
	DB_DT_ID	    totype;

	/*
	** before we call qdata_cvt() to convert input value into longtext, make
	** sure that the input value is of "character type", i.e. c, char, text,
	** varchar, or longtext
	*/

	status = psl_must_be_string(cb, yacc_cb->yypvt[-0].psl_dbval, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = (yacc_cb->yypvt[-0].psl_dbval->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;

	if (qdata_cvt(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, totype, (PTR *) &value) != E_DB_OK)
	    return (E_DB_ERROR);

	yacc_cb->yyval.psl_strtype = sconvert(value);
    } break;

case 1821:
if (!((*yyvarspp)->bypass_actions))
/* # line 40792 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	(VOID) psl_sx_error(2723L, cb, psq_cb);
	YYABORT;
    } break;

case 1822:
if (!((*yyvarspp)->bypass_actions))
/* # line 40799 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_textype = yacc_cb->yypvt[-0].psl_textype;
    } break;

case 1823:
if (!((*yyvarspp)->bypass_actions))
/* # line 40803 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_textype = yacc_cb->yypvt[-0].psl_textype;
    } break;

case 1824:
if (!((*yyvarspp)->bypass_actions))
/* # line 40809 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	err_code;

	yyvarsp->aggr_allowed &= ~(PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);

	/* Updates on secondary index tables that are btrees
	** are not allowed.
	*/
	if (yacc_cb->yypvt[-1].psl_rngtype->pss_tabdesc->tbl_status_mask & DMT_IDX
	    &&
	    yacc_cb->yypvt[-1].psl_rngtype->pss_tabdesc->tbl_storage_type == DMT_BTREE_TYPE
	   )
	{
	    (VOID) psf_error(2124L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &yacc_cb->yypvt[-1].psl_rngtype->pss_tabname),
		&yacc_cb->yypvt[-1].psl_rngtype->pss_tabname);
	    return(E_DB_ERROR);	    
	}

	cb->pss_resrng = yacc_cb->yypvt[-1].psl_rngtype;
	yyvarsp->in_update_set_clause = TRUE;
    } break;

case 1825:
if (!((*yyvarspp)->bypass_actions))
/* # line 40834 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** aggregates are not allowed in the updatelist, but are OK in the
	** where_clause
	*/
	yyvarsp->aggr_allowed |= (PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
	yyvarsp->in_update_set_clause = FALSE;
    } break;

case 1826:
if (!((*yyvarspp)->bypass_actions))
/* # line 40843 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PST_QNODE	    *rsdmnode;
	PST_QNODE	    *rootnode;
	PST_RT_NODE	    root;
	PST_QTREE	    *tree;
	DB_STATUS	    status;
	i4		    err_code;
	i4		    qrymod_resp_mask;
	PST_QNODE	    *qual;
	PST_PROCEDURE	    *pnode;
	i4		    tbl_stat_mask;
	i4		    tbl_2_stat_mask;
	i4		    hdr_mask;
	PSC_CURBLK	    *cursor = (PSC_CURBLK *) NULL;
	extern PSF_SERVBLK  *Psf_srvblk;
	i4		    mask;

	/*
	** Mode could have been altered by a subselect in the WHERE clause.
	** If so, we need to restore it. Note that "where current of" will
	** never alter the mode.
	*/
	if (psq_cb->psq_mode == PSQ_RETRIEVE)
	{
	    psq_cb->psq_mode = PSQ_REPLACE;
	}

	/*
	** For searched update a tid node must be added here.
	** For positioned update we must NOT add one.
	*/

	if (psq_cb->psq_mode == PSQ_REPLACE)
	{
	    if (~cb->pss_distrib & DB_3_DDB_SESS)
	    {
		PST_QNODE       *tidnode;
		PST_RSDM_NODE   resdom;
		PST_VAR_NODE    tidvar;

		hdr_mask = 0;

		/* Set up a var. node representing the tid.
		** pst_adresdom should not be used here because it relies on
		** cb->pss_rsdmno, which may be incorrect now due to the fact
		** that subselects in the where clause reset it every time a new
		** target list is started.
		*/

		tidvar.pst_vno = yacc_cb->yypvt[-6].psl_rngtype->pss_rgno;
		tidvar.pst_atno.db_att_id = 0;	    /* tid is always column 0 */
		STmove(((*cb->pss_dbxlate & CUI_ID_REG_U) ? "TID" : "tid"),
			' ', DB_MAXNAME, tidvar.pst_atname.db_att_name);

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &tidvar, sizeof(tidvar),
		    DB_TID8_TYPE, (i2) 0, (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL,
		    &tidnode, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);	    /* non-zero return means error */
		}

		/* Set up a resdom result domain representing a tid. */
		resdom.pst_rsno = 0;
		cb->pss_rsdmno++; /* Count resdoms */
		resdom.pst_ntargno = (i4) 0;
		resdom.pst_ttargtype = (i4) PST_ATTNO;
		resdom.pst_rsupdt = FALSE;
		resdom.pst_dmuflags = 0;
		resdom.pst_rsflags = 0; /* no PST_RS_PRINT*/

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, tidnode,
		    PST_RESDOM, (PTR) &resdom, sizeof(resdom), DB_TID8_TYPE, (i2) 0,
		    (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL, &rsdmnode, 
		    &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);	/* non-zero return means error */
		}

		/* prepend the tid node to the target list */
		(VOID) pst_tlprpnd(rsdmnode, yacc_cb->yypvt[-2].psl_trtype);

		/* remember qualification */
	    }
	    else
	    {
		hdr_mask = PST_1INSERT_TID;
	    }

	    /* remember qualification */
	    qual = yacc_cb->yypvt[-0].psl_trtype;
	}
	else	/* PSQ_REPCURS */
	{
	    hdr_mask = 0;

	    cursor = (PSC_CURBLK *) yacc_cb->yypvt[-0].psl_trtype;

	    /* Check if cursor updateable */
	    if (cursor->psc_forupd == FALSE)
	    {
		(VOID) psf_error(2217L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    psf_trmwhite(DB_MAXNAME, cursor->psc_blkid.db_cur_name),
		    cursor->psc_blkid.db_cur_name);
		return (E_DB_ERROR);
	    }

	    /*
	    ** For update cursor we must compare names of objects and of object
	    ** owners.
	    */
	    if (MEcmp((PTR) &(cursor->psc_tabnm),
		      (PTR) &(yacc_cb->yypvt[-6].psl_rngtype->pss_tabname), sizeof(DB_TAB_NAME)) ||
		MEcmp((PTR) &(cursor->psc_ownnm),
		      (PTR) &(yacc_cb->yypvt[-6].psl_rngtype->pss_ownname), sizeof(DB_OWN_NAME)))
	    {
		(VOID) psf_error(2227L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 4,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &(cursor->psc_tabnm)),
		    &(cursor->psc_tabnm),
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &(cursor->psc_ownnm)),
		    &(cursor->psc_ownnm),
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &(yacc_cb->yypvt[-6].psl_rngtype->pss_tabname)),
		    &(yacc_cb->yypvt[-6].psl_rngtype->pss_tabname),
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &(yacc_cb->yypvt[-6].psl_rngtype->pss_ownname)),
		    &(yacc_cb->yypvt[-6].psl_rngtype->pss_ownname));
		return(E_DB_ERROR);
	    }

	    /*
	    ** When arguments of update are processed, we are not aware
	    ** of the fact that this is positioned update, which requires
	    ** additional processing. For this reason, the processing has
	    ** to be done here. This is not as clean as I would like it to
	    ** be, but it looks like this is the easiest solution.
	    ** We need to walk down the resdom branch and make sure that
	    ** all of them have been declared for update. We also need to
	    ** make sure that all VAR nodes, if any, are replaced by CURVAL
	    ** nodes (that can be done in place).
	    */
	    for (rsdmnode = yacc_cb->yypvt[-2].psl_trtype;
		 rsdmnode != (PST_QNODE *) NULL &&
		    rsdmnode->pst_sym.pst_type == PST_RESDOM;
		 rsdmnode = rsdmnode->pst_left)
	    {
		PSC_RESCOL	*rescol;

		rescol = psq_ccol(cursor,
		    (DB_ATT_NAME *) rsdmnode->pst_sym.pst_value.pst_s_rsdm.
					pst_rsname);

		/*
		** A column must have been specified in the FOR UPDATE
		** clause, therefore we should complain about it being
		** not updateable. 
		*/
		if (rescol == (PSC_RESCOL *) NULL)
		{
		    (VOID) psf_error(2207L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 3,
			sizeof(cb->pss_lineno), &cb->pss_lineno,
			psf_trmwhite(DB_MAXNAME, cursor->psc_blkid.db_cur_name),
			cursor->psc_blkid.db_cur_name,
			psf_trmwhite(DB_MAXNAME,
			    rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
		    return (E_DB_ERROR);
		}

		/*
		** at this point we know that the column has been implicitly or
		** explicitly declared in the FOR UPDATE <column name list>
		*/
		/*
		** if a user has NOT specified FOR UPDATE/READONLY, we would
		** build a list of attributes consisting of all attributes of
		** the table or view over which the cursor was being defined.
		** If a cursor was defined on a view, some of the view's
		** attributes may be non-updatable because they are based on an
		** expression.  For every such attribute, a bit will be set in
		** psc_expmap.
		*/
		if (BTtest((i4) rescol->psc_attid.db_att_id,
			(char *) &cursor->psc_expmap))
		{
		    /*
		    ** this attribute may not be updated because it is based on
		    ** an expression
		    */
		    (VOID) psf_error(E_PS0402_NONUPDATABLE_COLUMN, 0L,
			PSF_USERERR, &err_code, &psq_cb->psq_error, 3,
			psf_trmwhite((u_i4) sizeof(rescol->psc_attname),
			    (char *) &rescol->psc_attname),
			(PTR) &rescol->psc_attname,
			psf_trmwhite((u_i4) sizeof(cursor->psc_tabnm),
			    cursor->psc_tabnm.db_tab_name),
			(PTR) cursor->psc_tabnm.db_tab_name,
			psf_trmwhite((u_i4) DB_MAXNAME,
			    cursor->psc_blkid.db_cur_name),
			(PTR) cursor->psc_blkid.db_cur_name);
		    return(E_DB_ERROR);
		}

		/*
		** at this point we know that the column has been implicitly or
		** explicitly declared in the FOR UPDATE <column name list> and
		** it is based on a column of a base table; the last test is to
		** determine whether a user possesses sufficient privilege to
		** update this column:
		*/
	
		if (!BTtest((i4) rescol->psc_attid.db_att_id,
			(char *) &cursor->psc_updmap))
		{
		    /*
		    ** user lacks a privilege required to update this attribute
		    */
		    (VOID) psf_error(E_PS0403_CURS_UPDT_NO_PRIV, 0L,
			PSF_USERERR, &err_code, &psq_cb->psq_error, 3,
			psf_trmwhite((u_i4) sizeof(rescol->psc_attname),
			    (char *) &rescol->psc_attname),
			(PTR) &rescol->psc_attname,
			psf_trmwhite((u_i4) sizeof(cursor->psc_tabnm),
			    cursor->psc_tabnm.db_tab_name),
			(PTR) cursor->psc_tabnm.db_tab_name,
			psf_trmwhite((u_i4) DB_MAXNAME,
			    cursor->psc_blkid.db_cur_name),
			(PTR) cursor->psc_blkid.db_cur_name);
		    return(E_DB_ERROR);
		}
	    }

	    /* create QLEND node as qualification */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT,
		    (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &qual,
		    &psq_cb->psq_error, (i4) 0);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);	/* non-zero return means error */
	    }
	}

	/* Make the root node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&yyvarsp->from_list);
	root.pst_tvrc   = BTcount((char *) &yyvarsp->from_list, BITS_IN(yyvarsp->from_list));
	MEcopy((char *)&yyvarsp->from_list, sizeof(PST_J_MASK),
					(char *)&root.pst_tvrm);

	/*
	** If the FROM list contained any joins, merge the join_search quals
	** with the qualification of the subselect
	*/

	if (yyvarsp->j_qual->pss_qual != (PST_QNODE *) NULL)
	{
	    if (!qual || qual->pst_sym.pst_type == PST_QLEND)
	    {
		qual = yyvarsp->j_qual->pss_qual;
	    }
	    else
	    {
		status = pst_node(cb, &cb->pss_ostream, qual,
		    yyvarsp->j_qual->pss_qual, PST_AND, (PTR) NULL,
		    sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		    (DB_ANYTYPE *) NULL, &qual, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		    return (status);
	    }

	    /*
	    ** Note that we need not "discard" this PSS_J_QUAL node, since it
	    ** was allocated on stack and should be kept around.  We do have to
	    ** make sure that the qual pointer is set to NULL, though.  Not
	    ** doing so inside a dbproc could prove to be disasterous.
	    */
	    yyvarsp->j_qual->pss_qual = (PST_QNODE *) NULL;
	}

	status = pst_node(cb, &cb->pss_ostream, yacc_cb->yypvt[-2].psl_trtype, qual, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_INT_TYPE, (i2) 0, (i4) 4,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* Now check the target list to see if there are any
	** resdoms with pst_ttargtype of PST_USER, if so
	** convert them to PST_ATTNO.
	*/
	for (rsdmnode = rootnode->pst_left;
	 rsdmnode != (PST_QNODE *) NULL && 
	 rsdmnode->pst_sym.pst_type == PST_RESDOM;
	 rsdmnode = rsdmnode->pst_left)
	{
	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		== PST_USER)
	    {
		rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		    = PST_ATTNO;
	    }
	}

	/* For repeat queries we must determine if the query is shareable.
	** We already know that this is an SQL query, so the only criterion
	** to be checked out is whether all relations/views are DBA owned or
	** are catalogs.
	*/
	if (cb->pss_defqry == PSQ_DEFQRY)
	{
	    status = psl_shareable(psq_cb, cb,&yyvarsp->qp_shareable, &yyvarsp->shr_qryinfo);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}

	/* Apply the qrymod algorithm (views, permits, integrities) */
	status = psy_qrymod(rootnode, cb, psq_cb, &yyvarsp->join_id,
	    &qrymod_resp_mask);
	if (status != E_DB_OK)
	    return (status);

	/*
	** if processing UPDATE WHERE CURRENT OF CURSOR, we delayed replacing
	** PST_VAR with PST_CURVAL until now to make life easier for psy_view()
	*/
	if (psq_cb->psq_mode == PSQ_REPCURS)
	{
	    for (rsdmnode = rootnode->pst_left;
		 rsdmnode != (PST_QNODE *) NULL &&
		    rsdmnode->pst_sym.pst_type == PST_RESDOM;
		 rsdmnode = rsdmnode->pst_left)
	    {
		status = psl_curval(cb, psq_cb, cursor, &rsdmnode->pst_right);
		if (DB_FAILURE_MACRO(status))
		{
		    return (status);
		}
	    }
	}

	tbl_stat_mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	tbl_2_stat_mask = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/* Make sure base table is updateable;
	** In case of an index or a non-extended catalog
	** catalog update privilege must be on.
	** In case of security catalog make sure session has
	** security privilege active.
	** Bug 34079, since 6.0 you were never supposed to be 
        ** able to update a secondary index.  Fixed it so 
        ** the same error is returned whether you have update 
        ** syscat or not (jennifer)
	**
	** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
	** allow UPDATE on indexes which are non-extended catalogs
	*/
        if (tbl_2_stat_mask & DMT_READONLY)
        {
            (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L, PSF_USERERR,
                         &err_code, &psq_cb->psq_error, 0);
            return(E_DB_ERROR);
        }
	else if (tbl_stat_mask & DMT_IDX)
	{
	    if (!(   tbl_stat_mask & DMT_CATALOG
		  && ~tbl_stat_mask & DMT_EXTENDED_CAT
		  && cb->pss_ses_flag & PSS_CATUPD
		  && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
		 )
	       )
	    {
		_VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
		        (char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return(E_DB_ERROR);
	    }
	}
	else if ( ( (tbl_stat_mask & DMT_CATALOG
		     	|| tbl_2_stat_mask & DMT_TEXTENSION)
		 && ~tbl_stat_mask & DMT_EXTENDED_CAT
		 && !(cb->pss_ses_flag & PSS_CATUPD))
		     ||
		     ((tbl_stat_mask & DMT_SECURE) &&
        	       !(cb->pss_ustat & DU_USECURITY)))
	{
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_UPDATE, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_REPLACE, &e_error);
		if (local_status > status)
		    status = local_status;
	    _VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	cb->pss_qualdepth--;

	mask=(yyvarsp->isdbp) ? 0 : PST_0FULL_HEADER,

	/* Make the header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, (mask | hdr_mask), &yyvarsp->xlated_qry);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = yyvarsp->join_id;

	/* Fix the root in QSF */
	if (pnode != (PST_PROCEDURE *) NULL)
	{
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}
	yacc_cb->yyval.psl_qttype = tree;
    } break;

case 1827:
if (!((*yyvarspp)->bypass_actions))
/* # line 41304 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;

	psq_cb->psq_mode = PSQ_REPLACE;

	/* Open memory stream for allocating query tree */
	if (yyvarsp->isdbp == FALSE)
	{
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error)) != E_DB_OK)
	    {
		return (status);    /* non-zero return means error */
	    }
	}
	else
	{
	    /*
	    ** To indicate that in 'i= :i' in a subselect the first
	    ** "i" must not be processed as a local var (bug 8269).
	    */
	    yyvarsp->dbpinfo->pss_flags |= PSS_1SUB_SEEN;
	}

	MEfill(sizeof(PST_J_MASK), 0, (char *)&yyvarsp->flists[++cb->pss_qualdepth]);

	/* Start off with no columns */
	cb->pss_rsdmno = 0;
    } break;

case 1829:
if (!((*yyvarspp)->bypass_actions))
/* # line 41336 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	yacc_cb->yyval.psl_trtype = pst_tlprpnd(yacc_cb->yypvt[-2].psl_trtype, yacc_cb->yypvt[-0].psl_trtype);

    } break;

case 1830:
if (!((*yyvarspp)->bypass_actions))
/* # line 41346 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PST_QNODE	       *resdomnode;
        DB_ATT_NAME	       colname;

	/* normalize the attribute name */
	STmove((char *)yacc_cb->yypvt[-2].psl_strtype, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *) &colname);

	/*
	** pst_adresdom will check if $1 is a column of updated relation.
	*/
	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL, yacc_cb->yypvt[-0].psl_trtype,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1831:
if (!((*yyvarspp)->bypass_actions))
/* # line 41365 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS              status;
	PST_QNODE	       *resdomnode, *constnode;
        DB_ATT_NAME	       colname;
	DMT_ATT_ENTRY	       *coldesc;
	i4		       err_code;
	DB_ERROR	       err_blk;

	/* normalize the attribute name */
	STmove((char *)yacc_cb->yypvt[-2].psl_strtype, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *) &colname);

	coldesc = pst_coldesc(cb->pss_resrng, &colname);
	if (coldesc == (DMT_ATT_ENTRY *) NULL)
	{
	    /* Couldn't find the column. */
	    psf_error(2100L, 0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 4,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &cb->pss_resrng->pss_ownname),
		&cb->pss_resrng->pss_ownname,
		psf_trmwhite(sizeof(DB_ATT_NAME), (char *)&colname), 
		&colname);
	    return (E_DB_ERROR);
	}

	if (coldesc->att_flags & DMT_F_NDEFAULT ||
	    (coldesc->att_type > 0 && 
		EQUAL_CANON_DEF_ID(coldesc->att_defaultID, 
						DB_DEF_NOT_SPECIFIED)))
	{
	    /* Mandatory column value not present */
	    (void) psf_error(2779L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, psf_trmwhite(sizeof(DB_ATT_NAME),
			(char *) &colname), &colname);
	    return(E_DB_ERROR);
	}
	status = psl_make_default_node(cb, &cb->pss_ostream, cb->pss_resrng, 
			coldesc->att_number, &constnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** pst_adresdom will check if $1 is a column of updated relation
	** (though it doesn't need to, because pst_coldesc() already did).
	*/
	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL,
	    constnode, cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1832:
if (!((*yyvarspp)->bypass_actions))
/* # line 41421 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	PST_QNODE	*newnode;
	PST_QNODE	*resdomnode;
	PST_CNST_NODE	pst_cnst_node;
	DB_DT_ID	datatype;
	i2		dataprec;
	i4		datalen;
	i4		err_code;
        DB_ATT_NAME	colname;

	/* normalize the attribute name */
	STmove((char *)yacc_cb->yypvt[-2].psl_strtype, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *) &colname);

	/*
	** pst_adresdom will check if $1 is a column of updated relation.
	*/
	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL, 
	    (PST_QNODE *) NULL, cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** Verify if column to be updated is nullable.
	*/
	datatype = resdomnode->pst_sym.pst_dataval.db_datatype;
	dataprec = resdomnode->pst_sym.pst_dataval.db_prec;
	datalen = resdomnode->pst_sym.pst_dataval.db_length;
	if (datatype > 0)
	{
	    /* nonnullable data type */
	    (VOID) psf_error(2780L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
	    return (E_DB_ERROR);
	}

	/*
	** Create a constant node for the NULL value.
	*/
	pst_cnst_node.pst_tparmtype = PST_USER;
	pst_cnst_node.pst_parm_no = 0;
	pst_cnst_node.pst_pmspec = PST_PMNOTUSED;
	pst_cnst_node.pst_cqlang = DB_SQL;
	pst_cnst_node.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &pst_cnst_node,
	    sizeof (PST_CNST_NODE), datatype, dataprec, datalen,
	    (DB_ANYTYPE *) "1", &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Initialize the value associated with the const node to NULL.
	*/
	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, 
			       &newnode->pst_sym.pst_dataval);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Hook up the const node to resdom node.
	*/
	resdomnode->pst_right = newnode;

	yacc_cb->yyval.psl_trtype = resdomnode;
    } break;

case 1833:
if (!((*yyvarspp)->bypass_actions))
/* # line 41494 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** for DELETE and UPDATE we need to notify SCF if no qualification was
	** provided; as of now where_cur is only used by DELETE and UPDATE, so
	** we don't need to check query mode.
	** We only need to notify SCF if the DELETE/UPDATE is part of a
	** PREPARE statement. Bug 106509.
	*/
	if ( (cb->pss_defqry == PSQ_PREPARE) &&
	     (yacc_cb->yypvt[-0].psl_trtype->pst_sym.pst_type == PST_QLEND) )
	    psq_cb->psq_flag |= PSQ_ALLDELUPD;
	else
	    psq_cb->psq_flag &= ~PSQ_ALLDELUPD;

	yacc_cb->yyval.psl_trtype = yacc_cb->yypvt[-0].psl_trtype;
    } break;

case 1834:
if (!((*yyvarspp)->bypass_actions))
/* # line 41511 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	PSC_CURBLK             *cursor;
	DB_STATUS	       status;
	i4		       err_code;

	/* Look up the cursor */
	status = psq_crfind(cb, yacc_cb->yypvt[-0].psl_cursid, &cursor, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return(status);

	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-0].psl_cursid->db_cur_name), yacc_cb->yypvt[-0].psl_cursid->db_cur_name);
	    return (E_DB_ERROR);
	}

	if (psq_cb->psq_mode == PSQ_DELETE)
	{
	    psq_cb->psq_mode = PSQ_DELCURS;

	    /* check for delete permission */
	    if (cursor->psc_delall == FALSE)
	    {
		(VOID) psf_error(2211L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, yacc_cb->yypvt[-0].psl_cursid->db_cur_name), yacc_cb->yypvt[-0].psl_cursid->db_cur_name);
		return (E_DB_ERROR);
	    }
	}
	else if (psq_cb->psq_mode == PSQ_REPLACE)
	{
	    psq_cb->psq_mode = PSQ_REPCURS;
	}

	/* Hand found cursor id back to caller */
	STRUCT_ASSIGN_MACRO(cursor->psc_blkid, psq_cb->psq_cursid);

	/* type casting only for the compiler and lint */
	yacc_cb->yyval.psl_trtype = (PST_QNODE *) cursor;
    } break;
	}
	return(0);
}

i4
psls41iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1835:
if (!((*yyvarspp)->bypass_actions))
/* # line 41561 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_cursid = yacc_cb->yypvt[-0].psl_cursid;
    } break;

case 1836:
if (!((*yyvarspp)->bypass_actions))
/* # line 41565 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** A Dynamic SQL cursor name from the user.  The zero assignment
	** indicates to look this cursor up by name alone.
	*/
	psq_cb->psq_cursid.db_cursor_id[0] = 0;
	psq_cb->psq_cursid.db_cursor_id[1] = 0;
	STmove((char *)yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, psq_cb->psq_cursid.db_cur_name);
	yacc_cb->yyval.psl_cursid = &psq_cb->psq_cursid;
    } break;

case 1837:
if (!((*yyvarspp)->bypass_actions))
/* # line 41578 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	DB_STATUS	status;
	DB_IICOMMENT	*comment;
	PTR		p;

	/* At least one of long_remark, short_remark must be specified */
	if (yacc_cb->yypvt[-1].psl_textype == (DB_TEXT_STRING *) NULL && yacc_cb->yypvt[-0].psl_textype == (DB_TEXT_STRING *) NULL)
	{
	    (VOID) psf_error(E_PS0BA2_NO_REMARK_SPECIFIED, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** to get to this point we must have at least 1 remark specified,
	** and it has been determined that comment object exists
	*/

	/* Allocate DB_1_IICOMMENT structure */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_1_IICOMMENT),
			    &p, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	comment = &((DB_1_IICOMMENT *) p)->dbc_tuple;
	((DB_1_IICOMMENT *) p)->dbc_flag = 0;
	
	/* initialize II_DBCOMMENT tuple */
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid, comment->dbc_tabid);
	comment->dbc_type = ((comment->dbc_attid = (i2) yacc_cb->yypvt[-2].psl_inttype) == 0L)
							? DBC_T_TABLE
							: DBC_T_COLUMN;

	if (yacc_cb->yypvt[-1].psl_textype == (DB_TEXT_STRING *) NULL)
	{
	    /* long remark was not specified */
	    comment->dbc_len_long = (u_i2) 0;
	}
	else
	{
	    MEcopy((PTR) yacc_cb->yypvt[-1].psl_textype->db_t_text,
	           (comment->dbc_len_long = yacc_cb->yypvt[-1].psl_textype->db_t_count),
		   (PTR) comment->dbc_long);
	    ((DB_1_IICOMMENT *) p)->dbc_flag |= DBC_LR_SPECIFIED;
	}

	if (yacc_cb->yypvt[-0].psl_textype == (DB_TEXT_STRING *) NULL)
	{
	    /* short remark was not specified */
	    MEfill(DBC_L_SHORT, (u_char) ' ', (PTR) comment->dbc_short);
	}
	else
	{
	    MEmove(yacc_cb->yypvt[-0].psl_textype->db_t_count, (PTR) yacc_cb->yypvt[-0].psl_textype->db_t_text, (char) ' ',
	           DBC_L_SHORT, (PTR) comment->dbc_short);
	    ((DB_1_IICOMMENT *) p)->dbc_flag |= DBC_SR_SPECIFIED;
	}

	comment->dbc_sequence = (i2) 0;

	((PSY_CB *) cb->pss_object)->psy_tupptr = p;
    } break;

case 1838:
if (!((*yyvarspp)->bypass_actions))
/* # line 41644 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_COMMENT;

	/* "COMMENT" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("COMMENT")-1, "COMMENT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the COMMENT statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    } break;

case 1839:
if (!((*yyvarspp)->bypass_actions))
/* # line 41667 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;

	if (yacc_cb->yypvt[-0].psl_objspec->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_owner,
		&yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &yacc_cb->yypvt[-0].psl_objspec->pss_obj_name, cb,
		TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (MEcmp((PTR) &resrange->pss_ownname, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    DB_ERROR	e_error;
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, yacc_cb->yypvt[-0].psl_objspec, rngvar_info,
		    sizeof("COMMENT") - 1, "COMMENT", &psq_cb->psq_error);
	    }
	    /*
	    ** must audit failure to comment
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		status = psy_secaudit(FALSE, cb, resrange->pss_tabname.db_tab_name,
			&resrange->pss_ownname, sizeof(resrange->pss_tabname),
			SXF_E_TABLE, I_SX2039_TBL_COMMENT,
			SXF_A_FAIL | SXF_A_CONTROL, 
			&e_error);
	    }

	    /*
	    ** user definitely may not add/change a comment on someone else's
	    ** table
	    */
	    (VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("COMMENT") - 1, "COMMENT",
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &resrange->pss_ownname),
		&resrange->pss_ownname);

		return(E_DB_ERROR);
	}

	STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
			    ((PSY_CB *) cb->pss_object)->psy_tabname[0]);
	cb->pss_resrng = resrange;

	yacc_cb->yyval.psl_inttype = 0L;
    } break;

case 1840:
if (!((*yyvarspp)->bypass_actions))
/* # line 41749 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DMT_ATT_ENTRY   *attribute;
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;

	/*
	** figure out if the column exists;
	** column name was stored in comment_col production
	*/
	attribute = pst_coldesc(cb->pss_resrng,
			&((PSY_COL *) psy_cb->psy_colq.q_next)->psy_colnm);

	/* Check for attribute not found */
	if (attribute == (DMT_ATT_ENTRY *) NULL)
	{
	    char	*colnm;

	    colnm = (char *) &((PSY_COL *) psy_cb->psy_colq.q_next)->psy_colnm;

	    (VOID) psf_error(E_PS0BA3_NONEXISTENT_COLUMN, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 2,
			psf_trmwhite(sizeof(DB_TAB_NAME), 
			    (char *) psy_cb->psy_tabname),
			psy_cb->psy_tabname,
			psf_trmwhite(sizeof(DB_ATT_NAME), colnm), colnm);

	    return(E_DB_ERROR);
	}
	else
	{
	    yacc_cb->yyval.psl_inttype = attribute->att_intlid;		
	}
    } break;

case 1841:
if (!((*yyvarspp)->bypass_actions))
/* # line 41785 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* column */

	yyvarsp->col_ref.pss_tab_name = (char *) NULL;
	yyvarsp->col_ref.pss_col_name = yacc_cb->yypvt[-0].psl_strtype;
	yyvarsp->col_ref.pss_flags = 0;

	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1842:
if (!((*yyvarspp)->bypass_actions))
/* # line 41795 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* table.column or corr_name.column */

	yyvarsp->col_ref.pss_flags = PSS_TBL_OR_CORR_NAME_SPECIFIED;
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = yacc_cb->yypvt[-0].psl_strtype;

	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1843:
if (!((*yyvarspp)->bypass_actions))
/* # line 41812 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* <schema>.table.column */

	/* If this is a modify statement, it's possible that the alternate
	** keyword set is turned on, and SESSION won't be recognized as
	** a keyword -- recognize it by hand here.
	*/
	if (STcompare(yacc_cb->yypvt[-4].psl_strtype,"session") == 0)
	{
	    if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		yacc_cb->yypvt[-2].psl_strtype, &psq_cb->psq_error))
	    {
		return(E_DB_ERROR);
	    }

	    STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, yyvarsp->col_ref.pss_schema_name);
	}
	else
	{
	    MEmove(STlength(yacc_cb->yypvt[-4].psl_strtype), (PTR) yacc_cb->yypvt[-4].psl_strtype, ' ',
		    sizeof(yyvarsp->col_ref.pss_schema_name),
		    (PTR) &yyvarsp->col_ref.pss_schema_name);
	}
	yyvarsp->col_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = yacc_cb->yypvt[-0].psl_strtype;
	    
	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1844:
if (!((*yyvarspp)->bypass_actions))
/* # line 41842 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* $DBA.table.column */

	yyvarsp->id_type = PSS_ID_DBA;
	yyvarsp->col_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	MEmove(STlength(cb->pss_dbaname), (PTR) cb->pss_dbaname, ' ',
	    sizeof(yyvarsp->col_ref.pss_schema_name),
	    (PTR) &yyvarsp->col_ref.pss_schema_name);
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = yacc_cb->yypvt[-0].psl_strtype;
	    
	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1845:
if (!((*yyvarspp)->bypass_actions))
/* # line 41856 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* $INGRES.table.column */

	yyvarsp->id_type = PSS_ID_INGRES;
	yyvarsp->col_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	MEmove(sizeof(*cb->pss_cat_owner), (PTR) cb->pss_cat_owner, ' ',
	    sizeof(yyvarsp->col_ref.pss_schema_name),
	    (PTR) &yyvarsp->col_ref.pss_schema_name);
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = yacc_cb->yypvt[-0].psl_strtype;
	    
	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1846:
if (!((*yyvarspp)->bypass_actions))
/* # line 41895 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* session.table.column */
	/* See also above: id.id.id */

	if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		yacc_cb->yypvt[-2].psl_strtype, &psq_cb->psq_error))
	{
	    return(E_DB_ERROR);
	}

	yyvarsp->col_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, yyvarsp->col_ref.pss_schema_name);
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = yacc_cb->yypvt[-0].psl_strtype;
	    
	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1847:
if (!((*yyvarspp)->bypass_actions))
/* # line 41915 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* table.* or corr_name.* */

	yyvarsp->col_ref.pss_flags = PSS_TBL_OR_CORR_NAME_SPECIFIED | PSS_ALL_COLUMNS;
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = (char *) NULL;

	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1848:
if (!((*yyvarspp)->bypass_actions))
/* # line 41932 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* <schema>.table.* */

	yyvarsp->col_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	MEmove(STlength(yacc_cb->yypvt[-4].psl_strtype), (PTR) yacc_cb->yypvt[-4].psl_strtype, ' ',
	    sizeof(yyvarsp->col_ref.pss_schema_name),
	    (PTR) &yyvarsp->col_ref.pss_schema_name);
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = (char *) NULL;
	    
	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1849:
if (!((*yyvarspp)->bypass_actions))
/* # line 41946 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* $DBA.table.* */

	yyvarsp->col_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	MEmove(STlength(cb->pss_dbaname), (PTR) cb->pss_dbaname, ' ',
	    sizeof(yyvarsp->col_ref.pss_schema_name),
	    (PTR) &yyvarsp->col_ref.pss_schema_name);
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = (char *) NULL;
	    
	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1850:
if (!((*yyvarspp)->bypass_actions))
/* # line 41960 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* $INGRES.table.* */

	yyvarsp->col_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	MEmove(sizeof(*cb->pss_cat_owner), (PTR) cb->pss_cat_owner, ' ',
	    sizeof(yyvarsp->col_ref.pss_schema_name),
	    (PTR) &yyvarsp->col_ref.pss_schema_name);
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = (char *) NULL;
	    
	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1851:
if (!((*yyvarspp)->bypass_actions))
/* # line 42001 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* session.table.* */

	if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		yacc_cb->yypvt[-2].psl_strtype, &psq_cb->psq_error))
	{
	    return(E_DB_ERROR);
	}

	yyvarsp->col_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, yyvarsp->col_ref.pss_schema_name);
	yyvarsp->col_ref.pss_tab_name = yacc_cb->yypvt[-2].psl_strtype;
	yyvarsp->col_ref.pss_col_name = (char *) NULL;

	yacc_cb->yyval.psl_col_ref = &yyvarsp->col_ref;
    } break;

case 1852:
if (!((*yyvarspp)->bypass_actions))
/* # line 42021 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	status = psl_comment_col(cb, psq_cb, yacc_cb->yypvt[-0].psl_col_ref);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    } break;

case 1853:
if (!((*yyvarspp)->bypass_actions))
/* # line 42033 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	if (yacc_cb->yypvt[-0].psl_textype->db_t_count > DBC_L_LONG)
	{
	    i4	    max_len = (i4) DBC_L_LONG;

	    (VOID) psf_error(E_PS0BA1_LONG_REMARK_TOO_LONG, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     sizeof(i4), &max_len);
	    return (E_DB_ERROR);
	}
	else
	{
	    yacc_cb->yyval.psl_textype = yacc_cb->yypvt[-0].psl_textype;
	}
    } break;

case 1854:
if (!((*yyvarspp)->bypass_actions))
/* # line 42051 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_textype = (DB_TEXT_STRING *) NULL;
    } break;

case 1855:
if (!((*yyvarspp)->bypass_actions))
/* # line 42057 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4	    err_code;

	/* if(1) - temporary fix for compiler warnings till following code is
                  completed */

	if (yacc_cb->yypvt[-0].psl_textype->db_t_count > DBC_L_SHORT)
	{
	    i4	    max_len = (i4) DBC_L_SHORT;

	    (VOID) psf_error(E_PS0BA0_SHORT_REMARK_TOO_LONG, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     sizeof(i4), &max_len);
	    return (E_DB_ERROR);
	}
	else
	{
	    yacc_cb->yyval.psl_textype = yacc_cb->yypvt[-0].psl_textype;
	}
    } break;

case 1856:
if (!((*yyvarspp)->bypass_actions))
/* # line 42078 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_textype = (DB_TEXT_STRING *) NULL;
    } break;

case 1857:
if (!((*yyvarspp)->bypass_actions))
/* # line 42084 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{


	psq_cb->psq_mode = PSQ_SET_SESS_AUTH_ID;
    } break;

case 1858:
if (!((*yyvarspp)->bypass_actions))
/* # line 42090 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

	/*
	** user must have DB_ADMIN privilege in order to issue
	** SET SESSION AUTHORIZATION
	*/

	status = psy_ckdbpr(psq_cb, (u_i4) DBPR_DB_ADMIN);

	if (DB_FAILURE_MACRO(status))
	{
	    i4	err_code;

	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	error;
		DB_STATUS	local_stat;
		char	*objname;
		i4		objlength;
		i4	msg_id;

		/*
		** failure to execute SET SESSION AUTHORIZATION due to insufficient
		** privilege must be audited
		*/
		msg_id     = I_SX2033_SET_USER_AUTH;

		if (psq_cb->psq_ret_flag & PSQ_USE_SESSION_USER)
		{
		    objname    = ERx("\"SESSION USER\"");
		    objlength  = sizeof(ERx("\"SESSION USER\""));
		}
		else if (psq_cb->psq_ret_flag & PSQ_USE_SYSTEM_USER)
		{
		    objname    = ERx("\"SYSTEM USER\"");
		    objlength  = sizeof(ERx("\"SYSTEM USER\""));
		}
		else if (psq_cb->psq_ret_flag & PSQ_USE_CURRENT_USER)
		{
		    objname    = ERx("\"CURRENT USER\"");
		    objlength  = sizeof(ERx("\"CURRENT USER\""));
		}
		else if (psq_cb->psq_ret_flag & PSQ_USE_INITIAL_USER)
		{
		    objname    = ERx("\"INITIAL_USER\"");
		    objlength  = sizeof(ERx("\"INITIAL_USER\""));
		}
		/* check for dynamic query parameter */
		else if (cb->pss_defqry == PSQ_PREPARE &&
			 cb->pss_highparm != -1)
		{
		    objname    = ERx("\"DYNAMIC PARAMETER\"");
		    objlength  = sizeof(ERx("\"DYNAMIC PARAMETER\""));
		}
		else
		{
		    objname = psq_cb->psq_user.db_tab_own.db_own_name;
		    objlength  = sizeof(DB_OWN_NAME);
		}

		local_stat = psy_secaudit(FALSE, cb,
			    objname, (DB_OWN_NAME *)NULL,
			    objlength, SXF_E_USER,
			    msg_id, SXF_A_FAIL | SXF_A_SELECT,
			    &error);

		if (local_stat > status)
		    status = local_stat;
	    }

	    (VOID) psf_error(E_PS0354_SETID_INSUF_PRIV, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(status);
	}
    } break;

case 1859:
if (!((*yyvarspp)->bypass_actions))
/* # line 42169 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* store new user id in PSQ_CB */
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', DB_MAXNAME, (char *) &psq_cb->psq_user);
    } break;

case 1860:
if (!((*yyvarspp)->bypass_actions))
/* # line 42174 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* will reset the effective user identifier to the value of $DBA */
	STmove(cb->pss_dbaname, ' ', DB_MAXNAME, (char *) &psq_cb->psq_user);
    } break;

case 1861:
if (!((*yyvarspp)->bypass_actions))
/* # line 42179 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* will reset the effective user identifier to $ingres */
	MEmove(sizeof(*cb->pss_cat_owner), (PTR)cb->pss_cat_owner, ' ',
		DB_MAXNAME, (PTR) &psq_cb->psq_user);
    } break;

case 1862:
if (!((*yyvarspp)->bypass_actions))
/* # line 42185 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* a rather meaningless query until mofule language is supported */
	psq_cb->psq_ret_flag |= PSQ_USE_CURRENT_USER;
    } break;

case 1863:
if (!((*yyvarspp)->bypass_actions))
/* # line 42190 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* another meaningless query until mofule language is supported */
	psq_cb->psq_ret_flag |= PSQ_USE_CURRENT_USER;
    } break;

case 1864:
if (!((*yyvarspp)->bypass_actions))
/* # line 42195 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* this query will NEVER have any effect */
	psq_cb->psq_ret_flag |= PSQ_USE_SESSION_USER;
    } break;
	}
	return(0);
}

i4
psls42iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1865:
if (!((*yyvarspp)->bypass_actions))
/* # line 42200 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** will reset the effective user identifier to the identifier of the
	** "real" user
	*/
	psq_cb->psq_ret_flag |= PSQ_USE_SYSTEM_USER;
    } break;

case 1866:
if (!((*yyvarspp)->bypass_actions))
/* # line 42208 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** will reset the effective user identifier to that in effect at
	** session startup
	*/
	psq_cb->psq_ret_flag |= PSQ_USE_INITIAL_USER;
    } break;

case 1867:
if (!((*yyvarspp)->bypass_actions))
/* # line 42216 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	u_i4	    len, save_len, id_len = DB_MAXNAME;
	i4	    leading_blanks;
	char	    *c = (char *) yacc_cb->yypvt[-0].psl_textype->db_t_text;
	DB_STATUS   status;

	/*
	** according to SQL92, we need to strip off leading and trailing blanks
	** from the contents of the string constant and only then may we verify
	** that the remainder represents a valid identifier
	*/

	len = psf_trmwhite((u_i4) yacc_cb->yypvt[-0].psl_textype->db_t_count, c);

	for (leading_blanks = 0; CMspace(c); leading_blanks++, CMnext(c))
	;

	/*
	** we are saving length of the string to be passed to
	** cui_idxlate() so that we can ensure that the entire string
	** was "consumed" by it
	*/
	save_len = len -= leading_blanks;

	status = cui_idxlate((u_char *) c, &len, (u_char *) &psq_cb->psq_user,
			     &id_len, (u_i4) *cb->pss_dbxlate,
			     (u_i4 *) NULL, &psq_cb->psq_error);

	if (save_len != len || DB_FAILURE_MACRO(status))
	{
	    i4	err_code;

	    psf_error(E_PS0359_NOT_A_VALID_AUTH_ID, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) save_len, (PTR) c);

	    return(E_DB_ERROR);
	}

	/* fill the rest of psq_cb->psq_user with blanks */
	if (id_len < DB_MAXNAME)
	{
	    MEfill((DB_MAXNAME - id_len), (u_char) ' ',
		(PTR) ((char *) &psq_cb->psq_user + id_len));
	}
    } break;

case 1868:
if (!((*yyvarspp)->bypass_actions))
/* # line 42263 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_TEXT_STRING	    *str;
	DB_STATUS	    status;
	u_i4		    len, save_len, id_len = DB_MAXNAME;
	i4		    leading_blanks;
	char		    *c;
	DB_DT_ID	    totype;

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = (yacc_cb->yypvt[-0].psl_dbval->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;

	status = qdata_cvt(cb, psq_cb, yacc_cb->yypvt[-0].psl_dbval, totype, (PTR *) &str);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	/*
	** according to SQL92, we need to strip off leading and trailing blanks
	** from the contents of the string constant and only then may we verify
	** that the remainder represents a valid identifier
	*/

	c = (char *) str->db_t_text;

	len = psf_trmwhite((u_i4) str->db_t_count, c);

	for (leading_blanks = 0; CMspace(c); leading_blanks++, CMnext(c))
	;

	/*
	** we are saving length of the string to be passed to
	** cui_idxlate() so that we can ensure that the entire string
	** was "consumed" by it
	*/
	save_len = len -= leading_blanks;

	status = cui_idxlate((u_char *) c, &len, (u_char *) &psq_cb->psq_user,
			     &id_len, (u_i4) *cb->pss_dbxlate,
			     (u_i4 *) NULL, &psq_cb->psq_error);

	if (save_len != len || DB_FAILURE_MACRO(status))
	{
	    i4	err_code;

	    psf_error(E_PS0359_NOT_A_VALID_AUTH_ID, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) save_len, (PTR) c);

	    return(E_DB_ERROR);
	}

	/* fill the rest of psq_cb->psq_user with blanks */
	if (id_len < DB_MAXNAME)
	{
	    MEfill((DB_MAXNAME - id_len), (u_char) ' ',
		(PTR) ((char *) &psq_cb->psq_user + id_len));
	}
    } break;

case 1869:
if (!((*yyvarspp)->bypass_actions))
/* # line 42326 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* dynamic parameter marker may only occur when preparing a statement */
	if (cb->pss_defqry != PSQ_PREPARE)
	{
	    i4	err_code;

	    (VOID) psf_error(2306L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}

	++cb->pss_highparm;
	if (yyvarsp->in_target_clause)
	   ++cb->pss_targparm;
    } break;

case 1870:
if (!((*yyvarspp)->bypass_actions))
/* # line 42372 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/*
	**	Check if distributed or not
	*/
	/* REGISTER TABLE AS LINK|NATIVE is allowed ONLY in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;

	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		STlength("REGISTER ... LINK"), "REGISTER ... LINK");
	    return (E_DB_ERROR);
	}

	status = psl_rg1_reg_distr_tv(cb, yacc_cb->yypvt[-4].psl_objspec, yacc_cb->yypvt[-5].psl_tytype, &yyvarsp->xlated_qry, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1871:
if (!((*yyvarspp)->bypass_actions))
/* # line 42397 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DD_NAME),
	  ((QED_DDL_INFO *) cb->pss_object)->qed_d6_tab_info_p->dd_t1_tab_name);

	cb->pss_distr_sflags |= PSS_LDB_TABLE;

	if (yyvarsp->id_type == PSS_ID_SCONST)
	{
	    cb->pss_distr_sflags |= PSS_QUOTED_TBLNAME;
	}
	else if (yyvarsp->id_type == PSS_ID_DELIM)
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;
    } break;

case 1872:
if (!((*yyvarspp)->bypass_actions))
/* # line 42412 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DD_2LDB_TAB_INFO	*ldb_tab_info =
	                   ((QED_DDL_INFO *) cb->pss_object)->qed_d6_tab_info_p;
			   
	STmove(yacc_cb->yypvt[-2].psl_strtype, ' ', sizeof(DD_NAME), ldb_tab_info->dd_t2_tab_owner);
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DD_NAME), ldb_tab_info->dd_t1_tab_name);

	cb->pss_distr_sflags |= PSS_LDB_TABLE;

	if (yyvarsp->id_type == PSS_ID_SCONST)
	{
	    cb->pss_distr_sflags |= PSS_QUOTED_TBLNAME;
	}
	else if (yyvarsp->id_type == PSS_ID_DELIM)
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;
    } break;

case 1874:
if (!((*yyvarspp)->bypass_actions))
/* # line 42432 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	cb->pss_distr_sflags &= ~(PSS_DELIM_OWNNAME|PSS_DELIM_TBLNAME);
    } break;

case 1875:
if (!((*yyvarspp)->bypass_actions))
/* # line 42438 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yyvarsp->id_type == PSS_ID_SCONST)
	{
	    cb->pss_distr_sflags |= PSS_QUOTED_OWNNAME;
	}
	else if (yyvarsp->id_type == PSS_ID_DELIM)
	{
	    cb->pss_distr_sflags |= PSS_DELIM_OWNNAME;
	}
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1876:
if (!((*yyvarspp)->bypass_actions))
/* # line 42452 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;

	/* we are done processing the new object names */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
	
	if (!STcompare("native", yacc_cb->yypvt[-0].psl_strtype))
	{
	    cb->pss_stmt_flags |= PSS_REG_AS_NATIVE;
	}
	else if (STcompare("link", yacc_cb->yypvt[-0].psl_strtype))
	{
	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
			     &cb->pss_lineno, STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 1877:
if (!((*yyvarspp)->bypass_actions))
/* # line 42473 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* REGISTER [TABLE|VIEW|PROCEDURE] */

	i4		err_code;
	DB_STATUS	status;

	i4 val1;
	i4 val2;
    	char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

        if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
        {
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"Read REGISTER keyword (value %d)\n", yacc_cb->yypvt[-0].psl_tytype);
        }

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /*
	    **	Distributed
	    */
	    psq_cb->psq_mode = PSQ_REG_LINK;
	    status = psl_rg3_reg_tvi(cb, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	else
	{
	    /* 
	    ** Must be GW register - GW will fail later if its wrong.
	    ** We allow both REGISTER and REGISTER TABLE as 
	    ** identical to GW. (only REGISTER VIEW fails here since GW can't
	    ** register a view)
	    */

	    if (yacc_cb->yypvt[-0].psl_tytype == DD_2OBJ_TABLE || yacc_cb->yypvt[-0].psl_tytype== -1)
	    {
	        if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
	        {
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"Turning REGISTER [TABLE] into REGISTER IMPORT\n");
	        }

		psq_cb->psq_mode = PSQ_REG_IMPORT;
		yacc_cb->yypvt[-0].psl_tytype = DD_2OBJ_TABLE;
		status = psl_ct10_crt_tbl_kwd(cb, psq_cb,
				&yyvarsp->with_clauses, (i4) 0);
		if (DB_FAILURE_MACRO(status))
		    return (status);
		yyvarsp->with_dups = -1;
		yyvarsp->with_journaling = -1;
	    }
	    else
	    {
		if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"Generating error on REGISTER VIEW in non-distributed\n");
		}

		(VOID) psf_error(3083L, 0L, PSF_USERERR, &err_code,
			 &psq_cb->psq_error,2,
			(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
			 (i4) sizeof("VIEW")-1, "VIEW");

		return (E_DB_ERROR);
	    }
	}

	/* we are about to process new object names */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;

	yacc_cb->yyval.psl_tytype = yacc_cb->yypvt[-0].psl_tytype;
    } break;

case 1878:
if (!((*yyvarspp)->bypass_actions))
/* # line 42550 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	/* treat as gateway if not STAR session */

	/* test object name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct12_crname(cb, psq_cb, yacc_cb->yypvt[-0].psl_objspec);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    status = psl_ct9_new_loc_name(cb, psq_cb, (char *) NULL,
			yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, &yyvarsp->with_clauses, &yyvarsp->xlated_qry);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	yacc_cb->yyval.psl_objspec = yacc_cb->yypvt[-0].psl_objspec;
    } break;

case 1879:
if (!((*yyvarspp)->bypass_actions))
/* # line 42577 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = -1;
    } break;

case 1880:
if (!((*yyvarspp)->bypass_actions))
/* # line 42581 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DD_2OBJ_TABLE;
    } break;

case 1881:
if (!((*yyvarspp)->bypass_actions))
/* # line 42585 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_tytype = DD_3OBJ_VIEW;
    } break;

case 1882:
if (!((*yyvarspp)->bypass_actions))
/* # line 42589 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        /* flag that this is a procedure and return tye corect object type */
        cb->pss_distr_sflags |= PSS_REGISTER_PROC;
        yacc_cb->yyval.psl_tytype = DD_5OBJ_REG_PROC;
    } break;

case 1883:
if (!((*yyvarspp)->bypass_actions))
/* # line 42613 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* we are done processing the new object names */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    } break;

case 1884:
if (!((*yyvarspp)->bypass_actions))
/* # line 42618 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_rg1_reg_distr_tv(cb, yacc_cb->yypvt[-3].psl_objspec, -1,
				&yyvarsp->xlated_qry, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1885:
if (!((*yyvarspp)->bypass_actions))
/* # line 42630 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		err_code;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void) psf_error(2086L, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     sizeof(ERx("CREATE LINK"))-1, 
			     ERx("CREATE LINK"));
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_0_CRT_LINK;
	status = psl_rg3_reg_tvi(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* we are about to process new object names */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    } break;

case 1887:
if (!((*yyvarspp)->bypass_actions))
/* # line 42656 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4		err_code;
	    
	    (VOID) psf_error(E_PS110D_TBL_NOCOL, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
    } break;

case 1888:
if (!((*yyvarspp)->bypass_actions))
/* # line 42669 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

        if (cb->pss_distr_sflags & PSS_REGISTER_PROC)
        {
            /* opps, column lists are not permitted with the register procedure
            ** statement and this is a register procedure statement.  Better
            ** report a syntax error to the user
            */
            i4             err_code;

            (VOID) psf_error(E_PS091C_NOPARAMS_ALLOWED, 0L, PSF_USERERR,
                             &err_code, &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }
	status = psl_rg6_link_col_list(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1889:
if (!((*yyvarspp)->bypass_actions))
/* # line 42690 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

        if (cb->pss_distr_sflags & PSS_REGISTER_PROC)
        {
            /* opps, column lists are not permitted with the register procedure
            ** statement and this is a register procedure statement.  Better
            ** report a syntax error to the user
            */
            i4             err_code;

            (VOID) psf_error(E_PS091C_NOPARAMS_ALLOWED, 0L, PSF_USERERR,
                             &err_code, &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }
	status = psl_rg6_link_col_list(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1891:
if (!((*yyvarspp)->bypass_actions))
/* # line 42714 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		err_code;

	if (psq_cb->psq_mode == PSQ_DIRDISCON)
	{
	    /*
	    ** direct disconnect doesn't allow a with_clause
	    */
	    (VOID) psf_error(2083L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error,0);
	}
    } break;

case 1892:
if (!((*yyvarspp)->bypass_actions))
/* # line 42727 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_rg5_ldb_spec(cb, yacc_cb->yypvt[-0].psl_strtype, psq_cb->psq_mode, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1893:
if (!((*yyvarspp)->bypass_actions))
/* # line 42736 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_rg5_ldb_spec(cb, (char *) NULL,
	    			psq_cb->psq_mode, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
	
    } break;

case 1899:
if (!((*yyvarspp)->bypass_actions))
/* # line 42760 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4		    err_code;
	i4		    colno;
	QEU_CB              *qeu_cb;
	DMU_CB              *dmu_cb;
	DMU_ATTR_ENTRY      **attrs;
	i4             length;
	DB_STATUS	    status;
	i4		    len;
 
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/*
	** So that we can access the source query text at *pss_bgnstmt in
	** qeu_dbu() in qeus.c, copy it and terminate it with a 0-byte.  Then,
	** use qeu_qtext to point to this string.  This is so the query
	** text can be put into iiqrytext.  Other commands collect the text via
	** pss_open, pss_tadd, and pss_tout, eventually putting it into
	** pss_tstream in the psy_cb & pointing cb->pss_object at the psy_cb;
	** but historically pss_object is already used here to point to a
	** qeu_cb, so we've gotta pass the string via the qeu_cb.  We don't
	** think *pss_bgnstmt is null-terminated, but we want our copy to be
	** so.
	**
	** The iiqrytext buffer must be one byte longer than the actual
	** actual ddl statement;  otherwise STlcopy may access violate
	** when tagging on the concluding '\0'.
	*/ 

	len = cb->pss_nxtchar - cb->pss_bgnstmt;
	status = psf_malloc(cb, &cb->pss_ostream, len + 1, 
	    (PTR *) &qeu_cb->qeu_qtext, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Note STlcopy guarentees terminating \0 in destination string */
	STncpy(qeu_cb->qeu_qtext, (char *) cb->pss_bgnstmt, len);
	qeu_cb->qeu_qtext[ len ] = '\0';

	/* find columns */
	attrs = (DMU_ATTR_ENTRY **) dmu_cb->dmu_attr_array.ptr_address;
	length = 0;

	/* Ensure GW_IMA tables are structure=sortkeyed (b117546) kibro01 */
	if (dmu_cb->dmu_gw_id == DMGW_IMA &&
	    cb->pss_restab.pst_struct != DB_BTRE_STORE)
	{
	    /* Error! - structure must be sortkeyed */
	    (VOID) psf_error(9357L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
    	    return (E_DB_ERROR);
	}

	if (dmu_cb->dmu_gw_id == DMGW_IMA)
	{
	    i4 dummy, dummy2;
	    bool found_vnode_or_server = FALSE;
	    bool found_match;

	    for (dummy = 0; dummy < cb->pss_rsdmno; dummy++)
	    {
		DMU_GWATTR_ENTRY    *gwattr;
		char		    *att_name;

		gwattr = *((DMU_GWATTR_ENTRY **)
			dmu_cb->dmu_gwattr_array.ptr_address + dummy);
		att_name = gwattr->gwat_xbuffer;

		/* If item contains ".", that means it is a Classid */
		if (STindex(att_name,ERx("."),0))
			continue;

		/* Search through GM_atts array */
		found_match = FALSE;
		for (dummy2 = 0; GM_atts[dummy2].name != NULL; dummy2++)
		{
		    if (STbcompare(att_name,0,GM_atts[dummy2].name,0,TRUE)==0)
		    {
			if (GM_atts[dummy2].type == GMA_VNODE ||
			    GM_atts[dummy2].type == GMA_SERVER)
			{
			    if (found_vnode_or_server)
			    {
			        /* Error! - only allowed one of these */
			        (VOID) psf_error(9356L, 0L, PSF_USERERR,
					&err_code, &psq_cb->psq_error, 0);
	    		        return (E_DB_ERROR);
			    }
			    found_vnode_or_server = TRUE;
			}
			found_match = TRUE;
		    }
		}
		if (!found_match)
		{
		    /* Error! - unknown non-classid word */
		    (VOID) psf_error(9355L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, (i4) STlen(att_name), att_name);
	    	    return (E_DB_ERROR);
		}
	    }
	}

        /* Make sure there is a location */
        if (!dmu_cb->dmu_location.data_in_size)
        {
	    /* Default location for 'normal' & 'subselect' versions */
	    STmove("$default", ' ', sizeof(DB_LOC_NAME),
	           (char*) dmu_cb->dmu_location.data_address);
            dmu_cb->dmu_location.data_in_size = sizeof(DB_LOC_NAME);
        }


	/* Default if no "rows=" clause is given, is 1000 rows. */
	if (dmu_cb->dmu_gwrowcount == DMGW_NO_ROW_ENTRY)
	    dmu_cb->dmu_gwrowcount = 1000;

	/* b117252/b117253 (kibro01)
	** Check we're not using journaling or update if IMA gateway
	*/
	if (dmu_cb->dmu_gw_id == DMGW_IMA)
	{
	    DMU_CHAR_ENTRY	*char_entry;
	    i4		char_count;
	    i4		ix;
	    DMU_FROM_PATH_ENTRY *from_path;
	    char	*from_ptr;

	    char_entry = (DMU_CHAR_ENTRY *)
		((char *) dmu_cb->dmu_char_array.data_address);
	    char_count = 
		dmu_cb->dmu_char_array.data_in_size/sizeof(DMU_CHAR_ENTRY);

	    for (ix = 0; ix < char_count; ix++)
	    {
		switch (char_entry[ix].char_id)
		{
		    case DMU_GW_UPDT:
			from_path = (DMU_FROM_PATH_ENTRY *)
				dmu_cb->dmu_olocation.data_address;
			from_ptr = from_path->from_buffer;

			if (char_entry[ix].char_value == DMU_C_ON &&
				STbcompare(from_ptr,0,"OBJECTS",0,TRUE) != 0)
			{
			    char *x = "UPDATE";
			    /* Cannot have UPDATE on IMA tables */
			    (VOID) psf_error(9311L, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 1, (i4) STlen(x), x);
	    		    return (E_DB_ERROR);
			}
			break;
		    case DMU_JOURNALED:
			if (char_entry[ix].char_value == DMU_C_ON)
			{
			    char *x = "JOURNALING";
			    /* Cannot have JOURNALING on IMA tables */
			    (VOID) psf_error(9311L, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 1, (i4) STlen(x), x);
	    		    return (E_DB_ERROR);
			}
			break;
		    default:
			break;
		}
	    }
	}
    } break;

case 1902:
if (!((*yyvarspp)->bypass_actions))
/* # line 42935 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	DMU_ATTR_ENTRY	    **attrs;
	i4		    colno;
	DMU_GWATTR_ENTRY    **gwattrs;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	attrs = (DMU_ATTR_ENTRY **) dmu_cb->dmu_attr_array.ptr_address;
	colno = cb->pss_rsdmno - 1;
	gwattrs =
	    (DMU_GWATTR_ENTRY **)(dmu_cb->dmu_gwattr_array.ptr_address);
 
	/* No extended format; set flag appropriately. */
	(gwattrs[colno])->gwat_flags_mask &= ~DMGW_F_EXTFMT;
    } break;

case 1904:
if (!((*yyvarspp)->bypass_actions))
/* # line 42956 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	i4		    size_extfmt;
	DMU_GWATTR_ENTRY    *gwattr;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	gwattr = *((DMU_GWATTR_ENTRY **) dmu_cb->dmu_gwattr_array.ptr_address +
		   cb->pss_rsdmno - 1);
	/* size may not exceed limit */
	if ((size_extfmt = (i4) yacc_cb->yypvt[-0].psl_textype->db_t_count) > (DMU_MAXSIZE_EXTFMT - 1))
	    size_extfmt = DMU_MAXSIZE_EXTFMT - 1;
 
	STncpy (gwattr->gwat_xbuffer, (char *) yacc_cb->yypvt[-0].psl_textype->db_t_text, size_extfmt);
	gwattr->gwat_xbuffer[ size_extfmt ] = '\0';
	gwattr->gwat_xsize = size_extfmt;
	/* This is always the first flag setting, so use "=", not "|=" */
	gwattr->gwat_flags_mask = DMGW_F_EXTFMT;
    } break;

case 1905:
if (!((*yyvarspp)->bypass_actions))
/* # line 42979 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEU_CB			*qeu_cb;
	DMU_CB			*dmu_cb;
	i4			from_value_size;
	DMU_FROM_PATH_ENTRY	*from_path_ptr;
	i4			err_code;
	i4			val1,val2;
    	char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
 
	from_path_ptr = (DMU_FROM_PATH_ENTRY *)
			 dmu_cb->dmu_olocation.data_address;
	if ((from_value_size = (i4) yacc_cb->yypvt[-0].psl_textype->db_t_count) > DMU_MAXSIZE_FROM)
	{
	    /* size over limit */
	    (VOID) psf_error(9308L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	else
	{
	    from_path_ptr->from_size = from_value_size;
	    if (from_value_size != 0)
	    {
	       STcopy(sconvert(yacc_cb->yypvt[-0].psl_textype), from_path_ptr->from_buffer);
	       if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
	       {
			psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
				"Register FROM source is '%s'\n", 
					from_path_ptr->from_buffer);
	       }
	    }
	}
    } break;
	}
	return(0);
}

i4
psls43iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1914:
if (!((*yyvarspp)->bypass_actions))
/* # line 43036 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4 val1,val2;
    	char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */
	/*
	** this is for the keyword parameters: DBMS parameter and STRUCTURE
	** parameter which has no prefix value, UNIQUE
	*/
                            
	i4		err_code;
	QEU_CB		*qeu_cb;
	DMU_CB		*dmu_cb;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "dbms") == 0)
	{
            if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
            {
	    	psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"Register DBMS value is '%s'\n", yacc_cb->yypvt[-0].psl_strtype);
            }

	    /*
	    ** if this is the first parm, parm flag should be OFF if the value
	    ** of flag is ON then issue error message for duplicate parm
	    */
	    if (dmu_cb->dmu_gw_id != DMGW_NONE)	/* duplicate parm found  */
	    {
		(VOID) psf_error(9309L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
		return (E_DB_ERROR);
	    }
 
	    if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"vsam") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_VSAM;
	    }
	    else if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"rms") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_RMS;
	    }
	    else if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"ims") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_IMS;
	    }
	    else if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"idmsx") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_IDMSX;
	    }
	    else if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"lg_test") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_LG_TEST;
	    }
	    else if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"dmf_test") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_DMF_TEST;
	    }
	    else if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"ima") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_IMA;
	    }
	    else if (STcompare(yacc_cb->yypvt[-0].psl_strtype,"sxa") ==0)
	    {
		/*
		**	C2-Audit Gateway
		*/
		dmu_cb->dmu_gw_id = DMGW_SEC_AUD;
	    }
	    else
	    {
		(VOID) psf_error(9310L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);
	    }
	    /*
	    **	Validate the DBMS is valid for this particular server
	    **  we do this here otherwise its not detected until a low-level
	    **  GWF routine which can't be handled too cleanly to the user.
	    **
	    **  An example might be registering an RMS gateway table in
	    **  regular Ingres DBMS
	    */
	    {
		GW_RCB gwfrcb;
		DB_STATUS status;
		gwfrcb.gwr_gw_id=dmu_cb->dmu_gw_id;
		gwfrcb.gwr_type=GWR_CB_TYPE;
		gwfrcb.gwr_length=sizeof(GW_RCB);

		status=gwf_call(GWU_VALIDGW, &gwfrcb);
		if (status==E_DB_WARN)
		{
			/*
			**	Not valid for this server
			*/
			(VOID) psf_error(9324L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
			return E_DB_ERROR;

		}
		else if (status!=E_DB_OK)
		{
			psf_error(gwfrcb.gwr_error.err_code, 0L,
					PSF_USERERR, &err_code,
					&psq_cb->psq_error, 0);

			return status;
		}
	    }
	}

        /* schang : create a procedure for code sharing */
	else if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "structure") == 0)
	{
            DB_STATUS                   status;

            if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
            {
	    	psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"Register STRUCTURE value is '%s'\n", yacc_cb->yypvt[-0].psl_strtype);
            }

	    status = psl_reg_struct(&cb->pss_restab.pst_struct, dmu_cb, yacc_cb->yypvt[-0].psl_strtype,
		(i4) DMU_C_OFF, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
        }
	else 
	{
	    (VOID) psf_error(9311L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 1915:
if (!((*yyvarspp)->bypass_actions))
/* # line 43175 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* this is for the STRUCTURE parameter with prefix value UNIQUE */
	i4		err_code;
	QEU_CB         *qeu_cb;
	DMU_CB         *dmu_cb;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
 
        /* schang : call shared procedure */
	if (STcompare(yacc_cb->yypvt[-3].psl_strtype, "structure") == 0)
	{
            DB_STATUS                   status;

            status = psl_reg_struct(&cb->pss_restab.pst_struct, dmu_cb, yacc_cb->yypvt[-0].psl_strtype,
		(i4) DMU_C_ON, &psq_cb->psq_error);
            if (status != E_DB_OK)
                return (status);
        }
	else
	{
	    (VOID) psf_error(8005L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite(yacc_cb->yypvt[-3].psl_strtype), yacc_cb->yypvt[-3].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 1916:
if (!((*yyvarspp)->bypass_actions))
/* # line 43204 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEU_CB		*qeu_cb;
	DMU_CB		*dmu_cb;
	i4		err_code;

	if (STcompare(yacc_cb->yypvt[-4].psl_strtype,"key") != 0)
	{
	    (void) psf_error(8005L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, yacc_cb->yypvt[-4].psl_strtype, yacc_cb->yypvt[-4].psl_strtype);
	    return (E_DB_ERROR);
	}

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/*
	** 'keys' clause specified, but no columns were specified.
	*/
	if (dmu_cb->dmu_key_array.ptr_in_count == 0)
	{
	    /* duplicate parm found  */
	    (VOID) psf_error(9316L, 0L, PSF_USERERR, &err_code,
	               	     &psq_cb->psq_error, 1,
			     (i4) STlength(ERx("key")), ERx("key"));
	    return (E_DB_ERROR);
	}
        /* 
        ** chash01 (oct-02-2003) this is the place to verify
        **   that multi-column key must be all chars and/or varchar
        **   by going through the list of key components.
        */
        if (dmu_cb->dmu_gw_id == DMGW_RMS)
        {
            DMU_ATTR_ENTRY **att = (DMU_ATTR_ENTRY **) 
                                     dmu_cb->dmu_attr_array.ptr_address;
	    DMU_KEY_ENTRY   **key = (DMU_KEY_ENTRY **) 
                                     dmu_cb->dmu_key_array.ptr_address;
            i4          att_count = dmu_cb->dmu_attr_array.ptr_in_count;
            i4          key_count = dmu_cb->dmu_key_array.ptr_in_count;
            i4          type_abs, i, j, mismatch;

            if (key_count > 1)
            {
                /*
                ** if more than one column in key definition, they needs
                ** to be of the same char/varchar types, to guarantee the
                ** collating sequence (and sort sequence) is the same.
                */
                mismatch = 0;
                for (i = 0; i < key_count; i++)
                {
                    for (j = 0; j < att_count; j++)
                    {
	                if (!MEcmp((char *) &(key[i]->key_attr_name), 
                                   (char *) &(att[j]->attr_name),
		                  sizeof(DB_ATT_NAME)))
                        {
                            type_abs = abs(att[j]->attr_type);
                            switch (type_abs)
                            {
                              case DB_CHR_TYPE:
                              case DB_VCH_TYPE:
                              case DB_CHA_TYPE:
                              case DB_TXT_TYPE:
                                  break;
                              default:
                                  mismatch = 1;
                                  break;
                            }
                            /* 
                            ** once a key column is found in the base table
                            ** column list, break out the inner loop
                            */
                            break;
                        }
                    }
                    /*
                    ** once a non-char type found in multi-column key
                    ** there is no need to continue, break out the loop
                    ** and emit error/warning message.
                    */
                    if (mismatch)
                        break;
                }
                if (j >= att_count)
                {
                    key[i]->key_attr_name.db_att_name[DB_MAXNAME-1] = EOS;
	            _VOID_ psf_error(5302L, 0L, PSF_USERERR, &err_code,
	                         &psq_cb->psq_error, 1,
                                 STtrmwhite(key[i]->key_attr_name.db_att_name),
                                 key[i]->key_attr_name.db_att_name);
	            return (E_DB_ERROR);
                }
                if (mismatch)
                {
                    char colname[DB_MAXNAME];

                    MEcopy(key[i]->key_attr_name.db_att_name,
                           (u_i4)DB_MAXNAME, colname);
                    colname[DB_MAXNAME-1] = EOS;
		    _VOID_ psf_error(W_PS1110_REG_TAB_IDX_MULTI_COL,
                                 0L, PSF_USERERR, &err_code,
                                 &psq_cb->psq_error, 1,
                                 STtrmwhite(colname),
                                 colname);
                }
            }
        }
    } break;

case 1919:
if (!((*yyvarspp)->bypass_actions))
/* # line 43320 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		    status;
	i4			    err_code;
	QEU_CB			    *qeu_cb;
	DMU_CB			    *dmu_cb;
	DB_ATT_NAME		    attname;
	DMU_KEY_ENTRY		    **key;
	DMU_KEY_ENTRY		    *keymem;
	DMU_ATTR_ENTRY		    **attrs;
	i4			    colno;
	i4			    keycnt;
	i4			    i;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
 
	keycnt = dmu_cb->dmu_key_array.ptr_in_count;
 
	STmove(yacc_cb->yypvt[-1].psl_strtype, ' ', sizeof(DB_ATT_NAME),  (char *) &attname);
 
	/* Check for duplicate column names. */
 
	/* check duplicate begin */
	key = (DMU_KEY_ENTRY **) dmu_cb->dmu_key_array.ptr_address;
	for (i = 0; i < keycnt; i++)
	{
	    /* check duplicate against previously entered key value */
	    if (!MEcmp((char *) &attname, (char *) &(*key)->key_attr_name,
		       sizeof(DB_ATT_NAME)))
	    {
		(VOID) psf_error(9307L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1, STlength(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
		return (E_DB_ERROR);
	    }
	    key++;
	}

	/* validate key value (need a valid column name) */
	attrs = (DMU_ATTR_ENTRY **) dmu_cb->dmu_attr_array.ptr_address;
	colno = cb->pss_rsdmno;
	for (i = 0; i < colno; i++)
	{
	    if (!MEcmp((char *)&attname,
		       (char *)&(attrs[i])->attr_name,
		       sizeof((attrs[i])->attr_name)))
	    {
		break;    /* we have match, a valid key value */
	    }
	}
	if (i >= colno)
	{
	    (VOID) psf_error(9312L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) STtrmwhite(yacc_cb->yypvt[-1].psl_strtype), yacc_cb->yypvt[-1].psl_strtype);
	    return (E_DB_ERROR);		
	 }

	/* Store the column name in the DMU_CB key entry array */
	key = (DMU_KEY_ENTRY **) dmu_cb->dmu_key_array.ptr_address;
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMU_KEY_ENTRY),
			    (PTR *) &keymem, &psq_cb->psq_error);
	key[keycnt]= keymem;
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(attname, (key[keycnt])->key_attr_name);

	if (yacc_cb->yypvt[-0].psl_tytype == PSS_ASCENDING)
	    (key[keycnt])->key_order = DMU_ASCENDING;
	else
	    (key[keycnt])->key_order = DMU_DESCENDING;

	dmu_cb->dmu_key_array.ptr_in_count++;

    } break;

case 1920:
if (!((*yyvarspp)->bypass_actions))
/* # line 43397 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* this is for ROWS keyword parameter */
	QEU_CB         *qeu_cb;
	DMU_CB         *dmu_cb;
	i4        err_code;
 
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
 
	    /*
	    ** If this is the first rows parameter, dmu_gwrowcount should be
	    ** DMGW_NO_ROW_ENTRY.  If pst_struct is not DMGW_NO_ROW_ENTRY then
	    ** issue error message for duplicate parameter.
	    */
	    if (dmu_cb->dmu_gwrowcount != DMGW_NO_ROW_ENTRY)
	    {
		/* duplicate parm found  */
		(VOID) psf_error(9309L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4)4, "ROWS");
		return (E_DB_ERROR);

	    }

/*	    TRdisplay ("pslsgram rows = %d\n",$3); */
	    dmu_cb->dmu_gwrowcount = (i4)yacc_cb->yypvt[-0].psl_inttype;
    } break;

case 1921:
if (!((*yyvarspp)->bypass_actions))
/* # line 43427 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** this is for the keyword parameters: duplicates, noduplicates,
	** journaling, nojournaling, update, noupdate, recovery, norecovery.
	*/
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	i4		    err_code;
	DMU_CHAR_ENTRY	    *chr;
	DMU_CHAR_ENTRY	    *chr_start;
	i4		    val1,val2;
    	char		    trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	chr_start = (DMU_CHAR_ENTRY *) dmu_cb->dmu_char_array.data_address;
 
        if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
        {
    	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"Register Table read keyword '%s'\n",yacc_cb->yypvt[-0].psl_strtype);
			
        }
 
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "duplicates") == 0)
	{
	    /*
	    ** if this is the first duplicates entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 2;			/* third entry */
	    if (chr->char_value != DMU_C_NOT_SET)
	    {
		/* duplicate or conflict duplicates/noduplicates parm */
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_DUPLICATES;
	    chr->char_value = DMU_C_ON;
	    cb->pss_restab.pst_resdup = TRUE;
	    yyvarsp->with_dups = 1;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "noduplicates") == 0)
	{
	    /*
	    ** if this is the first duplicates entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 2;	/* third entry */
	    if (chr->char_value != DMU_C_NOT_SET)
	    {
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);
	    }
	    /*
	    ** replace default DUPLICATES value by NODUPLICATES in the third
	    ** entry
	    */
	    chr->char_id = DMU_DUPLICATES;
	    chr->char_value = DMU_C_OFF;   /* disallow duplicates */
	    cb->pss_restab.pst_resdup = FALSE;
	    yyvarsp->with_dups = 0;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "journaling") == 0)
	{
	    /*
	    ** if this is the first journaling entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 3;	/* fourth entry */
	    if (chr->char_value != DMU_C_NOT_SET)
	    {
		/* duplicate or conflict */
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				(i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);
	    }
 
	    chr->char_id = DMU_JOURNALED;
	    chr->char_value = DMU_C_ON;        /* enable journaling */
/*************************DO AT EXIT*************************/
	    cb->pss_restab.pst_resjour = TRUE;
	    yyvarsp->with_journaling = 1;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "nojournaling") == 0) /* default parm */
	{
	    /*
	    ** if this is the first journaling entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 3;	/* fourth entry */
	    if (chr->char_value != DMU_C_NOT_SET)   /* duplicate or conflict */
	    {
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_JOURNALED;
	    chr->char_value = DMU_C_OFF;        /* disable journaling */
	    cb->pss_restab.pst_resjour = FALSE;
	    yyvarsp->with_journaling = 0;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "noupdate") == 0)
	{
	    /*
	    ** if this is the first update entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 5;	/* sixth entry */
	    if (chr->char_value != DMU_C_NOT_SET) /* duplicate or conflict */
	    {
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_GW_UPDT;
	    chr->char_value = DMU_C_OFF;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "recovery") == 0)
	{
	    /*
	    ** if this is the first parm, parm flag should be OFF if the value
	    ** of flag is PARM_ON then issue error message for duplicate or
	    ** conflict parm
	    */
	    chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_gwchar_array.data_address;
	    if (chr->char_value != DMU_C_NOT_SET) /* duplicate or conflict */
	    {
		/* duplicate or conflict parm found */
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_GW_RCVR;
	    chr->char_value = DMU_C_ON;
	}
	else if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "norecovery") == 0) /* default value */
	{
	    /*
	    ** if this is the first parm, parm flag should be OFF if the value
	    ** of flag is PARM_ON then issue error message for duplicate or
	    ** conflict parm
	    */
	    chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_gwchar_array.data_address;

	    if (chr->char_value != DMU_C_NOT_SET) /* duplicate or conflict */
	    {
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_GW_RCVR;
	    chr->char_value = DMU_C_OFF;
	}
	else 
	{
	    (VOID) psf_error(8007L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 1922:
if (!((*yyvarspp)->bypass_actions))
/* # line 43605 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	i4		    err_code;
	DMU_CHAR_ENTRY    *chr;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/*
	** if this is the first update entry, char_value should be
	** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	** conflicting entry.
	*/
	chr = (DMU_CHAR_ENTRY *)
	    (((char *) dmu_cb->dmu_char_array.data_address)
	    + 5 * sizeof(DMU_CHAR_ENTRY));    /* 6th entry */
	if (chr->char_value != DMU_C_NOT_SET) /* duplicate or conflict */
	{
	    (VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) sizeof("update"), "update");
	    return (E_DB_ERROR);
	}
	chr->char_id = DMU_GW_UPDT;
	chr->char_value = DMU_C_ON;
    } break;

case 1923:
if (!((*yyvarspp)->bypass_actions))
/* # line 43635 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEU_CB		*qeu_cb;
	DMU_CB		*dmu_cb;
	DMU_CHAR_ENTRY	*chr;
	i4		err_code;
	bool		keyed;
	bool		unique;
	bool		duplicates;
	i4		storestruct;
	i4	        val1,val2;
    	char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/***NOTE:  NEED TO CHECK THAT NO KEY HAS BEEN SPECIFIED AS A VARIANT**/
	/***key=(DMU_KEY_ENTRY **)dmu_cb->dmu_key_array.ptr_address;
	****for each key
	****	find matching attr
	****	    check its gflag value against DMGW_F_VARIANT
	***/ 
	/* DBMS is a required parameter in REGISTER TABLE command */
	if (dmu_cb->dmu_gw_id == DMGW_NONE)
	{
	    (VOID) psf_error(9315L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* First entry in characteristics array is storage structure */
	chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_char_array.data_address;

        if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
        {
    	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"Register Table gateway attribute list starts at %d (X%p)\n",
		chr,chr);
	}

	/* if structure not set, set it to defaule DB_HEAP_STORE */
	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DB_HEAP_STORE;
	keyed = (chr->char_value != DB_HEAP_STORE);
	storestruct = chr->char_value;

	/*  If RMS Gateway, disallow "fullkey" structure specifier. */
	if ((dmu_cb->dmu_gw_id == DMGW_RMS) && (storestruct == DB_HASH_STORE))
	{
	    (VOID) psf_error(9323L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 2, STlength("fullkey"),
			     "fullkey", STlength("RMS"), "RMS");
	    return (E_DB_ERROR);
	}

	/* no keys on heap */
	if (chr->char_value == DB_HEAP_STORE
	    &&
	    dmu_cb->dmu_key_array.ptr_in_count != 0)
	{
	    (VOID) psf_error(9317L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	        return (E_DB_ERROR);
	}
	else if (chr->char_value != DB_HEAP_STORE &&
		 dmu_cb->dmu_key_array.ptr_in_count == 0)
	{
	    /* NOTE this is a warning message */
            /* Schang : just warning is not adequate for RMS gateway */
            /*          It must terminate when structure = keyed     */
            /*          (sortkeyed) specified but not key= phrase.   */
            /*          fix GW bug 40997 */
                       
	    (VOID) psf_error(9318L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
            if (dmu_cb->dmu_gw_id == DMGW_RMS)
	        return (E_DB_ERROR);
            else
	        return (E_DB_OK);
	}

	/* if unique is not set, set it to default of non-unique */
	chr++;
	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DMU_C_OFF;
	unique = (chr->char_value == DMU_C_ON);

	/*  If duplicates not set, default appropriately for struct type. */
	chr++;
	if (chr->char_value == DMU_C_NOT_SET)
	{
	    if (keyed && unique)
		chr->char_value = DMU_C_OFF;
	    else
		chr->char_value = DMU_C_ON;
	}
	duplicates = (chr->char_value == DMU_C_ON);

	/* if journaled is not set, set it to default of not journaled */
	chr++;
	/*
	**	Make sure this is set to DMU_JOURNALED if not already
	*/
	if ( chr->char_id != DMU_JOURNALED)
		chr->char_id = DMU_JOURNALED;

	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DMU_C_OFF;

	/* skip gateway (always set) */
	chr++;

	/* if update is not set, set it to default of not updatable */
	chr++;
	/*
	**	Make sure this is set to DMU_GW_UPDT if not already
	*/
	if ( chr->char_id != DMU_GW_UPDT)
		chr->char_id = DMU_GW_UPDT;
	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DMU_C_OFF;

	/* Now do gwchar entry, recovery */
	/* if recovery is not set, set it to default of no recovery */
	chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_gwchar_array.data_address;
	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DMU_C_OFF;
    
	/*
	**  Check for compatible values of structure, uniqueness and duplicates.
	*/

	/*  If heap, disallow either "noduplicates" or "unique" qualifiers. */
	if (!keyed && (!duplicates || unique))
	{
	    (VOID) psf_error(9321L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*  If keyed and unique, disallow duplicates. */
	if (keyed && unique && duplicates)
	{
	    (VOID) psf_error(9322L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	return (E_DB_OK);
    } break;

case 1924:
if (!((*yyvarspp)->bypass_actions))
/* # line 43787 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4		err_code;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void) psf_error(2086L, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     sizeof(ERx("REGISTER INDEX"))-1, 
			     ERx("REGISTER INDEX"));
	    return (E_DB_ERROR);
	}

	status = psl_rg2_reg_distr_idx(cb, yacc_cb->yypvt[-4].psl_objspec->pss_orig_obj_name,
	    &yyvarsp->xlated_qry, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1925:
if (!((*yyvarspp)->bypass_actions))
/* # line 43811 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	DMU_CHAR_ENTRY	    *chr, *charlim;
	bool		    ssfound = FALSE;
	i4		    sstruct;
	i4                  err_code;
	DB_STATUS	    status;
	i4		    len;
    
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/*
	** So that we can access the source query text at *pss_bgnstmt in
	** qeu_dbu() in qeus.c, copy it and terminate it with a 0-byte.  Then,
	** use qeu_qtext to point to this string.  This is so the query
	** text can be put into iiqrytext.  Other commands collect the text vis
	** pss_open, pss_tadd, and pss_tout, eventually putting it into
	** pss_tstream in the psy_cb & pointing cb->pss_object at the psy_cb;
	** but historically pss_object is already used here to point to a
	** qeu_cb, so we've gotta pass the string via the qeu_cb.  We don't
	** think *pss_bgnstmt is null-terminated, but we want our copy to be
	** so.
	**
	** The iiqrytext buffer must be one byte longer than the actual
	** actual ddl statement;  otherwise STlcopy may access violate
	** when tagging on the concluding '\0'.
	*/
	len = cb->pss_nxtchar - cb->pss_bgnstmt;
	status = psf_malloc(cb, &cb->pss_ostream, len + 1, 
	    (PTR *) &qeu_cb->qeu_qtext, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Note STlcopy guarentees terminating \0 in destination string */
	STncpy(qeu_cb->qeu_qtext, (char *) cb->pss_bgnstmt, len);
	qeu_cb->qeu_qtext[ len ] = '\0';

        /* Make sure there is a location */
        if (!dmu_cb->dmu_location.data_in_size)
        {
	    /* Default location */
	    STmove("$default", ' ', sizeof(DB_LOC_NAME),
	        (char*) dmu_cb->dmu_location.data_address);
	    dmu_cb->dmu_location.data_in_size = sizeof(DB_LOC_NAME);
        }
        /*
        ** 03-oct-03 (chash01) Here we check that muti-column key will not
        ** have compnents other than char and varchar types. Warning will
        ** be issued for this violation.
        */
        if (dmu_cb->dmu_gw_id == DMGW_RMS)
        {
            DMT_ATT_ENTRY	*attribute;
            DMU_ATTR_ENTRY **idx_att = (DMU_ATTR_ENTRY **)
                                   dmu_cb->dmu_attr_array.ptr_address;

            i4             att_count =
                                   cb->pss_resrng->pss_tabdesc->tbl_attr_count;
            i4             idx_count = dmu_cb->dmu_key_array.ptr_in_count;
            i4 type_abs, i, j, mismatch;

            if (idx_count > 1)
            {
                /*
                ** if more than one column in key definition, they needs
                ** to be of the same char/varchar types, to guarantee the
                ** collating sequence (and sort sequence) is the same.
                */
                mismatch = 0;
                for (i = 0; i < idx_count; i++)
                {
		    /* Used to be an inner loop from 0 to att_count,
		    ** but it always stopped on the 1st iteration. Loop 
		    ** did nothing but cause compiler warning and it has
		    ** now been removed. DNI 30/3/2006 */
                    attribute = pst_coldesc(cb->pss_resrng,
                                                &(idx_att[i]->attr_name));
                    if (attribute)
                    {
                        type_abs = abs(attribute->att_type);
                        switch (type_abs)
                        {
                          case DB_CHR_TYPE:
                          case DB_VCH_TYPE:
                          case DB_CHA_TYPE:
                          case DB_TXT_TYPE:
                              break;
                          default:
                              mismatch = 1;
                              break;
                        }
                    }
                    else
                    {
                        idx_att[i]->attr_name.db_att_name[DB_MAXNAME-1] = EOS;
	                    _VOID_ psf_error(5302L, 0L, PSF_USERERR, &err_code,
	                     &psq_cb->psq_error, 1,
                             STtrmwhite(idx_att[i]->attr_name.db_att_name),
                             idx_att[i]->attr_name.db_att_name);
	                return (E_DB_ERROR);

                    }
                    /*
                    ** once a non char type found in multi-column key
                    ** there is no need to continue, break out the loop
                    ** and emit error/warning message.
                    */
                    if (mismatch)
                        break;
                }
                if (mismatch)
                {
                    char colname[DB_MAXNAME];

                    MEcopy(idx_att[i]->attr_name.db_att_name,
                           (u_i4)DB_MAXNAME, colname);
                    colname[DB_MAXNAME-1] = EOS;
		    psf_error(W_PS1110_REG_TAB_IDX_MULTI_COL,
                                 0L, PSF_USERERR, &err_code,
                                 &psq_cb->psq_error, 1,
                                 STtrmwhite(colname),
                                 colname);
                }
            }

        } 
	/* Find the end of the characteristics array */
	charlim = (DMU_CHAR_ENTRY *)
	    ((char *) dmu_cb->dmu_char_array.data_address
	     + dmu_cb->dmu_char_array.data_in_size);

	/*
	** Check whether storage structure has been specified, if not, specify
	** the session default.
	*/
	for (chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_char_array.data_address;
	     chr < charlim;
	     chr++
	    )
	{
	    if (chr->char_id == DMU_STRUCTURE)
	    {
		ssfound = TRUE;
		break;
	    }
	}

	if (ssfound == FALSE)
	{
	    /* Two characteristics needed */
	    if (dmu_cb->dmu_char_array.data_in_size >=
		(PSS_MAX_INDEX_CHARS) * sizeof (DMU_CHAR_ENTRY))
	    {
		/* Invalid with clause - too many options */
		(VOID) psf_error(E_PS1103_IDX_TOOMANYOPT, 0L, PSF_USERERR,
                    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    chr = (DMU_CHAR_ENTRY *)
		((char *) dmu_cb->dmu_char_array.data_address
		+ dmu_cb->dmu_char_array.data_in_size);
	    chr->char_id = DMU_COMPRESSED;
	    chr->char_value = DMU_C_OFF;
	    chr++;
	    chr->char_id = DMU_STRUCTURE;
	    chr->char_value = cb->pss_idxstruct;
	    dmu_cb->dmu_char_array.data_in_size += sizeof(DMU_CHAR_ENTRY) * 2;
	}

	sstruct = chr->char_value;

	/* Check for legal storage structure */
	if (sstruct == DB_HEAP_STORE || sstruct == DB_SORT_STORE)
	{
	    (VOID) psf_error(5540L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, 
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &dmu_cb->dmu_table_name),
		&dmu_cb->dmu_table_name);
	    return (E_DB_ERROR);
	}
    } break;

case 1926:
if (!((*yyvarspp)->bypass_actions))
/* # line 43998 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;

/* schang : change PSQ_INDEX to PSQ_REG_INDEX, this assignment is */
/*	    carried out here instead of inside _index_prefix()    */
/*	    so that we can use this as flag indicating action for */
/*	    registering index or for creating index		  */
								
	/* daveb: treat as gateway unless it's distributed, no error at all */

	psq_cb->psq_mode = PSQ_REG_INDEX;
	cb->pss_object = (PTR) 0;
	cb->pss_save_qeucb = (PTR) 0;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ci2_index_prefix(cb, psq_cb, &yyvarsp->with_clauses, yacc_cb->yypvt[-0].psl_bool);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	else	/* distributed */
	{
	    status = psl_rg3_reg_tvi(cb, psq_cb);
	}
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1927:
if (!((*yyvarspp)->bypass_actions))
/* # line 44028 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_bool = FALSE;
    } break;

case 1928:
if (!((*yyvarspp)->bypass_actions))
/* # line 44032 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(2033L, 0L, PSF_USERERR, &err_code,
			 &psq_cb->psq_error, 1, sizeof("UNIQUE") +1, "UNIQUE");
	    return (E_DB_ERROR);
	}
	yacc_cb->yyval.psl_bool = TRUE;
    } break;

case 1929:
if (!((*yyvarspp)->bypass_actions))
/* # line 44047 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;
/* BB_FIX_ME: We can get rid of error PS1101_REG_NOLOC now */

	/* test registered name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_objspec->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* daveb: treat at gateway unless STAR, no error possible */

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ci5_indexlocname(cb, (char *) NULL, yacc_cb->yypvt[-0].psl_objspec, 
		&yyvarsp->with_clauses, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	else	/* distributed */
	{
	    /*
	    ** BB_FIX_ME: Not sure what Star should call.  Decide
	    ** when REGISTER INDEX is finally implemented in Star.
	    */
	}
    } break;

case 1930:
if (!((*yyvarspp)->bypass_actions))
/* # line 44076 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* Star indexes must be registered AS LINK */
	if (STcompare(yacc_cb->yypvt[-0].psl_strtype, "link"))
	{
	    i4	    err_code;
	    
	    (VOID) psf_error(2033L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,STlength(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
	    return (E_DB_ERROR);
	}
    } break;

case 1933:
if (!((*yyvarspp)->bypass_actions))
/* # line 44103 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	i4             err_code;
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	DMU_CHAR_ENTRY	    *chr;
	i4		    storestruct;

	if (STcompare(yacc_cb->yypvt[-2].psl_strtype, "structure") == 0)
	{
	    /* Decode storage structure name.  Error if unknown */
	    if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "keyed"))
	    {
		storestruct = DB_ISAM_STORE;
	    }
	    else if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "fullkey"))
	    {
		storestruct = DB_HASH_STORE;
	    }
	    else if (!STcasecmp(yacc_cb->yypvt[-0].psl_strtype, "sortkeyed"))
	    {
		storestruct = DB_BTRE_STORE;
	    }
	    else
	    {
		(VOID) psf_error(E_PS1104_IDX_BADSTRUCT, 0L, PSF_USERERR,
                          &err_code, &psq_cb->psq_error, 1,
                          (i4) STtrmwhite(yacc_cb->yypvt[-0].psl_strtype), yacc_cb->yypvt[-0].psl_strtype);
		return (E_DB_ERROR);    /* non-zero return means error */
	    }

	    qeu_cb = (QEU_CB *) cb->pss_object;
	    dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	    /* Put the storage structure info in the characteristics array. */

	    if (dmu_cb->dmu_char_array.data_in_size >=
		PSS_MAX_INDEX_CHARS * sizeof (DMU_CHAR_ENTRY))
	    {
		/* Invalid with clause - too many options */
		(VOID) psf_error(5327L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    chr = (DMU_CHAR_ENTRY *) 
		((char *) dmu_cb->dmu_char_array.data_address
		+ dmu_cb->dmu_char_array.data_in_size);

	    chr->char_id = DMU_STRUCTURE;
	    chr->char_value = storestruct;
	    dmu_cb->dmu_char_array.data_in_size += sizeof(DMU_CHAR_ENTRY);

	}
	else
	{
	    (VOID) psf_error(E_PS1105_IDX_WITHINVAL, 0L, PSF_USERERR,
                      &err_code, &psq_cb->psq_error, 1,
                      (i4) STtrmwhite(yacc_cb->yypvt[-2].psl_strtype), yacc_cb->yypvt[-2].psl_strtype);

	    return (E_DB_ERROR);
	}
    } break;

case 1934:
if (!((*yyvarspp)->bypass_actions))
/* # line 44168 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (psq_cb->psq_mode == PSQ_DIRDISCON)
	{
	    /*
	    ** if "DIRECT DISCONNECT" was entered, return error
	    ** since, if seen here, was entered
	    ** while NOT in "direct connect" mode.)
	    */
	    return(E_DB_ERROR);
	}
    } break;

case 1935:
if (!((*yyvarspp)->bypass_actions))
/* # line 44182 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_ds1_dircon(psq_cb, yacc_cb->yypvt[-1].psl_strtype, yacc_cb->yypvt[-0].psl_strtype,
			cb->pss_distrib & DB_3_DDB_SESS);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1937:
if (!((*yyvarspp)->bypass_actions))
/* # line 44196 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS		status;

	status = psl_ds2_dir_exec_immed(yacc_cb->yypvt[-3].psl_strtype, cb->pss_distrib & DB_3_DDB_SESS,
			sconvert(yacc_cb->yypvt[-0].psl_textype), cb, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    } break;

case 1938:
if (!((*yyvarspp)->bypass_actions))
/* # line 44248 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	char	    *letter;
	/*
	** Translate nonkeywords to lower case unless regular identifiers are 
	** always lowercased
	*/
	if (~*cb->pss_dbxlate & CUI_ID_REG_L)
	{
	    for (letter =  yacc_cb->yypvt[-0].psl_strtype; *letter != EOS; CMnext(letter))
	        CMtolower(letter, letter);
	}

	yyvarsp->id_type = PSS_ID_NONKEY;
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1939:
if (!((*yyvarspp)->bypass_actions))
/* # line 44266 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	char	    *letter;
	/*
	** Translate nonkeywords to lower case unless regular identifiers are 
	** always lowercased
	*/
	if (~*cb->pss_dbxlate & CUI_ID_REG_L)
	{
	    for (letter =  yacc_cb->yypvt[-0].psl_strtype; *letter != EOS; CMnext(letter))
	        CMtolower(letter, letter);
	}

	yyvarsp->id_type = PSS_ID_NONKEY;
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1940:
if (!((*yyvarspp)->bypass_actions))
/* # line 44282 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->id_type = PSS_ID_SCONST;
	yacc_cb->yyval.psl_strtype = sconvert(yacc_cb->yypvt[-0].psl_textype);
    } break;

case 1941:
if (!((*yyvarspp)->bypass_actions))
/* # line 44290 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->id_type = PSS_ID_REG;
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1942:
if (!((*yyvarspp)->bypass_actions))
/* # line 44295 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->id_type = PSS_ID_SCONST;
	yacc_cb->yyval.psl_strtype = sconvert(yacc_cb->yypvt[-0].psl_textype);
    } break;

case 1943:
if (TRUE)	/* NOBYPASS */
/* # line 44306 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->id_type = PSS_ID_REG;
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1944:
if (TRUE)	/* NOBYPASS */
/* # line 44311 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->id_type = PSS_ID_DELIM;
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1945:
if (TRUE)	/* NOBYPASS */
/* # line 44322 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1946:
if (TRUE)	/* NOBYPASS */
/* # line 44326 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->id_type = PSS_ID_SCONST;
        yacc_cb->yyval.psl_strtype = sconvert(yacc_cb->yypvt[-0].psl_textype);
    } break;

case 1947:
if (TRUE)	/* NOBYPASS */
/* # line 44339 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1948:
if (TRUE)	/* NOBYPASS */
/* # line 44343 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        /* first, make sure the string is not too long */
        if (yacc_cb->yypvt[-0].psl_textype->db_t_count > DB_MAXNAME)
        {
            i4     err_code;
            i4          max_len = DB_MAXNAME;

            (VOID) psf_error(E_PS0353_NAME_STRING_TOO_LONG, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 2,
                yacc_cb->yypvt[-0].psl_textype->db_t_count, yacc_cb->yypvt[-0].psl_textype->db_t_text,
                sizeof(max_len), &max_len);
            return (E_DB_ERROR);
        }

	yyvarsp->id_type = PSS_ID_SCONST;
        yacc_cb->yyval.psl_strtype = sconvert(yacc_cb->yypvt[-0].psl_textype);
    } break;
	}
	return(0);
}

i4
psls44iftn(yacc_cb, yyrule, yystatusp, yyvarspp, cb, psq_cb)
YACC_CB		*yacc_cb;
i4		yyrule;
PSS_SESBLK	*cb;
DB_STATUS	*yystatusp;
YYVARS		**yyvarspp;
PSQ_CB *	psq_cb;
{
    YYVARS	*yyvarsp = *yyvarspp;
	switch(yyrule)
	{
case 1949:
if (TRUE)	/* NOBYPASS */
/* # line 44368 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
        yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
	/* if a single-quoted identifier was used,
	** do some special processing
	*/
	if (yyvarsp->id_type == PSS_ID_SCONST)
	{
		char		temp[DB_MAXNAME+1];
		DB_STATUS	status;

		/* if we are storing query text for the catalogs
		** remove/replace single-quotes
		*/
		if (cb->pss_stmt_flags & PSS_TXTEMIT) 
		{
		    status = psl_remove_single_quotes(cb->pss_tchain,
					  yacc_cb->yypvt[-0].psl_strtype, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return(status);
	    	}
		/* Make sure that identifier is not blank bug 79275 */
		if (STzapblank(yacc_cb->yypvt[-0].psl_strtype, temp) == 0)
		{
		    switch (psq_cb->psq_mode) 
		    {
			case PSQ_CUSER :
		      	    (void) psl_sx_error(3825L, cb, psq_cb);
			    break;
		    	case PSQ_AUSER :
		      	    (void) psl_sx_error(3826L, cb, psq_cb);
			    break;
		    	case PSQ_CAPLID :
		      	    (void) psl_sx_error(3817L, cb, psq_cb);
			    break;
		    	case PSQ_AAPLID :
		      	    (void) psl_sx_error(3818L, cb, psq_cb);
			    break;
		    	case PSQ_KAPLID :
		      	    (void) psl_sx_error(3819L, cb, psq_cb);
			    break;
		    	case PSQ_CGROUP :
		      	    (void) psl_sx_error(3813L, cb, psq_cb);
			    break;
		    	case PSQ_AGROUP :
		      	    (void) psl_sx_error(3814L, cb, psq_cb);
			    break;
		    	case PSQ_KGROUP :
		      	    (void) psl_sx_error(3816L, cb, psq_cb);
			    break;
		    	case PSQ_CREATE_SCHEMA :
		      	    (void) psl_sx_error(3851L, cb, psq_cb);
			    break;
			default :
			    /* Anything I missed */
			    break;
		    }
		    return(E_DB_ERROR);
		}

	}  /* end if (id_type == PSS_ID_SCONST) */

    } break;

case 1950:
if (TRUE)	/* NOBYPASS */
/* # line 44446 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	DB_STATUS	status;
	i4	        val1,val2;

	/* if a single-quoted identifier was used,
	** do some special processing
	*/
	if (yyvarsp->id_type == PSS_ID_SCONST)
	{
	    /* return an error if a single-quoted identifier was used
	    ** AND either
	    ** 	    trace point PS251 is set, OR
	    ** 	    one of the following new 6.5 commands is being used:
	    ** 		COMMENT ON
	    ** 		CREATE/ALTER/DROP USER
	    ** 		CREATE SYNONYM
	    ** 		REFERENTIAL CONSTRAINTS (this is actually caught in
	    ** 		                         the psl_ct19s_constraint())
	    */
	    if (   (psq_cb->psq_mode == PSQ_COMMENT)
		|| (psq_cb->psq_mode == PSQ_CUSER)
		|| (psq_cb->psq_mode == PSQ_AUSER)
		|| (psq_cb->psq_mode == PSQ_KUSER)
		|| (psq_cb->psq_mode == PSQ_CSYNONYM)
		|| (psq_cb->psq_mode == PSQ_ALTERTABLE)
		|| (ult_check_macro(&cb->pss_trace,
				 PSS_NO_SINGLE_QUOTED_IDS, &val1, &val2)))
	    {
		(void) psl_sx_error(2715L, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	
	    /* if we are storing query text for the catalogs
	    ** remove/replace single-quotes
	    */
	    if (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    {
		status = psl_remove_single_quotes(cb->pss_tchain,
						  yacc_cb->yypvt[-0].psl_strtype, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	}  /* end if (id_type == PSS_ID_SCONST) */

	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1951:
if (TRUE)	/* NOBYPASS */
/* # line 44493 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yyvarsp->id_type = PSS_ID_DBA;
	yacc_cb->yyval.psl_strtype = cb->pss_dbaname;
    } break;

case 1952:
if (TRUE)	/* NOBYPASS */
/* # line 44498 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	bool		upcase = ((*cb->pss_dbxlate & CUI_ID_REG_U) != 0);

	yyvarsp->id_type = PSS_ID_INGRES;
	/*@FIX_ME@  I don't like this -- should use pss_cat_owner? */
	yacc_cb->yyval.psl_strtype = (upcase ? "$INGRES" : "$ingres");
    } break;

case 1953:
if (TRUE)	/* NOBYPASS */
/* # line 44520 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (yyvarsp->id_type == PSS_ID_DELIM)
	    cb->pss_distr_sflags |= PSS_DELIM_OWNNAME;

	/* remember type of identifier used to represent schema name */
	yyvarsp->schema_id_type = yyvarsp->id_type;

	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1954:
if (!((*yyvarspp)->bypass_actions))
/* # line 44535 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1955:
if (TRUE)	/* NOBYPASS */
/* # line 44544 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	if (PSL_IS_RESERVED_IDENT(yacc_cb->yypvt[-0].psl_strtype, cb, psq_cb, FALSE))
	    return(E_DB_ERROR);
	
	yacc_cb->yyval.psl_strtype = yacc_cb->yypvt[-0].psl_strtype;
    } break;

case 1956:
if (TRUE)	/* NOBYPASS */
/* # line 44563 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_TAB_NAME), (char *) &yyvarsp->obj_spec.pss_obj_name);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &yyvarsp->obj_spec.pss_owner);

	yyvarsp->obj_spec.pss_objspec_flags = 0;

	yyvarsp->obj_spec.pss_orig_obj_name = yacc_cb->yypvt[-0].psl_strtype;

	/* remember type of identifier representing object name */
	yyvarsp->obj_spec.pss_obj_id_type = yyvarsp->id_type;

	yyvarsp->obj_spec.pss_schema_id_type = 0;

	if (yyvarsp->id_type == PSS_ID_DELIM)
	{
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;		
	}
	
	yacc_cb->yyval.psl_objspec = &yyvarsp->obj_spec;
    } break;

case 1957:
if (TRUE)	/* NOBYPASS */
/* # line 44584 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/* If we're in alternate keywords, "schema spec" might be
	** "session." -- if so, take appropriate actions.
	*/
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_TAB_NAME), (char *) &yyvarsp->obj_spec.pss_obj_name);
	if (STcompare(yacc_cb->yypvt[-2].psl_strtype,"session") == 0)
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, yyvarsp->obj_spec.pss_owner);
	    yyvarsp->obj_spec.pss_objspec_flags = 
			PSS_OBJSPEC_EXPL_SCHEMA | PSS_OBJSPEC_SESS_SCHEMA;
	    yyvarsp->obj_spec.pss_schema_id_type = PSS_ID_DELIM;
	    if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
			yacc_cb->yypvt[-0].psl_strtype, &psq_cb->psq_error))
	    {
		return(E_DB_ERROR);
	    }
	    cb->pss_stmt_flags |= PSS_HAS_DGTT;
	}
	else
	{
	    /* Not session. */
	    STmove(yacc_cb->yypvt[-2].psl_strtype, ' ', sizeof(DB_OWN_NAME), (char *) &yyvarsp->obj_spec.pss_owner);
	    yyvarsp->obj_spec.pss_objspec_flags = PSS_OBJSPEC_EXPL_SCHEMA;
	    yyvarsp->obj_spec.pss_schema_id_type = yyvarsp->schema_id_type;
	}

	/* remember types of identifiers representing schema and object names */
	yyvarsp->obj_spec.pss_obj_id_type = yyvarsp->id_type;

	yyvarsp->obj_spec.pss_orig_obj_name = yacc_cb->yypvt[-0].psl_strtype;

	if (yyvarsp->id_type == PSS_ID_DELIM)
	{
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;		
	}
	
	yacc_cb->yyval.psl_objspec = &yyvarsp->obj_spec;
    } break;

case 1958:
if (TRUE)	/* NOBYPASS */
/* # line 44623 "/home/ingres/SANDBOX/Ingres_SVN/server/src/back/psf/psl/pslsgram.yi" */
{
	/*
	** temporary table references are always spelled SESSION.t, where
	** any reference to SESSION.t is equivalent to a reference to U.t, where
	** U is the implementation-dependent internal schema name in which the
	** declared local temporary table exists.
	*/

	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, yyvarsp->obj_spec.pss_owner);
	STmove(yacc_cb->yypvt[-0].psl_strtype, ' ', sizeof(DB_TAB_NAME), 
	       yyvarsp->obj_spec.pss_obj_name.db_tab_name);

	yyvarsp->obj_spec.pss_objspec_flags = 
	    PSS_OBJSPEC_EXPL_SCHEMA | PSS_OBJSPEC_SESS_SCHEMA;

	yyvarsp->obj_spec.pss_orig_obj_name = yacc_cb->yypvt[-0].psl_strtype;

	/* 
	** remember type of identifier representing object name - to represent
	** "session" schema, delimited identifier must always be used.
	*/
	yyvarsp->obj_spec.pss_schema_id_type = PSS_ID_DELIM;
	yyvarsp->obj_spec.pss_obj_id_type = yyvarsp->id_type;

	if (yyvarsp->id_type == PSS_ID_DELIM)
	{
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;		
	}
	
	if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		yyvarsp->obj_spec.pss_orig_obj_name, &psq_cb->psq_error))
	{
	    return(E_DB_ERROR);
	}
    /*
	** flag presence, so can tinker with alias id
	** for repeat queries
	*/
	cb->pss_stmt_flags |= PSS_HAS_DGTT;

	yacc_cb->yyval.psl_objspec = &yyvarsp->obj_spec;
    } break;
}
	return(0);
}

