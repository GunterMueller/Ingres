Summary: %rpm_product%
Name: %rpm_basename%%rpm_specname%
Version: %rpm_version%
Release: %rpm_release%
License: %rpm_license%
Group: %rpm_group%
Source: none
Patch: none
Vendor: %rpm_vendor%
URL: %rpm_url%
BuildRoot: %rpm_buildroot%
Prefix: %rpm_prefix%
Provides: %rpm_basename%%rpm_specname%
Provides: %rpm_basename%-qr_run
Provides: %rpm_basename%-esql
Obsoletes: ca-ingres%rpm_specname%
Obsoletes: ca-ingres-qr_run
Obsoletes: ca-ingres-esql

AutoReq: 0
%define _unpackaged_files_terminate_build 0 
%define _missing_doc_files_terminate_build 0

%description 
%product_name% Base Package

The %product_name% Base Package combines the %product_name% Intelligent DBMS with the following %product_name% tools:

Terminal Monitors (sql/isql/iquel) - Simple SQL/Quel interfaces to the %product_name% Intelligent DBMS.

Query-By-Forms (qbf) - An interactive, visually oriented, forms-based system for rapidly creating, querying, and manipulating database tables.

Report-By-Forms (rbf) - An interactive, visually oriented, forms-based system for rapidly creating and producing simple database reports.

Report-Writer (rw) - A high-level programming system for creating and producing complex database reports without using a 3GL.

Visual-Forms-Editor (vifred) - A visually oriented tool for creating and editing %product_name% forms.

%product_name%/Menu (ingmenu) - A simple forms-based front-end to the %product_name% Query and Reporting Tools and Database Administration Tools.

Embedded SQL Precompilers

%product_name% Embedded SQL combines the flexibility of a 3GL with %product_name% advanced application development tools for rapid development of highly interactive, portable, forms-based applications, database procedures, and other 3GL programs which can access relational and non-relational databases.  These open, portable tools are designed for use on client-server and host-based systems and include complete libraries for database access and memory management.  Embedded SQL programming kits are available for C and several other 3GLs.

%prep

%pre
# RPM install option for PIF
# PIF_RPM_UPDATE_OPTION= --nodeps --replacefiles --replacepkgs
#set environment from RPM info
[ -z "$RPM_INSTALL_PREFIX" ] && RPM_INSTALL_PREFIX=%prefix
II_SYSTEM=$RPM_INSTALL_PREFIX
PATH=$II_SYSTEM/ingres/bin:$II_SYSTEM/ingres/utility:$PATH
LD_LIBRARY_PATH=/lib:/usr/lib:$II_SYSTEM/ingres/lib
export II_SYSTEM PATH LD_LIBRARY_PATH
unset BASH_ENV

rc=0 # initialize return code

export user_created=false
export group_created=false

fail_cleanup()
{
# Remove anything we have created if the pre-install failed
    $user_created && userdel -r $II_USERID
    $group_created && groupdel $II_GROUPID
    exit 1
}

iiread_response()
{
   value=""
   [ "$2" ] && [ -f "$2" ] &&
   {
      cut -d= -f1 $2 | grep $1 >/dev/null &&
      {
         value=`grep $1 $2 | cut -d= -f2`
      }
   }
   echo $value
}

# %pre starts here
#check to see if instance is running and abort if it is
[ -x $II_SYSTEM/ingres/utility/csreport ] && csreport >> /dev/null
if [ $? = 0 ]
then
    rc=1
    echo "The %product_brandname% %product_version%/%product_release% installation under $II_SYSTEM is running"
    echo "Aborting installation..."
    exit $rc
fi

# Abort if response file is set but invalid
[ "$II_RESPONSE_FILE" ] && [ ! -f "$II_RESPONSE_FILE" ] && {
rc=2
cat << !
Cannot locate response file.

	II_RESPONSE_FILE=$II_RESPONSE_FILE
!
exit $rc
}

# Mesg cmds.

ECHO=echo
CAT=cat

# Check II_INSTALLATION is valid if it's set
[ -r "$II_RESPONSE_FILE" ] && \
    instid=`iiread_response II_INSTALLATION $II_RESPONSE_FILE`
[ -z "$instid" ] && [ "$II_INSTALLATION" ] && instid=$II_INSTALLATION
[ "$instid" ] &&
{
     case "$instid" in
	[[:alpha:]][[:alnum:]])
		true # value OK, do nothing
		;;
	*)
		rc=3 # bad value, error and exit
		cat << !

${instid} is NOT a valid value for II_INSTALLATION

II_INSTALLATION must be a 2 character string. The first character must be a
letter, the second character can be a letter or a number.

! 	   
		exit $rc
		;;
	esac
}

#Silent install?
[ -r "$II_RESPONSE_FILE" ] && \
silent=`iiread_response SILENT_INSTALL $II_RESPONSE_FILE`
[ "$silent" ] &&
{
    ECHO=true
    CAT=true
}
export ECHO CAT

#Check for install userid, groupid; default to ingres
iiuser=`iiread_response II_USERID $II_RESPONSE_FILE`
II_USERID=${iiuser:-ingres}
iigroup=`iiread_response II_GROUPID $II_RESPONSE_FILE`
II_GROUPID=${iigroup:-ingres}

# Check for Ingres install group/user and create it if it's not present
findgroup=`grep ^$II_GROUPID: /etc/group | awk -F: '{print $1}'`
ypgroup=false
ypmatch $II_GROUPID group >& /dev/null
[ $? = 0 ] && ypgroup=true

if [ "$findgroup" != "$II_GROUPID" ] && ! $ypgroup  ; then

    /usr/sbin/groupadd $II_GROUPID
    # Failed?
    [ $? != 0 ] && {
    rc=4
    $ECHO "Failed to create group '$II_GROUPID'"
    exit $rc
    }
    export group_created=true
fi

# Check for user
( su $II_USERID -c "exit 0" ) > /dev/null 2>&1 ||
{
    # find default location for user home directories
    dflt_hdir=`/usr/sbin/useradd -D | grep ^HOME | cut -d= -f2`

    # if it's writable use it otherwise use II_SYSTEM
    if [ -w "$dflt_hdir" ]
    then
	# Check if the home directory already exists for some reason
	# If it does don't use -m
	if [ -d "$dflt_hdir/$II_USERID/.fonts" ] || \
	    [ -d "$dflt_hdir/$II_USERID/.xemacs" ] || \
	    [ -d "$dflt_hdir/$II_USERID/bin" ] || \
	    [ -d "$dflt_hdir/$II_USERID/Documents" ] || \
	    [ -d "$dflt_hdir/$II_USERID/public_html" ]
	then
	    /usr/sbin/useradd -g $II_GROUPID \
		-c '%product_brandname% Super User' $II_USERID
	    # Ensure new user owns it's home directory
  	    su $II_USERID -c "test -O ~" || chown -R $II_USERID "$dflt_hdir/$II_USERID"
 	else
	    /usr/sbin/useradd -g $II_GROUPID \
		-c '%product_brandname% Super User' -m $II_USERID
	fi
    else
	mkdir -p $II_SYSTEM
	/usr/sbin/useradd -g $II_GROUPID \
		-c '%product_brandname% Super User'  -d $II_SYSTEM -m $II_USERID
    fi
    # Failed?
    [ $? != 0 ] && {
    rc=5
    $ECHO "Failed to create user '$II_USERID'"
    exit $rc
    }

# Using SMB authenication?
    [ "`grep ^'auth required' /etc/pam.d/login | grep pam_smb_auth`" ] &&
    {
	$CAT << EOF
Your system appears to be using SMB authentication. Please run:

	 smbpasswd -a $II_USERID

to enable login.
EOF
    }

    $CAT << EOF
System user $II_USERID has been created but no password has been set.
Please set the password to enable login for this user.

EOF
    export user_created=true

}
# II_USERID doesn't exist

[ "$II_RESPONSE_FILE" ] && {

# Check response file is readable by specified installation owner.
# If not abort the install before it starts.
    if su -c "[ ! -r \"$II_RESPONSE_FILE\" ]" $II_USERID ; then
	rc=6
	$CAT << !
Response file is not readable by user $II_USERID

	II_RESPONSE_FILE=$II_RESPONSE_FILE

If user $II_USERID does not exist, the response file should be 
globally readable.
!
	exit $rc
    fi
}

# Need to make sure II_SYSTEM and every where up the tree is readable by 
# $II_USERID. If it isn't we abort the install.
inst_path=$II_SYSTEM
while [ "$inst_path" != "/" ]
do
    [ -d "$inst_path" ] &&
    {
	if su -c "[ ! -r \"$inst_path\" ]" $II_USERID ; then 
	    rc=7
	    $CAT << !
The following location is not completely readable by user $II_USERID

	$inst_path

II_SYSTEM must be completely readable by user $II_USERID for the 
installation to proceed.

	II_SYSTEM=$II_SYSTEM
!
	    exit $rc
	fi

	if su -c "[ ! -x \"$inst_path\" ]" $II_USERID ; then 
	    rc=8
	    $CAT << !
User $II_USERID does NOT have execute permission for following location

	$inst_path

User $II_USERID must have execute permission in II_SYSTEM for installation
to continue.

	II_SYSTEM=$II_SYSTEM
!
	    exit $rc
	fi
    }
    inst_path="`dirname $inst_path`"
done

# If we're not installing in the default location we must create link back
# to it to prevent RPM from removing all the files during upgrade!
# See issues 14247459 and 13865355
[ "$II_SYSTEM" != "%rpm_prefix%" ] &&
{
    basedir="`dirname %rpm_prefix%`"
    mkdir -p "$basedir" && [ ! -d %rpm_prefix% ] && \
        ln -s "$II_SYSTEM" "%rpm_prefix%" ||
    {
        $CAT << !
Warning!
Unable to create link under $basedir
This may result in problems when upgrading this installation.
Please create the following link in order to address this.

	%rpm_prefix%->$II_SYSTEM

!
    }
}

exit $rc

%install

%post

#Set environment
[ -z "$RPM_INSTALL_PREFIX" ] && RPM_INSTALL_PREFIX=%prefix
II_SYSTEM=$RPM_INSTALL_PREFIX
PATH=$II_SYSTEM/ingres/bin:$II_SYSTEM/ingres/utility:$PATH
LD_LIBRARY_PATH=/lib:/usr/lib:$II_SYSTEM/ingres/lib
export II_SYSTEM PATH LD_LIBRARY_PATH
unset BASH_ENV

rc=0 # initialize return code

# Mesg cmds.
ECHO=echo
CAT=cat

#Silent install?
[ -r "$II_RESPONSE_FILE" ] && \
	silent=`iiread_response SILENT_INSTALL $II_RESPONSE_FILE`
[ "$silent" ] &&
{
    ECHO=true
    CAT=true
}
export ECHO CAT

parse_response()
{

# Read response file and set environment variables accordingly
    [ "$II_RESPONSE_FILE" ] && [ ! -f "$II_RESPONSE_FILE" ] && {
    rc=1
    $CAT << !
Cannot locate response file.

	II_RESPONSE_FILE=$II_RESPONSE_FILE
!
    exit $rc
    }

    for var in `cut -s -d= -f1 $II_RESPONSE_FILE | grep -v ^#`
    do
	export ${var}=`iiread_response ${var} $II_RESPONSE_FILE`
    done
}

check_env()
{
    [ "$II_RESPONSE_FILE" ] && parse_response
    # Use response file if one if provided
    IISUFLAG=-batch
    [ "$II_RESPONSE_FILE" ] && IISUFLAG="$IISUFLAG -exresponse $II_RESPONSE_FILE"
    export II_SUFLAG

    #Check for install userid, groupid; default to ingres
    II_USERID=${II_USERID:-ingres}
    II_GROUPID=${II_GROUPID:-ingres}

    #Check for user defined installation ID otherwise default to II
    [ -z "$II_INSTALLATION" ] && II_INSTALLATION=`ingprenv II_INSTALLATION`
    [ -z "$II_INSTALLATION" ] && II_INSTALLATION=II

    ingsetenv II_INSTALLATION $II_INSTALLATION
    $CAT << !
II_INSTALLATION configured as $II_INSTALLATION.
!

}

genenv()
{
    # Pick up term type from response file
    [ "$II_TERMINAL" ] && export TERM_INGRES=$II_TERMINAL
    [ "$TERM_INGRES" ] || TERM_INGRES=konsolel
	    
    cat << ! > $II_SYSTEM/.ing${II_INSTALLATION}bash
# %product_brandname% environment for $II_INSTALLATION installation
# Generated at installation time

export II_SYSTEM=$II_SYSTEM
export PATH=\$II_SYSTEM/ingres/bin:\$II_SYSTEM/ingres/utility:\$PATH
if [ "\$LD_LIBRARY_PATH" ] ; then
    LD_LIBRARY_PATH=/usr/local/lib:\$II_SYSTEM/ingres/lib:\$II_SYSTEM/ingres/lib/lp32:\$LD_LIBRARY_PATH
else
    LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib:\$II_SYSTEM/ingres/lib:\$II_SYSTEM/ingres/lib/lp32
fi
export LD_LIBRARY_PATH
export TERM_INGRES=$TERM_INGRES
!

    cat << ! > $II_SYSTEM/.ing${II_INSTALLATION}tcsh
# %product_brandname% environment for $II_INSTALLATION installation
# Generated at installation time

setenv II_SYSTEM $II_SYSTEM
set path=(\$II_SYSTEM/ingres/{bin,utility} \$path)
if ( \$?LD_LIBRARY_PATH ) then
    setenv LD_LIBRARY_PATH /usr/local/lib:\$II_SYSTEM/ingres/lib:\$LD_LIBRARY_PATH
else
    setenv LD_LIBRARY_PATH /lib:/usr/lib:/usr/local/lib:\$II_SYSTEM/ingres/lib
endif
setenv TERM_INGRES $TERM_INGRES
!

} # genenv
 
do_setup()
{
    # correct dir ownership
    chown $II_USERID:$II_GROUPID ${II_SYSTEM}/ingres/.
    for dir in bin demo files ice install lib sig utility vdba
    do
	[ -d "${II_SYSTEM}/ingres/${dir}/." ] && \
	    chown -R $II_USERID:$II_GROUPID ${II_SYSTEM}/ingres/${dir}/.
    done

    # and version.rel
    chown $II_USERID:$II_GROUPID ${II_SYSTEM}/ingres/version.rel

    # If ingvalidpw exists then it needs to be owned by root
    # and have SUID set.
    [ -x $II_SYSTEM/ingres/bin/ingvalidpw ] && {
        chown root $II_SYSTEM/ingres/bin/ingvalidpw
        chmod 4755 $II_SYSTEM/ingres/bin/ingvalidpw
    }

    # Create config.dat and set installation owner and group
    touch $II_SYSTEM/ingres/files/config.dat
    CONFIG_HOST=`iipmhost`
    iisetres "ii.${CONFIG_HOST}.setup.owner.user" $II_USERID
    iisetres "ii.${CONFIG_HOST}.setup.owner.group" $II_GROUPID

    # Remove release.dat if it exists
    [ -f $II_SYSTEM/ingres/install/release.dat ] && \
	rm -f $II_SYSTEM/ingres/install/release.dat

    # Run setup
    su -m -c "iisutm $IISUFLAG || ( echo 'Setup of %product_name% Base Package failed.' && echo 'See $II_SYSTEM/ingres/files/install.log for more info.' )" $II_USERID || rc=2

# Generate environment script
genenv

eval homedir="~"$II_USERID
[ -d "$homedir" ] && [ -w "$homedir" ] || { \
    $CAT << EOF
The home directory for the user ${II_USERID}:

        $homedir

does not exist or is not writeable. The environment setup script for
this instance of Ingres r3 will be written to:

        $II_SYSTEM

EOF
        eval homedir=$II_SYSTEM
}

# Copy it to home directory if we can
[ "$homedir" != "$II_SYSTEM" ] && \
	su $II_USERID -c "cp -f $II_SYSTEM/.ing*sh $homedir" >& /dev/null

# Install startup scripts under /etc/rc.d

# Install RC files
[ -x $II_SYSTEM/ingres/utility/mkrc ] &&
{
    inst_id=`ingprenv II_INSTALLATION`
    mkrc -r
    mkrc && mkrc -i
    ( [ "$II_START_ON_BOOT" = "NO" ] || [ "$START_ON_BOOT" = "NO" ] ) && \
	 /sbin/chkconfig --del ingres${inst_id} >& /dev/null

}
    return $rc
}

check_env
do_setup

exit $rc

%preun
if [ $1 = 0 ] ; then
#Setup environement
[ -z "$RPM_INSTALL_PREFIX" ] && RPM_INSTALL_PREFIX=%prefix
II_SYSTEM=$RPM_INSTALL_PREFIX
PATH=$II_SYSTEM/ingres/bin:$II_SYSTEM/ingres/utility:$PATH
LD_LIBRARY_PATH=/lib:/usr/lib:$II_SYSTEM/ingres/lib
export II_SYSTEM PATH LD_LIBRARY_PATH
unset BASH_ENV

rc=0 # initialize return code

# Mesg cmds.

ECHO=echo
CAT=cat

#Silent install?
[ -x $II_SYSTEM/ingres/utility/iiread_response ] && \
	[ -r "$II_RESPONSE_FILE" ] &&
{
    silent=`iiread_response SILENT_INSTALL $II_RESPONSE_FILE`
    [ "$silent" ] &&
    {
	ECHO=true
	CAT=true
    }
    export ECHO CAT
}

#Check for install userid, groupid
CONFIG_HOST=`iipmhost`
if [ -x $II_SYSTEM/ingres/utility/iipmhost -a \
     -x $II_SYSTEM/ingres/utility/iigetres ] ; then
    CONFIG_HOST=`iipmhost`
    [ "$CONFIG_HOST" ] && \
    {
        II_USERID=`iigetres ii.${CONFIG_HOST}.setup.owner.user`
        II_GROUPID=`iigetres ii.${CONFIG_HOST}.setup.owner.group`
        export II_USERID II_GROUPID
    }
fi

. iisysdep
inst_id=`ingprenv II_INSTALLATION`
rcfile=$ETCRCFILES/ingres${inst_id}
inst_log="2>&1 | cat >> $II_SYSTEM/ingres/files/install.log"

$ECHO "Removing %product_name%..."
sleep 5

#Check to see if instance is running and try to shut it down
#Abort the install is we can't
[ -x $rcfile ] && [ -f $II_SYSTEM/ingres/files/config.dat ] &&
{
    eval $rcfile status >& /dev/null
    if [ $? = 0 ]
    then
        eval $rcfile stop $inst_log
        if [ $? != 0 ] ; then
            rc=2
            cat << EOF
%product_brandname% installation $inst_id is running and could not be cleanly shutdown.
Aborting installation...
EOF
            exit $rc
        fi
    fi
}

#Remove RC files
[ -x $II_SYSTEM/ingres/utility/mkrc ] && mkrc -r

#clean up environment files
[ "$II_USERID" ] && 
{
    eval homedir="~"$II_USERID
    for file in `ls -1 $homedir/.ing${inst_id}* 2> /dev/null`
    do
        su $II_USERID -c "rm -f $file"
    done

    for file in `ls -1 ${II_SYSTEM}/.ing${inst_id}* 2> /dev/null`
    do
	rm -f $file
    done

}

# remove link from default install location see comment in %post
[ -L "%rpm_prefix%" ] && rm -f "%rpm_prefix%"

exit $rc

else
    exit 0
fi

%triggerin -- %rpm_basename%-documentation >= 3.0
#When documentation is installed create link to it
[ -z "$RPM_INSTALL_PREFIX" ] && RPM_INSTALL_PREFIX=%prefix
II_SYSTEM=$RPM_INSTALL_PREFIX
PATH=$II_SYSTEM/ingres/bin:$II_SYSTEM/ingres/utility:$PATH
LD_LIBRARY_PATH=/lib:/usr/lib:$II_SYSTEM/ingres/lib
export II_SYSTEM PATH LD_LIBRARY_PATH

[ -L "$II_SYSTEM/ingres/doc" ] && rm -f "$II_SYSTEM/ingres/doc"
ln -s /usr/share/doc/%rpm_basename%-%rpm_version% $II_SYSTEM/ingres/doc

exit 0

%triggerun -- %rpm_basename%-documentation >= 3.0
# Only run during uninstall not upgrade
[ $2 = 0 ] || exit 0

#When documentation is uninstalled remove link
[ -z "$RPM_INSTALL_PREFIX" ] && RPM_INSTALL_PREFIX=%prefix
II_SYSTEM=$RPM_INSTALL_PREFIX
PATH=$II_SYSTEM/ingres/bin:$II_SYSTEM/ingres/utility:$PATH
LD_LIBRARY_PATH=/lib:/usr/lib:$II_SYSTEM/ingres/lib
export II_SYSTEM PATH LD_LIBRARY_PATH

rm -f $II_SYSTEM/ingres/doc

exit 0

%triggerin -- ca-cs-utils
. /etc/profile.CA
[ -z "$RPM_INSTALL_PREFIX" ] && RPM_INSTALL_PREFIX=%prefix
II_SYSTEM=$RPM_INSTALL_PREFIX
PATH=$II_SYSTEM/ingres/bin:$II_SYSTEM/ingres/utility:$PATH
LD_LIBRARY_PATH=/lib:/usr/lib:$II_SYSTEM/ingres/lib
export II_SYSTEM PATH LD_LIBRARY_PATH
inst_id=`ingprenv II_INSTALLATION`

# No need for link if II_SYSTEM is CASHCOMP
[ "$II_SYSTEM" != "$CASHCOMP" ] &&
{
    # Remove old link
    [ -L "$CASHCOMP/%product_brandname%${inst_id}" ] && \
	rm $CASHCOMP/%product_brandname%${inst_id}

    # Create link to CASHCOMP
    [ ! -d "$CASHCOMP/%product_brandname%${inst_id}" ] && \
	ln -s $II_SYSTEM $CASHCOMP/%product_brandname%${inst_id}
}

exit 0

%triggerun -- ca-cs-utils
# Only run during uninstall not upgrade
[ $2 = 0 ] || exit 0

. /etc/profile.CA
[ -z "$RPM_INSTALL_PREFIX" ] && RPM_INSTALL_PREFIX=%prefix
II_SYSTEM=$RPM_INSTALL_PREFIX
PATH=$II_SYSTEM/ingres/bin:$II_SYSTEM/ingres/utility:$PATH
LD_LIBRARY_PATH=/lib:/usr/lib:$II_SYSTEM/ingres/lib
export II_SYSTEM PATH LD_LIBRARY_PATH
inst_id=`ingprenv II_INSTALLATION`

# Remove link to CASHCOMP
[ -L "$CASHCOMP/%product_brandname%${inst_id}" ] && \
	rm $CASHCOMP/%product_brandname%${inst_id}

exit 0

%files
